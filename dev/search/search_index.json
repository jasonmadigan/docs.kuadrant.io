{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>Kuadrant combines Gateway API with gateway providers like Istio and Envoy Gateway to enhance application connectivity. It enables platform engineers and application developers to easily connect, secure, and protect their services and infrastructure across multiple clusters with policies for TLS, DNS, application authentication &amp; authorization, and rate limiting. Additionally, Kuadrant offers observability templates to further support infrastructure management.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>For a quick setup of Kuadrant, see our Getting Started guide. Alternatively, explore the architecture in our Architectural Overview.</p>"},{"location":"getting-started/","title":"Getting Started","text":"<p>This guide let's you quickly evaluate Kuadrant. You will need a Kubernetes cluster to try out Kuadrant. If you prefer, you can use the following steps to set up a local kind cluster.</p>"},{"location":"getting-started/#kind-cluster-setup","title":"Kind Cluster Setup","text":"<pre><code>kind create cluster\n</code></pre> <p>To use Kuadrant, the <code>LoadBalancer</code> service type is required for Gateways. kind does not have any built-in way to provide IP addresses to these service types. You can follow this guide to set up a LoadBalancer provider for kind.</p>"},{"location":"getting-started/#installation-options","title":"Installation Options","text":"<ul> <li>Install with Helm</li> <li>Install with OLM</li> </ul>"},{"location":"getting-started/#further-reading","title":"Further Reading","text":"<p>The documentation on this site follows the Di\u00e1taxis framework to better serve you, our users. This approach also helps us create new content and maintain existing material effectively. Under this framework, all content falls into one of four categories, accessible from the side navigation:</p> <ul> <li>Concepts - (also called 'Explanations') Deepens and broadens your understanding of Kuadrant.</li> <li>APIs &amp; Reference - Provides concise descriptions of Kuadrant APIs for quick consultation.</li> <li>Tutorials - Offers practical, step-by-step activities for you to safely try out.</li> <li>Guides - Delivers goal-oriented instructions to help you solve specific problems in any environment.</li> </ul>"},{"location":"install-olm/","title":"Install and Configure Kuadrant and Sail via OLM using the kubectl CLI","text":"<p>This document will walk you through setting up the required configuration to install kaudrant using kustomize or a tool that leverages kustomize such as kubectl along with OLM. It will also go through more advanced configuration options to enable building up a resilient configuration. You can view the full configuration built here: Full AWS Example.</p> <ol> <li> <p>Basic Install</p> </li> <li> <p>Configure DNS and TLS integration</p> </li> <li> <p>External Redis for Rate Limit Counters</p> </li> <li> <p>Limitador Resilient Configuration</p> </li> <li> <p>Authorino Resilient Configuration</p> </li> <li> <p>[OpenShift Specific] Setup Observability </p> </li> </ol>"},{"location":"install-olm/#prerequisites","title":"Prerequisites","text":"<ul> <li>Kubernetes (or OpenShift) cluster with support for services of type <code>LoadBalancer</code></li> <li>kubectl CLI</li> <li>OLM installed - (operator lifecycle manager releases)</li> <li>Gateway provider installed<ul> <li>If you don't have a Gateway provider installed, steps are included in this guide to install the Sail Operator that will configure and install an Istio installation. Kuadrant is intended to work with Istio or Envoy Gateway.  </li> </ul> </li> <li>(Optional) cert-manager for automated TLS capabilities:<ul> <li>cert-manager Operator for Red Hat OpenShift</li> <li>installing cert-manager via OperatorHub</li> </ul> </li> <li>(Optional) Access to AWS, Azure or GCP with DNS service.</li> <li>(Optional) Access to a Redis instance, for persistent storage for your rate limit counters.</li> </ul> <p>Note: for multiple clusters, it would make sense to do the installation via a tool like argocd. For other methods of addressing multiple clusters take a look at the kubectl docs</p>"},{"location":"install-olm/#basic-installation","title":"Basic Installation","text":"<p>This first step will install just Kuadrant at a given released version (post v1.x) in the <code>kuadrant-system</code> namespace and the Sail Operator. There will be no credentials/dns providers configured (This is the most basic setup but means TLSPolicy and DNSPolicy will not be able to be used). </p> <p>Start by creating the following <code>kustomization.yaml</code> in a directory locally. For the purpose of this doc, we will use: <code>~/kuadrant/</code> directory.</p> <pre><code>export KUADRANT_DIR=~/kuadrant\nmkdir -p $KUADRANT_DIR/install\ntouch $KUADRANT_DIR/install/kustomization.yaml\n</code></pre> <p>Add the below kustomisation CR to the kustomization.yaml created above:</p> <pre><code>apiVersion: kustomize.config.k8s.io/v1beta1\nkind: Kustomization\nresources:\n  # choose the cluster preference that matches your scenario below. Set the version by adding ?ref=v1.0.1. Change this version as needed (see https://github.com/Kuadrant/kuadrant-operator/releases)\n\n  - https://github.com/Kuadrant/kuadrant-operator//config/install/standard?ref=v1.0.1 \n  # - https://github.com/Kuadrant/kuadrant-operator//config/install/openshift?ref=v1.0.1\n\npatches: # remove this subscription patch if you are installing a development version. It will then use the \"preview\" channel\n\n  - patch: |-\n      apiVersion: operators.coreos.com/v1alpha1\n      kind: Subscription\n      metadata:\n        name: kuadrant\n      spec:\n        source: kuadrant-operator-catalog\n        sourceNamespace: kuadrant-system\n        name: kuadrant-operator\n        channel: 'stable' #set to preview if not using a release (for example if using main)\n</code></pre> <p>And execute the following to apply it to a cluster:</p> <pre><code># change the location depending on where you created the kustomization.yaml\nkubectl apply -k $KUADRANT_DIR/install\n</code></pre>"},{"location":"install-olm/#verify-the-operators-are-installed","title":"Verify the operators are installed:","text":"<p>OLM should begin installing the dependencies for Kuadrant. To wait for them to be ready, run:</p> <pre><code>kubectl -n kuadrant-system wait --timeout=160s --for=condition=Available deployments --all\n</code></pre> <p>Note: you may see <code>no matching resources found</code> if the deployments are not yet present.</p> <p>Once OLM has finished installing the operators (this can take several minutes). You should see the following in the kuadrant-system namespace:</p> <pre><code>kubectl get deployments -n kuadrant-system\n\n## Output\n# NAME                                    READY   UP-TO-DATE   AVAILABLE   AGE\n# authorino-operator                      1/1     1            1           83m\n# dns-operator-controller-manager         1/1     1            1           83m\n# kuadrant-console-plugin                 1/1     1            1           83m\n# kuadrant-operator-controller-manager    1/1     1            1           83m\n# limitador-operator-controller-manager   1/1     1            1           83m\n</code></pre> <p>You can also view the subscription for information about the install:</p> <pre><code>kubectl get subscription -n kuadrant-system -o=yaml\n</code></pre>"},{"location":"install-olm/#install-the-operand-components","title":"Install the operand components","text":"<p>Kuadrant has 2 additional operand components that it manages: <code>Authorino</code> that provides data plane auth integration and <code>Limitador</code> that provides data plane rate limiting. To set these up lets add a new <code>kustomization.yaml</code> in a new sub directory. We will re-use this later for further configuration. We do this as a separate step as we want to have the operators installed first.</p> <p>Add the following to your local directory.  For the purpose of this doc, we will use: <code>$KUADRANT_DIR/configure/kustomization.yaml</code>.</p> <pre><code>mkdir -p $KUADRANT_DIR/configure\ntouch $KUADRANT_DIR/configure/kustomization.yaml\n</code></pre> <p>Add the following to the new kustomization.yaml:</p> <pre><code>apiVersion: kustomize.config.k8s.io/v1beta1\nkind: Kustomization\nresources:\n\n  - https://github.com/Kuadrant/kuadrant-operator//config/install/configure/standard?ref=v1.0.1 #change this version as needed (see https://github.com/Kuadrant/kuadrant-operator/releases)\n</code></pre> <p>Lets apply this to your cluster:</p> <pre><code>kubectl apply -k $KUADRANT_DIR/configure\n</code></pre>"},{"location":"install-olm/#verify-kuadrant-is-installed-and-ready","title":"Verify Kuadrant is installed and ready:","text":"<pre><code>kubectl get kuadrant kuadrant -n kuadrant-system -o=jsonpath='{.status.conditions[?(@.type==\"Ready\")].message}{\"\\n\"}'\n</code></pre> <p>You should see the message <code>kuadrant is ready</code>.</p>"},{"location":"install-olm/#verify-istio-is-configured-and-ready","title":"Verify Istio is configured and ready:","text":"<pre><code>kubectl wait istio/default --for=condition=ready=true\n</code></pre> <p>At this point Kuadrant is installed and ready to be used as is Istio as the gateway provider. This means AuthPolicy and RateLimitPolicy can now be configured and used to protect any Gateways you create.</p>"},{"location":"install-olm/#configure-gateway-controller-names-required-for-openshift-service-mesh","title":"Configure Gateway Controller Names (Required for OpenShift Service Mesh)","text":"<p>When using OpenShift Service Mesh or other gateway providers that don't use the default gateway controller names, you must configure the appropriate environment variable on the Kuadrant operator controller manager deployment. Without this configuration, WasmPlugins will not be created properly.</p> <p>Default Values:</p> <ul> <li>Istio: <code>istio.io/gateway-controller</code> </li> <li>Envoy Gateway: <code>gateway.envoyproxy.io/gatewayclass-controller</code></li> </ul> <pre><code>kubectl patch subscription kuadrant -n kuadrant-system --type=json -p='[{\"op\":\"add\",\"path\":\"/spec/config\",\"value\":{\"env\":[{\"name\":\"ISTIO_GATEWAY_CONTROLLER_NAMES\",\"value\":\"openshift.io/gateway-controller/v1\"}]}}]'\n</code></pre> <p>Note: For Envoy Gateway, use the same command but change the environment variable name to <code>ENVOY_GATEWAY_GATEWAY_CONTROLLER_NAMES</code>. The environment variables accept comma-separated lists of gateway controller names.</p>"},{"location":"install-olm/#configure-dns-and-tls-integration","title":"Configure DNS and TLS integration","text":"<p>In this section will build on the previous steps and expand the <code>kustomization.yaml</code> we created in <code>$KUADRANT_DIR/configure</code>. </p> <p>In order for cert-manager and the Kuadrant DNS operator to be able to access and manage DNS records and setup TLS certificates and provide external connectivity for your endpoints, you need to setup a credential for these components. To do this, we will use a Kubernetes secret via a kustomize secret generator. You can find other example overlays for each supported cloud provider under the  configure directory.</p> <p>An example lets-encrypt certificate issuer is provided, but for more information on certificate issuers take a look at the cert-manager documentation.</p> <p>Lets modify our existing local kustomize overlay to setup these secrets and the cluster certificate issuer:</p> <p>First you will need to setup the required <code>.env</code> file specified in the kuztomization.yaml file in the same directory as your existing configure kustomization. Below is an example for AWS:</p> <p><pre><code>touch $KUADRANT_DIR/configure/aws-credentials.env\n</code></pre> Add the following to your new file</p> <pre><code>AWS_ACCESS_KEY_ID=xxx\nAWS_SECRET_ACCESS_KEY=xxx\nAWS_REGION=eu-west-1\n</code></pre> <p>With this setup, lets update our configure kustomization to generate the needed secrets. We will also define a TLS ClusterIssuer (see below). The full <code>kustomization.yaml</code> file should look like:</p> <pre><code>apiVersion: kustomize.config.k8s.io/v1beta1\nkind: Kustomization\nresources:\n\n  - https://github.com/Kuadrant/kuadrant-operator//config/install/configure/standard?ref=v1.0.1 #change this version as needed (see https://github.com/Kuadrant/kuadrant-operator/releases)\n  - cluster-issuer.yaml #(comment if you dont want to use it. The issuer yaml is defined below). Ensure you name the file correctly.\n\n\ngeneratorOptions:\n  disableNameSuffixHash: true\n  labels:\n    app.kubernetes.io/part-of: kuadrant\n    app.kubernetes.io/managed-by: kustomize\n\nsecretGenerator:\n\n  - name: aws-provider-credentials\n    namespace: cert-manager # assumes cert-manager namespace exists.\n    envs:\n      - aws-credentials.env # notice this matches the .env file above. You will need to setup this file locally\n    type: 'kuadrant.io/aws'\n  - name: aws-provider-credentials\n    namespace: gateway-system # this is the namespace where your gateway will be provisioned\n    envs:\n      - aws-credentials.env #notice this matches the .env file above. you need to set up this file locally first. \n    type: 'kuadrant.io/aws'\n</code></pre> <p>Below is an example Lets-Encrypt Cluster Issuer that uses the aws credential we setup above. Create this in the same directory as the configure kustomization.yaml:</p> <pre><code>touch $KUADRANT_DIR/configure/cluster-issuer.yaml\n</code></pre> <p>Add the following to this new file:</p> <pre><code># example lets-encrypt cluster issuer that will work with the credentials we will add\napiVersion: cert-manager.io/v1\nkind: ClusterIssuer\nmetadata:\n  name: lets-encrypt-aws\nspec:\n  acme:\n    privateKeySecretRef:\n      name: le-secret\n    server: https://acme-v02.api.letsencrypt.org/directory\n    solvers:\n\n      - dns01:\n          route53:\n            accessKeyIDSecretRef:\n              key: AWS_ACCESS_KEY_ID\n              name: aws-provider-credentials #notice this matches the name of the secret we created.\n            region: us-east-1 #override if needed\n            secretAccessKeySecretRef:\n              key: AWS_SECRET_ACCESS_KEY\n              name: aws-provider-credentials\n</code></pre> <p>To apply our changes (note this doesn't need to be done in different steps, but is done so here to illustrate how you can build up your configuration of Kuadrant) execute:</p> <pre><code>kubectl apply -k $KUADRANT_DIR/configure\n</code></pre> <p>The cluster issuer should become ready:</p> <pre><code>kubectl wait clusterissuer/lets-encrypt-aws --for=condition=ready=true\n</code></pre> <p>We create two credentials. One for use with <code>DNSPolicy</code> in the gateway-system namespace and one for use by cert-manager in the <code>cert-manager</code> namespace. With these credentials in place and the cluster issuer configured. You are now ready to start using DNSPolicy and TLSPolicy to secure and connect your Gateways.</p>"},{"location":"install-olm/#use-an-external-redis","title":"Use an External Redis","text":"<p>To connect <code>Limitador</code> (the component responsible for rate limiting requests) to redis so that its counters are stored and can be shared with other limitador instances follow these steps:</p> <p>Again we will build on the kustomization we started. In the same way we did for the cloud provider credentials, we need to setup a <code>redis-credential.env</code> file in the same directory as the kustomization.</p> <pre><code>touch $KUADRANT_DIR/configure/redis-credentials.env\n</code></pre> <p>Add the redis connection string to this file in the following format:</p> <pre><code>URL=redis://xxxx\n</code></pre> <p>Next we need to add a new secret generator to our existing configure file at <code>$KUADRANT_DIR/configure/kustomization.yaml</code> add it below the other <code>secretGenerators</code></p> <pre><code>  - name: redis-credentials\n    namespace: kuadrant-system\n    envs:\n      - redis-credentials.env\n    type: 'kuadrant.io/redis'\n</code></pre> <p>We also need to patch the existing <code>Limitador</code> resource. Add the following to the <code>$KUADRANT_DIR/configure/kustomization.yaml</code></p> <pre><code>patches:\n\n  - patch: |-\n      apiVersion: limitador.kuadrant.io/v1alpha1\n      kind: Limitador\n      metadata:\n        name: limitador\n        namespace: kuadrant-system\n      spec:\n        storage:\n          redis:\n            configSecretRef:\n              name: redis-credentials\n</code></pre> <p>Your full <code>kustomize.yaml</code> will now be:</p> <pre><code>apiVersion: kustomize.config.k8s.io/v1beta1\nkind: Kustomization\nresources:\n\n  - https://github.com/Kuadrant/kuadrant-operator//config/install/configure/standard?ref=v1.0.1 #change this version as needed (see https://github.com/Kuadrant/kuadrant-operator/releases)\n  - cluster-issuer.yaml #(comment if you dont want to use it. The issuer yaml is defined below). Ensure you name the file correctly.\n\n\ngeneratorOptions:\n  disableNameSuffixHash: true\n  labels:\n    app.kubernetes.io/part-of: kuadrant\n    app.kubernetes.io/managed-by: kustomize\n\nsecretGenerator:\n\n  - name: aws-provider-credentials\n    namespace: cert-manager # assumes cert-manager namespace exists.\n    envs:\n      - aws-credentials.env # notice this matches the .env file above. You will need to setup this file locally\n    type: 'kuadrant.io/aws'\n  - name: aws-provider-credentials\n    namespace: gateway-system # this is the namespace where your gateway will be provisioned\n    envs:\n      - aws-credentials.env #notice this matches the .env file above. you need to set up this file locally first.\n    type: 'kuadrant.io/aws'\n  - name: redis-credentials\n    namespace: kuadrant-system\n    envs:\n      - redis-credentials.env\n    type: 'kuadrant.io/redis'\n\npatches:\n\n  - patch: |-\n      apiVersion: limitador.kuadrant.io/v1alpha1\n      kind: Limitador\n      metadata:\n        name: limitador\n        namespace: kuadrant-system\n      spec:\n        storage:\n          redis:\n            configSecretRef:\n              name: redis-credentials\n</code></pre> <p>Re-Apply the configuration to setup the new secret and configuration:</p> <pre><code>kubectl apply -k $KUADRANT_DIR/configure/\n</code></pre> <p>Limitador is now configured to use the provided redis connection URL as a data store for rate limit counters. Limitador will become temporarily unavailable as it restarts.</p>"},{"location":"install-olm/#validate","title":"Validate","text":"<p>Validate Kuadrant is in a ready state as before:</p> <pre><code>kubectl get kuadrant kuadrant -n kuadrant-system -o=wide\n\n# NAME       STATUS   AGE\n# kuadrant   Ready    61m\n</code></pre>"},{"location":"install-olm/#resilient-deployment-of-data-plane-components","title":"Resilient Deployment of data plane components","text":""},{"location":"install-olm/#limitador-topologyconstraints-poddisruptionbudget-and-resource-limits","title":"Limitador: TopologyConstraints, PodDisruptionBudget and Resource Limits","text":"<p>To set limits, replicas and a <code>PodDisruptionBudget</code> for limitador you can add the following to the existing limitador patch in your local <code>limitador</code> in the <code>$KUADRANT_DIR/configure/kustomize.yaml</code> spec:</p> <pre><code>pdb:\n  maxUnavailable: 1\nreplicas: 2\nresourceRequirements:\n    requests:\n      cpu: 10m\n      memory: 10Mi # set these based on your own needs.\n</code></pre> <p>re-apply the configuration. This will result in two instances of limitador becoming available and a <code>podDisruptionBudget</code> being setup:</p> <pre><code>kubectl apply -k $KUADRANT_DIR/configure/\n</code></pre> <p>For topology constraints, you will need to patch the limitador deployment directly:</p> <p>add the below <code>yaml</code> to a <code>limitador-topoloy-patch.yaml</code> file under a <code>$KUADRANT_DIR/configure/patches</code> directory:</p> <pre><code>mkdir -p $KUADRANT_DIR/configure/patches\ntouch $KUADRANT_DIR/configure/patches/limitador-topoloy-patch.yaml\n</code></pre> <pre><code>spec:\n  template:\n    spec:\n      topologySpreadConstraints:\n\n        - maxSkew: 1\n          topologyKey: kubernetes.io/hostname\n          whenUnsatisfiable: ScheduleAnyway\n          labelSelector:\n            matchLabels:\n              limitador-resource: limitador\n        - maxSkew: 1\n          topologyKey: kubernetes.io/zone\n          whenUnsatisfiable: ScheduleAnyway\n          labelSelector:\n            matchLabels:\n              limitador-resource: limitador\n</code></pre> <p>Apply this to the existing limitador deployment</p> <pre><code>kubectl patch deployment limitador-limitador -n kuadrant-system --patch-file $KUADRANT_DIR/configure/patches/limitador-topoloy-patch.yaml\n</code></pre>"},{"location":"install-olm/#authorino-topologyconstraints-poddisruptionbudget-and-resource-limits","title":"Authorino: TopologyConstraints, PodDisruptionBudget and Resource Limits","text":"<p>To increase the number of replicas for Authorino add a new patch to the <code>$KUADRANT_DIR/configure/kustomization.yaml</code></p> <pre><code>  - patch: |-\n      apiVersion: operator.authorino.kuadrant.io/v1beta1\n      kind: Authorino\n      metadata:\n        name: authorino\n        namespace: kuadrant-system\n      spec:\n        replicas: 2\n</code></pre> <p>and re-apply the configuration:</p> <pre><code>kubectl apply -k $KUADRANT_DIR/configure/\n</code></pre> <p>To add resource limits and or topology constraints to Authorino. You will need to patch the Authorino deployment directly: Add the below <code>yaml</code> to a <code>authorino-topoloy-patch.yaml</code> under the <code>$KUADRANT_DIR/configure/patches</code> directory:</p> <pre><code>touch $KUADRANT_DIR/configure/patches/authorino-topoloy-patch.yaml\n</code></pre> <pre><code>spec:\n  template:\n    spec:\n      containers:\n\n        - name: authorino\n          resources:\n            requests:\n              cpu: 10m # set your own needed limits here\n              memory: 10Mi # set your own needed limits here\n      topologySpreadConstraints:\n        - maxSkew: 1\n          topologyKey: kubernetes.io/hostname\n          whenUnsatisfiable: ScheduleAnyway\n          labelSelector:\n            matchLabels:\n              authorino-resource: authorino\n        - maxSkew: 1\n          topologyKey: kubernetes.io/zone\n          whenUnsatisfiable: ScheduleAnyway\n          labelSelector:\n            matchLabels:\n              authorino-resource: authorino\n</code></pre> <p>Apply the patch:</p> <pre><code>kubectl patch deployment authorino -n kuadrant-system --patch-file $KUADRANT_DIR/configure/patches/authorino-topoloy-patch.yaml\n</code></pre> <p>Kuadrant is now installed and ready to use and the data plane components are configured to be distributed and resilient.</p> <p>For reference the full configure kustomization should look like: <pre><code>kind: Kustomization\nresources:\n\n  - https://github.com/Kuadrant/kuadrant-operator//config/install/configure/standard?ref=v1.0.1 #change this version as needed (see https://github.com/Kuadrant/kuadrant-operator/releases)\n  - cluster-issuer.yaml\ngeneratorOptions:\n  disableNameSuffixHash: true\n  labels:\n    app.kubernetes.io/part-of: kuadrant\n    app.kubernetes.io/managed-by: kustomize\n\nsecretGenerator:\n\n  - name: aws-provider-credentials\n    namespace: cert-manager # assumes cert-manager namespace exists.\n    envs:\n      - aws-credentials.env # notice this matches the .env file above. You will need to setup this file locally\n    type: 'kuadrant.io/aws'\n  - name: aws-provider-credentials\n    namespace: gateway-system # this is the namespace where your gateway will be provisioned\n    envs:\n      - aws-credentials.env #notice this matches the .env file above. you need to set up this file locally first.\n    type: 'kuadrant.io/aws'\n  - name: redis-credentials\n    namespace: kuadrant-system\n    envs:\n      - redis-credentials.env\n    type: 'kuadrant.io/redis'\n\npatches:\n\n  - patch: |-\n      apiVersion: limitador.kuadrant.io/v1alpha1\n      kind: Limitador\n      metadata:\n        name: limitador\n        namespace: kuadrant-system\n      spec:\n        pdb:\n          maxUnavailable: 1\n        replicas: 2\n        resourceRequirements:\n          requests:\n            cpu: 10m\n            memory: 10Mi # set these based on your own needs.\n        storage:\n          redis:\n            configSecretRef:\n              name: redis-credentials\n  - patch: |-\n      apiVersion: operator.authorino.kuadrant.io/v1beta1\n      kind: Authorino\n      metadata:\n        name: authorino\n        namespace: kuadrant-system\n      spec:\n        replicas: 2\n</code></pre> The configure directory should contain the following:</p> <pre><code>configure/\n\u251c\u2500\u2500 aws-credentials.env\n\u251c\u2500\u2500 cluster-issuer.yaml\n\u251c\u2500\u2500 kustomization.yaml\n\u251c\u2500\u2500 patches\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 authorino-topoloy-patch.yaml\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 limitador-topoloy-patch.yaml\n\u2514\u2500\u2500 redis-credentials.env\n</code></pre>"},{"location":"install-olm/#set-up-observability-openshift-only","title":"Set up observability (OpenShift Only)","text":"<p>Verify that user workload monitoring is enabled in your Openshift cluster. If it not enabled, check the Openshift documentation for how to do this.</p> <pre><code>kubectl get configmap cluster-monitoring-config -n openshift-monitoring -o jsonpath='{.data.config\\.yaml}'|grep enableUserWorkload\n# (expected output)\n# enableUserWorkload: true\n</code></pre> <p>Install the gateway &amp; Kuadrant metrics components and configuration, including Grafana.</p> <pre><code># change the version as needed\nkubectl apply -k https://github.com/Kuadrant/kuadrant-operator//config/install/configure/observability?ref=v1.0.1\n</code></pre> <p>Configure the Openshift thanos-query instance as a data source in Grafana.</p> <pre><code>TOKEN=\"Bearer $(oc whoami -t)\"\nHOST=\"$(kubectl -n openshift-monitoring get route thanos-querier -o jsonpath='https://{.status.ingress[].host}')\"\necho \"TOKEN=$TOKEN\" &gt; config/observability/openshift/grafana/datasource.env\necho \"HOST=$HOST\" &gt;&gt; config/observability/openshift/grafana/datasource.env\nkubectl apply -k config/observability/openshift/grafana\n</code></pre> <p>Create the example dashboards in Grafana</p> <pre><code>kubectl apply -k https://github.com/Kuadrant/kuadrant-operator/examples/dashboards?ref=v1.0.1\n</code></pre> <p>Access the Grafana UI, using the default user/pass of root/secret. You should see the example dashboards in the 'monitoring' folder. For more information on the example dashboards, check out the documentation.</p> <pre><code>kubectl -n monitoring get routes grafana-route -o jsonpath=\"https://{.status.ingress[].host}\"\n</code></pre>"},{"location":"install-olm/#next-steps","title":"Next Steps","text":"<ul> <li>Try out our Secure, protect, and connect guide</li> </ul>"},{"location":"install-helm/","title":"Install with Helm","text":""},{"location":"install-helm/#_prerequisites","title":"Prerequisites","text":"<ul> <li> <p>Kubernetes cluster with support for services of type <code>LoadBalancer</code></p> </li> <li> <p>kubectl CLI</p> </li> </ul>"},{"location":"install-helm/#_basic_installation","title":"Basic Installation","text":"<p>The latest helm installation instructions for the kuadrant operator are maintained at ArtifactHub.</p> <p>After installing the operator, you can create a Kuadrant resource to install the operand components.</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1beta1\nkind: Kuadrant\nmetadata:\n  name: kuadrant\n  namespace: kuadrant-system\nEOF</code></pre> <p>If everything went well, the status of the resource should be <code>Ready</code></p> <pre><code>kubectl get kuadrant kuadrant -n kuadrant-system -o=jsonpath='{.status.conditions[?(@.type==\"Ready\")].message}{\"\\n\"}'</code></pre>"},{"location":"install-helm/#_next_steps","title":"Next Steps","text":"<ul> <li> <p>Try out our Secure, protect, and connect guide</p> </li> </ul>"},{"location":"kuadrant-operator/doc/cel/introduction/","title":"Introduction to CEL","text":""},{"location":"kuadrant-operator/doc/cel/introduction/#the-basic-syntax","title":"The Basic Syntax","text":"<p>Using CEL in Kuadrant, you evaluate the Request (attributes like path, method, headers) or the Connection (mTLS details, source IP).</p>"},{"location":"kuadrant-operator/doc/cel/introduction/#variables-and-attribute-access","title":"Variables and Attribute Access","text":"<p>Kuadrant exposes a standard set of attributes. You access them using dot notation or map lookups.</p> <ul> <li>Dot Notation: <code>request.path</code>, <code>request.method</code></li> <li>Map Lookup: <code>request.headers['user-agent']</code> (Required for headers, as they contain hyphens).</li> </ul>"},{"location":"kuadrant-operator/doc/cel/introduction/#literals","title":"Literals","text":"<p>CEL supports standard data types:</p> Type Examples Int <code>200</code>, <code>404</code>, <code>-1</code> UInt <code>200u</code>, <code>404u</code> String <code>'GET'</code>, <code>\"/api/v1\"</code>, <code>r\"regex\\d+\"</code> Bool <code>true</code>, <code>false</code> Duration <code>duration('500ms')</code>, <code>duration('10s')</code> Map <code>{'group': 'admin', 'tier': 'gold'}</code> List <code>[1, 2, 3]</code> <p>For more details on all member overloads for these types, please refer to the standard library docs.</p> <p>Caution</p> <p>CEL has no implicit type coercion. It isn't valid to for example compare different types, this expression is invalid: <code>\"3\" != 3</code></p>"},{"location":"kuadrant-operator/doc/cel/introduction/#logical-operators","title":"Logical Operators","text":"<p>Within policies, in <code>Predicate</code>s you can combine checks. If the expression evaluates to <code>true</code>, the policy applies (e.g. allowing or denying the request based on the action).</p>"},{"location":"kuadrant-operator/doc/cel/introduction/#boolean-logic","title":"Boolean Logic","text":"<ul> <li> <p>AND (<code>&amp;&amp;</code>): Both conditions must be true. <pre><code>// Method is POST AND path starts with /api/admin\nrequest.method == 'POST' &amp;&amp; request.path.startsWith('/api/admin')\n</code></pre></p> </li> <li> <p>OR (<code>||</code>): At least one condition must be true. <pre><code>// Method is GET OR HEAD\nrequest.method == 'GET' || request.method == 'HEAD'\n</code></pre></p> </li> <li> <p>NOT (<code>!</code>): Inverts the result. <pre><code>// User-Agent must NOT contain 'bot'\n!request.headers['user-agent'].contains('bot')\n</code></pre></p> </li> </ul>"},{"location":"kuadrant-operator/doc/cel/introduction/#conditional-logic-ifelse","title":"Conditional Logic (If/Else)","text":"<p>Conditional logic is useful for dependent checks, such as validating specific headers only for certain paths.</p> <pre><code>// If path is /secure, check for x-user-id header, otherwise allow.\nrequest.path.startsWith('/secure') ? has(request.headers['x-user-id']) : true\n</code></pre>"},{"location":"kuadrant-operator/doc/cel/introduction/#handling-optional-fields-presence","title":"Handling Optional Fields (Presence)","text":"<p>In HTTP traffic, headers and metadata are often missing. Accessing a missing map key in CEL can result in an error or <code>no_such_field</code>.</p>"},{"location":"kuadrant-operator/doc/cel/introduction/#the-has-macro","title":"The <code>has()</code> Macro","text":"<p>Use <code>has()</code> to check if a header or metadata field exists before accessing it.</p> <pre><code>// Rule: If an Authorization header exists, it must start with 'Bearer'\nhas(request.headers['authorization']) ? request.headers['authorization'].startsWith('Bearer ') : true\n</code></pre> <p>Note</p> <p>For <code>request.headers</code>, checking <code>has()</code> ensures the key exists in the map. For standard attributes like <code>request.referer</code>, it checks if the value is populated. See below to learn about the optional syntax, which can in places be an alternative to the ternary operator.</p>"},{"location":"kuadrant-operator/doc/cel/introduction/#working-with-lists-and-maps","title":"Working with Lists and Maps","text":"<p>While standard HTTP headers are often strings, Kuadrant provides powerful lists in some contexts like JWT Auth (Claims). In CEL, you can use these macros on both <code>Map</code>s or <code>List</code>s to work with collections:</p>"},{"location":"kuadrant-operator/doc/cel/introduction/#all","title":"<code>.all()</code>","text":"<p>Checks if every item in the list satisfies a condition.</p> <pre><code>auth.identity.groups.all(group, group.endsWith('.admin'))\n</code></pre>"},{"location":"kuadrant-operator/doc/cel/introduction/#exists","title":"<code>.exists()</code>","text":"<p>Checks if at least one item satisfies a condition.</p> <pre><code>// Rule: The JWT 'groups' claim must contain 'admin'\nauth.identity.claims['groups'].exists(g, g == 'admin')\n</code></pre>"},{"location":"kuadrant-operator/doc/cel/introduction/#exists_one","title":"<code>.exists_one()</code>","text":"<p>Checks if exactly one item satisfies the condition.</p> <pre><code>// Rule: Exactly one group must match\nauth.identity.groups.exists_one(group, group == 'foo')\n</code></pre>"},{"location":"kuadrant-operator/doc/cel/introduction/#filter","title":"<code>.filter()</code>","text":"<p>Returns a new list containing only the elements that satisfy the condition.</p> <pre><code>// Get all groups that end with '.admin'\nauth.identity.groups.filter(group, group.endsWith('.admin'))\n</code></pre>"},{"location":"kuadrant-operator/doc/cel/introduction/#map","title":"<code>.map()</code>","text":"<p>Returns a new list where each element has been transformed by the expression.</p> <pre><code>// Convert all group names to lowercase\nauth.identity.groups.map(group, group.lowerascii())\n</code></pre>"},{"location":"kuadrant-operator/doc/cel/introduction/#string-manipulation-regex","title":"String Manipulation &amp; Regex","text":"<p>Validating paths and headers.</p>"},{"location":"kuadrant-operator/doc/cel/introduction/#comparisons","title":"Comparisons","text":"<ul> <li>Equality: <code>request.method == 'PUT'</code></li> <li> <p>Prefix/Suffix: <pre><code>request.path.startsWith('/public/')\nrequest.headers['host'].endsWith('.example.com')\n</code></pre></p> </li> <li> <p>Contains: <code>request.headers['user-agent'].contains('Mozilla')</code></p> </li> </ul>"},{"location":"kuadrant-operator/doc/cel/introduction/#regular-expressions","title":"Regular Expressions","text":"<p>CEL uses RE2 syntax for regex.</p> <pre><code>// Rule: X-Request-ID must be a UUID-like format\nrequest.headers['x-request-id'].matches(r'^[0-9a-f-]+$')\n</code></pre> <p>Tip</p> <p>Always use <code>r'...'</code> for regex strings to handle backslashes correctly.</p>"},{"location":"kuadrant-operator/doc/cel/introduction/#type-conversion-math","title":"Type Conversion &amp; Math","text":"<p>HTTP headers are always strings. To compare them numerically (e.g., Content-Length or custom logic), you must cast them.</p>"},{"location":"kuadrant-operator/doc/cel/introduction/#casting","title":"Casting","text":"<ul> <li>int(): Converts strings to integers.</li> <li>size(): Returns the size of a string, list, or map.</li> </ul> <pre><code>// Rule: Content-Length must be less than 1MB (1,000,000 bytes)\nhas(request.headers['content-length']) &amp;&amp; int(request.headers['content-length']) &lt; 1000000\n</code></pre>"},{"location":"kuadrant-operator/doc/cel/introduction/#timestamps-and-durations","title":"Timestamps and Durations","text":"<p>You can create <code>timestamp</code> &amp; <code>duration</code> values, using these functions to operate on these types:</p> <pre><code>// Was the request made in the first 12 hours of 2025?\nrequest.time - timestamp('2025-01-01T12:00:00Z') &lt; duration('12h')\n</code></pre> <p>For more details on all member overloads for these types, please refer to the standard library docs.</p>"},{"location":"kuadrant-operator/doc/cel/introduction/#the-optional-type","title":"The <code>Optional</code> Type","text":"<p>The <code>optional</code> type offers a cleaner way to handle missing headers or metadata without verbose <code>has()</code> checks.</p>"},{"location":"kuadrant-operator/doc/cel/introduction/#creating-optionals","title":"Creating Optionals","text":"<p>You can wrap values that might be missing:</p> <ul> <li><code>optional.of(value)</code>: Wraps a value.</li> <li><code>optional.none()</code>: Represents a missing value.</li> </ul> <pre><code>// Wraps the 'x-priority' header into an Optional\noptional.of(request.headers['x-priority'])\n</code></pre>"},{"location":"kuadrant-operator/doc/cel/introduction/#unwrapping-with-defaults-orvalue","title":"Unwrapping with Defaults (<code>orValue</code>)","text":"<p>Provide a default value if the header is missing.</p> <p>Old Way (Verbose):</p> <pre><code>(has(request.headers['x-retries']) ? int(request.headers['x-retries']) : 0) &lt; 3\n</code></pre> <p>New Way (Optional):</p> <pre><code>// If header is missing, default to 0, then check if &lt; 3\noptional.of(request.headers['x-retries']).orValue('0').matches(r'^[0-2]$')\n</code></pre> <p>(Note: Since headers are strings, we handle the value as a string or cast inside a map).</p> <p>Optional syntax:</p> <pre><code>request.?headers[?'x-retries']).orValue('0').matches(r'^[0-2]$')\n</code></pre> <p>The <code>.?</code> operator will not err out if the field, <code>headers</code> in this case, isn't present. Instead it will return a <code>Optional</code> representing <code>None</code>. If on the other hand the field is there, in this case a <code>Map&lt;String, String&gt;</code>, the  value will be wrapped into a <code>Optional</code> holding the actual reference to the value.</p> <p>The <code>[?&lt;index&gt;]</code> syntax does the same for index accesses into a collection, whether it's a <code>List</code> or a <code>Map</code>.</p> <p>To use the value, access it using <code>.orValue()</code> providing a default value in the case of absence. </p> <p>To read more about the <code>Optional</code> type, see the <code>Optional</code> documentation.</p>"},{"location":"kuadrant-operator/doc/cel/introduction/#safe-transformation-optmap","title":"Safe Transformation (<code>optMap</code>)","text":"<p>Transform a value only if it exists.</p> <pre><code>// Rule: If 'x-debug' header exists, it must be 'true'. If missing, pass.\noptional.of(request.headers['x-debug'])\n  .optMap(val, val == 'true')\n  .orValue(true)\n</code></pre>"},{"location":"kuadrant-operator/doc/cel/introduction/#chaining-or","title":"Chaining (<code>or</code>)","text":"<p>Check multiple headers in order of preference.</p> <pre><code>// Use 'x-client-id', or fallback to 'x-app-id', or default to 'anonymous'\noptional.of(request.headers['x-client-id'])\n  .or(optional.of(request.headers['x-app-id']))\n  .orValue('anonymous')\n</code></pre>"},{"location":"kuadrant-operator/doc/cel/introduction/#summary-cheat-sheet","title":"Summary Cheat Sheet","text":"Requirement CEL Expression Strategy Header must exist <code>has(request.headers['x-token'])</code> Path validation <code>request.path.startsWith('/api/')</code> Regex Match <code>request.headers['authority'].matches(r'.*\\.internal$')</code> Size Limit <code>request.size &lt; 1024</code> Header Fallback <code>request.headers[?'x-group'].orValue('guest')</code>"},{"location":"kuadrant-operator/doc/cel/standard/","title":"CEL Standard Function Library","text":"<p>The standard library provides a set of core functions for CEL.</p>"},{"location":"kuadrant-operator/doc/cel/standard/#logical-operators","title":"Logical Operators","text":""},{"location":"kuadrant-operator/doc/cel/standard/#conditional-ternary","title":"Conditional (Ternary)","text":"<p>The ternary operator tests a boolean predicate and returns the left-hand side (truthy) expression if true, or the right-hand side (falsy) expression if false.</p> <ul> <li>Signature: <code>&lt;bool&gt; ? &lt;A&gt; : &lt;A&gt; -&gt; &lt;A&gt;</code></li> </ul>"},{"location":"kuadrant-operator/doc/cel/standard/#examples","title":"Examples:","text":"<pre><code>'hello'.contains('lo') ? 'hi' : 'bye' // 'hi'\n32 % 3 == 0 ? 'divisible' : 'not divisible' // 'not divisible'\n</code></pre>"},{"location":"kuadrant-operator/doc/cel/standard/#logical-and","title":"Logical AND","text":"<p>Logically AND two boolean values. Errors and unknown values are valid inputs and will not halt evaluation.</p> <ul> <li>Signature: <code>&lt;bool&gt; &amp;&amp; &lt;bool&gt; -&gt; &lt;bool&gt;</code></li> </ul>"},{"location":"kuadrant-operator/doc/cel/standard/#examples_1","title":"Examples:","text":"<pre><code>true &amp;&amp; true   // true\ntrue &amp;&amp; false  // false\nerror &amp;&amp; true  // error\nerror &amp;&amp; false // false\n</code></pre>"},{"location":"kuadrant-operator/doc/cel/standard/#logical-or","title":"Logical OR","text":"<p>Logically OR two boolean values. Errors and unknown values are valid inputs and will not halt evaluation.</p> <ul> <li>Signature: <code>&lt;bool&gt; || &lt;bool&gt; -&gt; &lt;bool&gt;</code></li> </ul>"},{"location":"kuadrant-operator/doc/cel/standard/#examples_2","title":"Examples:","text":"<pre><code>true || false // true\nfalse || false // false\nerror || true // true\nerror || error // error\n</code></pre>"},{"location":"kuadrant-operator/doc/cel/standard/#logical-not","title":"Logical NOT","text":"<p>Logically negate a boolean value.</p> <ul> <li>Signature: <code>!&lt;bool&gt; -&gt; &lt;bool&gt;</code></li> </ul>"},{"location":"kuadrant-operator/doc/cel/standard/#examples_3","title":"Examples:","text":"<pre><code>!true // false\n!false // true\n!error // error\n</code></pre>"},{"location":"kuadrant-operator/doc/cel/standard/#equality-operators","title":"Equality Operators","text":""},{"location":"kuadrant-operator/doc/cel/standard/#equals","title":"Equals","text":"<p>Compare two values of the same type for equality.</p> <ul> <li>Signature: <code>&lt;A&gt; == &lt;A&gt; -&gt; bool</code></li> </ul>"},{"location":"kuadrant-operator/doc/cel/standard/#examples_4","title":"Examples:","text":"<pre><code>1 == 1 // true\n'hello' == 'world' // false\nbytes('hello') == b'hello' // true\nduration('1h') == duration('60m') // true\ndyn(3.0) == 3 // true\n</code></pre>"},{"location":"kuadrant-operator/doc/cel/standard/#not-equals","title":"Not Equals","text":"<p>Compare two values of the same type for inequality.</p> <ul> <li>Signature: <code>&lt;A&gt; != &lt;A&gt; -&gt; bool</code></li> </ul>"},{"location":"kuadrant-operator/doc/cel/standard/#examples_5","title":"Examples:","text":"<pre><code>1 != 2     // true\n\"a\" != \"a\" // false\n3.0 != 3.1 // true\n</code></pre>"},{"location":"kuadrant-operator/doc/cel/standard/#mathematical-operators","title":"Mathematical Operators","text":""},{"location":"kuadrant-operator/doc/cel/standard/#addition","title":"Addition","text":"<p>Adds two numeric values or concatenates two strings, bytes, or lists.</p> <ul> <li>Signature:<ul> <li><code>&lt;int&gt; + &lt;int&gt; -&gt; &lt;int&gt;</code></li> <li><code>&lt;uint&gt; + &lt;uint&gt; -&gt; &lt;uint&gt;</code></li> <li><code>&lt;double&gt; + &lt;double&gt; -&gt; &lt;double&gt;</code></li> <li><code>&lt;string&gt; + &lt;string&gt; -&gt; &lt;string&gt;</code></li> <li><code>&lt;bytes&gt; + &lt;bytes&gt; -&gt; &lt;bytes&gt;</code></li> <li><code>&lt;list&lt;A&gt;&gt; + &lt;list&lt;A&gt;&gt; -&gt; &lt;list&lt;A&gt;&gt;</code></li> <li><code>&lt;duration&gt; + &lt;duration&gt; -&gt; &lt;duration&gt;</code></li> <li><code>&lt;duration&gt; + &lt;timestamp&gt; -&gt; &lt;timestamp&gt;</code></li> <li><code>&lt;timestamp&gt; + &lt;duration&gt; -&gt; &lt;timestamp&gt;</code></li> </ul> </li> </ul>"},{"location":"kuadrant-operator/doc/cel/standard/#examples_6","title":"Examples:","text":"<pre><code>1 + 2 // 3\n22u + 33u // 55u\n3.14 + 1.59 // 4.73\n\"Hello, \" + \"world!\" // \"Hello, world!\"\nb'hi' + bytes('ya') // b'hiya'\n[1] + [2, 3] // [1, 2, 3]\nduration('1m') + duration('1s') // duration('1m1s')\nduration('24h') + timestamp('2023-01-01T00:00:00Z') // timestamp('2023-01-02T00:00:00Z')\ntimestamp('2023-01-01T00:00:00Z') + duration('24h1m2s') // timestamp('2023-01-02T00:01:02Z')\n</code></pre>"},{"location":"kuadrant-operator/doc/cel/standard/#division","title":"Division","text":"<p>Divide two numbers.</p> <ul> <li>Signature:<ul> <li><code>&lt;int&gt; / &lt;int&gt; -&gt; &lt;int&gt;</code></li> <li><code>&lt;uint&gt; / &lt;uint&gt; -&gt; &lt;uint&gt;</code></li> <li><code>&lt;double&gt; / &lt;double&gt; -&gt; &lt;double&gt;</code></li> </ul> </li> </ul>"},{"location":"kuadrant-operator/doc/cel/standard/#examples_7","title":"Examples:","text":"<pre><code>10 / 2 // 5\n42u / 2u // 21u\n7.0 / 2.0 // 3.5\n</code></pre>"},{"location":"kuadrant-operator/doc/cel/standard/#modulo","title":"Modulo","text":"<p>Compute the modulus of one integer into another.</p> <ul> <li>Signature:<ul> <li><code>&lt;int&gt; % &lt;int&gt; -&gt; &lt;int&gt;</code></li> <li><code>&lt;uint&gt; % &lt;uint&gt; -&gt; &lt;uint&gt;</code></li> </ul> </li> </ul>"},{"location":"kuadrant-operator/doc/cel/standard/#examples_8","title":"Examples:","text":"<pre><code>3 % 2 // 1\n6u % 3u // 0u\n</code></pre>"},{"location":"kuadrant-operator/doc/cel/standard/#multiplication","title":"Multiplication","text":"<p>Multiply two numbers.</p> <ul> <li>Signature:<ul> <li><code>&lt;int&gt; * &lt;int&gt; -&gt; &lt;int&gt;</code></li> <li><code>&lt;uint&gt; * &lt;uint&gt; -&gt; &lt;uint&gt;</code></li> <li><code>&lt;double&gt; * &lt;double&gt; -&gt; &lt;double&gt;</code></li> </ul> </li> </ul>"},{"location":"kuadrant-operator/doc/cel/standard/#examples_9","title":"Examples:","text":"<pre><code>-2 * 6 // -12\n13u * 3u // 39u\n3.5 * 40.0 // 140.0\n</code></pre>"},{"location":"kuadrant-operator/doc/cel/standard/#negation","title":"Negation","text":"<p>Negate a numeric value.</p> <ul> <li>Signature: <code>-&lt;T&gt; -&gt; &lt;T&gt;</code> (where T is int or double)</li> </ul>"},{"location":"kuadrant-operator/doc/cel/standard/#examples_10","title":"Examples:","text":"<pre><code>-(5) // -5\n-(3.14) // -3.14\n</code></pre>"},{"location":"kuadrant-operator/doc/cel/standard/#subtraction","title":"Subtraction","text":"<p>Subtract two numbers, or two time-related values.</p> <ul> <li>Signature:<ul> <li><code>&lt;int&gt; - &lt;int&gt; -&gt; &lt;int&gt;</code></li> <li><code>&lt;uint&gt; - &lt;uint&gt; -&gt; &lt;uint&gt;</code></li> <li><code>&lt;double&gt; - &lt;double&gt; -&gt; &lt;double&gt;</code></li> <li><code>&lt;duration&gt; - &lt;duration&gt; -&gt; &lt;duration&gt;</code></li> <li><code>&lt;timestamp&gt; - &lt;duration&gt; -&gt; &lt;timestamp&gt;</code></li> <li><code>&lt;timestamp&gt; - &lt;timestamp&gt; -&gt; &lt;duration&gt;</code></li> </ul> </li> </ul>"},{"location":"kuadrant-operator/doc/cel/standard/#examples_11","title":"Examples:","text":"<pre><code>5 - 3 // 2\n42u - 3u // 39u\n10.5 - 2.0 // 8.5\nduration('1m') - duration('1s') // duration('59s')\ntimestamp('2023-01-10T12:00:00Z') - duration('12h') // timestamp('2023-01-10T00:00:00Z')\ntimestamp('2023-01-10T12:00:00Z') - timestamp('2023-01-10T00:00:00Z') // duration('12h')\n</code></pre>"},{"location":"kuadrant-operator/doc/cel/standard/#relational-operators","title":"Relational Operators","text":""},{"location":"kuadrant-operator/doc/cel/standard/#less-than","title":"Less Than","text":"<p>Compare two values and return true if the first value is less than the second.</p> <ul> <li>Signature: <code>&lt;T&gt; &lt; &lt;T&gt; -&gt; bool</code> (supports bool, int, uint, double, string, bytes, timestamp, duration, and mixed numeric comparisons)</li> </ul>"},{"location":"kuadrant-operator/doc/cel/standard/#examples_12","title":"Examples:","text":"<pre><code>false &lt; true // true\n-2 &lt; 3 // true\n1 &lt; 2u // true\n1u &lt; 2u // true\n1.1 &lt; 1.2 // true\n'a' &lt; 'b' // true\nb'hello' &lt; b'world' // true\ntimestamp('2001-01-01T02:03:04Z') &lt; timestamp('2002-02-02T02:03:04Z') // true\nduration('1ms') &lt; duration('1s') // true\n</code></pre>"},{"location":"kuadrant-operator/doc/cel/standard/#less-than-or-equal","title":"Less Than or Equal","text":"<p>Compare two values and return true if the first value is less than or equal to the second.</p> <ul> <li>Signature: <code>&lt;T&gt; &lt;= &lt;T&gt; -&gt; bool</code> (supports same types as Less Than)</li> </ul>"},{"location":"kuadrant-operator/doc/cel/standard/#examples_13","title":"Examples:","text":"<pre><code>'a' &lt;= 'a' // true\n1 &lt;= 1.0 // true\n</code></pre>"},{"location":"kuadrant-operator/doc/cel/standard/#greater-than","title":"Greater Than","text":"<p>Compare two values and return true if the first value is greater than the second.</p> <ul> <li>Signature: <code>&lt;T&gt; &gt; &lt;T&gt; -&gt; bool</code> (supports same types as Less Than)</li> </ul>"},{"location":"kuadrant-operator/doc/cel/standard/#examples_14","title":"Examples:","text":"<pre><code>3 &gt; -2 // true\n'b' &gt; 'a' // true\n</code></pre>"},{"location":"kuadrant-operator/doc/cel/standard/#greater-than-or-equal","title":"Greater Than or Equal","text":"<p>Compare two values and return true if the first value is greater than or equal to the second.</p> <ul> <li>Signature: <code>&lt;T&gt; &gt;= &lt;T&gt; -&gt; bool</code> (supports same types as Less Than)</li> </ul>"},{"location":"kuadrant-operator/doc/cel/standard/#examples_15","title":"Examples:","text":"<pre><code>2u &gt;= 1u // true\n'b' &gt;= 'a' // true\n</code></pre>"},{"location":"kuadrant-operator/doc/cel/standard/#collections-and-indexing","title":"Collections and Indexing","text":""},{"location":"kuadrant-operator/doc/cel/standard/#indexing","title":"Indexing","text":"<p>Select a value from a list by index, or value from a map by key.</p> <ul> <li>Signature:<ul> <li><code>&lt;list&lt;A&gt;&gt;[&lt;int&gt;] -&gt; &lt;A&gt;</code></li> <li><code>&lt;map&lt;K, V&gt;&gt;[&lt;K&gt;] -&gt; &lt;V&gt;</code></li> </ul> </li> </ul>"},{"location":"kuadrant-operator/doc/cel/standard/#examples_16","title":"Examples:","text":"<pre><code>[1, 2, 3][1] // 2\n{'key': 'value'}['key'] // 'value'\n</code></pre>"},{"location":"kuadrant-operator/doc/cel/standard/#in","title":"In","text":"<p>Test whether a value exists in a list, or a key exists in a map.</p> <ul> <li>Signature:<ul> <li><code>&lt;A&gt; in &lt;list&lt;A&gt;&gt; -&gt; bool</code></li> <li><code>&lt;K&gt; in &lt;map&lt;K, V&gt;&gt; -&gt; bool</code></li> </ul> </li> </ul>"},{"location":"kuadrant-operator/doc/cel/standard/#examples_17","title":"Examples:","text":"<pre><code>2 in [1, 2, 3] // true\n'key1' in {'key1': 'value1', 'key2': 'value2'} // true\n</code></pre>"},{"location":"kuadrant-operator/doc/cel/standard/#size","title":"size","text":"<p>Compute the size of a list or map, the number of characters in a string, or the number of bytes in a sequence.</p> <ul> <li>Signature:<ul> <li><code>size(&lt;T&gt;) -&gt; int</code></li> <li><code>&lt;T&gt;.size() -&gt; int</code>   (where T is string, bytes, list, or map)</li> </ul> </li> </ul>"},{"location":"kuadrant-operator/doc/cel/standard/#examples_18","title":"Examples:","text":"<pre><code>size('hello') // 5\n'hello'.size() // 5\nsize([1, 2, 3]) // 3\n{'a': 1, 'b': 2}.size() // 2\n</code></pre>"},{"location":"kuadrant-operator/doc/cel/standard/#type-conversions","title":"Type Conversions","text":""},{"location":"kuadrant-operator/doc/cel/standard/#type","title":"type","text":"<p>Convert a value to its type identifier.</p> <ul> <li>Signature: <code>type(&lt;A&gt;) -&gt; type</code></li> </ul>"},{"location":"kuadrant-operator/doc/cel/standard/#examples_19","title":"Examples:","text":"<pre><code>type(1) // int\ntype('hello') // string\n</code></pre>"},{"location":"kuadrant-operator/doc/cel/standard/#bool","title":"bool","text":"<p>Convert a value to a boolean.</p> <ul> <li>Signature: <code>bool(&lt;T&gt;) -&gt; bool</code> (T can be bool, string)</li> </ul>"},{"location":"kuadrant-operator/doc/cel/standard/#examples_20","title":"Examples:","text":"<pre><code>bool('true') // true\nbool(true) // true\n</code></pre>"},{"location":"kuadrant-operator/doc/cel/standard/#bytes","title":"bytes","text":"<p>Convert a value to bytes.</p> <ul> <li>Signature: <code>bytes(&lt;T&gt;) -&gt; bytes</code> (T can be bytes, string)</li> </ul>"},{"location":"kuadrant-operator/doc/cel/standard/#examples_21","title":"Examples:","text":"<pre><code>bytes('hello') // b'hello'\n</code></pre>"},{"location":"kuadrant-operator/doc/cel/standard/#double","title":"double","text":"<p>Convert a value to a double.</p> <ul> <li>Signature: <code>double(&lt;T&gt;) -&gt; double</code> (T can be double, int, uint, string)</li> </ul>"},{"location":"kuadrant-operator/doc/cel/standard/#examples_22","title":"Examples:","text":"<pre><code>double(123) // 123.0\ndouble('1.23') // 1.23\n</code></pre>"},{"location":"kuadrant-operator/doc/cel/standard/#duration","title":"duration","text":"<p>Convert a value to a duration.</p> <ul> <li>Signature: <code>duration(&lt;T&gt;) -&gt; duration</code> (T can be duration, int (nanoseconds), string)</li> </ul>"},{"location":"kuadrant-operator/doc/cel/standard/#examples_23","title":"Examples:","text":"<pre><code>duration('1h2m3s') // duration('3723s')\n</code></pre>"},{"location":"kuadrant-operator/doc/cel/standard/#dyn","title":"dyn","text":"<p>Indicate that the type is dynamic for type-checking purposes.</p> <ul> <li>Signature: <code>dyn(&lt;A&gt;) -&gt; dyn</code></li> </ul>"},{"location":"kuadrant-operator/doc/cel/standard/#examples_24","title":"Examples:","text":"<pre><code>dyn(1) // 1\n</code></pre>"},{"location":"kuadrant-operator/doc/cel/standard/#int","title":"int","text":"<p>Convert a value to an int.</p> <ul> <li>Signature: <code>int(&lt;T&gt;) -&gt; int</code> (T can be int, uint, double, string, duration (nanoseconds), timestamp (epoch seconds))</li> </ul>"},{"location":"kuadrant-operator/doc/cel/standard/#examples_25","title":"Examples:","text":"<pre><code>int(123u) // 123\nint('123') // 123\nint(duration('1s')) // 1000000000\nint(timestamp('1970-01-01T00:00:01Z')) // 1\n</code></pre>"},{"location":"kuadrant-operator/doc/cel/standard/#string","title":"string","text":"<p>Convert a value to a string.</p> <ul> <li>Signature: <code>string(&lt;T&gt;) -&gt; string</code> (T can be any primitive type)</li> </ul>"},{"location":"kuadrant-operator/doc/cel/standard/#examples_26","title":"Examples:","text":"<pre><code>string(123) // '123'\nstring(true) // 'true'\nstring(timestamp('1970-01-01T00:00:00Z')) // '1970-01-01T00:00:00Z'\n</code></pre>"},{"location":"kuadrant-operator/doc/cel/standard/#timestamp","title":"timestamp","text":"<p>Convert a value to a timestamp.</p> <ul> <li>Signature: <code>timestamp(&lt;T&gt;) -&gt; timestamp</code> (T can be timestamp, int (epoch seconds), string)</li> </ul>"},{"location":"kuadrant-operator/doc/cel/standard/#examples_27","title":"Examples:","text":"<pre><code>timestamp(1) // timestamp('1970-01-01T00:00:01Z')\ntimestamp('2025-01-01T12:34:56Z') // timestamp('2025-01-01T12:34:56Z')\n</code></pre>"},{"location":"kuadrant-operator/doc/cel/standard/#uint","title":"uint","text":"<p>Convert a value to a uint.</p> <ul> <li>Signature: <code>uint(&lt;T&gt;) -&gt; uint</code> (T can be uint, int, double, string)</li> </ul>"},{"location":"kuadrant-operator/doc/cel/standard/#examples_28","title":"Examples:","text":"<pre><code>uint(123) // 123u\nuint('123') // 123u\n</code></pre>"},{"location":"kuadrant-operator/doc/cel/standard/#string-functions","title":"String Functions","text":""},{"location":"kuadrant-operator/doc/cel/standard/#contains","title":"contains","text":"<p>Test whether a string contains a substring.</p> <ul> <li>Signature: <code>&lt;string&gt;.contains(&lt;string&gt;) -&gt; bool</code></li> </ul>"},{"location":"kuadrant-operator/doc/cel/standard/#examples_29","title":"Examples:","text":"<pre><code>'hello world'.contains('o w') // true\n</code></pre>"},{"location":"kuadrant-operator/doc/cel/standard/#endswith","title":"endsWith","text":"<p>Test whether a string ends with a substring suffix.</p> <ul> <li>Signature: <code>&lt;string&gt;.endsWith(&lt;string&gt;) -&gt; bool</code></li> </ul>"},{"location":"kuadrant-operator/doc/cel/standard/#examples_30","title":"Examples:","text":"<pre><code>'hello world'.endsWith('world') // true\n</code></pre>"},{"location":"kuadrant-operator/doc/cel/standard/#startswith","title":"startsWith","text":"<p>Test whether a string starts with a substring prefix.</p> <ul> <li>Signature: <code>&lt;string&gt;.startsWith(&lt;string&gt;) -&gt; bool</code></li> </ul>"},{"location":"kuadrant-operator/doc/cel/standard/#examples_31","title":"Examples:","text":"<pre><code>'hello world'.startsWith('hello') // true\n</code></pre>"},{"location":"kuadrant-operator/doc/cel/standard/#matches","title":"matches","text":"<p>Test whether a string matches an RE2 regular expression.</p> <ul> <li>Signature:<ul> <li><code>matches(&lt;string&gt;, &lt;string&gt;) -&gt; bool</code></li> <li><code>&lt;string&gt;.matches(&lt;string&gt;) -&gt; bool</code></li> </ul> </li> </ul>"},{"location":"kuadrant-operator/doc/cel/standard/#examples_32","title":"Examples:","text":"<pre><code>matches('123-456', '^[0-9]+(-[0-9]+)?$') // true\n'hello'.matches('^h.*o$') // true\n</code></pre>"},{"location":"kuadrant-operator/doc/cel/standard/#date-and-time-functions","title":"Date and Time Functions","text":"<p>All timestamp accessor methods support an optional IANA timezone string argument. If omitted, UTC is used.</p>"},{"location":"kuadrant-operator/doc/cel/standard/#getfullyear","title":"getFullYear","text":"<p>Get the 0-based full year from a timestamp.</p> <ul> <li>Signature:<ul> <li><code>&lt;timestamp&gt;.getFullYear() -&gt; int</code></li> <li><code>&lt;timestamp&gt;.getFullYear(&lt;string&gt;) -&gt; int</code></li> </ul> </li> </ul>"},{"location":"kuadrant-operator/doc/cel/standard/#examples_33","title":"Examples:","text":"<pre><code>timestamp('2023-07-14T10:30:45.123Z').getFullYear() // 2023\ntimestamp('2023-01-01T05:30:00Z').getFullYear('-08:00') // 2022\n</code></pre>"},{"location":"kuadrant-operator/doc/cel/standard/#getmonth","title":"getMonth","text":"<p>Get the 0-based month from a timestamp.</p> <ul> <li>Signature:<ul> <li><code>&lt;timestamp&gt;.getMonth() -&gt; int</code></li> <li><code>&lt;timestamp&gt;.getMonth(&lt;string&gt;) -&gt; int</code></li> </ul> </li> </ul>"},{"location":"kuadrant-operator/doc/cel/standard/#examples_34","title":"Examples:","text":"<pre><code>timestamp('2023-07-14T10:30:45.123Z').getMonth() // 6\n</code></pre>"},{"location":"kuadrant-operator/doc/cel/standard/#getdayofyear","title":"getDayOfYear","text":"<p>Get the 0-based day of the year from a timestamp.</p> <ul> <li>Signature:<ul> <li><code>&lt;timestamp&gt;.getDayOfYear() -&gt; int</code></li> <li><code>&lt;timestamp&gt;.getDayOfYear(&lt;string&gt;) -&gt; int</code></li> </ul> </li> </ul>"},{"location":"kuadrant-operator/doc/cel/standard/#getdayofmonth","title":"getDayOfMonth","text":"<p>Get the 0-based day of the month from a timestamp.</p> <ul> <li>Signature:<ul> <li><code>&lt;timestamp&gt;.getDayOfMonth() -&gt; int</code></li> <li><code>&lt;timestamp&gt;.getDayOfMonth(&lt;string&gt;) -&gt; int</code></li> </ul> </li> </ul>"},{"location":"kuadrant-operator/doc/cel/standard/#getdate","title":"getDate","text":"<p>Get the 1-based day of the month from a timestamp.</p> <ul> <li>Signature:<ul> <li><code>&lt;timestamp&gt;.getDate() -&gt; int</code></li> <li><code>&lt;timestamp&gt;.getDate(&lt;string&gt;) -&gt; int</code></li> </ul> </li> </ul>"},{"location":"kuadrant-operator/doc/cel/standard/#getdayofweek","title":"getDayOfWeek","text":"<p>Get the 0-based day of the week from a timestamp.</p> <ul> <li>Signature:<ul> <li><code>&lt;timestamp&gt;.getDayOfWeek() -&gt; int</code></li> <li><code>&lt;timestamp&gt;.getDayOfWeek(&lt;string&gt;) -&gt; int</code></li> </ul> </li> </ul>"},{"location":"kuadrant-operator/doc/cel/standard/#gethours","title":"getHours","text":"<p>Get the hours portion from a timestamp, or convert a duration to hours.</p> <ul> <li>Signature:<ul> <li><code>&lt;timestamp&gt;.getHours() -&gt; int</code></li> <li><code>&lt;timestamp&gt;.getHours(&lt;string&gt;) -&gt; int</code></li> <li><code>&lt;duration&gt;.getHours() -&gt; int</code></li> </ul> </li> </ul>"},{"location":"kuadrant-operator/doc/cel/standard/#examples_35","title":"Examples:","text":"<pre><code>timestamp('2023-07-14T10:30:45.123Z').getHours() // 10\nduration('3723s').getHours() // 1\n</code></pre>"},{"location":"kuadrant-operator/doc/cel/standard/#getminutes","title":"getMinutes","text":"<p>Get the minutes portion from a timestamp, or convert a duration to minutes.</p> <ul> <li>Signature:<ul> <li><code>&lt;timestamp&gt;.getMinutes() -&gt; int</code></li> <li><code>&lt;timestamp&gt;.getMinutes(&lt;string&gt;) -&gt; int</code></li> <li><code>&lt;duration&gt;.getMinutes() -&gt; int</code></li> </ul> </li> </ul>"},{"location":"kuadrant-operator/doc/cel/standard/#getseconds","title":"getSeconds","text":"<p>Get the seconds portion from a timestamp, or convert a duration to seconds.</p> <ul> <li>Signature:<ul> <li><code>&lt;timestamp&gt;.getSeconds() -&gt; int</code></li> <li><code>&lt;timestamp&gt;.getSeconds(&lt;string&gt;) -&gt; int</code></li> <li><code>&lt;duration&gt;.getSeconds() -&gt; int</code></li> </ul> </li> </ul>"},{"location":"kuadrant-operator/doc/cel/standard/#getmilliseconds","title":"getMilliseconds","text":"<p>Get the milliseconds portion from a timestamp or duration.</p> <ul> <li>Signature:<ul> <li><code>&lt;timestamp&gt;.getMilliseconds() -&gt; int</code></li> <li><code>&lt;timestamp&gt;.getMilliseconds(&lt;string&gt;) -&gt; int</code></li> <li><code>&lt;duration&gt;.getMilliseconds() -&gt; int</code></li> </ul> </li> </ul>"},{"location":"kuadrant-operator/doc/cel/extensions/optional/","title":"CEL Optional Type and Functions","text":"<p>The <code>optional</code> library provides a set of functions and macros for working with optional values in CEL.  Optional values are useful for representing values that may or may not be present, similar to <code>Option</code> in Rust or <code>Optional</code> in Java.</p>"},{"location":"kuadrant-operator/doc/cel/extensions/optional/#the-optional-type","title":"The <code>optional</code> Type","text":"<p>The CEL type for optional values is <code>optional_type(T)</code>, where <code>T</code> is the type of the value contained within the optional.</p>"},{"location":"kuadrant-operator/doc/cel/extensions/optional/#construction-functions","title":"Construction Functions","text":""},{"location":"kuadrant-operator/doc/cel/extensions/optional/#optionalof","title":"optional.of","text":"<p>Creates a new optional containing the given value.</p> <ul> <li>Signature: <code>optional.of(T) -&gt; optional_type(T)</code></li> </ul>"},{"location":"kuadrant-operator/doc/cel/extensions/optional/#examples","title":"Examples:","text":"<pre><code>optional.of(1)         // returns optional(1)\noptional.of(\"hello\")   // returns optional(\"hello\")\noptional.of(null)      // returns optional(null)\n</code></pre>"},{"location":"kuadrant-operator/doc/cel/extensions/optional/#optionalofnonzerovalue","title":"optional.ofNonZeroValue","text":"<p>Creates a new optional containing the given value, or <code>optional.none()</code> if the value is a zero or empty value (e.g., <code>0</code>, <code>\"\"</code>, <code>[]</code>, <code>{}</code>, <code>false</code>, or <code>null</code>).</p> <ul> <li>Signature: <code>optional.ofNonZeroValue(T) -&gt; optional_type(T)</code></li> </ul>"},{"location":"kuadrant-operator/doc/cel/extensions/optional/#examples_1","title":"Examples:","text":"<pre><code>optional.ofNonZeroValue(null)    // returns optional.none()\noptional.ofNonZeroValue(\"\")      // returns optional.none()\noptional.ofNonZeroValue(0)       // returns optional.none()\noptional.ofNonZeroValue(\"hello\") // returns optional.of(\"hello\")\n</code></pre>"},{"location":"kuadrant-operator/doc/cel/extensions/optional/#optionalnone","title":"optional.none","text":"<p>Returns a singleton value representing an empty optional.</p> <ul> <li>Signature: <code>optional.none() -&gt; optional_type(any)</code></li> </ul>"},{"location":"kuadrant-operator/doc/cel/extensions/optional/#examples_2","title":"Examples:","text":"<pre><code>optional.none()\n</code></pre>"},{"location":"kuadrant-operator/doc/cel/extensions/optional/#accessor-methods","title":"Accessor Methods","text":""},{"location":"kuadrant-operator/doc/cel/extensions/optional/#hasvalue","title":"hasValue","text":"<p>Determines whether the optional contains a value.</p> <ul> <li>Signature: <code>&lt;optional_type(T)&gt;.hasValue() -&gt; bool</code></li> </ul>"},{"location":"kuadrant-operator/doc/cel/extensions/optional/#examples_3","title":"Examples:","text":"<pre><code>optional.of(1).hasValue()   // returns true\noptional.none().hasValue()  // returns false\n</code></pre>"},{"location":"kuadrant-operator/doc/cel/extensions/optional/#value","title":"value","text":"<p>Obtains the value contained by the optional. If the optional is empty, it results in an error.</p> <ul> <li>Signature: <code>&lt;optional_type(T)&gt;.value() -&gt; T</code></li> </ul>"},{"location":"kuadrant-operator/doc/cel/extensions/optional/#examples_4","title":"Examples:","text":"<pre><code>optional.of(1).value()   // returns 1\noptional.none().value()  // error: optional.none() dereference\n</code></pre>"},{"location":"kuadrant-operator/doc/cel/extensions/optional/#transformation-methods","title":"Transformation Methods","text":""},{"location":"kuadrant-operator/doc/cel/extensions/optional/#or","title":"or","text":"<p>Chains optional expressions together, picking the first valued optional expression.</p> <ul> <li>Signature: <code>&lt;optional_type(T)&gt;.or(&lt;optional_type(T)&gt;) -&gt; optional_type(T)</code></li> </ul>"},{"location":"kuadrant-operator/doc/cel/extensions/optional/#examples_5","title":"Examples:","text":"<pre><code>optional.none().or(optional.of(1)) // returns optional.of(1)\noptional.of(1).or(optional.of(2))   // returns optional.of(1)\n</code></pre>"},{"location":"kuadrant-operator/doc/cel/extensions/optional/#orvalue","title":"orValue","text":"<p>Chains optional expressions together, picking the first valued optional or the default value.</p> <ul> <li>Signature: <code>&lt;optional_type(T)&gt;.orValue(T) -&gt; T</code></li> </ul>"},{"location":"kuadrant-operator/doc/cel/extensions/optional/#examples_6","title":"Examples:","text":"<pre><code>optional.of(1).orValue(0)   // returns 1\noptional.none().orValue(0)  // returns 0\n{'a': 1}[? 'b'].orValue(0)  // returns 0\n</code></pre>"},{"location":"kuadrant-operator/doc/cel/extensions/optional/#macros","title":"Macros","text":""},{"location":"kuadrant-operator/doc/cel/extensions/optional/#optmap","title":"optMap","text":"<p>Performs a computation on the value if present and returns the result as an optional.</p> <ul> <li>Signature: <code>&lt;optional_type(T)&gt;.optMap(var, expr)</code></li> </ul>"},{"location":"kuadrant-operator/doc/cel/extensions/optional/#examples_7","title":"Examples:","text":"<pre><code>optional.of(1).optMap(i, i * 2)  // returns optional.of(2)\noptional.none().optMap(i, i * 2) // returns optional.none()\n</code></pre>"},{"location":"kuadrant-operator/doc/cel/extensions/optional/#optflatmap","title":"optFlatMap","text":"<p>Performs a computation on the value if present and produces an optional value within the computation.</p> <ul> <li>Signature: <code>&lt;optional_type(T)&gt;.optFlatMap(var, expr)</code></li> </ul>"},{"location":"kuadrant-operator/doc/cel/extensions/optional/#examples_8","title":"Examples:","text":"<pre><code>// m = {'key': {'subkey': 'value'}}\nm.?key.optFlatMap(k, k.?subkey) // returns optional.of('value')\n\n// m = {'key': {}}\nm.?key.optFlatMap(k, k.?subkey) // returns optional.none()\n</code></pre>"},{"location":"kuadrant-operator/doc/cel/extensions/optional/#selection-and-indexing","title":"Selection and Indexing","text":""},{"location":"kuadrant-operator/doc/cel/extensions/optional/#optional-selection","title":"Optional Selection (<code>.?</code>)","text":"<p>If the field is present, creates an optional of the field value; otherwise, returns <code>optional.none()</code>.</p>"},{"location":"kuadrant-operator/doc/cel/extensions/optional/#examples_9","title":"Examples:","text":"<pre><code>msg.?field                // optional.of(field) if present, else optional.none()\nmsg.?field.?nested_field  // optional.of(nested_field) if both are present\n</code></pre>"},{"location":"kuadrant-operator/doc/cel/extensions/optional/#optional-indexing","title":"Optional Indexing (<code>[? ]</code>)","text":"<p>If the index or key is present, creates an optional of the element value; otherwise, returns <code>optional.none()</code>.</p>"},{"location":"kuadrant-operator/doc/cel/extensions/optional/#examples_10","title":"Examples:","text":"<pre><code>[1, 2, 3][? 1]    // returns optional.of(2)\n[1, 2, 3][? 5]    // returns optional.none()\n{'a': 1}[? 'a']   // returns optional.of(1)\n{'a': 1}[? 'b']   // returns optional.none()\n</code></pre>"},{"location":"kuadrant-operator/doc/cel/extensions/optional/#list-functions-v2","title":"List Functions (v2+)","text":""},{"location":"kuadrant-operator/doc/cel/extensions/optional/#first-last","title":"first / last","text":"<p>Returns the first or last value in a list as an optional.</p> <ul> <li>Signature: <code>&lt;list&lt;T&gt;&gt;.first() -&gt; optional_type(T)</code></li> <li>Signature: <code>&lt;list&lt;T&gt;&gt;.last() -&gt; optional_type(T)</code></li> </ul>"},{"location":"kuadrant-operator/doc/cel/extensions/optional/#examples_11","title":"Examples:","text":"<pre><code>[1, 2, 3].first() // returns optional.of(1)\n[].first()        // returns optional.none()\n[1, 2, 3].last()  // returns optional.of(3)\n</code></pre>"},{"location":"kuadrant-operator/doc/cel/extensions/optional/#optionalunwrap-unwrapopt","title":"optional.unwrap / unwrapOpt","text":"<p>Converts a list of optional values to a list containing only values which are not <code>optional.none()</code>.</p> <ul> <li>Signature: <code>optional.unwrap(list&lt;optional_type(T)&gt;) -&gt; list&lt;T&gt;</code></li> <li>Signature: <code>&lt;list&lt;optional_type(T)&gt;&gt;.unwrapOpt() -&gt; list&lt;T&gt;</code></li> </ul>"},{"location":"kuadrant-operator/doc/cel/extensions/optional/#examples_12","title":"Examples:","text":"<pre><code>optional.unwrap([optional.of(1), optional.none()]) // returns [1]\n[optional.of(1), optional.none()].unwrapOpt()      // returns [1]\n</code></pre>"},{"location":"kuadrant-operator/doc/cel/extensions/strings/","title":"CEL Strings Extension Functions","text":"<p>The strings extension library provides a set of functions for string manipulation in CEL.</p>"},{"location":"kuadrant-operator/doc/cel/extensions/strings/#functions","title":"Functions","text":""},{"location":"kuadrant-operator/doc/cel/extensions/strings/#charat","title":"charAt","text":"<p>Returns the character at the given position. If the position is negative, or greater than the length of the string, the function will produce an error.</p> <ul> <li>Supported version: 0</li> <li>Signature: <code>&lt;string&gt;.charAt(&lt;int&gt;) -&gt; &lt;string&gt;</code></li> </ul>"},{"location":"kuadrant-operator/doc/cel/extensions/strings/#examples","title":"Examples:","text":"<pre><code>'hello'.charAt(4)  // return 'o'\n'hello'.charAt(5)  // return ''\n'hello'.charAt(-1) // error\n</code></pre>"},{"location":"kuadrant-operator/doc/cel/extensions/strings/#format","title":"format","text":"<p>Returns a new string with substitutions being performed, printf-style.</p> <ul> <li>Supported version: 1 (Updated at version 4)</li> <li>Signature: <code>&lt;string&gt;.format(&lt;list&gt;) -&gt; &lt;string&gt;</code></li> </ul> <p>The valid formatting clauses are:</p> <ul> <li><code>%s</code> - substitutes a string. This can also be used on bools, lists, maps, bytes, Duration and Timestamp, in addition to all numerical types (int, uint, and double).</li> <li><code>%d</code> - substitutes an integer.</li> <li><code>%f</code> - substitutes a double with fixed-point precision. The default precision is 6.</li> <li><code>%e</code> - substitutes a double in scientific notation. The default precision is 6.</li> <li><code>%b</code> - substitutes an integer with its equivalent binary string. Can also be used on bools.</li> <li><code>%x</code> - substitutes an integer with its equivalent in hexadecimal, or if given a string or bytes, will output each character's equivalent in hexadecimal.</li> <li><code>%X</code> - same as above, but with A-F capitalized.</li> <li><code>%o</code> - substitutes an integer with its equivalent in octal.</li> </ul>"},{"location":"kuadrant-operator/doc/cel/extensions/strings/#examples_1","title":"Examples:","text":"<pre><code>\"this is a string: %s\\nand an integer: %d\".format([\"str\", 42]) // returns \"this is a string: str\\nand an integer: 42\"\n\"a double substituted with %%s: %s\".format([64.2]) // returns \"a double substituted with %s: 64.2\"\n\"string type: %s\".format([type(string)]) // returns \"string type: string\"\n\"timestamp: %s\".format([timestamp(\"2023-02-03T23:31:20+00:00\")]) // returns \"timestamp: 2023-02-03T23:31:20Z\"\n\"duration: %s\".format([duration(\"1h45m47s\")]) // returns \"duration: 6347s\"\n\"%f\".format([3.14]) // returns \"3.140000\"\n\"scientific notation: %e\".format([2.71828]) // returns \"scientific notation: 2.718280\\u202f\\u00d7\\u202f10\\u2070\\u2070\"\n\"5 in binary: %b\".format([5]) // returns \"5 in binary; 101\"\n\"26 in hex: %x\".format([26]) // returns \"26 in hex: 1a\"\n\"26 in hex (uppercase): %X\".format([26]) // returns \"26 in hex (uppercase): 1A\"\n\"30 in octal: %o\".format([30]) // returns \"30 in octal: 36\"\n\"a map inside a list: %s\".format([[1, 2, 3, {\"a\": \"x\", \"b\": \"y\", \"c\": \"z\"}]]) // returns \"a map inside a list: [1, 2, 3, {\"a\":\"x\", \"b\":\"y\", \"c\":\"z\"}]\"\n\"true bool: %s - false bool: %s\\nbinary bool: %b\".format([true, false, true]) // returns \"true bool: true - false bool: false\\nbinary bool: 1\"\n</code></pre>"},{"location":"kuadrant-operator/doc/cel/extensions/strings/#indexof","title":"indexOf","text":"<p>Returns the integer index of the first occurrence of the search string. If the search string is not found the function returns -1.</p> <p>The function also accepts an optional position from which to begin the substring search. If the substring is the empty string, the index where the search starts is returned (zero or custom).</p> <ul> <li>Supported version: 0</li> <li>Signature: <code>&lt;string&gt;.indexOf(&lt;string&gt;) -&gt; &lt;int&gt;</code> or <code>&lt;string&gt;.indexOf(&lt;string&gt;, &lt;int&gt;) -&gt; &lt;int&gt;</code></li> </ul>"},{"location":"kuadrant-operator/doc/cel/extensions/strings/#examples_2","title":"Examples:","text":"<pre><code>'hello mellow'.indexOf('')         // returns 0\n'hello mellow'.indexOf('ello')     // returns 1\n'hello mellow'.indexOf('jello')    // returns -1\n'hello mellow'.indexOf('', 2)      // returns 2\n'hello mellow'.indexOf('ello', 2)  // returns 7\n'hello mellow'.indexOf('ello', 20) // returns -1\n'hello mellow'.indexOf('ello', -1) // error\n</code></pre>"},{"location":"kuadrant-operator/doc/cel/extensions/strings/#join","title":"join","text":"<p>Returns a new string where the elements of string list are concatenated. The function also accepts an optional separator which is placed between elements in the resulting string.</p> <ul> <li>Supported version: 2 (Initial version was 0, but it was moved to v2 for generic <code>Lister</code> support)</li> <li>Signature: <code>&lt;list&lt;string&gt;&gt;.join() -&gt; &lt;string&gt;</code> or <code>&lt;list&lt;string&gt;&gt;.join(&lt;string&gt;) -&gt; &lt;string&gt;</code></li> </ul>"},{"location":"kuadrant-operator/doc/cel/extensions/strings/#examples_3","title":"Examples:","text":"<pre><code>['hello', 'mellow'].join() // returns 'hellomellow'\n['hello', 'mellow'].join(' ') // returns 'hello mellow'\n[].join() // returns ''\n[].join('/') // returns ''\n</code></pre>"},{"location":"kuadrant-operator/doc/cel/extensions/strings/#lastindexof","title":"lastIndexOf","text":"<p>Returns the integer index at the start of the last occurrence of the search string. If the search string is not found the function returns -1.</p> <p>The function also accepts an optional position which represents the last index to be considered as the beginning of the substring match. If the substring is the empty string, the index where the search starts is returned (string length or custom).</p> <ul> <li>Supported version: 0</li> <li>Signature: <code>&lt;string&gt;.lastIndexOf(&lt;string&gt;) -&gt; &lt;int&gt;</code> or <code>&lt;string&gt;.lastIndexOf(&lt;string&gt;, &lt;int&gt;) -&gt; &lt;int&gt;</code></li> </ul>"},{"location":"kuadrant-operator/doc/cel/extensions/strings/#examples_4","title":"Examples:","text":"<pre><code>'hello mellow'.lastIndexOf('')         // returns 12\n'hello mellow'.lastIndexOf('ello')     // returns 7\n'hello mellow'.lastIndexOf('jello')    // returns -1\n'hello mellow'.lastIndexOf('ello', 6)  // returns 1\n'hello mellow'.lastIndexOf('ello', 20) // returns -1\n'hello mellow'.lastIndexOf('ello', -1) // error\n</code></pre>"},{"location":"kuadrant-operator/doc/cel/extensions/strings/#lowerascii","title":"lowerAscii","text":"<p>Returns a new string where all ASCII characters are lower-cased. This function does not perform Unicode case-mapping for characters outside the ASCII range.</p> <ul> <li>Supported version: 0</li> <li>Signature: <code>&lt;string&gt;.lowerAscii() -&gt; &lt;string&gt;</code></li> </ul>"},{"location":"kuadrant-operator/doc/cel/extensions/strings/#examples_5","title":"Examples:","text":"<pre><code>'TacoCat'.lowerAscii()      // returns 'tacocat'\n'TacoC\u00c6t Xii'.lowerAscii()  // returns 'tacoc\u00c6t xii'\n</code></pre>"},{"location":"kuadrant-operator/doc/cel/extensions/strings/#stringsquote","title":"strings.quote","text":"<p>Takes the given string and makes it safe to print (without any formatting due to escape sequences). If any invalid UTF-8 characters are encountered, they are replaced with \\uFFFD.</p> <ul> <li>Supported version: 1</li> <li>Signature: <code>strings.quote(&lt;string&gt;) -&gt; &lt;string&gt;</code></li> </ul>"},{"location":"kuadrant-operator/doc/cel/extensions/strings/#examples_6","title":"Examples:","text":"<pre><code>strings.quote('single-quote with \"double quote\"') // returns '\"single-quote with \\\"double quote\\\"\"'\nstrings.quote(\"two escape sequences \\a\\n\") // returns '\"two escape sequences \\\\a\\\\n\"'\n</code></pre>"},{"location":"kuadrant-operator/doc/cel/extensions/strings/#replace","title":"replace","text":"<p>Returns a new string based on the target, which replaces the occurrences of a search string with a replacement string if present. The function accepts an optional limit on the number of substring replacements to be made.</p> <p>When the replacement limit is 0, the result is the original string. When the limit is a negative number, the function behaves the same as replace all.</p> <ul> <li>Supported version: 0</li> <li>Signature: <code>&lt;string&gt;.replace(&lt;string&gt;, &lt;string&gt;) -&gt; &lt;string&gt;</code> or <code>&lt;string&gt;.replace(&lt;string&gt;, &lt;string&gt;, &lt;int&gt;) -&gt; &lt;string&gt;</code></li> </ul>"},{"location":"kuadrant-operator/doc/cel/extensions/strings/#examples_7","title":"Examples:","text":"<pre><code>'hello hello'.replace('he', 'we')     // returns 'wello wello'\n'hello hello'.replace('he', 'we', -1) // returns 'wello wello'\n'hello hello'.replace('he', 'we', 1)  // returns 'wello hello'\n'hello hello'.replace('he', 'we', 0)  // returns 'hello hello'\n'hello hello'.replace('', '_')  // returns '_h_e_l_l_o_ _h_e_l_l_o_'\n'hello hello'.replace('h', '')  // returns 'ello ello'\n</code></pre>"},{"location":"kuadrant-operator/doc/cel/extensions/strings/#split","title":"split","text":"<p>Returns a list of strings split from the input by the given separator. The function accepts an optional argument specifying a limit on the number of substrings produced by the split.</p> <p>When the split limit is 0, the result is an empty list. When the limit is 1, the result is the target string to split. When the limit is a negative number, the function behaves the same as split all.</p> <ul> <li>Supported version: 0</li> <li>Signature: <code>&lt;string&gt;.split(&lt;string&gt;) -&gt; &lt;list&lt;string&gt;&gt;</code> or <code>&lt;string&gt;.split(&lt;string&gt;, &lt;int&gt;) -&gt; &lt;list&lt;string&gt;&gt;</code></li> </ul>"},{"location":"kuadrant-operator/doc/cel/extensions/strings/#examples_8","title":"Examples:","text":"<pre><code>'hello hello hello'.split(' ')     // returns ['hello', 'hello', 'hello']\n'hello hello hello'.split(' ', 0)  // returns []\n'hello hello hello'.split(' ', 1)  // returns ['hello hello hello']\n'hello hello hello'.split(' ', 2)  // returns ['hello', 'hello hello']\n'hello hello hello'.split(' ', -1) // returns ['hello', 'hello', 'hello']\n</code></pre>"},{"location":"kuadrant-operator/doc/cel/extensions/strings/#substring","title":"substring","text":"<p>Returns the substring given a numeric range corresponding to character positions. Optionally may omit the trailing range for a substring from a given character position until the end of a string.</p> <p>Character offsets are 0-based with an inclusive start range and exclusive end range. It is an error to specify an end range that is lower than the start range, or for either the start or end index to be negative or exceed the string length.</p> <ul> <li>Supported version: 0</li> <li>Signature: <code>&lt;string&gt;.substring(&lt;int&gt;) -&gt; &lt;string&gt;</code> or <code>&lt;string&gt;.substring(&lt;int&gt;, &lt;int&gt;) -&gt; &lt;string&gt;</code></li> </ul>"},{"location":"kuadrant-operator/doc/cel/extensions/strings/#examples_9","title":"Examples:","text":"<pre><code>'tacocat'.substring(4)    // returns 'cat'\n'tacocat'.substring(0, 4) // returns 'taco'\n'tacocat'.substring(-1)   // error\n'tacocat'.substring(2, 1) // error\n</code></pre>"},{"location":"kuadrant-operator/doc/cel/extensions/strings/#trim","title":"trim","text":"<p>Returns a new string which removes the leading and trailing whitespace in the target string. The trim function uses the Unicode definition of whitespace which does not include the zero-width spaces.</p> <ul> <li>Supported version: 0</li> <li>Signature: <code>&lt;string&gt;.trim() -&gt; &lt;string&gt;</code></li> </ul>"},{"location":"kuadrant-operator/doc/cel/extensions/strings/#examples_10","title":"Examples:","text":"<pre><code>'  \\ttrim\\n    '.trim() // returns 'trim'\n</code></pre>"},{"location":"kuadrant-operator/doc/cel/extensions/strings/#upperascii","title":"upperAscii","text":"<p>Returns a new string where all ASCII characters are upper-cased. This function does not perform Unicode case-mapping for characters outside the ASCII range.</p> <ul> <li>Supported version: 0</li> <li>Signature: <code>&lt;string&gt;.upperAscii() -&gt; &lt;string&gt;</code></li> </ul>"},{"location":"kuadrant-operator/doc/cel/extensions/strings/#examples_11","title":"Examples:","text":"<pre><code>'TacoCat'.upperAscii()      // returns 'TACOCAT'\n'TacoC\u00c6t Xii'.upperAscii()  // returns 'TACOC\u00c6T XII'\n</code></pre>"},{"location":"kuadrant-operator/doc/cel/extensions/strings/#reverse","title":"reverse","text":"<p>Returns a new string whose characters are the same as the target string, only formatted in reverse order. This function relies on converting strings to rune arrays in order to reverse.</p> <ul> <li>Supported version: 3</li> <li>Signature: <code>&lt;string&gt;.reverse() -&gt; &lt;string&gt;</code></li> </ul>"},{"location":"kuadrant-operator/doc/cel/extensions/strings/#examples_12","title":"Examples:","text":"<pre><code>'gums'.reverse() // returns 'smug'\n'John Smith'.reverse() // returns 'htimS nhoJ'\n</code></pre>"},{"location":"kuadrant-operator/doc/extensions/planpolicy/","title":"PlanPolicy Extension","text":"<p>The PlanPolicy extension provides plan-based rate limiting capabilities for Kuadrant. It enables you to define different service tiers (plans) with associated rate limits and automatically categorize authenticated users into these plans based on predicate expressions.</p>"},{"location":"kuadrant-operator/doc/extensions/planpolicy/#overview","title":"Overview","text":"<p>PlanPolicy enhances the existing Kuadrant AuthPolicy by adding plan identification and automatic rate limiting based on authenticated user metadata. This allows you to implement tiered service offerings where different users receive different rate limits based on their subscription plan or other attributes.</p>"},{"location":"kuadrant-operator/doc/extensions/planpolicy/#how-it-works","title":"How it works","text":""},{"location":"kuadrant-operator/doc/extensions/planpolicy/#integration","title":"Integration","text":"<p>PlanPolicy works in conjunction with AuthPolicy and RateLimitPolicy:</p> <ol> <li>AuthPolicy handles authentication and stores identity metadata in secrets</li> <li>PlanPolicy evaluates predicate expressions against the authenticated identity to determine the user's plan</li> <li>The policy automatically creates rate limits for each plan tier</li> <li>Rate limiting is enforced based on the identified plan</li> </ol>"},{"location":"kuadrant-operator/doc/extensions/planpolicy/#the-planpolicy-custom-resource","title":"The PlanPolicy custom resource","text":""},{"location":"kuadrant-operator/doc/extensions/planpolicy/#overview_1","title":"Overview","text":"<p>The <code>PlanPolicy</code> spec includes the following parts:</p> <ul> <li>A reference to an existing Gateway API resource (<code>spec.targetRef</code>)</li> <li>List of plans with predicates and limits (<code>spec.plans</code>)</li> </ul> <p>Each plan defines:</p> <ul> <li>Tier: A unique identifier for the plan (e.g., \"gold\", \"silver\", \"bronze\")</li> <li>Predicate: A CEL expression that determines if a user belongs to this plan</li> <li>Limits: Rate limiting configuration for the plan</li> </ul>"},{"location":"kuadrant-operator/doc/extensions/planpolicy/#high-level-example-and-field-definition","title":"High-level example and field definition","text":"<pre><code>apiVersion: extensions.kuadrant.io/v1alpha1\nkind: PlanPolicy\nmetadata:\n  name: my-plan-policy\nspec:\n  # Reference to an existing networking resource to attach the policy to\n  # Can target Gateway or HTTPRoute resources\n  # Must be in the same namespace as the PlanPolicy\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute  # or Gateway\n    name: my-route\n\n  # List of plans ordered by priority (first match wins)\n  plans:\n\n    - tier: gold\n      predicate: |\n        has(auth.identity) &amp;&amp; auth.identity.metadata.annotations[\"secret.kuadrant.io/plan-id\"] == \"gold\"\n      limits:\n        daily: 1000\n        weekly: 5000\n    - tier: silver\n      predicate: |\n        has(auth.identity) &amp;&amp; auth.identity.metadata.annotations[\"secret.kuadrant.io/plan-id\"] == \"silver\"\n      limits:\n        daily: 500\n        weekly: 2000\n    - tier: bronze\n      predicate: |\n        has(auth.identity) &amp;&amp; auth.identity.metadata.annotations[\"secret.kuadrant.io/plan-id\"] == \"bronze\"\n      limits:\n        daily: 100\n        weekly: 500\n</code></pre>"},{"location":"kuadrant-operator/doc/extensions/planpolicy/#using-the-planpolicy","title":"Using the PlanPolicy","text":""},{"location":"kuadrant-operator/doc/extensions/planpolicy/#targeting-a-httproute-networking-resource","title":"Targeting a HTTPRoute networking resource","text":"<p>When a PlanPolicy targets an HTTPRoute, the policy will be enforced on all traffic flowing through that specific route.</p> <p>Target an HTTPRoute by setting the <code>spec.targetRef</code> field of the PlanPolicy as follows:</p> <pre><code>apiVersion: extensions.kuadrant.io/v1alpha1\nkind: PlanPolicy\nmetadata:\n  name: my-route-plan\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: my-route\n  plans:\n    # ... plan definitions\n</code></pre>"},{"location":"kuadrant-operator/doc/extensions/planpolicy/#targeting-a-gateway-networking-resource","title":"Targeting a Gateway networking resource","text":"<p>When a PlanPolicy targets a Gateway, the policy will be enforced on all routes attached to that gateway.</p> <p>Target a Gateway by setting the <code>spec.targetRef</code> field of the PlanPolicy as follows:</p> <pre><code>apiVersion: extensions.kuadrant.io/v1alpha1\nkind: PlanPolicy\nmetadata:\n  name: my-gateway-plan\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: my-gateway\n  plans:\n    # ... plan definitions\n</code></pre>"},{"location":"kuadrant-operator/doc/extensions/planpolicy/#plan-predicates","title":"Plan predicates","text":"<p>Plan predicates are CEL expressions that determine which plan a user belongs to. The predicates are evaluated in order, and the first matching plan is selected.</p> <p>Common predicate patterns:</p> <pre><code># Plan based on annotation in auth secret\npredicate: |\n  has(auth.identity) &amp;&amp; auth.identity.metadata.annotations[\"secret.kuadrant.io/plan-id\"] == \"gold\"\n\n# Plan based on JWT claim\npredicate: |\n  has(auth.identity) &amp;&amp; auth.identity.sub == \"premium-user\"\n\n# Plan based on multiple conditions\npredicate: |\n  has(auth.identity) &amp;&amp; \n  auth.identity.metadata.annotations[\"secret.kuadrant.io/plan-id\"] == \"gold\" &amp;&amp;\n  auth.identity.metadata.labels[\"app\"] == \"my-app\"\n</code></pre>"},{"location":"kuadrant-operator/doc/extensions/planpolicy/#plan-limits","title":"Plan limits","text":"<p>Plan limits define the rate limiting configuration for each tier. You can specify:</p> <ul> <li>daily: Daily request limit</li> <li>weekly: Weekly request limit  </li> <li>monthly: Monthly request limit</li> <li>yearly: Yearly request limit</li> <li>custom: Custom rate limits using RateLimitPolicy Rate format</li> </ul> <pre><code>limits:\n  daily: 1000\n  weekly: 5000\n  monthly: 20000\n  yearly: 200000\n  custom:\n\n    - limit: 100\n      window: \"1h\"\n    - limit: 10\n      window: \"1m\"\n</code></pre>"},{"location":"kuadrant-operator/doc/extensions/planpolicy/#prerequisites","title":"Prerequisites","text":"<p>Before using PlanPolicy, ensure you have:</p> <ol> <li>Kuadrant Operator installed and running</li> <li>Gateway API resources (Gateway and HTTPRoute) configured</li> <li>AuthPolicy configured for authentication</li> </ol>"},{"location":"kuadrant-operator/doc/extensions/planpolicy/#examples","title":"Examples","text":"<p>Check out the following user guide for a complete example of using PlanPolicy:</p> <ul> <li>Plan-based Rate Limiting Tutorial</li> </ul>"},{"location":"kuadrant-operator/doc/extensions/planpolicy/#known-limitations","title":"Known limitations","text":"<ul> <li>PlanPolicies can only target HTTPRoutes/Gateways defined within the same namespace as the PlanPolicy</li> <li>Plan predicates are evaluated in order - ensure more specific plans come before general ones</li> <li>Requires authentication to be configured via AuthPolicy for plan identification</li> </ul>"},{"location":"kuadrant-operator/doc/install/mtls-configuration/","title":"Configure mTLS between the Gateway and Kuadrant components","text":""},{"location":"kuadrant-operator/doc/install/mtls-configuration/#overview","title":"Overview","text":"<p>This guide includes manual steps to enable mTLS between an Istio provided gateway and the Kuadrant data plane components. If you use an AuthPolicy or RateLimitPolicy, there will be communication between the gateway and the respective Kuadrant components at request time. This communication happens between the Wasm plugin in Envoy proxy, and Authorino or Limitador. At the time of writing there is an RFC discussing how to add mTLS capabilities as a feature of the Kuadrant operator. If you are interested in having that feature or influencing how it is delivered, please engage on that pull request.</p> <p>Note</p> <p>This method currently only works if the Gateway is provided by Istio, with service mesh capabilities enabled across the cluster. For example, the Istio CNI agent is running on each node.</p> <p>OpenShift 4.19+ Users</p> <p>If you require mTLS on OpenShift Container Platform (OCP) 4.19 or later, the Cluster Ingress Operator (CIO) managed Istio is not a viable option because it lacks the necessary service mesh capabilities that Kuadrant's mTLS feature relies on.</p> <p>Instead, you must create a custom Istio CR (Custom Resource) with the CNI (Container Network Interface) requirement enabled. The Gateway API can also be enabled on this custom Istio CR.</p> <p>Important: When defining your Gateways, ensure they avoid using the <code>openshift.io/gateway-controller/v1</code> controller name. This prevents the Cluster Ingress Operator from attempting to manage resources for your custom Istio control plane.</p>"},{"location":"kuadrant-operator/doc/install/mtls-configuration/#prerequisites","title":"Prerequisites","text":"<ul> <li>Have Istio as the Gateway API provider installed.</li> <li>You have installed Kuadrant in a Kubernetes cluster.</li> </ul>"},{"location":"kuadrant-operator/doc/install/mtls-configuration/#enabling-mtls","title":"Enabling mTLS","text":"<p>In order to ensure that communications between the gateway and the kuadrant data plane components are secured, set kuadrant's custom resource <code>spec.mtls.enable</code> field to <code>true</code>.</p> <p>Example:</p> <pre><code>apiVersion: kuadrant.io/v1beta1\nkind: Kuadrant\nmetadata:\n  name: kuadrant-sample\nspec:\n  mtls:\n    enable: true\n</code></pre> <p>Note</p> <p>In the absence of AuthPolicy or RateLimitPolicy, the gateway does not communicate with kuadrant data plane components. Hence, enabling mTLS is useless.</p> <p>Note</p> <p>Behind the scenes, kuadrant will create a PeerAuthentication resource where the <code>mtls</code> mode is set to <code>STRICT</code>.</p>"},{"location":"kuadrant-operator/doc/install/mtls-configuration/#mtls-enabled-at-a-component-level","title":"mTLS enabled at a component level","text":"<p>mTLS can also be enabled at a component level. Kuadrant allows to opt-out from using mTLS for some specific component.</p> <p>For example, enable mTLS for kuadrant data plane components, but disable limitador:</p> <pre><code>apiVersion: kuadrant.io/v1beta1\nkind: Kuadrant\nmetadata:\n  name: kuadrant-sample\nspec:\n  mtls:\n    enable: true\n    limitador: false\n</code></pre> <p>For example, enable mTLS for kuadrant data plane components, but disable authorino:</p> <pre><code>apiVersion: kuadrant.io/v1beta1\nkind: Kuadrant\nmetadata:\n  name: kuadrant-sample\nspec:\n  mtls:\n    enable: true\n    authorino: false\n</code></pre>"},{"location":"kuadrant-operator/doc/install/mtls-configuration/#disabling-mtls","title":"Disabling mTLS","text":"<p>To disable mTLS, either set kuadrant's custom resource <code>spec.mtls.enable</code> field to <code>false</code> or just remove optional <code>spec.mtls</code> field.</p> <p>Example:</p> <pre><code>apiVersion: kuadrant.io/v1beta1\nkind: Kuadrant\nmetadata:\n  name: kuadrant-sample\nspec:\n  mtls: null\n</code></pre>"},{"location":"kuadrant-operator/doc/observability/envoy-access-logs/","title":"Envoy Access Logs and Request Correlation","text":""},{"location":"kuadrant-operator/doc/observability/envoy-access-logs/#introduction","title":"Introduction","text":"<p>This guide explains how to configure Envoy access logs in Istio-based Kuadrant deployments to enable request correlation using <code>x-request-id</code>. Access logs provide detailed information about each request processed by the gateway, including timing, response codes, and request identifiers that can be correlated with traces and application logs.</p>"},{"location":"kuadrant-operator/doc/observability/envoy-access-logs/#prerequisites","title":"Prerequisites","text":"<ul> <li>A Kubernetes cluster with Istio and Kuadrant installed</li> <li>Istio configured as your Gateway API provider</li> </ul>"},{"location":"kuadrant-operator/doc/observability/envoy-access-logs/#understanding-request-correlation","title":"Understanding Request Correlation","text":"<p>Request correlation allows you to track a single request across multiple services and components using a unique identifier. In Envoy and Istio, this is typically done using the <code>x-request-id</code> header, which is:</p> <ul> <li>Automatically generated by Envoy for each incoming request (if not already present)</li> <li>Propagated to upstream services</li> <li>Included in access logs for correlation with application logs and traces</li> <li>Used to correlate requests across gateways, Authorino, Limitador, and backend services</li> </ul>"},{"location":"kuadrant-operator/doc/observability/envoy-access-logs/#configuring-access-logs-with-the-telemetry-api","title":"Configuring Access Logs with the Telemetry API","text":""},{"location":"kuadrant-operator/doc/observability/envoy-access-logs/#basic-configuration","title":"Basic Configuration","text":"<p>Enable access logs using Istio's Telemetry API. This is the recommended approach for configuring access logs in Istio.</p> <pre><code>apiVersion: telemetry.istio.io/v1alpha1\nkind: Telemetry\nmetadata:\n  name: access-logs\n  namespace: istio-system  # Or gateway-system, depending on your setup\nspec:\n  accessLogging:\n\n    - providers:\n      - name: envoy\n</code></pre> <p>This enables access logs with Envoy's default log format.</p>"},{"location":"kuadrant-operator/doc/observability/envoy-access-logs/#structured-logging-json-format","title":"Structured Logging (JSON Format)","text":"<p>For better parsing and integration with log aggregation systems (Loki, Elasticsearch, etc.), enable JSON-formatted access logs:</p> <pre><code>apiVersion: telemetry.istio.io/v1alpha1\nkind: Telemetry\nmetadata:\n  name: access-logs-json\n  namespace: istio-system\nspec:\n  accessLogging:\n\n    - providers:\n      - name: envoy\n    filter:\n      expression: \"response.code &gt;= 400\"  # Optional: only log errors\n</code></pre> <p>To enable JSON encoding, configure the Istio mesh with a custom access log provider.</p> <p>Check which Istio installation method you're using:</p> <pre><code># Sail Operator (modern/recommended)\nkubectl get istio -A\n\n# Classic IstioOperator (legacy)\nkubectl get istiooperator -A\n</code></pre> <p>If using Istio Sail Operator (recommended):</p> <pre><code>apiVersion: sailoperator.io/v1\nkind: Istio\nmetadata:\n  name: default\nspec:\n  namespace: istio-system\n  values:\n    meshConfig:\n      accessLogFile: /dev/stdout\n      accessLogEncoding: JSON\n      accessLogFormat: |\n        {\n          \"start_time\": \"%START_TIME%\",\n          \"method\": \"%REQ(:METHOD)%\",\n          \"path\": \"%REQ(X-ENVOY-ORIGINAL-PATH?:PATH)%\",\n          \"protocol\": \"%PROTOCOL%\",\n          \"response_code\": \"%RESPONSE_CODE%\",\n          \"response_flags\": \"%RESPONSE_FLAGS%\",\n          \"bytes_received\": \"%BYTES_RECEIVED%\",\n          \"bytes_sent\": \"%BYTES_SENT%\",\n          \"duration\": \"%DURATION%\",\n          \"upstream_service_time\": \"%RESP(X-ENVOY-UPSTREAM-SERVICE-TIME)%\",\n          \"x_forwarded_for\": \"%REQ(X-FORWARDED-FOR)%\",\n          \"user_agent\": \"%REQ(USER-AGENT)%\",\n          \"request_id\": \"%REQ(X-REQUEST-ID)%\",\n          \"authority\": \"%REQ(:AUTHORITY)%\",\n          \"upstream_host\": \"%UPSTREAM_HOST%\",\n          \"upstream_cluster\": \"%UPSTREAM_CLUSTER%\",\n          \"route_name\": \"%ROUTE_NAME%\"\n        }\n</code></pre> <p>If using classic IstioOperator (legacy installations):</p> <pre><code>apiVersion: install.istio.io/v1alpha1\nkind: IstioOperator\nmetadata:\n  name: istio\nspec:\n  meshConfig:\n    accessLogFile: /dev/stdout\n    accessLogEncoding: JSON\n      accessLogFormat: |\n        {\n          \"start_time\": \"%START_TIME%\",\n          \"method\": \"%REQ(:METHOD)%\",\n          \"path\": \"%REQ(X-ENVOY-ORIGINAL-PATH?:PATH)%\",\n          \"protocol\": \"%PROTOCOL%\",\n          \"response_code\": \"%RESPONSE_CODE%\",\n          \"response_flags\": \"%RESPONSE_FLAGS%\",\n          \"bytes_received\": \"%BYTES_RECEIVED%\",\n          \"bytes_sent\": \"%BYTES_SENT%\",\n          \"duration\": \"%DURATION%\",\n          \"upstream_service_time\": \"%RESP(X-ENVOY-UPSTREAM-SERVICE-TIME)%\",\n          \"x_forwarded_for\": \"%REQ(X-FORWARDED-FOR)%\",\n          \"user_agent\": \"%REQ(USER-AGENT)%\",\n          \"request_id\": \"%REQ(X-REQUEST-ID)%\",\n          \"authority\": \"%REQ(:AUTHORITY)%\",\n          \"upstream_host\": \"%UPSTREAM_HOST%\",\n          \"upstream_cluster\": \"%UPSTREAM_CLUSTER%\",\n          \"route_name\": \"%ROUTE_NAME%\"\n        }\n</code></pre>"},{"location":"kuadrant-operator/doc/observability/envoy-access-logs/#key-fields-for-request-correlation","title":"Key Fields for Request Correlation","text":"<p>The most important fields for request correlation are:</p> <ul> <li><code>request_id</code> (<code>%REQ(X-REQUEST-ID)%</code>): The unique request identifier generated by Envoy</li> <li><code>start_time</code> (<code>%START_TIME%</code>): Request start time for temporal correlation</li> <li><code>route_name</code> (<code>%ROUTE_NAME%</code>): The route that matched the request (useful for policy debugging)</li> <li><code>upstream_cluster</code> (<code>%UPSTREAM_CLUSTER%</code>): The upstream service that handled the request</li> </ul>"},{"location":"kuadrant-operator/doc/observability/envoy-access-logs/#correlating-with-kuadrant-components","title":"Correlating with Kuadrant Components","text":""},{"location":"kuadrant-operator/doc/observability/envoy-access-logs/#request-flow-and-correlation-points","title":"Request Flow and Correlation Points","text":"<p>A typical request flows through these components:</p> <pre><code>Client \u2192 Envoy Gateway \u2192 [Wasm Shim] \u2192 Authorino \u2192 Limitador \u2192 Backend Service\n         \u2193                                    \u2193            \u2193\n    Access Logs                          Auth Logs    Rate Limit Logs\n</code></pre>"},{"location":"kuadrant-operator/doc/observability/envoy-access-logs/#configuring-kuadrant-for-request-correlation","title":"Configuring Kuadrant for Request Correlation","text":"<p>To enable request correlation across Kuadrant components, configure the <code>httpHeaderIdentifier</code> in the Kuadrant CR:</p> <pre><code>apiVersion: kuadrant.io/v1beta1\nkind: Kuadrant\nmetadata:\n  name: kuadrant\n  namespace: kuadrant-system\nspec:\n  observability:\n    dataPlane:\n      httpHeaderIdentifier: x-request-id\n      defaultLevels:\n\n        - debug: \"true\"  # Optional: Controls OTEL trace filtering for the wasm-shim\n    tracing:\n      defaultEndpoint: rpc://jaeger.jaeger.svc.cluster.local:4317\n      insecure: true\n</code></pre> <p>This configuration:</p> <ul> <li>Tells wasm-shim to include the <code>x-request-id</code> header value in trace spans</li> <li>Enables request correlation across Envoy access logs, Authorino, Limitador, and wasm-shim traces</li> <li>Optionally controls OpenTelemetry trace filtering via <code>defaultLevels</code></li> </ul> <p>Important - Understanding Kuadrant Observability vs Envoy Access Logs:</p> <ul> <li>Envoy Access Logs (configured via Istio Telemetry API above): HTTP request/response logs visible via <code>kubectl logs</code> on gateway pods</li> <li>Kuadrant <code>dataPlane.defaultLevels</code>: Controls trace span filtering sent to your tracing collector (Jaeger/Tempo), not gateway pod logs</li> <li>Kuadrant <code>dataPlane.httpHeaderIdentifier</code>: Includes the specified header in both trace spans and enables correlation with access logs</li> </ul> <p>For detailed information on wasm-shim observability configuration and how to enable debug logging in gateway pods, see the Tracing documentation.</p>"},{"location":"kuadrant-operator/doc/observability/envoy-access-logs/#example-log-correlation","title":"Example Log Correlation","text":"<p>With proper configuration, you can correlate logs across all components using the <code>x-request-id</code>:</p> <p>Envoy Access Log (JSON): <pre><code>{\n  \"start_time\": \"2026-01-23T15:45:12.345Z\",\n  \"method\": \"GET\",\n  \"path\": \"/api/users\",\n  \"response_code\": 200,\n  \"request_id\": \"a1b2c3d4-e5f6-7890-abcd-ef1234567890\",\n  \"route_name\": \"toystore-route\"\n}\n</code></pre></p> <p>Authorino Log: <pre><code>{\"level\":\"info\",\"ts\":\"2026-01-23T15:45:12.350Z\",\"request_id\":\"a1b2c3d4-e5f6-7890-abcd-ef1234567890\",\"msg\":\"auth check succeeded\",\"identity\":\"alice\"}\n</code></pre></p> <p>Limitador Log: <pre><code>Request received: ... \"x-request-id\": \"a1b2c3d4-e5f6-7890-abcd-ef1234567890\" ...\n</code></pre></p>"},{"location":"kuadrant-operator/doc/observability/envoy-access-logs/#integration-with-tracing","title":"Integration with Tracing","text":"<p>When both access logging and tracing are enabled, you can correlate traces with access logs:</p> <ol> <li>Access logs show the <code>x-request-id</code></li> <li>Traces include the <code>x-request-id</code> as a span attribute</li> <li>Use Grafana to jump from logs to traces and vice versa</li> </ol> <p>See the tracing documentation for details on enabling tracing.</p>"},{"location":"kuadrant-operator/doc/observability/envoy-access-logs/#filtering-access-logs","title":"Filtering Access Logs","text":"<p>To reduce log volume, filter access logs based on specific criteria:</p>"},{"location":"kuadrant-operator/doc/observability/envoy-access-logs/#log-only-errors","title":"Log Only Errors","text":"<pre><code>apiVersion: telemetry.istio.io/v1alpha1\nkind: Telemetry\nmetadata:\n  name: access-logs-errors-only\n  namespace: istio-system\nspec:\n  accessLogging:\n\n    - providers:\n      - name: envoy\n      filter:\n        expression: \"response.code &gt;= 400\"\n</code></pre>"},{"location":"kuadrant-operator/doc/observability/envoy-access-logs/#log-specific-routes","title":"Log Specific Routes","text":"<pre><code>apiVersion: telemetry.istio.io/v1alpha1\nkind: Telemetry\nmetadata:\n  name: access-logs-api-only\n  namespace: istio-system\nspec:\n  accessLogging:\n\n    - providers:\n      - name: envoy\n      filter:\n        expression: 'request.url_path.startsWith(\"/api/\")'\n</code></pre>"},{"location":"kuadrant-operator/doc/observability/envoy-access-logs/#exclude-health-checks","title":"Exclude Health Checks","text":"<pre><code>apiVersion: telemetry.istio.io/v1alpha1\nkind: Telemetry\nmetadata:\n  name: access-logs-no-healthz\n  namespace: istio-system\nspec:\n  accessLogging:\n\n    - providers:\n      - name: envoy\n      filter:\n        expression: '!request.url_path.startsWith(\"/healthz\")'\n</code></pre>"},{"location":"kuadrant-operator/doc/observability/envoy-access-logs/#envoy-access-log-format-variables","title":"Envoy Access Log Format Variables","text":"<p>Common Envoy access log format variables:</p> Variable Description <code>%START_TIME%</code> Request start time <code>%REQ(HEADER)%</code> Request header value (e.g., <code>%REQ(X-REQUEST-ID)%</code>) <code>%RESP(HEADER)%</code> Response header value <code>%PROTOCOL%</code> Protocol (HTTP/1.1, HTTP/2, etc.) <code>%RESPONSE_CODE%</code> HTTP response code <code>%RESPONSE_FLAGS%</code> Response flags indicating issues (UH, UF, etc.) <code>%BYTES_RECEIVED%</code> Bytes received from client <code>%BYTES_SENT%</code> Bytes sent to client <code>%DURATION%</code> Total request duration in milliseconds <code>%UPSTREAM_HOST%</code> Upstream host address <code>%UPSTREAM_CLUSTER%</code> Upstream cluster name <code>%ROUTE_NAME%</code> Route name that matched <p>For a complete list, see the Envoy access log documentation.</p>"},{"location":"kuadrant-operator/doc/observability/envoy-access-logs/#troubleshooting","title":"Troubleshooting","text":""},{"location":"kuadrant-operator/doc/observability/envoy-access-logs/#access-logs-not-appearing","title":"Access Logs Not Appearing","text":"<ol> <li> <p>Check Telemetry configuration: <pre><code>kubectl get telemetry -n istio-system\nkubectl describe telemetry access-logs -n istio-system\n</code></pre></p> </li> <li> <p>Verify gateway pod logs: <pre><code>kubectl logs -n istio-system -l istio=gateway --tail=50\n</code></pre></p> </li> <li> <p>Check Istio configuration: <pre><code>kubectl get istio -n istio-system -o yaml | grep -A 10 \"accessLog\"\n</code></pre></p> </li> </ol>"},{"location":"kuadrant-operator/doc/observability/envoy-access-logs/#request-id-not-propagating","title":"Request ID Not Propagating","text":"<p>Ensure that:</p> <ul> <li>The <code>x-request-id</code> header is not being overwritten by upstream services</li> <li>Envoy is configured to generate request IDs (enabled by default)</li> <li>Application code preserves the <code>x-request-id</code> header when making outbound requests</li> </ul>"},{"location":"kuadrant-operator/doc/observability/envoy-access-logs/#log-format-issues","title":"Log Format Issues","text":"<p>If using custom JSON format and logs appear malformed:</p> <ul> <li>Validate JSON syntax (trailing commas are not allowed in JSON)</li> <li>Check for proper escaping of special characters</li> <li>Test format with a simple configuration first</li> </ul>"},{"location":"kuadrant-operator/doc/observability/envoy-access-logs/#best-practices","title":"Best Practices","text":"<ol> <li>Use structured (JSON) logging for easier parsing and analysis</li> <li>Always include <code>x-request-id</code> in your log format for correlation</li> <li>Filter logs to reduce volume and costs (e.g., exclude health checks)</li> <li>Aggregate logs centrally using Loki, Elasticsearch, or similar</li> <li>Correlate with traces for complete observability</li> <li>Configure log rotation to prevent disk space issues</li> <li>Use log levels appropriately (info for access logs, debug for detailed troubleshooting)</li> </ol>"},{"location":"kuadrant-operator/doc/observability/envoy-access-logs/#additional-resources","title":"Additional Resources","text":"<ul> <li>Istio Telemetry API Documentation</li> <li>Configure access logs with Telemetry API</li> <li>Envoy Access Logs</li> <li>Kuadrant Tracing Documentation</li> <li>Kuadrant Metrics Documentation</li> </ul>"},{"location":"kuadrant-operator/doc/observability/examples/","title":"Example Dashboards and Alerts","text":"<p>Explore a variety of starting points for monitoring your Kuadrant installation with our examples folder. These dashboards and alerts are ready-to-use and easily customizable to fit your environment.</p> <p>There are some example dashboards uploaded to Grafana.com . You can use the ID's listed below to import these dashboards into Grafana:</p> Name ID App Developer Dashboard <code>21538</code> Business User Dashboard <code>20981</code> Platform Engineer Dashboard <code>20982</code> DNS Operator Dashboard <code>22695</code>"},{"location":"kuadrant-operator/doc/observability/examples/#dashboards","title":"Dashboards","text":""},{"location":"kuadrant-operator/doc/observability/examples/#importing-dashboards-into-grafana","title":"Importing Dashboards into Grafana","text":"<p>For more details on how to import dashboards into Grafana, visit the import dashboards page. </p> <ul> <li>UI Method:<ul> <li>JSON -  Use the 'Import' feature in the Grafana UI to upload dashboard JSON files directly.</li> <li>ID - Use the 'Import' feature in the Grafana UI to import via Grafana.com using a Dashboard ID. </li> </ul> </li> <li>ConfigMap Method: Automate dashboard provisioning by adding files to a ConfigMap, which should be mounted at <code>/etc/grafana/provisioning/dashboards</code>.</li> </ul> <p>Datasources are configured as template variables, automatically integrating with your existing data sources. Metrics for these dashboards are sourced from Prometheus. For more details on the metrics used, visit the metrics documentation page.</p>"},{"location":"kuadrant-operator/doc/observability/examples/#alerts","title":"Alerts","text":""},{"location":"kuadrant-operator/doc/observability/examples/#setting-up-alerts-in-prometheus","title":"Setting Up Alerts in Prometheus","text":"<p>You can integrate the example alerts into Prometheus as <code>PrometheusRule</code> resources. Feel free to adjust alert thresholds to suit your specific operational needs.</p> <p>Additionally, Service Level Objective (SLO) alerts generated with Sloth are included. A benefit of these alerts is the ability to integrate them with this SLO dashboard, which utilizes generated labels to comprehensively overview your SLOs.</p> <p>Further information on the metrics used for these alerts can be found on the metrics page.</p>"},{"location":"kuadrant-operator/doc/observability/metrics/","title":"Metrics","text":"<p>This is a reference page for some of the different metrics used in example dashboards and alerts. It is not an exhaustive list. The documentation for each component may provide more details on a per-component basis. Some of the metrics are sourced from components outside the Kuadrant project, for example, Envoy. The value of this reference is showing some of the more widely desired metrics, and how to join the metrics from different sources together in a meaningful way.</p>"},{"location":"kuadrant-operator/doc/observability/metrics/#metrics-sources","title":"Metrics sources","text":"<ul> <li>Kuadrant components</li> <li>Istio</li> <li>Envoy</li> <li>Kube State Metrics</li> <li>Gateway API State Metrics</li> <li>Kubernetes metrics</li> </ul>"},{"location":"kuadrant-operator/doc/observability/metrics/#kuadrant-operator-metrics","title":"Kuadrant operator metrics","text":"<p>The Kuadrant operator exposes its own set of Prometheus metrics to provide visibility into policy enforcement status and operator health. These metrics are automatically available when the operator is running and can be scraped via the ServiceMonitor created when <code>observability.enable: true</code> is set in the Kuadrant CR.</p>"},{"location":"kuadrant-operator/doc/observability/metrics/#policy-metrics","title":"Policy metrics","text":"<p>Policy metrics track the state of all Kuadrant policies in the cluster. These metrics are updated automatically as policies are created, modified, or deleted.</p> Metric Name Type Labels Description <code>kuadrant_policies_total</code> Gauge <code>kind</code> Total number of Kuadrant policies by kind (<code>AuthPolicy</code>, <code>RateLimitPolicy</code>, <code>DNSPolicy</code>, <code>TLSPolicy</code>, <code>TokenRateLimitPolicy</code>). Note: Extension policies (<code>OIDCPolicy</code>, <code>PlanPolicy</code>, <code>TelemetryPolicy</code>) are not tracked. <code>kuadrant_policies_enforced</code> Gauge <code>kind</code>, <code>status</code> Number of policies by kind and enforcement status. <code>status=\"true\"</code> when policy has <code>Enforced</code> condition with status <code>True</code>, <code>status=\"false\"</code> otherwise."},{"location":"kuadrant-operator/doc/observability/metrics/#operator-health-metrics","title":"Operator health metrics","text":"<p>Operator health metrics provide visibility into the operator's startup state, dependency detection, and component readiness. These metrics are critical for understanding whether the operator can successfully manage policies.</p> Metric Name Type Labels Description <code>kuadrant_dependency_detected</code> Gauge <code>dependency</code> Whether a dependency was detected at operator startup (1=detected, 0=not detected). Dependencies: <code>authorino</code>, <code>limitador</code>, <code>cert-manager</code>, <code>dns-operator</code>, <code>istio</code>, <code>envoygateway</code>. <code>kuadrant_controller_registered</code> Gauge <code>controller</code> Whether a controller was registered at startup and is active (1=registered, 0=not registered). Controllers: <code>auth_policies</code>, <code>rate_limit_policies</code>, <code>dns_policies</code>, <code>tls_policies</code>, <code>token_rate_limit_policies</code>. <code>kuadrant_exists</code> Gauge - Whether a Kuadrant CR exists in the cluster (1=exists, 0=does not exist). <code>kuadrant_ready</code> Gauge <code>namespace</code>, <code>name</code> Whether the Kuadrant CR has a <code>Ready</code> condition with status <code>True</code> (1=ready, 0=not ready). Metric is absent when CR doesn't exist. <code>kuadrant_component_ready</code> Gauge <code>component</code>, <code>namespace</code> Whether a Kuadrant-managed component is ready (1=ready, 0=not ready). Components: <code>authorino</code>, <code>limitador</code>. Metric is absent when CR doesn't exist."},{"location":"kuadrant-operator/doc/observability/metrics/#resource-usage-metrics","title":"Resource usage metrics","text":"<p>Resource metrics, like CPU, memory and disk usage, primarily come from the Kubernetes metrics components. These include <code>container_cpu_usage_seconds_total</code>, <code>container_memory_working_set_bytes</code> and <code>kubelet_volume_stats_used_bytes</code>. A stable list of metrics is maintained in the Kubernetes repository. These low-level metrics typically have a set of recording rules that aggregate values by labels and time ranges. For example, <code>node_namespace_pod_container:container_cpu_usage_seconds_total:sum_irate</code> or <code>namespace_workload_pod:kube_pod_owner:relabel</code>. If you have deployed the kube-prometheus project, you should have the majority of these metrics being scraped.</p>"},{"location":"kuadrant-operator/doc/observability/metrics/#networking-metrics","title":"Networking metrics","text":"<p>Low-level networking metrics like <code>container_network_receive_bytes_total</code> are also available from the Kubernetes metrics components. HTTP &amp; GRPC traffic metrics with higher level labels are available from Istio. One of the main metrics would be <code>istio_requests_total</code>, which is a counter incremented for every request handled by an Istio proxy. Latency metrics are available via the <code>istio_request_duration_milliseconds</code> metric, with buckets for varying response times.</p> <p>Some example dashboards have panels that make use of the request URL path. The path is not added as a label to Istio metrics by default, as it has the potential to increase metric cardinality, and thus storage requirements. If you want to make use of the path in your queries or visualisations, you can enable the request path metric via the Telemetry resource in istio:</p> <pre><code>apiVersion: telemetry.istio.io/v1alpha1\nkind: Telemetry\nmetadata:\n  name: namespace-metrics\n  namespace: gateway-system\nspec:\n  metrics:\n\n  - providers:\n    - name: prometheus\n    overrides:\n    - match:\n        metric: REQUEST_COUNT\n      tagOverrides:\n        request_url_path:\n          value: \"request.url_path\"\n    - match:      \n        metric: REQUEST_DURATION\n      tagOverrides:\n        request_url_path:\n          value: \"request.url_path\"\n</code></pre>"},{"location":"kuadrant-operator/doc/observability/metrics/#state-metrics","title":"State metrics","text":"<p>The kube-state-metrics project exposes the state of various kuberenetes resources as metrics and labels. For example, the ready <code>status</code> of a <code>Pod</code> is available as <code>kube_pod_status_ready</code>, with labels for the pod <code>name</code> and <code>namespace</code>. This can be useful for linking lower level container metrics back to a meaningful resource in the Kubernetes world.</p>"},{"location":"kuadrant-operator/doc/observability/metrics/#joining-metrics","title":"Joining metrics","text":"<p>Metric queries can be as simple as just the name of the metric, or can be complex with joining &amp; grouping. A lot of the time it can be useful to tie back low level metrics to more meaningful Kubernetes resources. For example, if the memory usage is maxed out on a container and that container is constantly being OOMKilled, it can be useful to get the Deployment and Namespace of that container for debugging. Prometheus query language (or promql) allows vector matching or results (sometimes called joining).</p> <p>When using Gateway API and Kuadrant resources like HTTPRoute and RateLimitPolicy, the state metrics can be joined to Istio metrics to give a meaningful result set. Here's an example that queries the number of requests per second, and includes the name of the HTTPRoute that the traffic is for.</p> <pre><code>sum(\n    rate(\n        istio_requests_total{}[5m]\n    )\n) by (destination_service_name)\n\n\n* on(destination_service_name) group_right \n    label_replace(gatewayapi_httproute_labels{}, \\\"destination_service_name\\\", \\\"$1\\\",\\\"service\\\", \\\"(.+)\\\")\n</code></pre> <p>Breaking this query down, there are 2 parts. The first part is getting the rate of requests hitting the Istio gateway, aggregated to 5m intervals:</p> <pre><code>sum(\n    rate(\n        destination_service_name{}[5m]\n    )\n) by (destination_service_name)\n</code></pre> <p>The result set here will include a label for the destination service name (i.e. the Service in Kubernetes). This label is key to looking up the HTTPRoute this traffic belongs to.</p> <p>The 2nd part of the query uses the <code>gatewayapi_httproute_labels</code> metric and the <code>label_replace</code> function. The <code>gatewayapi_httproute_labels</code> metric gives a list of all httproutes, including any labels on them. The HTTPRoute in this example has a label called 'service', set to be the same as the Istio service name. This allows us to join the 2 results set. However, because the label doesn't match exactly (<code>destination_service_name</code> and <code>service</code>), we can replace the label so that it does match. That's what the <code>label_replace</code> does.</p> <pre><code>    label_replace(gatewayapi_httproute_labels{}, \\\"destination_service_name\\\", \\\"$1\\\",\\\"service\\\", \\\"(.+)\\\")\n</code></pre> <p>The 2 parts are joined together using vector matching.</p> <pre><code>* on(destination_service_name) group_right \n</code></pre> <ul> <li><code>*</code> is the binary operator i.e. multiplication (gives join like behaviour)</li> <li><code>on()</code> specifies which labels to \"join\" the 2 results with</li> <li><code>group_right</code> enables a one to many matching.</li> </ul> <p>See the Prometheus documentation for further details on matching.</p>"},{"location":"kuadrant-operator/doc/observability/tracing/","title":"Enabling tracing with a central collector","text":""},{"location":"kuadrant-operator/doc/observability/tracing/#introduction","title":"Introduction","text":"<p>This guide outlines the steps to enable tracing in Istio and Kuadrant components (Authorino, Limitador, and wasm-shim), directing traces to a central collector for improved observability and troubleshooting. We'll also explore a typical troubleshooting flow using traces and logs.</p>"},{"location":"kuadrant-operator/doc/observability/tracing/#prerequisites","title":"Prerequisites","text":"<ul> <li>A Kubernetes cluster with Istio and Kuadrant installed.</li> <li>A trace collector (e.g., Jaeger or Tempo) configured to support OpenTelemetry (OTel).</li> </ul>"},{"location":"kuadrant-operator/doc/observability/tracing/#configuration-steps","title":"Configuration Steps","text":""},{"location":"kuadrant-operator/doc/observability/tracing/#istio-tracing-configuration","title":"Istio Tracing Configuration","text":"<p>Enable tracing in Istio by using the Telemetry API. Depending on your method for installing Istio, you will need to configure a tracing <code>extensionProvider</code> in your MeshConfig, Istio or IstioOperator resource as well. Here is an example Telemetry and Istio config to sample 100% of requests, if using the Istio Sail Operator.</p> <pre><code>apiVersion: telemetry.istio.io/v1alpha1\nkind: Telemetry\nmetadata:\n  name: mesh-default\n  namespace: gateway-system\nspec:\n  tracing:\n\n  - providers:\n    - name: jaeger-collector\n    randomSamplingPercentage: 100\n---\napiVersion: operator.istio.io/v1alpha1\nkind: Istio\nmetadata:\n  name: default\nspec:\n  namespace: gateway-system\n  values:\n    meshConfig:\n      defaultConfig:\n        tracing: {}\n      enableTracing: true\n      extensionProviders:\n      - name: jaeger-collector\n        opentelemetry:\n          port: 4317\n          service: jaeger-collector.jaeger.svc.cluster.local\n</code></pre> <p>Important:</p> <p>The OpenTelemetry collector protocol should be explicitly set in the service port <code>name</code> or <code>appProtocol</code> fields as per the Istio documentation. For example, when using gRPC, the port <code>name</code> should begin with <code>grpc-</code> or the <code>appProtocol</code> should be <code>grpc</code>.</p>"},{"location":"kuadrant-operator/doc/observability/tracing/#kuadrant-tracing-configuration","title":"Kuadrant Tracing Configuration","text":"<p>Kuadrant components (Authorino, Limitador, and Wasm-shim) have request tracing capabilities. Configure tracing centrally via the Kuadrant CR to automatically propagate the configuration to all components. Ensure the collector is the same one that Istio is sending traces so that they can be correlated later.</p>"},{"location":"kuadrant-operator/doc/observability/tracing/#kuadrant-cr-configuration","title":"Kuadrant CR Configuration","text":"<p>Configure tracing centrally in the Kuadrant CR. This configuration will be automatically propagated to:</p> <ul> <li>Authorino (Auth service - authentication decisions)</li> <li>Limitador (Rate limiting service - rate limit checks)</li> <li>Wasm-shim (Envoy WebAssembly filter - gateway-level tracing)</li> </ul> <pre><code>apiVersion: kuadrant.io/v1beta1\nkind: Kuadrant\nmetadata:\n  name: kuadrant\n  namespace: kuadrant-system\nspec:\n  observability:\n    dataPlane:\n      defaultLevels:\n\n        - debug: \"true\"  # Enable DEBUG level trace filtering\n      httpHeaderIdentifier: x-request-id\n    tracing:\n      defaultEndpoint: rpc://jaeger-collector.jaeger.svc.cluster.local:4317\n      insecure: true\n</code></pre> <p>Tracing Configuration Fields:</p> <ul> <li><code>defaultEndpoint</code>: The URL of the tracing collector backend (OTLP endpoint). Supported protocols:</li> <li><code>rpc://</code> for gRPC OTLP (port 4317)</li> <li><code>http://</code> for HTTP OTLP (port 4318)</li> <li><code>insecure</code>: Set to <code>true</code> to skip TLS certificate verification (useful for development environments).</li> </ul> <p>Important: Point to the collector service (e.g., <code>jaeger-collector</code>), not the query service. The collector receives traces from your applications, while the query service is only for viewing traces in the UI.</p> <p>Once applied, the Authorino and Limitador components will be redeployed with tracing enabled.</p> <p>Data Plane Configuration Fields:</p> <ul> <li><code>defaultLevels</code>: Controls the OpenTelemetry trace filtering level for the wasm-shim. This determines which trace spans are exported to your tracing collector.</li> <li>Supported levels (highest to lowest verbosity): <code>debug</code>, <code>info</code>, <code>warn</code>, <code>error</code></li> <li>Current implementation (MVP): Set to <code>\"true\"</code> to enable that level (e.g., <code>debug: \"true\"</code>)</li> <li>Future: Will support CEL expressions for dynamic request-time evaluation</li> <li>Default: <code>WARN</code> if not specified</li> <li> <p>Priority: DEBUG &gt; INFO &gt; WARN &gt; ERROR (highest level set wins)</p> </li> <li> <p><code>httpHeaderIdentifier</code>: Specifies the HTTP header name used to correlate requests in traces (e.g., <code>x-request-id</code>)</p> </li> </ul> <p>Important - Understanding what <code>defaultLevels</code> controls:</p> <p>The <code>defaultLevels</code> configuration controls trace span filtering sent to your observability backend (Jaeger, Tempo, etc.), not the verbosity of logs appearing in gateway pod output.</p> <ul> <li>To view traces: Configure <code>defaultLevels</code> in the Kuadrant CR and view traces in your tracing UI (Jaeger/Grafana)</li> <li>To see debug logs in gateway pods: Configure Envoy's log level separately (see Enabling Gateway Debug Logs in the troubleshooting section)</li> </ul>"},{"location":"kuadrant-operator/doc/observability/tracing/#direct-configuration-advanced","title":"Direct Configuration (Advanced)","text":"<p>For advanced use cases, you can configure tracing directly in the Authorino or Limitador CRs:</p> <pre><code>apiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  tracing:\n    endpoint: rpc://authorino-collector:4317\n    insecure: true\n---\napiVersion: limitador.kuadrant.io/v1alpha1\nkind: Limitador\nmetadata:\n  name: limitador\nspec:\n  tracing:\n    endpoint: rpc://limitador-collector:4317\n</code></pre> <p>Important: When tracing is configured directly in Authorino or Limitador CRs, those settings take precedence over the Kuadrant CR configuration. The Kuadrant operator will cede ownership of the tracing field to you, allowing full control over component-specific tracing endpoints. This is useful when you need different collectors for different components.</p>"},{"location":"kuadrant-operator/doc/observability/tracing/#configuration-precedence","title":"Configuration Precedence","text":"<p>The tracing configuration follows this precedence order:</p> <ol> <li>Component-specific configuration (Authorino/Limitador CR) - highest priority</li> <li>Centralized configuration (Kuadrant CR) - applies when component CRs don't specify tracing</li> </ol> <p>If you set tracing in the Kuadrant CR and later configure it directly in an Authorino or Limitador CR, the component-specific configuration will take precedence, and the Kuadrant operator will no longer manage that component's tracing settings.</p> <p>Note on Trace Continuity:</p> <p>Currently, trace IDs do not propagate to WebAssembly modules in Istio/Envoy. This affects trace continuity when rate limiting is enforced, as requests may not have the relevant 'parent' trace ID in their trace information.</p> <p>However, if the trace initiation point is outside of Envoy/Istio, the 'parent' trace ID will be available and included in traces passed to the collector. This limitation can impact correlating traces across the gateway, auth service, rate limiting, and other components in the request path.</p> <p>Despite this, Kuadrant configures tracing for the wasm-shim when using the centralized configuration, ensuring that trace data is collected even if parent-child relationships may be limited in some scenarios.</p>"},{"location":"kuadrant-operator/doc/observability/tracing/#control-plane-tracing","title":"Control Plane Tracing","text":"<p>The Kuadrant operator itself (the control plane) exports traces to your OpenTelemetry collector, allowing you to observe the operator's reconciliation loops and internal operations. This is useful for debugging controller behavior, understanding operator performance, and tracking policy lifecycle events.</p> <p>Note: Control plane tracing may already be enabled in your installation. Check if you can see <code>kuadrant-operator</code> service in your tracing UI before configuring.</p>"},{"location":"kuadrant-operator/doc/observability/tracing/#enabling-control-plane-tracing","title":"Enabling Control Plane Tracing","text":"<p>The Kuadrant operator exposes OpenTelemetry environment variables for control plane tracing. To enable control plane tracing, you need to set these environment variables in your operator deployment. The method for setting these will depend on your deployment approach (e.g., using Kustomize, Helm, OLM, or direct YAML manifests).</p> <p>Available environment variables:</p> Environment Variable Description Default <code>OTEL_EXPORTER_OTLP_ENDPOINT</code> OTLP collector endpoint for all signals (logs, traces, metrics). Supports <code>http://</code>, <code>https://</code>, <code>rpc://</code> schemes - (tracing disabled) <code>OTEL_EXPORTER_OTLP_TRACES_ENDPOINT</code> OTLP traces-specific endpoint (overrides <code>OTEL_EXPORTER_OTLP_ENDPOINT</code>) - <code>OTEL_EXPORTER_OTLP_INSECURE</code> Disable TLS for OTLP export <code>false</code> <code>OTEL_SERVICE_NAME</code> Service name for telemetry data <code>kuadrant-operator</code> <code>OTEL_SERVICE_VERSION</code> Service version for telemetry data Build version (from ldflags) <p>Note: Tracing is enabled when either <code>OTEL_EXPORTER_OTLP_ENDPOINT</code> or <code>OTEL_EXPORTER_OTLP_TRACES_ENDPOINT</code> is set to a non-empty value.</p> <p>Example values:</p> <ul> <li><code>OTEL_EXPORTER_OTLP_ENDPOINT=rpc://jaeger-collector.jaeger.svc.cluster.local:4317</code></li> <li><code>OTEL_EXPORTER_OTLP_INSECURE=true</code> (use <code>false</code> in production with TLS)</li> </ul> <p>Control plane traces will appear under service name <code>kuadrant-operator</code> in Jaeger/Grafana.</p>"},{"location":"kuadrant-operator/doc/observability/tracing/#control-plane-vs-data-plane-tracing","title":"Control Plane vs Data Plane Tracing","text":"<p>Kuadrant supports tracing at two levels:</p> <ol> <li>Control Plane Tracing (this section): Traces the operator's reconciliation loops and internal operations</li> <li>Shows policy lifecycle events, topology building, resource creation</li> <li> <p>Helps debug operator behavior and performance</p> </li> <li> <p>Data Plane Tracing (see configuration above): Traces actual user requests through the gateway and policy enforcement components</p> </li> <li>Shows request flows through Istio/Envoy, Authorino, Limitador, and wasm-shim</li> <li>Helps debug request-level issues and policy enforcement</li> </ol> <p>Configuration:</p> <ul> <li>Control Plane: Configured via environment variables in the operator deployment (see \"Enabling Control Plane Tracing\" above)</li> <li>Data Plane: Configured via the Kuadrant CR (<code>spec.observability.tracing</code>)</li> </ul> <p>When both are configured to send traces to the same collector, you get a complete view of your Kuadrant system from policy reconciliation to request processing.</p>"},{"location":"kuadrant-operator/doc/observability/tracing/#what-control-plane-traces-show","title":"What Control Plane Traces Show","text":"<p>Control plane traces capture operator activities such as:</p> <ul> <li>Policy reconciliation: When a policy (AuthPolicy, RateLimitPolicy, DNSPolicy, TLSPolicy) is created, updated, or deleted</li> <li>Resource creation: Creating Authorino AuthConfigs, Limitador configurations, wasm-shim, etc.</li> <li>Gateway topology discovery: Analyzing Gateway API resources and computing policy attachments</li> <li>Status updates: Updating policy status conditions</li> <li>Conflict detection: Detecting and resolving policy conflicts</li> <li>Error handling: Tracking reconciliation errors and retries</li> </ul> <p>These traces are separate from data plane traces (actual user requests) and help operators understand what the Kuadrant operator is doing behind the scenes.</p>"},{"location":"kuadrant-operator/doc/observability/tracing/#viewing-control-plane-traces","title":"Viewing Control Plane Traces","text":"<p>Once control plane tracing is enabled, you can view operator traces in Jaeger or Grafana:</p> <p>Using Jaeger UI:</p> <ol> <li>Port-forward to Jaeger Query service:    <pre><code>kubectl port-forward -n &lt;jaeger-namespace&gt; svc/jaeger-query 16686:80\n</code></pre></li> </ol> <p>Or if using the Jaeger all-in-one deployment:    <pre><code>kubectl port-forward -n &lt;jaeger-namespace&gt; svc/jaeger 16686:16686\n</code></pre></p> <ol> <li> <p>Open http://localhost:16686</p> </li> <li> <p>Select service: kuadrant-operator</p> </li> <li> <p>Search for traces by:</p> </li> <li>Operation name: Look for operations like <code>controller.reconcile</code>, <code>workflow.data_plane_policies</code></li> <li>Tags: Filter by specific policy using <code>policy.name=my-policy-name</code></li> <li>Duration: Find slow reconciliations (e.g., min duration &gt; 100ms)</li> </ol> <p>Example searches:</p> <p>Find all traces for a specific RateLimitPolicy: <pre><code>Service: kuadrant-operator\nTags: policy.name=my-ratelimitpolicy\n</code></pre></p> <p>Find slow reconciliations for data plane policies: <pre><code>Service: kuadrant-operator\nOperation: workflow.data_plane_policies\nMin Duration: 100ms\n</code></pre></p> <p>Example Trace Spans:</p> <p>A typical reconciliation loop generates traces showing the workflow structure:</p> <pre><code>controller.reconcile (29.8ms)\n\u251c\u2500 topology.build (495\u00b5s)\n\u251c\u2500 workflow.init (12.56ms)\n\u2502  \u2514\u2500 init.topology_reconciler (10.41ms)\n\u251c\u2500 workflow.data_plane_policies (15.73ms)\n\u2502  \u251c\u2500 validation (72\u00b5s)\n\u2502  \u251c\u2500 effective_policies (3.01ms)\n\u2502  \u2502  \u251c\u2500 effective_policies.auth\n\u2502  \u2502  \u251c\u2500 effective_policies.ratelimit\n\u2502  \u2502  \u2514\u2500 effective_policies.token_ratelimit\n\u2502  \u251c\u2500 reconciler.auth_configs (293\u00b5s)\n\u2502  \u251c\u2500 reconciler.limitador_limits (216\u00b5s)\n\u2502  \u2514\u2500 wasm.BuildConfigForPath (142\u00b5s)\n\u2514\u2500 status_update (12.64ms)\n</code></pre> <p>The trace structure reflects the operator's workflow-based reconciliation:</p> <p>Main Workflows:</p> <ul> <li>controller.reconcile: Main reconciliation entry point for all policy changes</li> <li>topology.build: Building the Gateway API topology graph</li> <li>workflow.init: Initialization workflow (topology reconciliation, event logging)</li> <li>workflow.data_plane_policies: Auth and rate limiting policy reconciliation</li> <li>workflow.dns: DNS policy reconciliation (when DNS policies are present)</li> <li>workflow.tls: TLS policy reconciliation (when TLS policies are present)</li> <li>workflow.observability: Observability configuration reconciliation</li> <li>workflow.limitador: Limitador deployment reconciliation (when Limitador operator is installed)</li> <li>workflow.authorino: Authorino deployment reconciliation (when Authorino operator is installed)</li> <li>status_update: Final workflow for updating policy statuses</li> </ul> <p>Data Plane Policy Workflow Spans:</p> <ul> <li>validation: Validates AuthPolicy, RateLimitPolicy, TokenRateLimitPolicy resources</li> <li>effective_policies: Computes effective policies for each HTTPRoute and Gateway</li> <li><code>effective_policies.auth</code>: Effective auth policies</li> <li><code>effective_policies.ratelimit</code>: Effective rate limit policies</li> <li><code>effective_policies.token_ratelimit</code>: Effective token rate limit policies</li> <li>reconciler.auth_configs: Reconciles Authorino AuthConfig resources</li> <li>reconciler.limitador_limits: Reconciles Limitador limit configurations</li> <li>reconciler.istio_extension: Reconciles Istio WasmPlugin and EnvoyFilter resources (when Istio is the gateway provider)</li> <li>reconciler.envoy_gateway_extension: Reconciles Envoy Gateway extension policies (when Envoy Gateway is the provider)</li> <li>wasm.BuildConfigForPath: Builds wasm-shim configuration for a specific HTTPRoute path</li> </ul>"},{"location":"kuadrant-operator/doc/observability/tracing/#tracing-policy-lifecycle","title":"Tracing Policy Lifecycle","text":"<p>To trace a specific policy creation or update:</p> <ol> <li> <p>Create or update a policy:    <pre><code>kubectl apply -f my-ratelimitpolicy.yaml\n</code></pre></p> </li> <li> <p>Get the policy creation/update timestamp:    <pre><code>kubectl get ratelimitpolicy my-policy -o jsonpath='{.metadata.creationTimestamp}'\n</code></pre></p> </li> <li> <p>Search in Jaeger:</p> </li> <li>Set the time range around the policy change timestamp</li> <li>Look for operation: <code>controller.reconcile</code></li> <li>Expand the trace to see workflow details like <code>workflow.data_plane_policies</code></li> <li>Look for specific reconciler spans like <code>reconciler.limitador_limits</code> or <code>reconciler.auth_configs</code></li> <li>Check timing information to identify performance bottlenecks</li> </ol>"},{"location":"kuadrant-operator/doc/observability/tracing/#correlating-control-plane-and-data-plane-traces","title":"Correlating Control Plane and Data Plane Traces","text":"<p>While control plane and data plane traces are separate, you can correlate them:</p> <ol> <li>Control plane trace: Shows when a policy was reconciled and resources created</li> <li>Data plane trace: Shows actual user requests processed with that policy</li> </ol> <p>Example workflow:</p> <ol> <li>Create a RateLimitPolicy at <code>15:30:00</code></li> <li>View control plane trace to see:</li> <li>Policy reconciliation completed at <code>15:30:05</code></li> <li>Limitador configuration updated</li> <li>WASM plugin deployed</li> <li>Send a test request at <code>15:30:10</code></li> <li>View data plane trace to see:</li> <li>Request processed through the wasm-shim</li> <li>Rate limit check sent to Limitador</li> <li>Response returned</li> </ol>"},{"location":"kuadrant-operator/doc/observability/tracing/#local-development","title":"Local Development","text":"<p>For local development, you can run the operator with control plane tracing enabled by setting environment variables:</p> <pre><code># Start Jaeger or an OTel collector\ndocker compose -f examples/otel/docker-compose.yaml up -d\n\n# Run the operator with OpenTelemetry enabled\n# Note: When running locally, env vars are used instead of the Kuadrant CR\nexport OTEL_EXPORTER_OTLP_INSECURE=true\nexport OTEL_EXPORTER_OTLP_ENDPOINT=http://localhost:4318\nmake run\n\n# View traces in Jaeger (http://localhost:16686)\n</code></pre> <p>Note: Control plane tracing is always configured via environment variables (whether running locally or in-cluster). Data plane tracing is configured via the Kuadrant CR.</p> <p>See the OpenTelemetry example for complete local development setup with Grafana, Tempo, Jaeger, Loki, and Prometheus.</p>"},{"location":"kuadrant-operator/doc/observability/tracing/#configuration-notes","title":"Configuration Notes","text":"<p>When you configure tracing via the Kuadrant CR (<code>spec.observability.tracing</code>), it automatically enables tracing for:</p> <ul> <li>Data Plane: Authorino, Limitador, and Wasm-shim</li> </ul> <p>For control plane tracing (the operator's reconciliation loops), you must configure environment variables in the operator deployment as described in the section above.</p> <p>The combination of control plane environment variables and Kuadrant CR data plane configuration provides complete tracing across your entire Kuadrant deployment.</p>"},{"location":"kuadrant-operator/doc/observability/tracing/#troubleshooting-control-plane-tracing","title":"Troubleshooting Control Plane Tracing","text":"<p>Traces not appearing in Jaeger:</p> <ol> <li>Check if tracing is configured in the Kuadrant CR:    <pre><code>kubectl get kuadrant kuadrant -n kuadrant-system -o jsonpath='{.spec.observability.tracing}'\n</code></pre></li> </ol> <p>Expected output should show <code>defaultEndpoint</code> configured:    <pre><code>{\"defaultEndpoint\":\"rpc://jaeger-collector.jaeger.svc.cluster.local:4317\",\"insecure\":true}\n</code></pre></p> <ol> <li> <p>Check operator logs for OTLP connection errors:    <pre><code>kubectl logs -n kuadrant-system -l control-plane=controller-manager --tail=50 | grep -i otel\n</code></pre></p> </li> <li> <p>Verify the tracing collector endpoint is reachable from the operator:    <pre><code># For HTTP OTLP endpoint (port 4318)\nkubectl exec -n kuadrant-system deployment/kuadrant-operator-controller-manager -- \\\n  curl -v http://jaeger-collector.jaeger.svc.cluster.local:4318/v1/traces\n</code></pre></p> </li> <li> <p>Test sending traces to the collector directly:    <pre><code># Port-forward to the collector for local testing\nkubectl port-forward -n &lt;jaeger-namespace&gt; svc/jaeger-collector 4318:4318\n\n# Send a test trace\ncurl -X POST http://localhost:4318/v1/traces \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"resourceSpans\":[]}'\n</code></pre></p> </li> </ol> <p>Traces are incomplete or missing spans:</p> <ul> <li>Check for errors in the operator logs that might indicate reconciliation failures</li> <li>Verify the collector is not dropping spans due to rate limiting or storage issues</li> <li>Check the collector's own logs for processing errors</li> </ul>"},{"location":"kuadrant-operator/doc/observability/tracing/#understanding-data-plane-traces","title":"Understanding Data Plane Traces","text":""},{"location":"kuadrant-operator/doc/observability/tracing/#prerequisites_1","title":"Prerequisites","text":"<p>Before you can view data plane traces, ensure you have:</p> <ol> <li>Tracing collector deployed - Jaeger, Tempo, or another OTLP-compatible collector</li> <li>Kuadrant CR configured with tracing endpoint:    <pre><code>spec:\n  observability:\n    tracing:\n      defaultEndpoint: rpc://jaeger-collector.jaeger.svc.cluster.local:4317\n</code></pre></li> <li>At least one policy applied - AuthPolicy or RateLimitPolicy on a Gateway or HTTPRoute</li> <li>Traffic flowing through the gateway - Send requests to see traces</li> </ol> <p>Without these prerequisites, you won't see traces in your tracing UI even if <code>defaultLevels</code> is configured.</p>"},{"location":"kuadrant-operator/doc/observability/tracing/#what-youll-see","title":"What You'll See","text":"<p>When data plane tracing is enabled with <code>defaultLevels: debug</code>, you'll see detailed trace spans showing the complete request flow through Kuadrant components.</p>"},{"location":"kuadrant-operator/doc/observability/tracing/#example-complete-request-trace","title":"Example: Complete Request Trace","text":"<p>Here's what a typical traced request looks like when it flows through auth and rate limiting policies:</p> <pre><code>Request Flow (29.4ms total):\n\u2502\n\u251c\u2500 Envoy Gateway Span (34.7ms)\n\u2502  \u2514\u2500 kuadrant_filter (29.4ms)\n\u2502     \u2502\n\u2502     \u251c\u2500 auth (6.8ms)\n\u2502     \u2502  \u251c\u2500 auth_request (1.2ms)\n\u2502     \u2502  \u2502  \u2514\u2500 Authorino gRPC Call\n\u2502     \u2502  \u2502     \u2514\u2500 envoy.service.auth.v3.Authorization/Check (2.0ms)\n\u2502     \u2502  \u2502        \u2514\u2500 Check (1.7ms)\n\u2502     \u2502  \u2514\u2500 auth_response (56\u03bcs)\n\u2502     \u2502\n\u2502     \u2514\u2500 ratelimit (6.0ms)\n\u2502        \u251c\u2500 ratelimit_request (576\u03bcs)\n\u2502        \u2502  \u2514\u2500 Limitador gRPC Call\n\u2502        \u2502     \u2514\u2500 should_rate_limit (309\u03bcs)\n\u2502        \u2502        \u2514\u2500 check_and_update (36\u03bcs)\n\u2502        \u2514\u2500 ratelimit_response (38\u03bcs)\n\u2502\n\u2514\u2500 Backend Service: httpbin (34.7ms)\n</code></pre>"},{"location":"kuadrant-operator/doc/observability/tracing/#trace-attributes-youll-see","title":"Trace Attributes You'll See","text":"<p>Data plane traces include rich context from multiple services:</p> <p>Wasm-shim Spans (service: <code>wasm-shim</code>):</p> <ul> <li>Request correlation IDs from <code>httpHeaderIdentifier</code> configuration</li> <li>Matched hostname and route configuration details</li> <li>Policy attribution showing which AuthPolicy/RateLimitPolicy rules were evaluated</li> <li>At DEBUG level: Detailed gRPC call information, property updates, and header manipulations</li> </ul> <p>Authorino Spans (service: <code>authorino</code>):</p> <ul> <li>Request ID correlation</li> <li>gRPC service calls and status codes</li> <li>Authentication and authorization decision details</li> </ul> <p>Limitador Spans (service: <code>limitador</code>):</p> <ul> <li>Rate limit check requests with trace context</li> <li>Limit descriptors and counter information</li> </ul>"},{"location":"kuadrant-operator/doc/observability/tracing/#viewing-this-trace-in-jaeger","title":"Viewing This Trace in Jaeger","text":"<p>Search by Request ID: <pre><code>Service: wasm-shim\nTags: request_id=adefc8cf-78af-9db7-97e5-5ae5e2b22c05\n</code></pre></p> <p>Filter by Operation: <pre><code>Service: wasm-shim\nOperation: kuadrant_filter\nMin Duration: 10ms\n</code></pre></p> <p>Examine Specific Policy: <pre><code>Service: wasm-shim\nTags: sources=authpolicy.kuadrant.io:kuadrant/my-auth-policy\n</code></pre></p>"},{"location":"kuadrant-operator/doc/observability/tracing/#what-this-shows-you","title":"What This Shows You","text":"<ol> <li>Complete Request Timeline: See exactly how long each component took</li> <li>Auth check: 6.8ms (including Authorino processing)</li> <li>Rate limit check: 6.0ms (including Limitador processing)</li> <li> <p>Total protection time: 12.8ms (wasm-shim)</p> </li> <li> <p>Request Correlation: Request IDs flow across all services (wasm-shim, Authorino, Limitador) for end-to-end tracing</p> </li> <li> <p>Policy Attribution: Trace attributes identify which policies (AuthPolicy, RateLimitPolicy) were evaluated for each request</p> </li> <li> <p>gRPC Call Details: At DEBUG level, traces include detailed information about calls to Authorino and Limitador services</p> </li> </ol>"},{"location":"kuadrant-operator/doc/observability/tracing/#troubleshooting-scenarios-with-traces","title":"Troubleshooting Scenarios with Traces","text":"<p>Scenario: Auth is slow</p> <ol> <li>Find the trace in Jaeger by <code>request_id</code></li> <li>Expand the <code>auth</code> span</li> <li>Check the <code>auth_request</code> \u2192 <code>Check</code> span duration</li> <li>Check Authorino pod logs for detailed errors or retries:    <pre><code>kubectl logs -n kuadrant-system -l app=authorino --tail=100 | grep &lt;request_id&gt;\n</code></pre></li> </ol> <p>Scenario: Rate limit not working</p> <ol> <li>Search for traces with <code>operation: ratelimit</code></li> <li>Check the <code>sources</code> tag - is your RateLimitPolicy listed?</li> <li>Check Limitador's <code>should_rate_limit</code> span for the decision</li> <li>Check Limitador pod logs for the limit descriptors sent:    <pre><code>kubectl logs -n kuadrant-system -l app=limitador --tail=100 | grep &lt;request_id&gt;\n</code></pre></li> </ol> <p>Scenario: Find which policy is rejecting requests</p> <ol> <li>Filter traces by response code: <code>Tags: http.status_code=403</code></li> <li>Look at the <code>sources</code> tag to identify the policy</li> <li>Check the span that completed just before the rejection</li> <li>Check component pod logs for detailed rejection reasons (Authorino or gateway logs depending on the policy)</li> </ol>"},{"location":"kuadrant-operator/doc/observability/tracing/#troubleshooting","title":"Troubleshooting","text":""},{"location":"kuadrant-operator/doc/observability/tracing/#enabling-gateway-debug-logs","title":"Enabling Gateway Debug Logs","text":"<p>The wasm-shim's logs you see via <code>kubectl logs</code> are controlled by Envoy's log level, not the Kuadrant CR <code>defaultLevels</code> setting.</p> <p>To enable debug logging in gateway pod output:</p> <p>For Istio gateways (dynamic - temporary):</p> <pre><code># Port-forward to Envoy admin interface\nkubectl port-forward -n istio-system deploy/istio-ingressgateway 15000:15000\n\n# Enable WASM debug logging\ncurl -X POST 'http://localhost:15000/logging?wasm=debug'\n\n# Or enable debug for all components:\ncurl -X POST 'http://localhost:15000/logging?level=debug'\n</code></pre> <p>Note: Most gateway pods don't have <code>curl</code> installed, so we use port-forwarding to access the Envoy admin interface from your local machine. This setting is temporary and will reset when the pod restarts.</p> <p>For Istio gateways (persistent - via Istio Operator):</p> <pre><code>apiVersion: operator.istio.io/v1alpha1\nkind: Istio\nmetadata:\n  name: default\nspec:\n  values:\n    meshConfig:\n      defaultConfig:\n        proxyMetadata:\n          WASM_LOG_LEVEL: debug\n</code></pre> <p>For Envoy Gateway:</p> <pre><code>apiVersion: gateway.envoyproxy.io/v1alpha1\nkind: EnvoyProxy\nmetadata:\n  name: custom-proxy-config\n  namespace: envoy-gateway-system\nspec:\n  logging:\n    level:\n      default: debug\n</code></pre> <p>Use Cases:</p> <ol> <li>Troubleshooting in production with traces: Set <code>defaultLevels.debug: \"true\"</code> in the Kuadrant CR to get detailed trace spans in Jaeger without flooding gateway logs</li> <li>Local development debugging: Enable both <code>defaultLevels.debug</code> AND Envoy's WASM log level for complete visibility</li> <li>Request correlation: Set <code>httpHeaderIdentifier: x-request-id</code> to track requests across components using the request ID header</li> </ol>"},{"location":"kuadrant-operator/doc/observability/tracing/#troubleshooting-flow-using-traces-and-logs","title":"Troubleshooting Flow Using Traces and Logs","text":"<p>Using a tracing interface like the Jaeger UI or Grafana, you can search for trace information by the trace ID. You may get the trace ID from logs, or from a header in a sample request you want to troubleshoot. You can also search for recent traces, filtering by the service you want to focus on.</p> <p>Here is an example trace in the Jaeger UI showing the total request time from the gateway (Istio), the time to check the curent rate limit count (and update it) in limitador and the time to check auth in Authorino:</p> <p></p> <p>In limitador, it is possible to enable request logging with trace IDs to get more information on requests. This requires the log level to be increased to at least debug, so the verbosity must be set to 3 or higher in the Limitador CR. For example:</p> <pre><code>apiVersion: limitador.kuadrant.io/v1alpha1\nkind: Limitador\nmetadata:\n  name: limitador\nspec:\n  verbosity: 3\n</code></pre> <p>A log entry will look something like this, with the <code>traceparent</code> field holding the trace ID:</p> <pre><code>\"ShouldRateLimit Request received: Request { metadata: MetadataMap { headers: {\"te\": \"trailers\", \"grpc-timeout\": \"1000m\", \"content-type\": \"application/grpc\", \"traceparent\": \"00-bd579c77366d2868ec14a69d0abd2b6d-532e38f2d4e17132-01\", \"x-request-id\": \"b18cf0b0-29d8-9feb-bcfb-a0dc08479400\", \"x-envoy-internal\": \"true\", \"x-envoy-expected-rq-timeout-ms\": \"1000\"} }, message: RateLimitRequest { domain: \"kuadrant/route-tester--d304\", descriptors: [RateLimitDescriptor { entries: [Entry { key: \"limit.testuser__2feff48d\", value: \"1\" }], limit: None }], hits_addend: 1 }, extensions: Extensions }\"\n</code></pre> <p>If you centrally aggregate logs using something like promtail and loki, you can jump between trace information and the relevant logs for that service:</p> <p></p> <p>Using a combination of tracing and logs, you can visualise and troubleshoot request timing issues and drill down to specific services. This method becomes even more powerful when combined with metrics, access logs, and dashboards to get a more complete picture of your users traffic.</p>"},{"location":"kuadrant-operator/doc/overviews/auth/","title":"Kuadrant Auth","text":"<p>A Kuadrant AuthPolicy custom resource:</p> <ol> <li>Targets Gateway API networking resources HTTPRoute and Gateway, using these to obtain the auth context, i.e., on which traffic workload (HTTP attributes, hostnames, user attributes, etc) to enforce auth.</li> <li>Supports targeting subsets (sections) of a network resource to apply the auth rules to, i.e. specific listeners of a Gateway or HTTP route rules of an HTTPRoute.</li> <li>Abstracts the details of the underlying external authorization protocol and configuration resources, that have a much broader remit and surface area.</li> <li>Enables platform engineers to set defaults that govern behavior at the lower levels of the network, until a more specific policy is applied.</li> <li>Enables platform engineers to set overrides over policies and/or individual policy rules specified at the lower levels of the network.</li> </ol>"},{"location":"kuadrant-operator/doc/overviews/auth/#how-it-works","title":"How it works","text":""},{"location":"kuadrant-operator/doc/overviews/auth/#integration","title":"Integration","text":"<p>Kuadrant integrates an External Authorization service (\"Authorino\") that is triggered on matching HTTP contexts.</p> <p>The workflow per request goes:</p> <ol> <li>On incoming request, the gateway checks the matching rules for enforcing the auth rules, as stated in the AuthPolicy custom resources and targeted Gateway API networking objects</li> <li>If the request matches, the gateway sends a CheckRequest to Authorino.</li> <li>The external auth service responds with a CheckResponse back to the gateway with either an <code>OK</code> or <code>DENIED</code> response code.</li> </ol> <p>An AuthPolicy and its targeted Gateway API networking resource contain all the statements to configure both the ingress gateway and the external auth service.</p>"},{"location":"kuadrant-operator/doc/overviews/auth/#the-authpolicy-custom-resource","title":"The AuthPolicy custom resource","text":""},{"location":"kuadrant-operator/doc/overviews/auth/#overview","title":"Overview","text":"<p>The <code>AuthPolicy</code> spec includes the following parts:</p> <ul> <li>A reference to an existing Gateway API resource (<code>spec.targetRef</code>)</li> <li>Authentication/authorization scheme (<code>spec.rules</code>)</li> <li>Top-level additional conditions (<code>spec.when</code>)</li> <li>List of named patterns (<code>spec.patterns</code>)</li> </ul> <p>The auth scheme specify rules for:</p> <ul> <li>Authentication (<code>spec.rules.authentication</code>)</li> <li>External auth metadata fetching (<code>spec.rules.metadata</code>)</li> <li>Authorization (<code>spec.rules.authorization</code>)</li> <li>Custom response items (<code>spec.rules.response</code>)</li> <li>Callbacks (<code>spec.rules.callbacks</code>)</li> </ul> <p>Each auth rule can declare specific <code>when</code> conditions for the rule to apply.</p> <p>The auth scheme (<code>rules</code>), as well as conditions and named patterns can be declared at the top-level level of the spec (with the semantics of defaults) or alternatively within explicit <code>defaults</code> or <code>overrides</code> blocks.</p> <p>Check out the API reference for a full specification of the AuthPolicy CRD.</p>"},{"location":"kuadrant-operator/doc/overviews/auth/#using-the-authpolicy","title":"Using the AuthPolicy","text":""},{"location":"kuadrant-operator/doc/overviews/auth/#targeting-a-httproute-networking-resource","title":"Targeting a HTTPRoute networking resource","text":"<p>When targeting a HTTPRoute, an AuthPolicy can be enforced on:</p> <ul> <li>all traffic routed by any rule specified in the HTTPRoute; or</li> <li>only traffic routed by a specific set of rules as stated in a selected HTTPRouteRule of the HTTPRoute, by specifying the <code>sectionName</code> field in the target reference (<code>spec.targetRef</code>) of the policy.</li> </ul> <p>Either way, the policy applies across all hostnames (<code>spec.hostnames</code>) and Gateways (<code>spec.parentRefs</code>) referenced in the HTTPRoute, provided the route is properly attached to the corresponding Gateway listeners.</p> <p>Additional filters for applying the policy can be set by specifying top-level conditions in the policy (<code>spec.rules.when</code>).</p> <p>Example 1 - Targeting an entire HTTPRoute</p> <pre><code>apiVersion: kuadrant.io/v1\nkind: AuthPolicy\nmetadata:\n  name: my-auth\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: my-route\n  rules: { \u2026 }\n</code></pre> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 (Gateway namespace) \u2502            \u2502   (App namespace)   \u2502\n\u2502                     \u2502            \u2502                     \u2502\n\u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u2502 parentRefs \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2502\n\u2502    \u2502 Gateway \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2524 HTTPRoute  \u2502     \u2502\n\u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2502            \u2502  | (my-route) \u2502     |\n\u2502                     \u2502            \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2502\n\u2502                     \u2502            \u2502        \u25b2            \u2502\n\u2502                     \u2502            \u2502        \u2502            \u2502\n\u2502                     \u2502            \u2502        \u2502 targetRef  \u2502\n\u2502                     \u2502            \u2502        \u2502            \u2502\n\u2502                     \u2502            \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2502\n\u2502                     \u2502            \u2502  \u2502 AuthPolicy \u2502     \u2502\n\u2502                     \u2502            \u2502  \u2502 (my-auth)  \u2502     \u2502\n\u2502                     \u2502            \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Example 2 - Targeting a specific set of rules of a HTTPRoute</p> <pre><code>apiVersion: kuadrant.io/v1\nkind: AuthPolicy\nmetadata:\n  name: my-route-auth\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: my-route\n    sectionName: rule-2\n  rules: { \u2026 }\n</code></pre> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 (Gateway namespace) \u2502            \u2502    (App namespace)   \u2502\n\u2502                     \u2502            \u2502                      \u2502\n\u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u2502 parentRefs \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u2502\n\u2502    \u2502 Gateway \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2524 HTTPRoute  \u2502      \u2502\n\u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2502            \u2502  | (my-route) \u2502      |\n\u2502                     \u2502            \u2502  |------------\u2502      |\n\u2502                     \u2502            \u2502  | - rule-1   \u2502      |\n\u2502                     \u2502            \u2502  | - rule-2   \u2502      |\n\u2502                     \u2502            \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2502\n\u2502                     \u2502            \u2502        \u25b2             \u2502\n\u2502                     \u2502            \u2502        \u2502             \u2502\n\u2502                     \u2502            \u2502        \u2502 targetRef   \u2502\n\u2502                     \u2502            \u2502        \u2502             \u2502\n\u2502                     \u2502            \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502                     \u2502            \u2502  \u2502   AuthPolicy    \u2502 \u2502\n\u2502                     \u2502            \u2502  \u2502 (my-route-auth) \u2502 \u2502\n\u2502                     \u2502            \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"kuadrant-operator/doc/overviews/auth/#targeting-a-gateway-networking-resource","title":"Targeting a Gateway networking resource","text":"<p>An AuthPolicy that targets a Gateway, without overrides, will be enforced to all HTTP traffic hitting the gateway, unless a more specific AuthPolicy targeting a matching HTTPRoute exists. Any new HTTPRoute referrencing the gateway as parent will be automatically covered by the gateway-targeting AuthPolicy, as well as changes in the existing HTTPRoutes.</p> <p>Target a Gateway HTTPRoute by setting the <code>spec.targetRef</code> field of the AuthPolicy as follows:</p> <pre><code>apiVersion: kuadrant.io/v1\nkind: AuthPolicy\nmetadata:\n  name: my-gw-auth\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: my-gw\n  defaults: # alternatively: `overrides`\n    rules: { \u2026 }\n</code></pre> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 (Infra namespace) \u2502             \u2502    (App namespace)   \u2502\n\u2502                   \u2502             \u2502                      \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u2502  parentRefs \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       \u2502\n\u2502  \u2502 Gateway \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2524 HTTPRoute \u2502       \u2502\n\u2502  | (my-gw) |      \u2502             \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2502             \u2502        \u25b2             \u2502\n\u2502       \u25b2           \u2502             \u2502        |             \u2502\n\u2502       \u2502           \u2502             \u2502        \u2502             \u2502\n\u2502       \u2502 targetRef \u2502             \u2502        \u2502 targetRef   \u2502\n\u2502       \u2502           \u2502             \u2502        \u2502             \u2502\n\u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502             \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502 \u2502  AuthPolicy  \u2502  \u2502             \u2502  \u2502   AuthPolicy    \u2502 \u2502\n\u2502 | (my-gw-auth) |  \u2502             \u2502  \u2502 (my-route-auth) \u2502 \u2502\n\u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502             \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"kuadrant-operator/doc/overviews/auth/#defaults-and-overrides","title":"Defaults and Overrides","text":"<p>Kuadrant AuthPolicies support Defaults &amp; Overrides essentially as specified in Gateway API GEP-2649.</p> <p>An AuthPolicy can declare a block of defaults (<code>spec.defaults</code>) or a block of overrides (<code>spec.overrides</code>). By default, policies that do not specify neither <code>defaults</code> nor <code>overrides</code>, act implicitly as if specifying <code>defaults</code>. A default set of policy rules are enforced until a more specific set supersedes them. In contrast, a set of overrides wins over any more specific set of rules.</p> <p>Setting default AuthPolicies provide, e.g., platform engineers with the ability to protect the infrastructure against unplanned and malicious network traffic attempt, such as by setting preemptive \"deny-all\" policies at the level of the gateways that block access on all routes attached to the gateway. Later on, application developers can define more specific auth rules at the level of the HTTPRoutes, opening access to individual routes.</p> <p>Inversely, a gateway policy that specify overrides declares a set of rules that is enforced on all routes attached to the gateway, thus atomically replacing any more specific policy occasionally attached to any of those routes.</p> <p>Although typical examples involve specifying <code>defaults</code> and <code>overrides</code> at the level of the Gateway object which interact with sets of policy rules defined at the more specific context (HTTPRoute), Defaults &amp; Overrides are actually transversal to object kinds. One can define AuthPolicies with <code>defaults</code> or <code>overrides</code> at any level of the following hierarchy and including multiple policies at the same level:</p> <ol> <li>Gateway</li> <li>Gateway listener (by targeting a Gateway with <code>sectionName</code>)</li> <li>HTTPRoute</li> <li>HTTPRouteRule (by targeting a HTTPRoute with <code>sectionName</code>)</li> </ol> <p>The final set of policy rules to enforce for a given request, known as \"effective policy\", is computed based on the basic principles stated in the Hierarchy section of GEP-2649 and Conflict Resolution of its predecessor GEP-713, for the hierarchical levels above.</p> <p>Kuadrant AuthPolicies extend Gateway API's Defaults &amp; Overrides with additional merge strategies for allowing users to specify sets of policy rules under <code>defaults</code> and/or <code>overrides</code> blocks that can be either atomically applied or merged into a composition of policy rules from the multiple AuthPolicies affecting a hierarchy of newtworking objects. The name of the policy rule is used for detecting conflicts.</p> <p>For details of the behavior of Defaults &amp; Overrides for the AuthPolicies covering all supported merge strategies, see RFC-0009.</p>"},{"location":"kuadrant-operator/doc/overviews/auth/#hostnames-and-wildcards","title":"Hostnames and wildcards","text":"<p>If an AuthPolicy targets a route defined for a hostname wildcard <code>*.com</code> and a second AuthPolicy targets another route for a hostname <code>api.com</code>, without any overrides nor merges in place, the policies will be enforced according to the principle of \"the more specific wins\". E.g., a request coming for <code>api.com</code> will be protected according to the rules from the AuthPolicy that targets the route for <code>api.com</code>, while a request for <code>other.com</code> will be protected with the rules from the AuthPolicy targeting the route for <code>*.com</code>. One should not expect both set of policy rules to be enforced on requests to <code>api.com</code> simply because both hostname and wildcard match.</p> <p>Example with 3 AuthPolicies and 3 HTTPRoutes, without merges nor overrides in place:</p> <ul> <li>AuthPolicy A \u2192 HTTPRoute A (<code>a.toystore.com</code>)</li> <li>AuthPolicy B \u2192 HTTPRoute B (<code>b.toystore.com</code>)</li> <li>AuthPolicy W \u2192 HTTPRoute W (<code>*.toystore.com</code>)</li> </ul> <p>Expected behavior:</p> <ul> <li>Request to <code>a.toystore.com</code> \u2192 AuthPolicy A will be enforced</li> <li>Request to <code>b.toystore.com</code> \u2192 AuthPolicy B will be enforced</li> <li>Request to <code>other.toystore.com</code> \u2192 AuthPolicy W will be enforced</li> </ul>"},{"location":"kuadrant-operator/doc/overviews/auth/#when-conditions","title":"<code>when</code> conditions","text":"<p><code>when</code> conditions can be used to scope an AuthPolicy or auth rule within an AuthPolicy (i.e. to filter the traffic to which a policy or policy rule applies) without any coupling to the underlying network topology.</p> <p>Use <code>when</code> conditions to conditionally activate policies and policy rules based on attributes that cannot be expressed in the HTTPRoutes' <code>spec.hostnames</code> and <code>spec.rules.matches</code> fields, or in general in AuthPolicies that target a Gateway.</p> <p><code>when</code> conditions in an AuthPolicy are compatible with Authorino conditions, thus supporting complex boolean expressions with AND and OR operators, as well as grouping.</p> <p>The selectors within the <code>when</code> conditions of an AuthPolicy are a subset of Kuadrant's Well-known Attributes (RFC 0002). Check out the reference for the full list of supported selectors.</p> <p>Authorino JSON path string modifiers can also be applied to the selectors within the <code>when</code> conditions of an AuthPolicy.</p>"},{"location":"kuadrant-operator/doc/overviews/auth/#examples","title":"Examples","text":"<p>Check out the following user guides for examples of protecting services with Kuadrant:</p> <ul> <li>Enforcing authentication &amp; authorization with Kuadrant AuthPolicy, for app developers and platform engineers</li> <li>Authenticated Rate Limiting for Application Developers</li> <li>Authenticated Rate Limiting with JWTs and Kubernetes RBAC</li> </ul>"},{"location":"kuadrant-operator/doc/overviews/auth/#known-limitations","title":"Known limitations","text":"<ul> <li>AuthPolicies can only target HTTPRoutes/Gateways defined within the same namespace of the AuthPolicy.</li> <li>AuthPolicies that reference other Kubernetes objects (typically <code>Secret</code>s) require those objects to the created in the same namespace as the <code>Kuadrant</code> custom resource managing the deployment. This is the case of AuthPolicies that define API key authentication with <code>allNamespaces</code> option set to <code>false</code> (default), where the API key Secrets must be created in the Kuadrant CR namespace and not in the AuthPolicy namespace.</li> </ul>"},{"location":"kuadrant-operator/doc/overviews/dns/","title":"Kuadrant DNS","text":"<p>A Kuadrant DNSPolicy custom resource:</p> <p>Targets Gateway API networking resources Gateways to provide dns management by managing the lifecycle of dns records in external dns providers such as AWS Route53 and Google DNS.</p>"},{"location":"kuadrant-operator/doc/overviews/dns/#how-it-works","title":"How it works","text":"<p>A DNSPolicy and its targeted Gateway API networking resource contain all the statements to configure both the ingress gateway and the external DNS service. The needed dns names are gathered from the listener definitions and the IPAdresses | CNAME hosts are gathered from the status block of the gateway resource.</p>"},{"location":"kuadrant-operator/doc/overviews/dns/#the-dnspolicy-custom-resource","title":"The DNSPolicy custom resource","text":""},{"location":"kuadrant-operator/doc/overviews/dns/#overview","title":"Overview","text":"<p>The <code>DNSPolicy</code> spec includes the following parts:</p> <ul> <li>A reference to an existing Gateway API resource (<code>spec.targetRef</code>)</li> <li>LoadBalancing specification (<code>spec.loadBalancing</code>)</li> <li>HealthCheck specification (<code>spec.healthCheck</code>)</li> </ul> <p>Check out the API reference for a full specification of the DNSPolicy CRD.</p>"},{"location":"kuadrant-operator/doc/overviews/dns/#using-the-dnspolicy","title":"Using the DNSPolicy","text":""},{"location":"kuadrant-operator/doc/overviews/dns/#dns-provider-setup","title":"DNS Provider Setup","text":"<p>A DNSPolicy acts against a target Gateway by processing its listeners for hostnames that it can create dns records for. In order for it to do this, it must know about the dns provider. This is done through the creation of dns provider secrets containing the credentials and configuration for the dns provider account.</p> <p>The policy can use a specific provider secret by referencing it in the <code>ProviderRefs</code>. Alternatively, if no reference is provided, the secret with <code>kuadrant.io/default-provider=true</code> label will be chosen as a default option.</p> <p>If for example a Gateway is created with a listener with a hostname of <code>echo.apps.hcpapps.net</code>:</p> <pre><code>apiVersion: gateway.networking.k8s.io/v1\nkind: Gateway\nmetadata:\n  name: my-gw\nspec:\n  listeners:\n\n    - allowedRoutes:\n        namespaces:\n          from: All\n      name: api\n      hostname: echo.apps.hcpapps.net\n      port: 80\n      protocol: HTTP\n</code></pre> <p>In order for the DNSPolicy to act upon that listener, a DNS provider Secret must exist for that hostnames' domain.</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: my-aws-credentials\n  namespace: &lt;Gateway Namespace&gt;\ndata:\n  AWS_ACCESS_KEY_ID: &lt;AWS_ACCESS_KEY_ID&gt;\n  AWS_REGION: &lt;AWS_REGION&gt;\n  AWS_SECRET_ACCESS_KEY: &lt;AWS_SECRET_ACCESS_KEY&gt;\ntype: kuadrant.io/aws\n</code></pre> <p>By default, Kuadrant will list the available zones and find the matching zone based on the listener host in the gateway listener. If it finds more than one matching zone for a given listener host, it will not update any of those zones. When providing a credential you should limit that credential down to just have write access to the zones you want Kuadrant to manage. Below is an example of a an AWS policy for doing this type of thing:</p> <pre><code>{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Sid\": \"VisualEditor0\",\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"route53:ListTagsForResources\",\n                \"route53:GetHealthCheckLastFailureReason\",\n                \"route53:GetHealthCheckStatus\",\n                \"route53:GetChange\",\n                \"route53:GetHostedZone\",\n                \"route53:ChangeResourceRecordSets\",\n                \"route53:ListResourceRecordSets\",\n                \"route53:GetHealthCheck\",\n                \"route53:UpdateHostedZoneComment\",\n                \"route53:UpdateHealthCheck\",\n                \"route53:CreateHealthCheck\",\n                \"route53:DeleteHealthCheck\",\n                \"route53:ListTagsForResource\",\n                \"route53:ListHealthChecks\",\n                \"route53:GetGeoLocation\",\n                \"route53:ListGeoLocations\",\n                \"route53:ListHostedZonesByName\",\n                \"route53:GetHealthCheckCount\"\n            ],\n            \"Resource\": [\n                \"arn:aws:route53:::hostedzone/Z08187901Y93585DDGM6K\",\n                \"arn:aws:route53:::healthcheck/*\",\n                \"arn:aws:route53:::change/*\"\n            ]\n        },\n        {\n            \"Sid\": \"VisualEditor1\",\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"route53:ListHostedZones\"\n            ],\n            \"Resource\": \"*\"\n        }\n    ]\n}\n</code></pre>"},{"location":"kuadrant-operator/doc/overviews/dns/#targeting-a-gateway-networking-resource","title":"Targeting a Gateway networking resource","text":"<p>When a DNSPolicy targets a Gateway, the policy will be enforced on all gateway listeners.</p> <p>Target a Gateway by setting the <code>spec.targetRef</code> field of the DNSPolicy as follows:</p> <pre><code>apiVersion: kuadrant.io/v1\nkind: DNSPolicy\nmetadata:\n  name: &lt;DNSPolicy name&gt;\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: &lt;Gateway Name&gt;\n</code></pre>"},{"location":"kuadrant-operator/doc/overviews/dns/#targeting-a-specific-listener-of-a-gateway","title":"Targeting a specific Listener of a gateway","text":"<p>A DNSPolicy can target a specific listener in a gateway using the <code>sectionName</code> property of the targetRef configuration. When you set the <code>sectionName</code>, the DNSPolicy will only affect that listener and no others. If you also have another DNSPolicy targeting the entire gateway, the more specific policy targeting the listerner will be the policy that is applied.</p> <pre><code>apiVersion: kuadrant.io/v1\nkind: DNSPolicy\nmetadata:\n  name: &lt;DNSPolicy name&gt;\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: &lt;Gateway Name&gt;\n    sectionName: &lt;myListenerName&gt;\n</code></pre>"},{"location":"kuadrant-operator/doc/overviews/dns/#dnsrecord-resource","title":"DNSRecord Resource","text":"<p>The DNSPolicy will create a DNSRecord resource for each listener hostname. The DNSPolicy resource uses the status of the Gateway to determine what dns records need to be created based on the clusters it has been placed onto.</p> <p>Given the following multi cluster gateway status:</p> <pre><code>status:\n  addresses:\n\n    - type: kuadrant.io/MultiClusterIPAddress\n      value: kind-mgc-workload-1/172.31.201.1\n    - type: kuadrant.io/MultiClusterIPAddress\n      value: kind-mgc-workload-2/172.31.202.1\n  listeners:\n    - attachedRoutes: 1\n      conditions: []\n      name: kind-mgc-workload-1.api\n      supportedKinds: []\n    - attachedRoutes: 1\n      conditions: []\n      name: kind-mgc-workload-2.api\n      supportedKinds: []\n</code></pre> <p>A DNSPolicy targeting this gateway would create an appropriate DNSRecord based on the routing strategy selected.</p>"},{"location":"kuadrant-operator/doc/overviews/dns/#loadbalanced","title":"loadbalanced","text":"<pre><code>apiVersion: kuadrant.io/v1alpha1\nkind: DNSRecord\nmetadata:\n  name: echo.apps.hcpapps.net\n  namespace: &lt;Gateway Namespace&gt;\nspec:\n  endpoints:\n\n    - dnsName: 24osuu.lb-2903yb.echo.apps.hcpapps.net\n      recordTTL: 60\n      recordType: A\n      targets:\n        - 172.31.202.1\n    - dnsName: default.lb-2903yb.echo.apps.hcpapps.net\n      providerSpecific:\n        - name: weight\n          value: \"120\"\n      recordTTL: 60\n      recordType: CNAME\n      setIdentifier: 24osuu.lb-2903yb.echo.apps.hcpapps.net\n      targets:\n        - 24osuu.lb-2903yb.echo.apps.hcpapps.net\n    - dnsName: default.lb-2903yb.echo.apps.hcpapps.net\n      providerSpecific:\n        - name: weight\n          value: \"120\"\n      recordTTL: 60\n      recordType: CNAME\n      setIdentifier: lrnse3.lb-2903yb.echo.apps.hcpapps.net\n      targets:\n        - lrnse3.lb-2903yb.echo.apps.hcpapps.net\n    - dnsName: echo.apps.hcpapps.net\n      recordTTL: 300\n      recordType: CNAME\n      targets:\n        - lb-2903yb.echo.apps.hcpapps.net\n    - dnsName: lb-2903yb.echo.apps.hcpapps.net\n      providerSpecific:\n        - name: geo-country-code\n          value: '*'\n      recordTTL: 300\n      recordType: CNAME\n      setIdentifier: default\n      targets:\n        - default.lb-2903yb.echo.apps.hcpapps.net\n    - dnsName: lrnse3.lb-2903yb.echo.apps.hcpapps.net\n      recordTTL: 60\n      recordType: A\n      targets:\n        - 172.31.201.1\n  providerRefs:\n    - name: my-aws-credentials\n</code></pre> <p>After DNSRecord reconciliation the listener hostname should be resolvable through dns:</p> <pre><code>dig echo.apps.hcpapps.net +short\nlb-2903yb.echo.apps.hcpapps.net.\ndefault.lb-2903yb.echo.apps.hcpapps.net.\nlrnse3.lb-2903yb.echo.apps.hcpapps.net.\n172.31.201.1\n</code></pre>"},{"location":"kuadrant-operator/doc/overviews/dns/#simple","title":"simple","text":"<pre><code>apiVersion: kuadrant.io/v1alpha1\nkind: DNSRecord\nmetadata:\n  name: echo.apps.hcpapps.net\n  namespace: &lt;Gateway Namespace&gt;\nspec:\n  endpoints:\n\n    - dnsName: echo.apps.hcpapps.net\n      recordTTL: 60\n      recordType: A\n      targets:\n        - 172.31.201.1\n        - 172.31.202.1\n  providerRefs:\n    - name: my-aws-credentials\n</code></pre> <p>After DNSRecord reconciliation the listener hostname should be resolvable through dns:</p> <pre><code>dig echo.apps.hcpapps.net +short\n172.31.201.1\n</code></pre>"},{"location":"kuadrant-operator/doc/overviews/dns/#known-limitations","title":"Known limitations","text":"<ul> <li>One Gateway can only be targeted by one DNSPolicy unless subsequent DNSPolicies choose to specific a sectionName in their targetRef.</li> <li>DNSPolicies can only target Gateways defined within the same namespace of the DNSPolicy.</li> </ul>"},{"location":"kuadrant-operator/doc/overviews/dns/#troubleshooting","title":"Troubleshooting","text":""},{"location":"kuadrant-operator/doc/overviews/dns/#understanding-status","title":"Understanding status","text":"<p>The <code>Status.Conditions</code> on DNSPolicy mostly serves as an aggregation of the DNSRecords conditions.  The DNSPolicy conditions: </p> <ul> <li><code>Accepted</code> indicates that policy was validated and is accepted by the controller for the reconciliation. </li> <li><code>Enforced</code> indicates that the controller acted upon the policy. If DNSRecords were created as the result this condition will reflect the <code>Ready</code> condition on the record. This condition is removed if <code>Accepted</code> is false. If partially enforced, the condition will be set to <code>True</code></li> <li><code>SubResourcesHealthy</code> reflects <code>Healthy</code> conditions of sub-resources. This condition is removed if <code>Accepted</code> is false. If partially healthy, the condition will be set to <code>False</code> </li> </ul> <p>The <code>Status.Conditions</code> on the DNSRecord are as follows: </p> <ul> <li><code>Ready</code> indicates that the record was successfully published to the provider. </li> <li><code>Healthy</code> indicates that dnshealthcheckprobes are healthy. If not all probes are healthy, the condition will be set to <code>False</code></li> </ul>"},{"location":"kuadrant-operator/doc/overviews/dns/#logs","title":"Logs","text":"<p>To increase the log level of the <code>kuadran-operator</code> refer to this logging doc.</p> <p>To increase the log level of the <code>dns-operator-controller-manager</code> and for the examples on log queries refer to the logging section in the DNS Operator readme </p>"},{"location":"kuadrant-operator/doc/overviews/dns/#debugging","title":"Debugging","text":"<p>This section will provide the typical sequence of actions during the troubleshooting.  It is meant to be a reference to identifying the problem rather than SOP. </p>"},{"location":"kuadrant-operator/doc/overviews/dns/#list-policies-to-identify-the-failing-one","title":"List policies to identify the failing one","text":"<pre><code>kubectl get dnspolicy -A -o wide\n</code></pre>"},{"location":"kuadrant-operator/doc/overviews/dns/#inspect-the-failing-policy","title":"Inspect the failing policy","text":"<p><pre><code>kubectl get dnspolicy &lt;dnspolicy-name&gt; -n &lt;dnspolicy-namespace&gt; -o yaml | yq '.status.conditions'\n</code></pre> The output will show which DNSRecords and for what reasons are failing. For example:  <pre><code>- lastTransitionTime: \"2024-12-04T09:46:22Z\"\n  message: DNSPolicy has been accepted\n  reason: Accepted\n  status: \"True\"\n  type: Accepted\n- lastTransitionTime: \"2024-12-04T09:46:29Z\"\n  message: 'DNSPolicy has been partially enforced. Not ready DNSRecords are: test-api '\n  reason: Enforced\n  status: \"True\"\n  type: Enforced\n- lastTransitionTime: \"2024-12-04T09:46:27Z\"\n  message: 'DNSPolicy has encountered some issues: not all sub-resources of policy are passing the policy defined health check. Not healthy DNSRecords are: test-api '\n  reason: Unknown\n  status: \"False\"\n  type: SubResourcesHealthy\n</code></pre> This example indicates that the policy was accepted and one of the DNSRecords - <code>test-api</code> DNSRecord - is not ready and not healthy </p>"},{"location":"kuadrant-operator/doc/overviews/dns/#locate-sub-records-to-confirm-conditions","title":"Locate sub-records to confirm conditions","text":"<p>This ensures that the Kuadrand operator propagated status correctly. The names of the DNSRecords are composed of the Gateway name followed by a listener name and are created in the DNSPolicy namespace. <pre><code>kubectl get dnsrecord -n &lt;dnspolicy-namespace&gt; \n</code></pre></p>"},{"location":"kuadrant-operator/doc/overviews/dns/#inspect-the-record-to-get-more-detailed-information-on-the-failure","title":"Inspect the record to get more detailed information on the failure","text":"<p><pre><code>kubectl get dnsrecord &lt;dnsrecord-name&gt; -n &lt;dnspolicy-namespace&gt; -o yaml | yq '.status'\n</code></pre> Most of the time the <code>conditions</code> will hold all necessary information.  However, it is advised to pay attention to the <code>queuedAt</code> and <code>validFor</code> field  to understand when the record was processed and when controller expects it to be reconciled again. </p>"},{"location":"kuadrant-operator/doc/overviews/dns/#inspect-health-check-probes","title":"Inspect health check probes","text":"<p>We create a probe per address per dns record. The name of the probe is DNSRecord name followed by an address.  <pre><code># list probes \nkubectl get dnshealthcheckprobe -n &lt;dnspolicy-namespace&gt;\n# inspect the probe \nkubectl get dnshealthcheckprobe &lt;probe-name&gt; -n &lt;dnspolicy-namespace&gt; -o yaml | yq '.status'\n</code></pre></p>"},{"location":"kuadrant-operator/doc/overviews/dns/#identify-what-in-logs-to-look-for","title":"Identify what in logs to look for","text":"<p>There are two operators to look into and a number of controllers. The commands above should provide an understanding of what component/process is failing.  Use the following to identify the correct controller:</p> <ul> <li>If the problem in the status propagation from the DNSRecord to the DNSPolicy or in the creation of the DNSRecord: <code>kuadrant-operator</code> logs under <code>kuadrant-operator.EffectiveDNSPoliciesReconciler</code> reconciler</li> <li>If the problem is in publishing DNSRecord or reacting to the healtcheckprobe CR: <code>dns-operator-controller-manager</code> logs under <code>dnsrecord_controller</code> reconciler</li> <li>If the problem in creation of the probes: <code>dns-operator-controller-manager</code> logs under <code>dnsrecord_controller.healthchecks</code> reconciler</li> <li>If the problem is in the execution of the healthchecks: <code>dns-operator-controller-manager</code> logs under <code>dnsprobe_controller</code> reconciler</li> </ul>"},{"location":"kuadrant-operator/doc/overviews/rate-limiting/","title":"Kuadrant Rate Limiting","text":"<p>A Kuadrant RateLimitPolicy custom resource, often abbreviated \"RateLimitPolicy\":</p> <ol> <li>Targets Gateway API networking resources such as HTTPRoutes and Gateways, using these resources to obtain additional context, i.e., which traffic workload (HTTP attributes, hostnames, user attributes, etc) to rate limit.</li> <li>Supports targeting subsets (sections) of a network resource to apply the limits to.</li> <li>Abstracts the details of the underlying Rate Limit protocol and configuration resources, that have a much broader remit and surface area.</li> <li>Enables cluster operators to set defaults that govern behavior at the lower levels of the network, until a more specific policy is applied.</li> </ol>"},{"location":"kuadrant-operator/doc/overviews/rate-limiting/#how-it-works","title":"How it works","text":""},{"location":"kuadrant-operator/doc/overviews/rate-limiting/#envoys-rate-limit-service-protocol","title":"Envoy's Rate Limit Service Protocol","text":"<p>Kuadrant's Rate Limit implementation relies on the Envoy's Rate Limit Service (RLS) protocol. The workflow per request goes:</p> <ol> <li>On incoming request, the gateway checks the matching rules for enforcing rate limits, as stated in the RateLimitPolicy custom resources and targeted Gateway API networking objects</li> <li>If the request matches, the gateway sends one RateLimitRequest to the external rate limiting service (\"Limitador\").</li> <li>The external rate limiting service responds with a RateLimitResponse back to the gateway with either an <code>OK</code> or <code>OVER_LIMIT</code> response code.</li> </ol> <p>A RateLimitPolicy and its targeted Gateway API networking resource contain all the statements to configure both the ingress gateway and the external rate limiting service.</p>"},{"location":"kuadrant-operator/doc/overviews/rate-limiting/#the-ratelimitpolicy-custom-resource","title":"The RateLimitPolicy custom resource","text":""},{"location":"kuadrant-operator/doc/overviews/rate-limiting/#overview","title":"Overview","text":"<p>The <code>RateLimitPolicy</code> spec includes, basically, two parts:</p> <ul> <li>A reference to an existing Gateway API resource (<code>spec.targetRef</code>)</li> <li>Limit definitions (<code>spec.limits</code>)</li> </ul> <p>Each limit definition includes:</p> <ul> <li>A set of rate limits (<code>spec.limits.&lt;limit-name&gt;.rates[]</code>)</li> <li>(Optional) A set of dynamic counter qualifiers (<code>spec.limits.&lt;limit-name&gt;.counters[]</code>)</li> <li>(Optional) A set of additional dynamic conditions to activate the limit (<code>spec.limits.&lt;limit-name&gt;.when[]</code>)</li> </ul> <p>The limit definitions (<code>limits</code>) can be declared at the top-level level of the spec (with the semantics of defaults) or alternatively within explicit <code>defaults</code> or <code>overrides</code> blocks.</p> Check out Kuadrant RFC 0002 to learn more about the Well-known Attributes that can be used to define counter qualifiers (<code>counters</code>) and conditions (<code>when</code>). <p>Check out the API reference for a full specification of the RateLimitPolicy CRD.</p>"},{"location":"kuadrant-operator/doc/overviews/rate-limiting/#using-the-ratelimitpolicy","title":"Using the RateLimitPolicy","text":""},{"location":"kuadrant-operator/doc/overviews/rate-limiting/#targeting-a-httproute-networking-resource","title":"Targeting a HTTPRoute networking resource","text":"<p>When a RateLimitPolicy targets a HTTPRoute, the policy is enforced to all traffic routed according to the rules and hostnames specified in the HTTPRoute, across all Gateways referenced in the <code>spec.parentRefs</code> field of the HTTPRoute.</p> <p>Target a HTTPRoute by setting the <code>spec.targetRef</code> field of the RateLimitPolicy as follows:</p> <pre><code>apiVersion: kuadrant.io/v1\nkind: RateLimitPolicy\nmetadata:\n  name: &lt;RateLimitPolicy name&gt;\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: &lt;HTTPRoute Name&gt;\n  limits: { \u2026 }\n</code></pre> <p></p>"},{"location":"kuadrant-operator/doc/overviews/rate-limiting/#hostnames-and-wildcards","title":"Hostnames and wildcards","text":"<p>If a RateLimitPolicy targets a route defined for <code>*.com</code> and another RateLimitPolicy targets another route for <code>api.com</code>, the Kuadrant control plane will not merge these two RateLimitPolicies. Unless one of the policies declare an overrides set of limites, the control plane will configure to mimic the behavior of gateway implementation by which the \"most specific hostname wins\", thus enforcing only the corresponding applicable policies and limit definitions.</p> <p>E.g., by default, a request coming for <code>api.com</code> will be rate limited according to the rules from the RateLimitPolicy that targets the route for <code>api.com</code>; while a request for <code>other.com</code> will be rate limited with the rules from the RateLimitPolicy targeting the route for <code>*.com</code>.</p> <p>See more examples in Overlapping Gateway and HTTPRoute RateLimitPolicies.</p>"},{"location":"kuadrant-operator/doc/overviews/rate-limiting/#targeting-a-gateway-networking-resource","title":"Targeting a Gateway networking resource","text":"<p>A RateLimitPolicy that targets a Gateway can declare a block of defaults (<code>spec.defaults</code>) or a block of overrides (<code>spec.overrides</code>). As a standard, gateway policies that do not specify neither defaults nor overrides, act as defaults.</p> <p>When declaring defaults, a RateLimitPolicy which targets a Gateway will be enforced to all HTTP traffic hitting the gateway, unless a more specific RateLimitPolicy targeting a matching HTTPRoute exists. Any new HTTPRoute referrencing the gateway as parent will be automatically covered by the default RateLimitPolicy, as well as changes in the existing HTTPRoutes.</p> <p>Defaults provide cluster operators with the ability to protect the infrastructure against unplanned and malicious network traffic attempt, such as by setting safe default limits on hostnames and hostname wildcards.</p> <p>Inversely, a gateway policy that specify overrides declares a set of rules to be enforced on all routes attached to the gateway, thus atomically replacing any more specific policy occasionally attached to any of those routes.</p> <p>Target a Gateway HTTPRoute by setting the <code>spec.targetRef</code> field of the RateLimitPolicy as follows:</p> <pre><code>apiVersion: kuadrant.io/v1\nkind: RateLimitPolicy\nmetadata:\n  name: &lt;RateLimitPolicy name&gt;\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: &lt;Gateway Name&gt;\n  defaults: # alternatively: `overrides`\n    limits: { \u2026 }\n</code></pre> <p></p>"},{"location":"kuadrant-operator/doc/overviews/rate-limiting/#overlapping-gateway-and-httproute-ratelimitpolicies","title":"Overlapping Gateway and HTTPRoute RateLimitPolicies","text":"<p>Two possible semantics are to be considered here \u2013 gateway policy defaults vs gateway policy overrides.</p> <p>Gateway RateLimitPolicies that declare defaults (or alternatively neither defaults nor overrides) protect all traffic routed through the gateway except where a more specific HTTPRoute RateLimitPolicy exists, in which case the HTTPRoute RateLimitPolicy prevails.</p> <p>Example with 4 RateLimitPolicies, 3 HTTPRoutes and 1 Gateway default (plus 2 HTTPRoute and 2 Gateways without RateLimitPolicies attached):</p> <ul> <li>RateLimitPolicy A \u2192 HTTPRoute A (<code>a.toystore.com</code>) \u2192 Gateway G (<code>*.com</code>)</li> <li>RateLimitPolicy B \u2192 HTTPRoute B (<code>b.toystore.com</code>) \u2192 Gateway G (<code>*.com</code>)</li> <li>RateLimitPolicy W \u2192 HTTPRoute W (<code>*.toystore.com</code>) \u2192 Gateway G (<code>*.com</code>)</li> <li>RateLimitPolicy G (defaults) \u2192 Gateway G (<code>*.com</code>)</li> </ul> <p>Expected behavior:</p> <ul> <li>Request to <code>a.toystore.com</code> \u2192 RateLimitPolicy A will be enforced</li> <li>Request to <code>b.toystore.com</code> \u2192 RateLimitPolicy B will be enforced</li> <li>Request to <code>other.toystore.com</code> \u2192 RateLimitPolicy W will be enforced</li> <li>Request to <code>other.com</code> (suppose a route exists) \u2192 RateLimitPolicy G will be enforced</li> <li>Request to <code>yet-another.net</code> (suppose a route and gateway exist) \u2192 No RateLimitPolicy will be enforced</li> </ul> <p>Gateway RateLimitPolicies that declare overrides protect all traffic routed through the gateway, regardless of existence of any more specific HTTPRoute RateLimitPolicy.</p> <p>Example with 4 RateLimitPolicies, 3 HTTPRoutes and 1 Gateway override (plus 2 HTTPRoute and 2 Gateways without RateLimitPolicies attached):</p> <ul> <li>RateLimitPolicy A \u2192 HTTPRoute A (<code>a.toystore.com</code>) \u2192 Gateway G (<code>*.com</code>)</li> <li>RateLimitPolicy B \u2192 HTTPRoute B (<code>b.toystore.com</code>) \u2192 Gateway G (<code>*.com</code>)</li> <li>RateLimitPolicy W \u2192 HTTPRoute W (<code>*.toystore.com</code>) \u2192 Gateway G (<code>*.com</code>)</li> <li>RateLimitPolicy G (overrides) \u2192 Gateway G (<code>*.com</code>)</li> </ul> <p>Expected behavior:</p> <ul> <li>Request to <code>a.toystore.com</code> \u2192 RateLimitPolicy G will be enforced</li> <li>Request to <code>b.toystore.com</code> \u2192 RateLimitPolicy G will be enforced</li> <li>Request to <code>other.toystore.com</code> \u2192 RateLimitPolicy G will be enforced</li> <li>Request to <code>other.com</code> (suppose a route exists) \u2192 RateLimitPolicy G will be enforced</li> <li>Request to <code>yet-another.net</code> (suppose a route and gateway exist) \u2192 No RateLimitPolicy will be enforced</li> </ul>"},{"location":"kuadrant-operator/doc/overviews/rate-limiting/#limit-definition","title":"Limit definition","text":"<p>A limit will be activated whenever a request comes in and the request matches:</p> <ul> <li>all of the <code>when</code> conditions specified in the limit.</li> </ul> <p>A limit can define:</p> <ul> <li>counters that are qualified based on dynamic values fetched from the request, or</li> <li>global counters (implicitly, when no qualified counter is specified)</li> </ul> <p>A limit is composed of one or more rate limits.</p> <p>E.g.</p> <pre><code>spec:\n  limits:\n    \"toystore-all\":\n      rates:\n\n        - limit: 5000\n          window: 1s\n\n    \"toystore-api-per-username\":\n      rates:\n\n        - limit: 100\n          window: 1s\n        - limit: 1000\n          window: 1m\n      counters:\n        - expression: auth.identity.username\n      when:\n        - predicate: request.host == 'api.toystore.com'\n\n    \"toystore-admin-unverified-users\":\n      rates:\n\n        - limit: 250\n          window: 1s\n      when:\n        - predicate: request.host == 'admin.toystore.com'\n        - predicate: !auth.identity.email_verified\n</code></pre> Request to Rate limits enforced <code>api.toystore.com</code> 100rps/username or 1000rpm/username (whatever happens first) <code>admin.toystore.com</code> 250rps <code>other.toystore.com</code> 5000rps"},{"location":"kuadrant-operator/doc/overviews/rate-limiting/#when-conditions","title":"<code>when</code> conditions","text":"<p><code>when</code> conditions can be used to scope a limit (i.e. to filter the traffic to which a limit definition applies) without any coupling to the underlying network topology, i.e. without making direct references to HTTPRouteRules.</p> <p>Use <code>when</code> conditions to conditionally activate limits based on attributes that cannot be expressed in the HTTPRoutes' <code>spec.hostnames</code> and <code>spec.rules.matches</code> fields, or in general in RateLimitPolicies that target a Gateway.</p> <p>The selectors within the <code>when</code> conditions of a RateLimitPolicy are a subset of Kuadrant's Well-known Attributes (RFC 0002). Check out the reference for the full list of supported selectors.</p>"},{"location":"kuadrant-operator/doc/overviews/rate-limiting/#examples","title":"Examples","text":"<p>Check out the following user guides for examples of rate limiting services with Kuadrant:</p> <ul> <li>Simple Rate Limiting for Applications</li> <li>Authenticated Rate Limiting for Application</li> <li>Gateway Rate Limiting for Cluster Operators</li> <li>Authenticated Rate Limiting with JWTs and Kubernetes RBAC</li> </ul>"},{"location":"kuadrant-operator/doc/overviews/rate-limiting/#known-limitations","title":"Known limitations","text":"<ul> <li>RateLimitPolicies can only target HTTPRoutes/Gateways defined within the same namespace of the RateLimitPolicy.</li> </ul>"},{"location":"kuadrant-operator/doc/overviews/rate-limiting/#implementation-details","title":"Implementation details","text":"<p>Driven by limitations related to how Istio injects configuration in the filter chains of the ingress gateways, Kuadrant relies on Envoy's Wasm Network filter in the data plane, to manage the integration with rate limiting service (\"Limitador\"), instead of the Rate Limit filter.</p> <p>Motivation: Multiple rate limit domains</p> <p>The first limitation comes from having only one filter chain per listener. This often leads to one single global rate limiting filter configuration per gateway, and therefore to a shared rate limit domain across applications and policies. Even though, in a rate limit filter, the triggering of rate limit calls, via actions to build so-called \"descriptors\", can be defined at the level of the virtual host and/or specific route rule, the overall rate limit configuration is only one, i.e., always the same rate limit domain for all calls to Limitador.</p> <p>On the other hand, the possibility to configure and invoke the rate limit service for multiple domains depending on the context allows to isolate groups of policy rules, as well as to optimize performance in the rate limit service, which can rely on the domain for indexation.</p> <p>Motivation: Fine-grained matching rules A second limitation of configuring the rate limit filter via Istio, particularly from Gateway API resources, is that rate limit descriptors at the level of a specific HTTP route rule require \"named routes\" \u2013 defined only in an Istio VirtualService resource and referred in an EnvoyFilter one. Because Gateway API HTTPRoute rules lack a \"name\" property<sup>1</sup>, as well as the Istio VirtualService resources are only ephemeral data structures handled by Istio in-memory in its implementation of gateway configuration for Gateway API, where the names of individual route rules are auto-generated and not referable by users in a policy<sup>2</sup><sup>3</sup>, rate limiting by attributes of the HTTP request (e.g., path, method, headers, etc) would be very limited while depending only on Envoy's Rate Limit filter.</p> <p>Motivated by the desire to support multiple rate limit domains per ingress gateway, as well as fine-grained HTTP route matching rules for rate limiting, Kuadrant implements a wasm-shim that handles the rules to invoke the rate limiting service, complying with Envoy's Rate Limit Service (RLS) protocol.</p> <p>The wasm module integrates with the gateway in the data plane via Wasm Network filter, and parses a configuration composed out of user-defined RateLimitPolicy resources by the Kuadrant control plane. Whereas the rate limiting service (\"Limitador\") remains an implementation of Envoy's RLS protocol, capable of being integrated directly via Rate Limit extension or by Kuadrant, via wasm module for the Istio Gateway API implementation.</p> <p>As a consequence of this design:</p> <ul> <li>Users can define fine-grained rate limit rules that match their Gateway and HTTPRoute definitions including for subsections of these.</li> <li>Rate limit definitions are insulated, not leaking across unrelated policies or applications.</li> <li>Conditions to activate limits are evaluated in the context of the gateway process, reducing the gRPC calls to the external rate limiting service only to the cases where rate limit counters are known in advance to have to be checked/incremented.</li> <li>The rate limiting service can rely on the indexation to look up for groups of limit definitions and counters.</li> <li>Components remain compliant with industry protocols and flexible for different integration options.</li> </ul> <p>A Kuadrant wasm-shim configuration for one RateLimitPolicy custom resources targeting a HTTPRoute looks like the following and it is generated automatically by the Kuadrant control plane:</p> <pre><code>apiVersion: extensions.istio.io/v1alpha1\nkind: WasmPlugin\nmetadata:\n  creationTimestamp: \"2024-10-01T16:59:40Z\"\n  generation: 1\n  name: kuadrant-kuadrant-ingressgateway\n  namespace: gateway-system\n  ownerReferences:\n\n    - apiVersion: gateway.networking.k8s.io/v1\n      blockOwnerDeletion: true\n      controller: true\n      kind: Gateway\n      name: kuadrant-ingressgateway\n      uid: 0298355b-fb30-4442-af2b-88d0c05bd2bd\n  resourceVersion: \"11253\"\n  uid: 36ef1fb7-9eca-46c7-af63-fe783f40148c\nspec:\n  phase: STATS\n  pluginConfig:\n    services:\n      ratelimit-service:\n        type: ratelimit\n        endpoint: ratelimit-cluster\n        failureMode: allow\n    actionSets:\n      - name: some_name_0\n        routeRuleConditions:\n          hostnames:\n            - \"*.toystore.website\"\n            - \"*.toystore.io\"\n          predicates:\n            - request.url_path.startsWith(\"/assets\")\n        actions:\n          - service: ratelimit-service\n            scope: gateway-system/app-rlp\n            predicates:\n              - request.host.endsWith('.toystore.website')\n            data:\n              - expression:\n                  key: limit.toystore_assets_all_domains__b61ee8e6\n                  value: \"1\"\n      - name: some_name_1\n        routeRuleConditions:\n          hostnames:\n            - \"*.toystore.website\"\n            - \"*.toystore.io\"\n          predicates:\n            - request.url_path.startsWith(\"/v1\")\n        actions:\n          - service: ratelimit-service\n            scope: gateway-system/app-rlp\n            predicates:\n              - request.host.endsWith('.toystore.website')\n              - auth.identity.username == \"\"\n            data:\n              - expression:\n                  key: limit.toystore_v1_website_unauthenticated__377837ee\n                  value: \"1\"\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: kuadrant-ingressgateway\n  url: oci://quay.io/kuadrant/wasm-shim:latest\n</code></pre> <ol> <li> <p>https://github.com/kubernetes-sigs/gateway-api/pull/996\u00a0\u21a9</p> </li> <li> <p>https://github.com/istio/istio/issues/36790\u00a0\u21a9</p> </li> <li> <p>https://github.com/istio/istio/issues/37346\u00a0\u21a9</p> </li> </ol>"},{"location":"kuadrant-operator/doc/overviews/telemetrypolicy/","title":"Kuadrant TelemetryPolicy","text":"<p>The Kuadrant TelemetryPolicy CRD allows you to add custom labels to Kuadrant data plane component metrics.</p>"},{"location":"kuadrant-operator/doc/overviews/telemetrypolicy/#how-it-works","title":"How it works","text":"<p>Custom labels are defined as key-value pairs, where the key is the label name and the value is either a literal or a CEL expression. Using dynamically evaluated CEL expressions, you can label existing metrics with any data referenced by the Well-known Attributes.</p> <p>Only labels with CEL expressions that resolve successfully will be included.</p>"},{"location":"kuadrant-operator/doc/overviews/telemetrypolicy/#examples","title":"Examples","text":"<p>The following example configuration adds <code>user</code> and <code>group</code> labels for authenticated traffic.</p> <pre><code>apiVersion: extensions.kuadrant.io/v1alpha1\nkind: TelemetryPolicy\nmetadata:\n  name: user-group\n  namespace: gateway-system\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: kuadrant-ingressgateway\n  metrics:\n    default:\n      labels:\n        user: auth.identity.userid\n        group: auth.identity.groups\n</code></pre>"},{"location":"kuadrant-operator/doc/overviews/tls/","title":"TLS","text":"<p>A Kuadrant TLSPolicy custom resource:</p> <p>Targets Gateway API networking resources Gateways to provide tls for gateway listeners by managing the lifecycle of tls certificates using <code>CertManager</code>.</p>"},{"location":"kuadrant-operator/doc/overviews/tls/#how-it-works","title":"How it works","text":""},{"location":"kuadrant-operator/doc/overviews/tls/#the-tlspolicy-custom-resource","title":"The TLSPolicy custom resource","text":""},{"location":"kuadrant-operator/doc/overviews/tls/#overview","title":"Overview","text":"<p>The <code>TLSPolicy</code> spec includes the following parts:</p> <ul> <li>A reference to an existing Gateway API resource (<code>spec.targetRef</code>)</li> </ul>"},{"location":"kuadrant-operator/doc/overviews/tls/#high-level-example-and-field-definition","title":"High-level example and field definition","text":"<pre><code>apiVersion: kuadrant.io/v1\nkind: TLSPolicy\nmetadata:\n  name: my-tls-policy\nspec:\n  # reference to an existing networking resource to attach the policy to\n  # it can only be a Gateway API Gateway resource\n  # it can only refer to objects in the same namespace as the TLSPolicy\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: mygateway\n</code></pre> <p>Check out the API reference for a full specification of the TLSPolicy CRD.</p>"},{"location":"kuadrant-operator/doc/overviews/tls/#using-the-tlspolicy","title":"Using the TLSPolicy","text":""},{"location":"kuadrant-operator/doc/overviews/tls/#targeting-a-gateway-networking-resource","title":"Targeting a Gateway networking resource","text":"<p>When a TLSPolicy targets a Gateway, the policy will be enforced on all gateway listeners that have a valid TLS section.</p> <p>Target a Gateway by setting the <code>spec.targetRef</code> field of the TLSPolicy as follows:</p> <pre><code>apiVersion: kuadrant.io/v1\nkind: TLSPolicy\nmetadata:\n  name: &lt;TLSPolicy name&gt;\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: &lt;Gateway Name&gt;\n</code></pre>"},{"location":"kuadrant-operator/doc/overviews/tls/#examples","title":"Examples","text":"<p>Check out the following user guides for examples of using the Kuadrant TLSPolicy:</p>"},{"location":"kuadrant-operator/doc/overviews/tls/#known-limitations","title":"Known limitations","text":""},{"location":"kuadrant-operator/doc/overviews/token-rate-limiting/","title":"Kuadrant Token Rate Limiting","text":"<p>A Kuadrant TokenRateLimitPolicy custom resource enables token-based rate limiting for AI/LLM workloads in a Gateway API network:</p> <ol> <li>Targets Gateway API networking resources such as HTTPRoutes and Gateways</li> <li>Automatically tracks actual token consumption from OpenAI-compatible API responses</li> <li>Supports user segmentation and sophisticated limiting strategies</li> <li>Integrates with AuthPolicy for user-based rate limiting using authentication claims</li> <li>Enables cluster operators to set defaults that govern behaviour at the lower levels of the network, until a more specific policy is applied</li> </ol>"},{"location":"kuadrant-operator/doc/overviews/token-rate-limiting/#how-it-works","title":"How it works","text":""},{"location":"kuadrant-operator/doc/overviews/token-rate-limiting/#token-tracking-protocol","title":"Token Tracking Protocol","text":"<p>Kuadrant's Token Rate Limit implementation extends the Envoy Rate Limit Service (RLS) protocol with automatic token usage extraction. The workflow per request goes:</p> <ol> <li>On incoming request, the gateway evaluates matching rules and predicates from TokenRateLimitPolicy resources</li> <li>If the request matches, the gateway prepares rate limit descriptors and monitors the response</li> <li>After receiving the response, the gateway extracts <code>usage.total_tokens</code> from the response body</li> <li>The gateway sends a RateLimitRequest to Limitador with the actual token count as <code>hits_addend</code></li> <li>Limitador tracks the cumulative token usage and responds with either <code>OK</code> or <code>OVER_LIMIT</code></li> </ol> <p>This approach ensures accurate usage-based rate limiting where limits are enforced based on actual AI/LLM token consumption rather than simple request counts.</p> <p>Important: Currently, TokenRateLimitPolicy only supports non-streaming OpenAI-style API responses (where <code>stream: false</code> or is omitted in the request). Support for streaming responses is planned for future releases.</p>"},{"location":"kuadrant-operator/doc/overviews/token-rate-limiting/#the-tokenratelimitpolicy-custom-resource","title":"The TokenRateLimitPolicy custom resource","text":""},{"location":"kuadrant-operator/doc/overviews/token-rate-limiting/#overview","title":"Overview","text":"<p>The <code>TokenRateLimitPolicy</code> spec includes, basically, two parts:</p> <ul> <li>A reference to an existing Gateway API resource (<code>spec.targetRef</code>)</li> <li>Limit definitions (<code>spec.limits</code>)</li> </ul> <p>Each limit definition includes:</p> <ul> <li>A set of rate limits (<code>spec.limits.&lt;limit-name&gt;.rates[]</code>)</li> <li>(Optional) A set of dynamic counter qualifiers (<code>spec.limits.&lt;limit-name&gt;.counters[]</code>)</li> <li>(Optional) A set of additional dynamic conditions to activate the limit (<code>spec.limits.&lt;limit-name&gt;.when[]</code>)</li> </ul> <p>The limit definitions (<code>limits</code>) can be declared at the top-level level of the spec (with the semantics of defaults) or alternatively within explicit <code>defaults</code> or <code>overrides</code> blocks.</p> Check out Kuadrant RFC 0002 to learn more about the Well-known Attributes that can be used to define counter qualifiers (<code>counters</code>) and conditions (<code>when</code>). <p>Check out the API reference for a full specification of the TokenRateLimitPolicy CRD.</p>"},{"location":"kuadrant-operator/doc/overviews/token-rate-limiting/#key-features","title":"Key Features","text":""},{"location":"kuadrant-operator/doc/overviews/token-rate-limiting/#automatic-token-tracking","title":"Automatic Token Tracking","text":"<p>TokenRateLimitPolicy automatically extracts token usage from AI/LLM responses without requiring any additional configuration:</p> <ul> <li>Zero configuration: Works out-of-the-box with OpenAI-compatible APIs</li> <li>Response parsing: Automatically extracts <code>usage.total_tokens</code> from response bodies</li> <li>Accurate accounting: Tracks actual token consumption, not estimates</li> <li>Graceful fallback: If token parsing fails, falls back to request counting</li> </ul>"},{"location":"kuadrant-operator/doc/overviews/token-rate-limiting/#user-segmentation","title":"User Segmentation","text":"<p>Create different limits for different user tiers, organisations, or teams:</p> <pre><code>limits:\n  free-tier:\n    rates:\n\n    - limit: 20000\n      window: 24h\n    when:\n    - predicate: 'auth.identity.groups.split(\",\").exists(g, g == \"free\")'\n    counters:\n    - expression: auth.identity.userid\n</code></pre>"},{"location":"kuadrant-operator/doc/overviews/token-rate-limiting/#multiple-time-windows","title":"Multiple Time Windows","text":"<p>Protect against both burst usage and sustained overconsumption:</p> <pre><code>limits:\n  burst-protection:\n    rates:\n\n    - limit: 1000     # 1k tokens per minute (burst protection)\n      window: 1m\n    - limit: 50000    # 50k tokens per hour (sustained usage)\n      window: 1h\n    - limit: 500000   # 500k tokens per day (daily quota)\n      window: 1d\n</code></pre>"},{"location":"kuadrant-operator/doc/overviews/token-rate-limiting/#policy-hierarchy-and-precedence","title":"Policy Hierarchy and Precedence","text":"<p>TokenRateLimitPolicy supports three modes of operation that provide different levels of precedence:</p>"},{"location":"kuadrant-operator/doc/overviews/token-rate-limiting/#implicit-defaults-using-limits","title":"Implicit Defaults (using <code>limits</code>)","text":"<p>When a policy specifies <code>limits</code> directly at the spec level, these act as implicit defaults:</p> <ul> <li>Applied to the target resource (<code>Gateway</code> or <code>HTTPRoute</code>) </li> <li>When targeting a Gateway: Can be overridden by more specific policies targeting individual routes</li> <li>Most common usage pattern for single-policy scenarios</li> </ul>"},{"location":"kuadrant-operator/doc/overviews/token-rate-limiting/#explicit-defaults-using-defaults","title":"Explicit Defaults (using <code>defaults</code>)","text":"<p>When a policy uses the <code>defaults</code> field:</p> <ul> <li>Applied as default rules for routes that lack more specific policies</li> <li>Useful for Gateway-level policies that provide baseline limits  </li> <li>Can be overridden by HTTPRoute-level policies or Gateway overrides</li> <li>Supports merge strategies (<code>atomic</code> or <code>merge</code>)</li> </ul>"},{"location":"kuadrant-operator/doc/overviews/token-rate-limiting/#overrides-using-overrides","title":"Overrides (using <code>overrides</code>)","text":"<p>When a policy uses the <code>overrides</code> field:</p> <ul> <li>Takes precedence over all other policies in the hierarchy</li> <li>Cannot be overridden by more specific policies</li> <li>Only allowed for Gateway-targeted policies</li> <li>Useful for enforcing organisation-wide limits that cannot be bypassed</li> </ul>"},{"location":"kuadrant-operator/doc/overviews/token-rate-limiting/#common-use-cases","title":"Common Use Cases","text":""},{"location":"kuadrant-operator/doc/overviews/token-rate-limiting/#aillm-api-protection","title":"AI/LLM API Protection","text":"<p>Protect your AI/LLM APIs from token exhaustion while ensuring fair usage across different user tiers:</p> <pre><code>apiVersion: kuadrant.io/v1alpha1\nkind: TokenRateLimitPolicy\nmetadata:\n  name: llm-protection\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: ai-gateway\n  limits:\n    free-users:\n      rates:\n\n      - limit: 10000    # 10k tokens per day for free tier\n        window: 24h\n      when:\n      - predicate: 'auth.identity.subscription == \"free\"'\n      counters:\n      - expression: auth.identity.userid\n\n    pro-users:\n      rates:\n\n      - limit: 100000   # 100k tokens per day for pro tier\n        window: 24h\n      when:\n      - predicate: 'auth.identity.subscription == \"pro\"'\n      counters:\n      - expression: auth.identity.userid\n</code></pre>"},{"location":"kuadrant-operator/doc/overviews/token-rate-limiting/#organisation-wide-quotas","title":"Organisation-Wide Quotas","text":"<p>Enforce organisation-level limits that cannot be bypassed by individual teams:</p> <pre><code>apiVersion: kuadrant.io/v1alpha1\nkind: TokenRateLimitPolicy\nmetadata:\n  name: org-quotas\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: api-gateway\n  overrides:\n    limits:\n      org-total:\n        rates:\n\n        - limit: 10000000  # 10M tokens per month org-wide\n          window: 720h\n        counters:\n        - expression: auth.identity.org_id\n</code></pre>"},{"location":"kuadrant-operator/doc/overviews/token-rate-limiting/#integration-with-authpolicy","title":"Integration with AuthPolicy","text":"<p>TokenRateLimitPolicy works seamlessly with Kuadrant's AuthPolicy to enable user-based rate limiting. When using API key authentication with groups, ensure the AuthPolicy exposes the necessary attributes:</p> <pre><code>apiVersion: kuadrant.io/v1\nkind: AuthPolicy\nmetadata:\n  name: api-auth\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: api-gateway\n  rules:\n    authentication:\n      api-key-users:\n        apiKey:\n          selector:\n            matchLabels:\n              app: my-llm\n        credentials:\n          authorizationHeader:\n            prefix: APIKEY\n    response:\n      success:\n        filters:\n          identity:\n            json:\n              properties:\n                groups:\n                  selector: auth.identity.metadata.annotations.kuadrant\\.io/groups\n                userid:\n                  selector: auth.identity.metadata.annotations.secret\\.kuadrant\\.io/user-id\n    authorization:\n      allow-groups:\n        opa:\n          rego: |\n            groups := split(object.get(input.auth.identity.metadata.annotations, \"kuadrant.io/groups\", \"\"), \",\")\n            allow { groups[_] == \"free\" }\n            allow { groups[_] == \"gold\" }\n</code></pre> <p>This configuration makes <code>auth.identity.groups</code> and <code>auth.identity.userid</code> available to TokenRateLimitPolicy for use in predicates and counters.</p>"},{"location":"kuadrant-operator/doc/overviews/token-rate-limiting/#see-also","title":"See Also","text":"<ul> <li>TokenRateLimitPolicy API Reference</li> <li>Token Rate Limiting Tutorial</li> <li>RateLimitPolicy Overview - For non-token-based rate limiting</li> <li>AuthPolicy Overview - For authentication configuration</li> <li>Gateway API Documentation</li> </ul>"},{"location":"kuadrant-operator/doc/reference/authpolicy/","title":"The AuthPolicy Custom Resource Definition (CRD)","text":""},{"location":"kuadrant-operator/doc/reference/authpolicy/#authpolicy","title":"AuthPolicy","text":"Field Type Required Description <code>spec</code> AuthPolicySpec Yes The specification for AuthPolicy custom resource <code>status</code> AuthPolicyStatus No The status for the custom resource"},{"location":"kuadrant-operator/doc/reference/authpolicy/#authpolicyspec","title":"AuthPolicySpec","text":"Field Type Required Description <code>targetRef</code> Gateway API LocalPolicyTargetReferenceWithSectionName Yes Reference to a Kubernetes resource that the policy attaches to <code>rules</code> AuthScheme No Implicit default authentication/authorization rules <code>patterns</code> MapNamedPattern&gt; No Implicit default named patterns of lists of <code>selector</code>, <code>operator</code> and <code>value</code> tuples, to be reused in <code>when</code> conditions and pattern-matching authorization rules. <code>when</code> []PatternExpressionOrRef No List of implicit default additional dynamic conditions (expressions) to activate the policy. Use it for filtering attributes that cannot be expressed in the targeted HTTPRoute's <code>spec.hostnames</code> and <code>spec.rules.matches</code> fields, or when targeting a Gateway. <code>defaults</code> AuthPolicyCommonSpec No Explicit default definitions. This field is mutually exclusive with any of the implicit default definitions: <code>spec.rules</code>, <code>spec.patterns</code>, <code>spec.when</code> <code>overrides</code> AuthPolicyCommonSpec No Atomic overrides definitions. This field is mutually exclusive with any of the implicit or explicit default definitions: <code>spec.rules</code>, <code>spec.patterns</code>, <code>spec.when</code>, <code>spec.default</code>"},{"location":"kuadrant-operator/doc/reference/authpolicy/#authpolicycommonspec","title":"AuthPolicyCommonSpec","text":"Field Type Required Description <code>rules</code> AuthScheme No Authentication/authorization rules <code>patterns</code> MapNamedPattern&gt; No Named patterns of lists of <code>selector</code>, <code>operator</code> and <code>value</code> tuples, to be reused in <code>when</code> conditions and pattern-matching authorization rules. <code>when</code> []PatternExpressionOrRef No List of additional dynamic conditions (expressions) to activate the policy. Use it for filtering attributes that cannot be expressed in the targeted HTTPRoute's <code>spec.hostnames</code> and <code>spec.rules.matches</code> fields, or when targeting a Gateway."},{"location":"kuadrant-operator/doc/reference/authpolicy/#authscheme","title":"AuthScheme","text":"Field Type Required Description <code>authentication</code> MapAuthenticationRule&gt; No Authentication rules. At least one config MUST evaluate to a valid identity object for the auth request to be successful. If omitted or empty, anonymous access is assumed. <code>metadata</code> MapMetadataRule&gt; No Rules for fetching auth metadata from external sources. <code>authorization</code> MapAuthorizationRule&gt; No Authorization rules. All policies MUST allow access for the auth request be successful. <code>response</code> ResponseSpec No Customizations to the response to the authorization request. Use it to set custom values for unauthenticated, unauthorized, and/or success access request. <code>callbacks</code> MapCallbackRule&gt; No Rules for post-authorization callback requests to external services. Triggered regardless of the result of the authorization request."},{"location":"kuadrant-operator/doc/reference/authpolicy/#authrulecommon","title":"AuthRuleCommon","text":"Field Type Required Description <code>when</code> []PatternExpressionOrRef No List of additional dynamic conditions (expressions) to activate the auth rule. Use it for filtering attributes that cannot be expressed in the targeted HTTPRoute's <code>spec.hostnames</code> and <code>spec.rules.matches</code> fields, or when targeting a Gateway. <code>cache</code> Caching spec No Caching options for the resolved object returned when applying this auth rule. (Default: disabled) <code>priority</code> Integer No Priority group of the auth rule. All rules in the same priority group are evaluated concurrently; consecutive priority groups are evaluated sequentially. (Default: <code>0</code>) <code>metrics</code> Boolean No Whether the auth rule emits individual observability metrics. (Default: <code>false</code>)"},{"location":"kuadrant-operator/doc/reference/authpolicy/#authenticationrule","title":"AuthenticationRule","text":"Field Type Required Description <code>apiKey</code> API Key authentication spec No Authentication based on API keys stored in Kubernetes secrets. Use one of: <code>apiKey</code>, <code>jwt</code>, <code>oauth2Introspection</code>, <code>kubernetesTokenReview</code>, <code>x509</code>, <code>plain</code>, <code>anonymous</code>. <code>kubernetesTokenReview</code> KubernetesTokenReview spec No Authentication by Kubernetes token review. Use one of: <code>apiKey</code>, <code>jwt</code>, <code>oauth2Introspection</code>, <code>kubernetesTokenReview</code>, <code>x509</code>, <code>plain</code>, <code>anonymous</code>. <code>jwt</code> JWT verification spec No Authentication based on JSON Web Tokens (JWT). Use one of: <code>apiKey</code>, <code>jwt</code>, <code>oauth2Introspection</code>, <code>kubernetesTokenReview</code>, <code>x509</code>, <code>plain</code>, <code>anonymous</code>. <code>oauth2Introspection</code> OAuth2 Token Introscpection spec No Authentication by OAuth2 token introspection. Use one of: <code>apiKey</code>, <code>jwt</code>, <code>oauth2Introspection</code>, <code>kubernetesTokenReview</code>, <code>x509</code>, <code>plain</code>, <code>anonymous</code>. <code>x509</code> X.509 authentication spec No Authentication based on client X.509 certificates. The certificates presented by the clients must be signed by a trusted CA whose certificates are stored in Kubernetes secrets. Use one of: <code>apiKey</code>, <code>jwt</code>, <code>oauth2Introspection</code>, <code>kubernetesTokenReview</code>, <code>x509</code>, <code>plain</code>, <code>anonymous</code>. <code>plain</code> Plain identity object spec No Identity object extracted from the context. Use this method when authentication is performed beforehand by a proxy and the resulting object passed to Authorino as JSON in the auth request. Use one of: <code>apiKey</code>, <code>jwt</code>, <code>oauth2Introspection</code>, <code>kubernetesTokenReview</code>, <code>x509</code>, <code>plain</code>, <code>anonymous</code>. <code>anonymous</code> Anonymous access No Anonymous access. Use one of: <code>apiKey</code>, <code>jwt</code>, <code>oauth2Introspection</code>, <code>kubernetesTokenReview</code>, <code>x509</code>, <code>plain</code>, <code>anonymous</code>. <code>credentials</code> Auth credentials spec No Customizations to where credentials are required to be passed in the request for authentication based on this auth rule. Defaults to HTTP Authorization header with prefix \"Bearer\". <code>overrides</code> Identity extension spec No JSON overrides to set to the resolved identity object. Do not use it with identity objects of other JSON types (array, string, etc). <code>defaults</code> Identity extension spec No JSON defaults to set to the resolved identity object. Do not use it with identity objects of other JSON types (array, string, etc). (inline) AuthRuleCommon No"},{"location":"kuadrant-operator/doc/reference/authpolicy/#metadatarule","title":"MetadataRule","text":"Field Type Required Description <code>http</code> HTTP GET/GET-by-POST external metadata spec No External source of auth metadata via HTTP request. Use one of: <code>http</code>, <code>userInfo</code>, <code>uma</code>. <code>userInfo</code> OIDC UserInfo spec No OpendID Connect UserInfo linked to an OIDC authentication rule declared in this same AuthPolicy. Use one of: <code>http</code>, <code>userInfo</code>, <code>uma</code>. <code>uma</code> UMA metadata spec No User-Managed Access (UMA) source of resource data.  Use one of: <code>http</code>, <code>userInfo</code>, <code>uma</code>. (inline) AuthRuleCommon No"},{"location":"kuadrant-operator/doc/reference/authpolicy/#authorizationrule","title":"AuthorizationRule","text":"Field Type Required Description <code>patternMatching</code> Pattern-matching authorization spec No Pattern-matching authorization rules. Use one of: <code>patternMatching</code>, <code>opa</code>, <code>kubernetesSubjectAccessReview</code>, <code>spicedb</code>. <code>opa</code> OPA authorization spec No Open Policy Agent (OPA) Rego policy. Use one of: <code>patternMatching</code>, <code>opa</code>, <code>kubernetesSubjectAccessReview</code>, <code>spicedb</code>. <code>kubernetesSubjectAccessReview</code> Kubernetes SubjectAccessReview spec No Authorization by Kubernetes SubjectAccessReview. Use one of: <code>patternMatching</code>, <code>opa</code>, <code>kubernetesSubjectAccessReview</code>, <code>spicedb</code>. <code>spicedb</code> SpiceDB authorization spec No Authorization decision delegated to external Authzed/SpiceDB server. Use one of: <code>patternMatching</code>, <code>opa</code>, <code>kubernetesSubjectAccessReview</code>, <code>spicedb</code>. (inline) AuthRuleCommon No"},{"location":"kuadrant-operator/doc/reference/authpolicy/#responsespec","title":"ResponseSpec","text":"Field Type Required Description <code>unauthenticated</code> Custom denial status spec No Customizations on the denial status and other HTTP attributes when the request is unauthenticated. (Default: <code>401 Unauthorized</code>) <code>unauthorized</code> Custom denial status spec No Customizations on the denial status and other HTTP attributes when the request is unauthorized. (Default: <code>403 Forbidden</code>) <code>success</code> SuccessResponseSpec No Response items to be included in the auth response when the request is authenticated and authorized."},{"location":"kuadrant-operator/doc/reference/authpolicy/#successresponsespec","title":"SuccessResponseSpec","text":"Field Type Required Description <code>headers</code> Map&lt;string:SuccessResponseItem&gt; No Custom success response items wrapped as HTTP headers to be injected in the request. <code>filters</code> Map&lt;string:SuccessResponseItem&gt; No Custom success response items made available to other filters managed by Kuadrant (i.e. Rate Limit)."},{"location":"kuadrant-operator/doc/reference/authpolicy/#successresponseitem","title":"SuccessResponseItem","text":"Field Type Required Description <code>plain</code> Plain text response item No Plain text content. Use one of: <code>plain</code>, <code>json</code>, <code>wristband</code>. <code>json</code> JSON injection response item No Specification of a JSON object. Use one of: <code>plain</code>, <code>json</code>, <code>wristband</code>. <code>wristband</code> Festival Wristband token response item No Specification of a JSON object. Use one of: <code>plain</code>, <code>json</code>, <code>wristband</code>. <code>key</code> String No The key used to add the custom response item (name of the HTTP header or root property of the Dynamic Metadata object). Defaults to the name of the response item if omitted."},{"location":"kuadrant-operator/doc/reference/authpolicy/#callbackrule","title":"CallbackRule","text":"Field Type Required Description <code>http</code> HTTP endpoints callback spec No HTTP endpoint settings to build the callback request (webhook). (inline) AuthRuleCommon No"},{"location":"kuadrant-operator/doc/reference/authpolicy/#namedpattern","title":"NamedPattern","text":"Field Type Required Description <code>selector</code> String Yes A valid Well-known attribute whose resolved value in the data plane will be compared to <code>value</code>, using the <code>operator</code>. <code>operator</code> String Yes The binary operator to be applied to the resolved value specified by the selector. One of: <code>eq</code> (equal to), <code>neq</code> (not equal to), <code>incl</code> (includes; for arrays), <code>excl</code> (excludes; for arrays), <code>matches</code> (regex). <code>value</code> String Yes The static value to be compared to the one resolved from the selector."},{"location":"kuadrant-operator/doc/reference/authpolicy/#authpolicystatus","title":"AuthPolicyStatus","text":"Field Type Description <code>observedGeneration</code> String Number of the last observed generation of the resource. Use it to check if the status info is up to date with latest resource spec. <code>conditions</code> []ConditionSpec List of conditions that define that status of the resource."},{"location":"kuadrant-operator/doc/reference/authpolicy/#conditionspec","title":"ConditionSpec","text":"<ul> <li>The lastTransitionTime field provides a timestamp for when the entity last transitioned from one status to another.</li> <li>The message field is a human-readable message indicating details about the transition.</li> <li>The reason field is a unique, one-word, CamelCase reason for the condition\u2019s last transition.</li> <li>The status field is a string, with possible values True, False, and Unknown.</li> <li>The type field is a string with the following possible values:</li> <li>Available: the resource has successfully configured;</li> </ul> Field Type Description <code>type</code> String Condition Type <code>status</code> String Status: True, False, Unknown <code>reason</code> String Condition state reason <code>message</code> String Condition state description <code>lastTransitionTime</code> Timestamp Last transition timestamp"},{"location":"kuadrant-operator/doc/reference/authpolicy/#high-level-example","title":"High-level example","text":"<pre><code>apiVersion: kuadrant.io/v1\nkind: AuthPolicy\nmetadata:\n  name: my-auth-policy\nspec:\n  # Reference to an existing networking resource to attach the policy to. REQUIRED.\n  # It can be a Gateway API HTTPRoute or Gateway resource.\n  # It can only refer to objects in the same namespace as the AuthPolicy.\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute / Gateway\n    name: myroute / mygateway\n\n  # Additional dynamic conditions to trigger the AuthPolicy.\n  # Use it for filtering attributes not supported by HTTPRouteRule or with AuthPolicies that target a Gateway.\n  # Check out https://github.com/Kuadrant/architecture/blob/main/rfcs/0002-well-known-attributes.md to learn more\n  # about the Well-known Attributes that can be used in this field.\n  # Equivalent to if otherwise declared within `defaults`.\n  when: [\u2026]\n\n  # Sets of common patterns of selector-operator-value triples, to be referred by name in `when` conditions\n  # and pattern-matching rules. Often employed to avoid repetition in the policy.\n  # Equivalent to if otherwise declared within `defaults`.\n  patterns: { \u2026 }\n\n  # The auth rules to apply to the network traffic routed through the targeted resource.\n  # Equivalent to if otherwise declared within `defaults`.\n  rules:\n    # Authentication rules to enforce.\n    # At least one config must evaluate to a valid identity object for the auth request to be successful.\n    # If omitted or empty, anonymous access is assumed.\n    authentication:\n      \"my-authn-rule\":\n        # The authentication method of this rule.\n        # One-of: apiKey, jwt, oauth2Introspection, kubernetesTokenReview, x509, plain, anonymous.\n        apiKey: { \u2026 }\n\n        # Where credentials are required to be passed in the request for authentication based on this rule.\n        # One-of: authorizationHeader, customHeader, queryString, cookie.\n        credentials:\n          authorizationHeader:\n            prefix: APIKEY\n\n        # Rule-level additional conditions.\n        when: [\u2026]\n\n        # Configs for caching the resolved object returned out of evaluating this auth rule.\n        cache: { \u2026 }\n\n    # Rules for fetching auth metadata from external sources.\n    metadata:\n      \"my-external-source\":\n        # The method for fetching metadata from the external source.\n        # One-of: http: userInfo, uma.\n        http: { \u2026 }\n\n    # Authorization rules to enforce.\n    # All policies must allow access for the auth request be successful.\n    authorization:\n      \"my-authz-rule\":\n        # The authorization method of this rule.\n        # One-of: patternMatching, opa, kubernetesSubjectAccessReview, spicedb.\n        opa: { \u2026 }\n\n    # Customizations to the authorization response.\n    response:\n      # Custom denial status and other HTTP attributes for unauthenticated requests.\n      unauthenticated: { \u2026 }\n\n      # Custom denial status and other HTTP attributes for unauhtorized requests.\n      unauthorized: { \u2026 }\n\n      # Custom response items when access is granted.\n      success:\n        # Custom response items wrapped as HTTP headers to be injected in the request\n        headers:\n          \"my-custom-header\":\n            # One-of: plain, json, wristband.\n            plain: { \u2026 }\n\n        # Custom response items wrapped as envoy dynamic metadata.\n        dynamicMetadata:\n          # One-of: plain, json, wristband.\n          \"my-custom-dyn-metadata\":\n            json: { \u2026 }\n\n    # Rules for post-authorization callback requests to external services.\n    # Triggered regardless of the result of the authorization request.\n    callbacks:\n      \"my-webhook\":\n        http: { \u2026 }\n\n    # Explicit defaults. Used in policies that target a Gateway object to express default rules to be enforced on\n    # routes that lack a more specific policy attached to.\n    # Mutually exclusive with `overrides` and with declaring the `rules`, `when` and `patterns` at the top-level of\n    # the spec.\n    defaults:\n      rules:\n        authentication: { \u2026 }\n        metadata: { \u2026 }\n        authorization: { \u2026 }\n        response: { \u2026 }\n        callbacks: { \u2026 }\n      when: [\u2026]\n      patterns: { \u2026 }\n\n    # Overrides. Used in policies that target a Gateway object to be enforced on all routes linked to the gateway,\n    # thus also overriding any more specific policy occasionally attached to any of those routes.\n    # Mutually exclusive with `defaults` and with declaring `rules`, `when` and `patterns` at the top-level of\n    # the spec.\n    overrides:\n      rules:\n        authentication: { \u2026 }\n        metadata: { \u2026 }\n        authorization: { \u2026 }\n        response: { \u2026 }\n        callbacks: { \u2026 }\n      when: [\u2026]\n      patterns: { \u2026 }\n</code></pre>"},{"location":"kuadrant-operator/doc/reference/dnspolicy/","title":"The DNSPolicy Custom Resource Definition (CRD)","text":""},{"location":"kuadrant-operator/doc/reference/dnspolicy/#dnspolicy","title":"DNSPolicy","text":"Field Type Required Description <code>spec</code> DNSPolicySpec Yes The specification for DNSPolicy custom resource <code>status</code> DNSPolicyStatus No The status for the custom resource"},{"location":"kuadrant-operator/doc/reference/dnspolicy/#dnspolicyspec","title":"DNSPolicySpec","text":"Field Type Required Description <code>targetRef</code> Gateway API LocalPolicyTargetReferenceWithSectionName Yes Reference to a Kubernetes resource that the policy attaches to <code>healthCheck</code> HealthCheckSpec No HealthCheck spec <code>loadBalancing</code> LoadBalancingSpec No LoadBalancing Spec <code>providerRefs</code> ProviderRefs No array of references to providers. (currently limited to max 1) <code>delegate</code> Boolean No Enable record delegation. Is an immutable field."},{"location":"kuadrant-operator/doc/reference/dnspolicy/#providerrefs","title":"ProviderRefs","text":"Field Type Required Description <code>providerRefs</code> []ProviderRef Yes max 1 reference. This is an array of providerRef that points to a local secret(s) that contains the required provider auth values"},{"location":"kuadrant-operator/doc/reference/dnspolicy/#providerref","title":"ProviderRef","text":"Field Type Required Description <code>name</code> String Yes Name of the secret in the same namespace that contains the provider credentials"},{"location":"kuadrant-operator/doc/reference/dnspolicy/#excludeaddresses","title":"ExcludeAddresses","text":"Field Type Required Description <code>excludeAddresses</code> []String No set of hostname, CIDR or IP Addresses to exclude from the DNS Provider"},{"location":"kuadrant-operator/doc/reference/dnspolicy/#healthcheckspec","title":"HealthCheckSpec","text":"Field Type Required Description <code>name</code> String Yes Name of the secret in the same namespace that contains the provider credentials <code>path</code> String Yes Path is the path to append to the host to reach the expected health check. Must start with \"?\" or \"/\", contain only valid URL characters and end with alphanumeric char or \"/\". For example \"/\" or \"/healthz\" are common <code>port</code> Number Yes Port to connect to the host on. Must be either 80, 443 or 1024-49151 <code>protocol</code> String Yes Protocol to use when connecting to the host, valid values are \"HTTP\" or \"HTTPS\" <code>failureThreshold</code> Number Yes FailureThreshold is a limit of consecutive failures that must occur for a host to be considered unhealthy <code>interval</code> Duration Yes Interval defines how frequently this probe should execute <code>additionalHeadersRef</code> String No AdditionalHeadersRef refers to a secret that contains extra headers to send in the probe request, this is primarily useful if an authentication token is required by the endpoint. <code>allowInsecureCertificate</code> Boolean No AllowInsecureCertificate will instruct the health check probe to not fail on a self-signed or otherwise invalid SSL certificate this is primarily used in development or testing environments"},{"location":"kuadrant-operator/doc/reference/dnspolicy/#loadbalancingspec","title":"LoadBalancingSpec","text":"Field Type Required Description <code>defaultGeo</code> Boolean Yes Specifies if this is the default geo <code>geo</code> String Yes Geo value to apply to geo endpoints <code>weight</code> Number No Weight value to apply to weighted endpoints default: 120"},{"location":"kuadrant-operator/doc/reference/dnspolicy/#dnspolicystatus","title":"DNSPolicyStatus","text":"Field Type Description <code>observedGeneration</code> String Number of the last observed generation of the resource. Use it to check if the status info is up to date with latest resource spec. <code>conditions</code> []Kubernetes meta/v1.Condition List of conditions that define that status of the resource. <code>healthCheck</code> HealthCheckStatus HealthCheck status. <code>recordConditions</code> [String][]Kubernetes meta/v1.Condition Status of individual DNSRecords owned by this policy."},{"location":"kuadrant-operator/doc/reference/dnspolicy/#healthcheckstatus","title":"HealthCheckStatus","text":"Field Type Description <code>conditions</code> []Kubernetes meta/v1.Condition List of conditions that define that status of the resource."},{"location":"kuadrant-operator/doc/reference/dnspolicy/#high-level-example","title":"High-level example","text":"<pre><code>apiVersion: kuadrant.io/v1\nkind: DNSPolicy\nmetadata:\n  name: my-dns-policy\nspec:\n  # reference to an existing networking resource to attach the policy to\n  # it can only be a Gateway API Gateway resource\n  # it can only refer to objects in the same namespace as the DNSPolicy\n  # it can target a specific listener using sectionName\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: mygateway\n    sectionName: api # (optional) if not set policy applies to all listeners that do not have a policy attached directly\n\n  # reference to an existing secret resource containing provider credentials and configuration\n  # it can only refer to Secrets in the same namespace as the DNSPolicy that have the type kuadrant.io/(provider) e.g kuadrant.io/aws\n  providerRefs:\n\n    - name: my-aws-credentials\n\n  # (optional) loadbalancing specification\n  # use it for providing the specification of how dns will be configured in order to provide balancing of requests across multiple clusters. If not configured, a simple A or CNAME record will be created. If you have a policy with no loadbalancing defined and want to move to a loadbalanced configuration, you will need to delete and re-create the policy.\n  loadBalancing:\n    # is this the default geo to be applied to records. It is important that you set the default geo flag to true **Only** for the GEO value you wish to act as the catchall GEO, you should not set multiple GEO values as default for a given targeted listener. Example: policy 1 targets listener 1 with a geo of US and sets default to true. Policy 2 targets a listener on another cluster and set the geo to EU and default to false. It is fine for policies in the same default GEO to set the value to true. The main thing is to have only one unique GEO set as the default for any shared listener hostname.\n    defaultGeo: true\n    # weighted specification. This will apply the given weight to the records created based on the targeted gateway listeners. If you have multiple gateways that share a listener host, you can set different weight values to influence how much traffic will be brought to a given gateway.\n    weight: 100\n    # This is the actual GEO location to set for records created by this policy. This can and should be different if you have multiple gateways across multiple geographic areas.\n\n    # AWS: To see all regions supported by AWS Route 53, please see the official (documentation)[https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/resource-record-sets-values-geo.html]. With Route 53 when setting a continent code use a \"GEO-\" prefix otherwise it will be considered a country code.\n\n    # GCP: To see all regions supported by GCP Cloud DNS, please see the official (documentation)[https://cloud.google.com/compute/docs/regions-zones]\n\n    #To see the different values you can use for the geo based DNS with Azure take a look at the following (documentation)[https://learn.microsoft.com/en-us/azure/traffic-manager/traffic-manager-geographic-regions]\n    geo: IE\n\n  # (optional) health check specification\n  # health check probes with the following specification will be created for each DNS target, these probes constantly check that the endpoint can be reached. They will flag an unhealthy endpoint in the status. If no DNSRecord has yet been published and the endpoint is unhealthy, the record will not be published until the health check passes.\n  healthCheck:\n    # the path on the listener host(s) that you want to check.\n    path: /health\n    # how many times does the health check need to fail before unhealthy.\n    failureThreshold: 3\n    # how often should it be checked.\n    interval: 5min\n    # additionalHeadersRef is reference to a local secret with a set of key value pairs to be used as headers when sending the health check request.\n    additionalHeadersRef:\n      name: headers\n</code></pre>"},{"location":"kuadrant-operator/doc/reference/kuadrant/","title":"The Kuadrant Custom Resource Definition (CRD)","text":""},{"location":"kuadrant-operator/doc/reference/kuadrant/#kuadrant","title":"kuadrant","text":"Field Type Required Description <code>spec</code> KuadrantSpec No Blank specification <code>status</code> KuadrantStatus No The status for the custom resources."},{"location":"kuadrant-operator/doc/reference/kuadrant/#kuadrantspec","title":"KuadrantSpec","text":"Field Type Required Description <code>observability</code> Observability No Kuadrant observability configuration. <code>mtls</code> mTLS No Two way authentication between kuadrant components. <code>components</code> Components No Optional Kuadrant components configuration."},{"location":"kuadrant-operator/doc/reference/kuadrant/#mtls","title":"mTLS","text":"Field Type Required Description <code>enable</code> Boolean No Enable mutual authentication communication between the gateway and the kuadrant data plane components. Default: <code>false</code> <code>limitador</code> Boolean No Enable mutual authentication communication between the gateway and Limitador. Default: <code>not set</code> <code>authorino</code> Boolean No Enable mutual authentication communication between the gateway and Authorino. Default: <code>not set</code> <p>The truth table for limitador component is as follows:</p> Spec Limtador mTLS enabled <code>{Enable: false, limitador: null}</code> false <code>{Enable: true, limitador: null}</code> true <code>{Enable: false, limitador: false}</code> false <code>{Enable: false, limitador: true}</code> false <code>{Enable: true, limitador: false}</code> false <code>{Enable: true, limitador: true}</code> true <p>The truth table for authorino component is as follows:</p> Spec Authorino mTLS enabled <code>{Enable: false, authorino: null}</code> false <code>{Enable: true, authorino: null}</code> true <code>{Enable: false, authorino: false}</code> false <code>{Enable: false, authorino: true}</code> false <code>{Enable: true, authorino: false}</code> false <code>{Enable: true, authorino: true}</code> true"},{"location":"kuadrant-operator/doc/reference/kuadrant/#observability","title":"Observability","text":"<p>Configures telemetry and monitoring settings for Kuadrant components. When enabled, it configures logging, tracing, and other observability features for both the control plane and data plane components.</p> Field Type Required Description <code>enable</code> Boolean No Enable observability on kuadrant. Default: <code>false</code> <code>dataPlane</code> DataPlane No Configures observability settings for the data plane components. <code>tracing</code> Tracing No Configures distributed tracing for request flows through the system."},{"location":"kuadrant-operator/doc/reference/kuadrant/#dataplane","title":"DataPlane","text":"<p>Configures observability for data plane components (WASM filters). Controls OpenTelemetry trace filtering and request correlation features.</p> Field Type Required Description <code>defaultLevels</code> []LogLevel No Specifies the OpenTelemetry trace filtering levels for WASM modules. Controls which trace spans are exported to your observability backend (Jaeger, Tempo, etc.). The highest priority level set determines the filter level. Important: This controls trace span filtering, not gateway pod log verbosity. To control logs visible via <code>kubectl logs</code>, configure Envoy's log level separately. <code>httpHeaderIdentifier</code> String No Specifies the HTTP header name used to identify and correlate requests in traces (e.g., \"x-request-id\", \"x-correlation-id\"). If set, this header value will be included in trace spans for request correlation across components."},{"location":"kuadrant-operator/doc/reference/kuadrant/#loglevel","title":"LogLevel","text":"<p>Defines a trace filtering level. The highest priority level set (DEBUG &gt; INFO &gt; WARN &gt; ERROR) determines the OTEL trace filter. Only one field should be set per LogLevel entry.</p> Field Type Required Description <code>debug</code> String No Debug level for trace filtering - highest verbosity, most spans exported. Current implementation (MVP): Set to <code>\"true\"</code> to enable. Future: Will support CEL expressions for dynamic request-time evaluation. <code>info</code> String No Info level for trace filtering. Current implementation (MVP): Set to <code>\"true\"</code> to enable. Future: Will support CEL expressions. <code>warn</code> String No Warn level for trace filtering. Current implementation (MVP): Set to <code>\"true\"</code> to enable. Future: Will support CEL expressions. <code>error</code> String No Error level for trace filtering - lowest verbosity, minimal spans exported. Current implementation (MVP): Set to <code>\"true\"</code> to enable. Future: Will support CEL expressions. <p>Example: <pre><code>dataPlane:\n  defaultLevels:\n\n    - debug: \"true\"  # Enable DEBUG level trace filtering\n  httpHeaderIdentifier: x-request-id\n</code></pre></p>"},{"location":"kuadrant-operator/doc/reference/kuadrant/#tracing","title":"Tracing","text":"<p>Configures distributed tracing integration for request flows. It enables tracing spans to be exported to external tracing systems (e.g., Jaeger, Zipkin, Tempo).</p> Field Type Required Description <code>defaultEndpoint</code> String No The default URL of the tracing collector backend where spans should be sent. This endpoint is used by Auth (Authorino), RateLimiting (Limitador) and WASM services for exporting trace data. If tracing endpoints have been configured directly in Authorino or Limitador CRs, those take precedence over this default value. Note: Per-gateway overrides are not currently supported. <code>insecure</code> Boolean No Controls whether to skip TLS certificate verification. Default: <code>false</code>"},{"location":"kuadrant-operator/doc/reference/kuadrant/#components","title":"Components","text":"Field Type Required Description <code>developerPortal</code> DeveloperPortal No Developer portal integration configuration."},{"location":"kuadrant-operator/doc/reference/kuadrant/#developerportal","title":"DeveloperPortal","text":"Field Type Required Description <code>enabled</code> Boolean No Enable the developer portal integration including APIProduct and APIKeyRequest CRDs. Default: <code>false</code>"},{"location":"kuadrant-operator/doc/reference/kuadrant/#kuadrantstatus","title":"KuadrantStatus","text":"Field Type Description <code>observedGeneration</code> String Number of the last observed generation of the resource. Use it to check if the status info is up to date with latest resource spec. <code>conditions</code> []ConditionSpec List of conditions that define that status of the resource. <code>mtlsLimitador</code> Boolean Limitador mTLS enabled. <code>mtlsAuthorino</code> Boolean Authorino mTLS enabled."},{"location":"kuadrant-operator/doc/reference/ratelimitpolicy/","title":"The RateLimitPolicy Custom Resource Definition (CRD)","text":""},{"location":"kuadrant-operator/doc/reference/ratelimitpolicy/#ratelimitpolicy","title":"RateLimitPolicy","text":"Field Type Required Description <code>spec</code> RateLimitPolicySpec Yes The specification for RateLimitPolicy custom resource <code>status</code> RateLimitPolicyStatus No The status for the custom resource"},{"location":"kuadrant-operator/doc/reference/ratelimitpolicy/#ratelimitpolicyspec","title":"RateLimitPolicySpec","text":"Field Type Required Description <code>targetRef</code> LocalPolicyTargetReferenceWithSectionName Yes Reference to a Kubernetes resource that the policy attaches to. For more info <code>defaults</code> RateLimitPolicyCommonSpec No Default limit definitions. This field is mutually exclusive with the <code>limits</code> field <code>overrides</code> RateLimitPolicyCommonSpec No Overrides limit definitions. This field is mutually exclusive with the <code>limits</code> field and <code>defaults</code> field. This field is only allowed for policies targeting <code>Gateway</code> in <code>targetRef.kind</code> <code>limits</code> MapLimit&gt; No Limit definitions. This field is mutually exclusive with the <code>defaults</code> field"},{"location":"kuadrant-operator/doc/reference/ratelimitpolicy/#localpolicytargetreferencewithsectionname","title":"LocalPolicyTargetReferenceWithSectionName","text":"Field Type Required Description <code>LocalPolicyTargetReference</code> LocalPolicyTargetReference Yes Reference to a local policy target. <code>sectionName</code> SectionName No Section name for further specificity (if needed)."},{"location":"kuadrant-operator/doc/reference/ratelimitpolicy/#localpolicytargetreference","title":"LocalPolicyTargetReference","text":"Field Type Required Description <code>group</code> <code>Group</code> Yes Group of the target resource. <code>kind</code> <code>Kind</code> Yes Kind of the target resource. <code>name</code> <code>ObjectName</code> Yes Name of the target resource."},{"location":"kuadrant-operator/doc/reference/ratelimitpolicy/#sectionname","title":"SectionName","text":"Field Type Required Description SectionName v1.SectionName (String) Yes SectionName is the name of a section in a Kubernetes resource. In the following resources, SectionName is interpreted as the following:  Gateway: Listener name HTTPRoute: HTTPRouteRule name* Service: Port name ### RateLimitPolicyCommonSpec Field Type Required Description <code>when</code> []Predicate No List of dynamic predicates to activate the policy. All expression must evaluate to true for the policy to be applied <code>limits</code> MapLimit&gt; No Explicit Limit definitions. This field is mutually exclusive with RateLimitPolicySpec <code>limits</code> field"},{"location":"kuadrant-operator/doc/reference/ratelimitpolicy/#predicate","title":"Predicate","text":"Field Type Required Description <code>predicate</code> String Yes Defines one CEL expression that must be evaluated to bool"},{"location":"kuadrant-operator/doc/reference/ratelimitpolicy/#counter","title":"Counter","text":"Field Type Required Description <code>expression</code> String Yes Defines one CEL expression that will be used as rate limiting counter"},{"location":"kuadrant-operator/doc/reference/ratelimitpolicy/#limit","title":"Limit","text":"Field Type Required Description <code>rates</code> []RateLimit No List of rate limits associated with the limit definition <code>counters</code> []Counter No List of rate limit counter qualifiers. Items must be a valid Well-known attribute. Each distinct value resolved in the data plane starts a separate counter for each rate limit. <code>when</code> []Predicate No List of dynamic predicates to activate the limit. All expression must evaluate to true for the limit to be applied"},{"location":"kuadrant-operator/doc/reference/ratelimitpolicy/#ratelimit","title":"RateLimit","text":"Field Type Required Description <code>limit</code> Number Yes Maximum value allowed within the given period of time (duration) <code>window</code> String Yes The period of time that the limit applies. Follows Gateway API Duration format"},{"location":"kuadrant-operator/doc/reference/ratelimitpolicy/#ratelimitpolicystatus","title":"RateLimitPolicyStatus","text":"Field Type Description <code>observedGeneration</code> String Number of the last observed generation of the resource. Use it to check if the status info is up to date with latest resource spec. <code>conditions</code> []ConditionSpec List of conditions that define that status of the resource."},{"location":"kuadrant-operator/doc/reference/ratelimitpolicy/#conditionspec","title":"ConditionSpec","text":"<ul> <li>The lastTransitionTime field provides a timestamp for when the entity last transitioned from one status to another.</li> <li>The message field is a human-readable message indicating details about the transition.</li> <li>The reason field is a unique, one-word, CamelCase reason for the condition\u2019s last transition.</li> <li>The status field is a string, with possible values True, False, and Unknown.</li> <li>The type field is a string with the following possible values:<ul> <li>Available: the resource has successfully configured;</li> </ul> </li> </ul> Field Type Description <code>type</code> String Condition Type <code>status</code> String Status: True, False, Unknown <code>reason</code> String Condition state reason <code>message</code> String Condition state description <code>lastTransitionTime</code> Timestamp Last transition timestamp"},{"location":"kuadrant-operator/doc/reference/ratelimitpolicy/#high-level-example","title":"High-level example","text":"<pre><code>apiVersion: kuadrant.io/v1\nkind: RateLimitPolicy\nmetadata:\n  name: my-rate-limit-policy\nspec:\n  # Reference to an existing networking resource to attach the policy to. REQUIRED.\n  # It can be a Gateway API HTTPRoute or Gateway resource.\n  # It can only refer to objects in the same namespace as the RateLimitPolicy.\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute / Gateway\n    name: myroute / mygateway\n\n  # The limits definitions to apply to the network traffic routed through the targeted resource.\n  # Equivalent to if otherwise declared within `defaults`.\n  limits:\n    \"my_limit\":\n      # The rate limits associated with this limit definition. REQUIRED.\n      # E.g., to specify a 50rps rate limit, add `{ limit: 50, duration: 1, unit: secod }`\n      rates: [\u2026]\n\n      # Counter qualifiers.\n      # Each dynamic value in the data plane starts a separate counter, combined with each rate limit.\n      # E.g., to define a separate rate limit for each user name detected by the auth layer, add `metadata.filter_metadata.envoy\\.filters\\.http\\.ext_authz.username`.\n      # Check out Kuadrant RFC 0002 (https://github.com/Kuadrant/architecture/blob/main/rfcs/0002-well-known-attributes.md) to learn more about the Well-known Attributes that can be used in this field.\n      counters: [\u2026]\n\n      # Additional dynamic conditions to trigger the limit.\n      # Use it for filtering attributes not supported by HTTPRouteRule or with RateLimitPolicies that target a Gateway.\n      # Check out Kuadrant RFC 0002 (https://github.com/Kuadrant/architecture/blob/main/rfcs/0002-well-known-attributes.md) to learn more about the Well-known Attributes that can be used in this field.\n      when: [\u2026]\n\n    # Explicit defaults. Used in policies that target a Gateway object to express default rules to be enforced on\n    # routes that lack a more specific policy attached to.\n    # Mutually exclusive with `overrides` and with declaring `limits` at the top-level of the spec.\n    defaults:\n      limits: { \u2026 }\n\n    # Overrides. Used in policies that target a Gateway object to be enforced on all routes linked to the gateway,\n    # thus also overriding any more specific policy occasionally attached to any of those routes.\n    # Mutually exclusive with `defaults` and with declaring `limits` at the top-level of the spec.\n    overrides:\n      limits: { \u2026 }\n</code></pre>"},{"location":"kuadrant-operator/doc/reference/telemetrypolicy/","title":"The TelemetryPolicy Custom Resource Definition (CRD)","text":""},{"location":"kuadrant-operator/doc/reference/telemetrypolicy/#telemetrypolicy","title":"TelemetryPolicy","text":"Field Type Required Description <code>spec</code> TelemetryPolicySpec Yes The specification for TelemetryPolicy custom resource <code>status</code> TelemetryPolicyStatus No The status for the custom resource"},{"location":"kuadrant-operator/doc/reference/telemetrypolicy/#telemetrypolicyspec","title":"TelemetryPolicySpec","text":"Field Type Required Description <code>targetRef</code> LocalPolicyTargetReferenceWithSectionName Yes Reference to a Kubernetes resource that the policy attaches to. For more info <code>metrics</code> MetricsSpec Yes Metrics holds the telemetry metrics configuration"},{"location":"kuadrant-operator/doc/reference/telemetrypolicy/#localpolicytargetreferencewithsectionname","title":"LocalPolicyTargetReferenceWithSectionName","text":"Field Type Required Description <code>LocalPolicyTargetReference</code> LocalPolicyTargetReference Yes Reference to a local policy target. <code>sectionName</code> SectionName No Section name for further specificity (if needed)."},{"location":"kuadrant-operator/doc/reference/telemetrypolicy/#localpolicytargetreference","title":"LocalPolicyTargetReference","text":"Field Type Required Description <code>group</code> <code>Group</code> Yes Group of the target resource. <code>kind</code> <code>Kind</code> Yes Kind of the target resource. <code>name</code> <code>ObjectName</code> Yes Name of the target resource."},{"location":"kuadrant-operator/doc/reference/telemetrypolicy/#sectionname","title":"SectionName","text":"Field Type Required Description SectionName v1.SectionName (String) Yes SectionName is the name of a section in a Kubernetes resource. In the following resources, SectionName is interpreted as the following:  Gateway: Listener name HTTPRoute: HTTPRouteRule name* Service: Port name"},{"location":"kuadrant-operator/doc/reference/telemetrypolicy/#metricsspec","title":"MetricsSpec","text":"Field Type Required Description <code>default</code> MetricsConfig Yes Default metrics configuration that applies to all requests"},{"location":"kuadrant-operator/doc/reference/telemetrypolicy/#metricsconfig","title":"MetricsConfig","text":"Field Type Required Description <code>labels</code> Map Yes Labels to add to metrics, where keys are label names and values are CEL expressions"},{"location":"kuadrant-operator/doc/reference/telemetrypolicy/#telemetrypolicystatus","title":"TelemetryPolicyStatus","text":"Field Type Description <code>observedGeneration</code> String Number of the last observed generation of the resource. Use it to check if the status info is up to date with latest resource spec. <code>conditions</code> []ConditionSpec List of conditions that define that status of the resource."},{"location":"kuadrant-operator/doc/reference/telemetrypolicy/#see-also","title":"See Also","text":"<ul> <li>TelemetryPolicy Overview</li> <li>Token Rate Limiting Tutorial</li> <li>Well-known Attributes</li> <li>Gateway API Documentation</li> </ul>"},{"location":"kuadrant-operator/doc/reference/tlspolicy/","title":"The TLSPolicy Custom Resource Definition (CRD)","text":""},{"location":"kuadrant-operator/doc/reference/tlspolicy/#tlspolicy","title":"TLSPolicy","text":"Field Type Required Description <code>spec</code> TLSPolicySpec Yes The specification for TLSPolicy custom resource <code>status</code> TLSPolicyStatus No The status for the custom resource"},{"location":"kuadrant-operator/doc/reference/tlspolicy/#tlspolicyspec","title":"TLSPolicySpec","text":"Field Type Required Description <code>targetRef</code> Gateway API LocalPolicyTargetReferenceWithSectionName Yes Reference to a Kuberentes resource that the policy attaches to <code>issuerRef</code> CertManager meta/v1.ObjectReference Yes IssuerRef is a reference to the issuer for the created certificate <code>commonName</code> String No CommonName is a common name to be used on the created certificate <code>duration</code> Kubernetes meta/v1.Duration No The requested 'duration' (i.e. lifetime) of the created certificate. <code>renewBefore</code> Kubernetes meta/v1.Duration No How long before the currently issued certificate's expiry cert-manager should renew the certificate. <code>usages</code> []CertManager v1.KeyUsage No Usages is the set of x509 usages that are requested for the certificate. Defaults to <code>digital signature</code> and <code>key encipherment</code> if not specified <code>revisionHistoryLimit</code> Number No RevisionHistoryLimit is the maximum number of CertificateRequest revisions that are maintained in the Certificate's history <code>privateKey</code> CertManager meta/v1.CertificatePrivateKey No Options to control private keys used for the Certificate <p>IssuerRef certmanmetav1.ObjectReference</p>"},{"location":"kuadrant-operator/doc/reference/tlspolicy/#tlspolicystatus","title":"TLSPolicyStatus","text":"Field Type Description <code>observedGeneration</code> String Number of the last observed generation of the resource. Use it to check if the status info is up to date with latest resource spec. <code>conditions</code> []Kubernetes meta/v1.Condition List of conditions that define that status of the resource."},{"location":"kuadrant-operator/doc/reference/tokenratelimitpolicy/","title":"The TokenRateLimitPolicy Custom Resource Definition (CRD)","text":""},{"location":"kuadrant-operator/doc/reference/tokenratelimitpolicy/#tokenratelimitpolicy","title":"TokenRateLimitPolicy","text":"Field Type Required Description <code>spec</code> TokenRateLimitPolicySpec Yes The specification for TokenRateLimitPolicy custom resource <code>status</code> TokenRateLimitPolicyStatus No The status for the custom resource"},{"location":"kuadrant-operator/doc/reference/tokenratelimitpolicy/#tokenratelimitpolicyspec","title":"TokenRateLimitPolicySpec","text":"Field Type Required Description <code>targetRef</code> LocalPolicyTargetReferenceWithSectionName Yes Reference to a Kubernetes resource that the policy attaches to. For more info <code>defaults</code> MergeableTokenRateLimitPolicySpec No Default limit definitions. This field is mutually exclusive with the <code>limits</code> field <code>overrides</code> MergeableTokenRateLimitPolicySpec No Overrides limit definitions. This field is mutually exclusive with the <code>limits</code> field and <code>defaults</code> field. This field is only allowed for policies targeting <code>Gateway</code> in <code>targetRef.kind</code> <code>limits</code> MapTokenLimit&gt; No Limit definitions. This field is mutually exclusive with the <code>defaults</code> field"},{"location":"kuadrant-operator/doc/reference/tokenratelimitpolicy/#localpolicytargetreferencewithsectionname","title":"LocalPolicyTargetReferenceWithSectionName","text":"Field Type Required Description <code>LocalPolicyTargetReference</code> LocalPolicyTargetReference Yes Reference to a local policy target. <code>sectionName</code> SectionName No Section name for further specificity (if needed)."},{"location":"kuadrant-operator/doc/reference/tokenratelimitpolicy/#localpolicytargetreference","title":"LocalPolicyTargetReference","text":"Field Type Required Description <code>group</code> <code>Group</code> Yes Group of the target resource. <code>kind</code> <code>Kind</code> Yes Kind of the target resource. <code>name</code> <code>ObjectName</code> Yes Name of the target resource."},{"location":"kuadrant-operator/doc/reference/tokenratelimitpolicy/#sectionname","title":"SectionName","text":"Field Type Required Description SectionName v1.SectionName (String) Yes SectionName is the name of a section in a Kubernetes resource. In the following resources, SectionName is interpreted as the following:  Gateway: Listener name HTTPRoute: HTTPRouteRule name* Service: Port name"},{"location":"kuadrant-operator/doc/reference/tokenratelimitpolicy/#mergeabletokenratelimitpolicyspec","title":"MergeableTokenRateLimitPolicySpec","text":"Field Type Required Description <code>strategy</code> String No Merge strategy to apply when merging with other policies. Values: <code>atomic</code> (default), <code>merge</code> <code>limits</code> MapTokenLimit&gt; Yes Map of named token-based rate limit configurations"},{"location":"kuadrant-operator/doc/reference/tokenratelimitpolicy/#tokenlimit","title":"TokenLimit","text":"Field Type Required Description <code>rates</code> []Rate No List of rate limit details including limit and window. If not specified, no rate limits are applied for this limit definition <code>when</code> []WhenPredicate No List of predicates for this limit. Used in combination with top-level predicates <code>counters</code> []Counter No CEL expressions that define counter keys for rate limiting. If not specified, rate limiting will be applied globally without user-specific tracking"},{"location":"kuadrant-operator/doc/reference/tokenratelimitpolicy/#rate","title":"Rate","text":"Field Type Required Description <code>limit</code> Number Yes Maximum token count allowed for the given window <code>window</code> Duration Yes Time window for the limit (e.g., \"1h\", \"24h\", \"1m\", \"1d\")"},{"location":"kuadrant-operator/doc/reference/tokenratelimitpolicy/#whenpredicate","title":"WhenPredicate","text":"Field Type Required Description <code>predicate</code> String Yes CEL expression that must evaluate to true for the limit to apply. See Well-known Attributes"},{"location":"kuadrant-operator/doc/reference/tokenratelimitpolicy/#counter","title":"Counter","text":"Field Type Required Description <code>expression</code> String Yes CEL expression that defines the counter key for rate limiting. See Well-known Attributes"},{"location":"kuadrant-operator/doc/reference/tokenratelimitpolicy/#tokenratelimitpolicystatus","title":"TokenRateLimitPolicyStatus","text":"<p>The status object for TokenRateLimitPolicy follows the PolicyStatus pattern from Gateway API.</p> Field Type Description <code>observedGeneration</code> Number Generation of the resource that was last reconciled <code>conditions</code> []Condition Current state of the policy"},{"location":"kuadrant-operator/doc/reference/tokenratelimitpolicy/#condition","title":"Condition","text":"<p>Standard Kubernetes condition fields following Gateway API conventions:</p> Field Type Description <code>type</code> String Type of condition (e.g., \"Accepted\", \"Enforced\") <code>status</code> String Status of the condition (\"True\", \"False\", \"Unknown\") <code>observedGeneration</code> Number Generation observed when this condition was last updated <code>lastTransitionTime</code> Timestamp Last time the condition transitioned from one status to another <code>reason</code> String Machine-readable reason for the condition's last transition <code>message</code> String Human-readable message indicating details about the last transition"},{"location":"kuadrant-operator/doc/reference/tokenratelimitpolicy/#token-usage-tracking","title":"Token Usage Tracking","text":"<p>TokenRateLimitPolicy automatically tracks token consumption from AI/LLM responses by monitoring the <code>usage.total_tokens</code> field in response bodies. This enables accurate usage-based rate limiting where:</p> <ul> <li>Request Phase: The policy evaluates predicates and descriptors during the request</li> <li>Response Phase: The policy extracts actual token usage from the response body</li> <li>Rate Limiting: Limitador receives the actual token count as <code>hits_addend</code> for precise accounting</li> </ul>"},{"location":"kuadrant-operator/doc/reference/tokenratelimitpolicy/#supported-response-format","title":"Supported Response Format","text":"<p>The policy automatically parses token usage from response bodies in the following format: <pre><code>{\n  \"usage\": {\n    \"total_tokens\": 150,\n    \"prompt_tokens\": 100,\n    \"completion_tokens\": 50\n  }\n}\n</code></pre></p> <p>This is compatible with OpenAI-style API responses and similar AI/LLM services.</p> <p>Streaming Support: Both streaming and non-streaming responses are supported:</p> <ul> <li>Non-streaming: Works with <code>stream: false</code> or when <code>stream</code> is omitted</li> <li>Streaming: Requires <code>\"stream\": true</code> and <code>\"stream_options\": { \"include_usage\": true }</code> to extract usage from the final stream event</li> </ul>"},{"location":"kuadrant-operator/doc/reference/tokenratelimitpolicy/#cel-expression-context","title":"CEL Expression Context","text":"<p>TokenRateLimitPolicy provides access to request attributes through CEL expressions. For a comprehensive list of available attributes, see the Well-known Attributes RFC.</p> <p>Common attributes include:</p> Context Available Attributes Example Usage Request <code>request.method</code>, <code>request.url_path</code>, <code>request.headers</code> <code>request.method == \"POST\"</code> Authentication <code>auth.identity.*</code>, <code>request.auth.claims.*</code> <code>auth.identity.userid</code>, <code>request.auth.claims[\"tier\"]</code> Remote Address <code>source.address</code>, <code>source.port</code> <code>source.address</code>"},{"location":"kuadrant-operator/doc/reference/tokenratelimitpolicy/#examples","title":"Examples","text":""},{"location":"kuadrant-operator/doc/reference/tokenratelimitpolicy/#basic-token-rate-limiting","title":"Basic Token Rate Limiting","text":"<pre><code>apiVersion: kuadrant.io/v1alpha1\nkind: TokenRateLimitPolicy\nmetadata:\n  name: basic-token-limit\n  namespace: gateway-system\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: ai-gateway\n  limits:\n    global:\n      rates:\n\n      - limit: 100000\n        window: 1h\n</code></pre>"},{"location":"kuadrant-operator/doc/reference/tokenratelimitpolicy/#user-based-token-limiting","title":"User-Based Token Limiting","text":"<pre><code>apiVersion: kuadrant.io/v1alpha1\nkind: TokenRateLimitPolicy\nmetadata:\n  name: user-token-limits\n  namespace: gateway-system\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: api-gateway\n  limits:\n    free:\n      rates:\n\n      - limit: 50000\n        window: 24h\n      when:\n      - predicate: request.path == \"/v1/chat/completions\"\n      - predicate: 'auth.identity.groups.split(\",\").exists(g, g == \"free\")'\n      counters:\n      - expression: auth.identity.userid\n    gold:\n      rates:\n      - limit: 200000\n        window: 24h\n      when:\n      - predicate: request.path == \"/v1/chat/completions\"\n      - predicate: 'auth.identity.groups.split(\",\").exists(g, g == \"gold\")'\n      counters:\n      - expression: auth.identity.userid\n</code></pre>"},{"location":"kuadrant-operator/doc/reference/tokenratelimitpolicy/#gateway-overrides","title":"Gateway Overrides","text":"<pre><code>apiVersion: kuadrant.io/v1alpha1\nkind: TokenRateLimitPolicy\nmetadata:\n  name: org-wide-limits\n  namespace: gateway-system\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: api-gateway\n  overrides:\n    strategy: atomic\n    limits:\n      org-quota:\n        rates:\n\n        - limit: 1000000\n          window: 24h\n        counters:\n        - expression: auth.identity.org_id\n</code></pre>"},{"location":"kuadrant-operator/doc/reference/tokenratelimitpolicy/#see-also","title":"See Also","text":"<ul> <li>TokenRateLimitPolicy Overview</li> <li>Token Rate Limiting Tutorial</li> <li>RateLimitPolicy Reference</li> <li>AuthPolicy Reference</li> <li>Well-known Attributes</li> <li>Gateway API Documentation</li> </ul>"},{"location":"kuadrant-operator/doc/user-guides/auth/auth-for-app-devs-and-platform-engineers/","title":"Enforcing authentication &amp; authorization with Kuadrant AuthPolicy","text":"<p>This tutorial walks you through the process of setting up a local Kubernetes cluster with Kuadrant where you will protect Gateway API endpoints by declaring Kuadrant AuthPolicy custom resources.</p> <p>Three AuthPolicies will be declared:</p> Use case AuthPolicies App developer 2 AuthPolicies targeting a HTTPRoute that routes traffic to a sample \"Toy Store\" application \u2192 enforce API key authentication to all requests in this route; require API key owners to be mapped to <code>groups:admins</code> metadata to access a specific HTTPRouteRule of the route. Platform engineer use-case 1 AuthPolicy targeting the <code>kuadrant-ingressgateway</code> Gateway \u2192 enforces a trivial \"deny-all\" policy that locks down any other HTTPRoute attached to the Gateway. <p>Topology:</p> <pre><code>                            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                            \u2502        (Gateway)        \u2502   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                            \u2502         external        \u2502\u25c4\u2500\u2500\u2502 (AuthPolicy)  \u2502\n                            \u2502                         \u2502   \u2502    gw-auth    \u2502\n                            \u2502            *            \u2502   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u25b2                      \u25b2\n                     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502   (HTTPRoute)    \u2502   \u2502   (HTTPRoute)    \u2502\n\u2502  (AuthPolicy)  \u2502\u2500\u2500\u25ba\u2502    toystore      \u2502   \u2502      other       \u2502\n\u2502 toystore-authn \u2502   \u2502                  \u2502   \u2502                  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502 api.toystore.com \u2502   \u2502 *.other-apps.com \u2502\n                     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                      \u25b2                \u25b2\n            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n            | (HTTPRouteRule) | | (HTTPRouteRule) |   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n            |     rule-1      | |     rule-2      |\u25c4\u2500\u2500\u2502   (AuthPolicy)  \u2502\n            |                 | |                 |   \u2502 toystore-admins \u2502\n            | - GET /cars*    | | - /admins*      |   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n            | - GET /dolls*   | \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/auth/auth-for-app-devs-and-platform-engineers/#prerequisites","title":"Prerequisites","text":"<ul> <li>Kubernetes cluster with Kuadrant operator installed. See our Getting Started guide for more information.</li> <li>kubectl command line tool.</li> </ul>"},{"location":"kuadrant-operator/doc/user-guides/auth/auth-for-app-devs-and-platform-engineers/#setup-environment-variables","title":"Setup environment variables","text":"<p>Set the following environment variables used for convenience in this tutorial:</p> <pre><code>export KUADRANT_GATEWAY_NS=api-gateway # Namespace for the example Gateway\nexport KUADRANT_GATEWAY_NAME=external # Name for the example Gateway\nexport KUADRANT_DEVELOPER_NS=toystore # Namespace for an example toystore app\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/auth/auth-for-app-devs-and-platform-engineers/#create-an-ingress-gateway","title":"Create an Ingress Gateway","text":"<p>Create the namespace the Gateway will be deployed in:</p> <pre><code>kubectl create ns ${KUADRANT_GATEWAY_NS}\n</code></pre> <p>Create a gateway using toystore as the listener hostname:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1\nkind: Gateway\nmetadata:\n  name: ${KUADRANT_GATEWAY_NAME}\n  namespace: ${KUADRANT_GATEWAY_NS}\n  labels:\n    kuadrant.io/gateway: \"true\"\nspec:\n  gatewayClassName: istio\n  listeners:\n\n    - name: http\n      protocol: HTTP\n      port: 80\n      allowedRoutes:\n        namespaces:\n          from: All\nEOF\n</code></pre> <p>Check the status of the <code>Gateway</code> ensuring the gateway is Accepted and Programmed:</p> <pre><code>kubectl get gateway ${KUADRANT_GATEWAY_NAME} -n ${KUADRANT_GATEWAY_NS} -o=jsonpath='{.status.conditions[?(@.type==\"Accepted\")].message}{\"\\n\"}{.status.conditions[?(@.type==\"Programmed\")].message}{\"\\n\"}'\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/auth/auth-for-app-devs-and-platform-engineers/#deploy-the-toy-store-sample-application-persona-app-developer","title":"Deploy the Toy Store sample application (Persona: App developer)","text":"<p>Create the namespace for the toystore API:</p> <p><pre><code>kubectl create ns ${KUADRANT_DEVELOPER_NS}\n</code></pre> Deploy the Toy store  <pre><code>kubectl apply -f https://raw.githubusercontent.com/Kuadrant/kuadrant-operator/refs/heads/main/examples/toystore/toystore.yaml -n ${KUADRANT_DEVELOPER_NS}\n</code></pre></p> <p>Create the Toy Store HTTPRoute <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: toystore\n  namespace: ${KUADRANT_DEVELOPER_NS}\n  labels:\n     app: toystore\nspec:\n  parentRefs:\n\n  - name: ${KUADRANT_GATEWAY_NAME}\n    namespace: ${KUADRANT_GATEWAY_NS}\n  hostnames:\n  - api.toystore.com\n  rules:\n  - matches: # rule-1\n    - method: GET\n      path:\n        type: PathPrefix\n        value: \"/cars\"\n    - method: GET\n      path:\n        type: PathPrefix\n        value: \"/dolls\"\n    backendRefs:\n    - name: toystore\n      port: 80\n  - matches: # rule-2\n    - path:\n        type: PathPrefix\n        value: \"/admin\"\n    backendRefs:\n    - name: toystore\n      port: 80\nEOF\n</code></pre></p> <p>Export the gateway hostname and port:</p> <pre><code>export KUADRANT_INGRESS_HOST=$(kubectl get gtw ${KUADRANT_GATEWAY_NAME} -n ${KUADRANT_GATEWAY_NS} -o jsonpath='{.status.addresses[0].value}')\nexport KUADRANT_INGRESS_PORT=$(kubectl get gtw ${KUADRANT_GATEWAY_NAME} -n ${KUADRANT_GATEWAY_NS} -o jsonpath='{.spec.listeners[?(@.name==\"http\")].port}')\nexport KUADRANT_GATEWAY_URL=${KUADRANT_INGRESS_HOST}:${KUADRANT_INGRESS_PORT}\n</code></pre> <p>Send requests to the application unprotected:</p> <pre><code>curl -H 'Host: api.toystore.com' http://$KUADRANT_GATEWAY_URL/cars -i\n# HTTP/1.1 200 OK\n</code></pre> <pre><code>curl -H 'Host: api.toystore.com' http://$KUADRANT_GATEWAY_URL/dolls -i\n# HTTP/1.1 200 OK\n</code></pre> <pre><code>curl -H 'Host: api.toystore.com' http://$KUADRANT_GATEWAY_URL/admin -i\n# HTTP/1.1 200 OK\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/auth/auth-for-app-devs-and-platform-engineers/#protect-the-toy-store-application-persona-app-developer","title":"Protect the Toy Store application (Persona: App developer)","text":"<p>Create AuthPolicies to enforce the following auth rules:</p> <ul> <li>Authentication:</li> <li>All users must present a valid API key</li> <li>Authorization:</li> <li><code>/admin*</code> paths (2nd rule of the HTTPRoute) require user mapped to the <code>admins</code> group (<code>kuadrant.io/groups=admins</code> annotation added to the Kubernetes API key Secret)</li> </ul> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1\nkind: AuthPolicy\nmetadata:\n  name: toystore-authn\n  namespace: ${KUADRANT_DEVELOPER_NS}\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: toystore\n  defaults:\n    strategy: merge\n    rules:\n      authentication:\n        \"api-key-authn\":\n          apiKey:\n            allNamespaces: true\n            selector:\n              matchLabels:\n                app: toystore\n          credentials:\n            authorizationHeader:\n              prefix: APIKEY\n---\napiVersion: kuadrant.io/v1\nkind: AuthPolicy\nmetadata:\n  name: toystore-admins\n  namespace: ${KUADRANT_DEVELOPER_NS}\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: toystore\n    sectionName: rule-2\n  rules:\n    authorization:\n      \"only-admins\":\n        opa:\n          rego: |\n            groups := split(object.get(input.auth.identity.metadata.annotations, \"kuadrant.io/groups\", \"\"), \",\")\n            allow { groups[_] == \"admins\" }\nEOF\n</code></pre> <p>Create the API keys (must be created in the same namespace as the Kuadrant CR):</p> <pre><code>kubectl apply -n kuadrant-system -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: api-key-regular-user\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    app: toystore\nstringData:\n  api_key: iamaregularuser\ntype: Opaque\n---\napiVersion: v1\nkind: Secret\nmetadata:\n  name: api-key-admin-user\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    app: toystore\n  annotations:\n    kuadrant.io/groups: admins\nstringData:\n  api_key: iamanadmin\ntype: Opaque\nEOF\n</code></pre> <p>Send requests to the application protected by Kuadrant:</p> <pre><code>curl -H 'Host: api.toystore.com' http://$KUADRANT_GATEWAY_URL/cars -i\n# HTTP/1.1 401 Unauthorized\n# www-authenticate: APIKEY realm=\"api-key-authn\"\n# x-ext-auth-reason: credential not found\n</code></pre> <pre><code>curl -H 'Host: api.toystore.com' -H 'Authorization: APIKEY iamaregularuser' http://$KUADRANT_GATEWAY_URL/cars -i\n# HTTP/1.1 200 OK\n</code></pre> <pre><code>curl -H 'Host: api.toystore.com' -H 'Authorization: APIKEY iamaregularuser' http://$KUADRANT_GATEWAY_URL/admin -i\n# HTTP/1.1 403 Forbidden\n# x-ext-auth-reason: Unauthorized\n</code></pre> <pre><code>curl -H 'Host: api.toystore.com' -H 'Authorization: APIKEY iamanadmin' http://$KUADRANT_GATEWAY_URL/admin -i\n# HTTP/1.1 200 OK\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/auth/auth-for-app-devs-and-platform-engineers/#create-a-default-deny-all-policy-at-the-level-of-the-gateway-persona-platform-engineer","title":"Create a default \"deny-all\" policy at the level of the gateway (Persona: Platform engineer)","text":"<p>Create the policy:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1\nkind: AuthPolicy\nmetadata:\n  name: gw-auth\n  namespace: ${KUADRANT_GATEWAY_NS}\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: ${KUADRANT_GATEWAY_NAME}\n  defaults:\n    strategy: atomic\n    rules:\n      authorization:\n        deny-all:\n          opa:\n            rego: \"allow = false\"\n      response:\n        unauthorized:\n          headers:\n            \"content-type\":\n              value: application/json\n          body:\n            value: |\n              {\n                \"error\": \"Forbidden\",\n                \"message\": \"Access denied by default by the gateway operator. If you are the administrator of the service, create a specific auth policy for the route.\"\n              }\nEOF\n</code></pre> <p>The policy won't be effective until there is at least one accepted route not yet protected by another more specific policy attached to it.</p> <p>Create a route that will inherit the default policy attached to the gateway:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: other\n  namespace: ${KUADRANT_DEVELOPER_NS}\nspec:\n  parentRefs:\n\n  - name: ${KUADRANT_GATEWAY_NAME}\n    namespace: ${KUADRANT_GATEWAY_NS}\n  hostnames:\n  - \"*.other-apps.com\"\nEOF\n</code></pre> <p>Send requests to the route protected by the default policy set at the level of the gateway:</p> <pre><code>curl -H 'Host: foo.other-apps.com' http://$KUADRANT_GATEWAY_URL/ -i\n# HTTP/1.1 403 Forbidden\n# content-type: application/json\n# x-ext-auth-reason: Unauthorized\n# [\u2026]\n#\n# {\n#   \"error\": \"Forbidden\",\n#   \"message\": \"Access denied by default by the gateway operator. If you are the administrator of the service, create a specific auth policy for the route.\"\n# }\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/dns/basic-dns-configuration/","title":"Basic DNS","text":""},{"location":"kuadrant-operator/doc/user-guides/dns/basic-dns-configuration/#basic-dns-setup","title":"Basic DNS setup","text":"<p>The document will cover the most basic DNS setup using the Kuadrant DNSPolicy API. In order to follow this guide, it is expected that you have a cluster setup with the latest version of Kuadrant installed. Also as we are using DNS, it is also important that the Gateways are accessible either via your local network or via the public internet. DNSPolicy will work with any Gateway provider so it is not essential that you have Istio or Envoy Gateway installed, but you do need a Gateway API provider installed. We would recommend using Istio or Envoy Gateway as this will allow you to use some of the other policies provided by Kuadrant.</p>"},{"location":"kuadrant-operator/doc/user-guides/dns/basic-dns-configuration/#gateway-and-httproute-configuration","title":"Gateway and HTTPRoute configuration","text":"<p>With a Gateway provider installed, in order to configure DNS via <code>DNSPolicy</code>, you must first configure a Gateway with a listener that uses a specified hostname. You must also have a HTTPRoute resource attached to this gateway listener. Below are some simple examples of these resources (note we are not using a HTTPS listener for simplicity but that will also work):</p> <p><pre><code>---\nkind: Gateway\napiVersion: gateway.networking.k8s.io/v1\nmetadata:\n  name: external\nspec:\n  gatewayClassName: istio\n  listeners:\n\n    - name: http\n      port: 8080\n      hostname: test.example.com\n      protocol: HTTP\n---\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: toystore\n  labels:\n    app: toystore\nspec:\n  parentRefs:\n    - name: external\n  hostnames: [\"test.example.com\"]\n  rules:\n    - matches:\n        - path:\n            type: PathPrefix\n            value: \"/toy\"\n          method: GET\n        - path:\n            type: Exact\n            value: \"/admin/toy\"\n          method: POST\n        - path:\n            type: Exact\n            value: \"/admin/toy\"\n          method: DELETE\n      backendRefs:\n        - name: toystore\n          port: 80\n</code></pre> With these defined, we are ready to setup DNS via DNSPolicy.</p>"},{"location":"kuadrant-operator/doc/user-guides/dns/basic-dns-configuration/#configure-a-dnsprovider","title":"Configure a DNSProvider","text":"<p>The first step is to configure a DNSProvider. This is a simple kubernetes secret with credentials to access the DNS provider. With Kuadrant we support using <code>AWS Route53, Azure and GCP</code> as DNS providers. It is important that this credential has access to write and read to your DNS zones.</p> <p>More info on the various DNS Providers</p> <p>In this example we will configure an AWS route53 DNS provider:</p> <pre><code>kubectl create secret generic aws-credentials \\\n  --namespace=my-gateway-namespace \\\n  --type=kuadrant.io/aws \\\n  --from-literal=AWS_ACCESS_KEY_ID=XXXX \\\n  --from-literal=AWS_REGION=eu-west-1 \\\n  --from-literal=AWS_SECRET_ACCESS_KEY=XXX\n</code></pre> <p>With this in place we can now define our DNSPolicy resource:</p> <pre><code>apiVersion: kuadrant.io/v1\nkind: DNSPolicy\nmetadata:\n  name: basic-dnspolicy\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: external\n  providerRefs:\n\n    - name: aws-credentials\n</code></pre> <p>This resource also needs to be created in the same namespace as your Gateway and the <code>targetRef</code> needs to reference your gateway. When this is done we can check the status of the DNSPolicy and the Gateway to check when it is ready.</p> <pre><code>kubectl wait dnspolicy/basic-dnspolicy -n my-gateway-namespace --for=\"condition=Ready=true\" --timeout=300s\n</code></pre> <p>If you look at the gateway status you should also see:</p> <pre><code>  - lastTransitionTime: \"2024-10-09T11:22:10Z\"\n    message: Object affected by DNSPolicy kuadrant-system/simple-dnspolicy\n    observedGeneration: 1\n    reason: Accepted\n    status: \"True\"\n    type: kuadrant.io/DNSPolicyAffected\n</code></pre> <p>DNS is now setup for your Gateway. After allowing a little time for the DNS propagate to the nameservers, you should be able to test the DNS using a dig command alternatively you can curl your endpoint.</p> <pre><code>dig test.example.com +short\n\ncurl -v test.example.com/toy\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/dns/basic-dns-configuration/#important-considerations","title":"Important Considerations","text":"<p>With this guide, you have learned how to setup the most basic DNSPolicy. DNSPolicy is also capable of setting up advanced DNS record structure to help balance traffic across multiple gateways. With the most basic policy outlined here, you should not apply it to more than one gateway that shares a listener with the same host name. There is one exception to this rule, which is if all your gateways are using IP addresses rather than hostname addresses; in this case DNSPolicy will merge the IPs into a multi-value response. However, if your Gateways are using hostnames, DNSPolicy will set up a simple CNAME record and as there is only one record and CNAMEs cannot have multiple values by definition, one of the DNSPolicies (the last one to attempt to update the provider) will report an error. </p>"},{"location":"kuadrant-operator/doc/user-guides/dns/core-dns/","title":"CoreDNS Support","text":""},{"location":"kuadrant-operator/doc/user-guides/dns/core-dns/#coredns-with-kuadrant","title":"CoreDNS with Kuadrant","text":"<p>With this guide, you will learn how to setup Kuadrant to use CoreDNS via the Kuadrant <code>DNSPolicy</code> and leverage CoreDNS as the authoritative nameserver(s) for a given domain shared across multiple gateways to provide both a weighted and GEO based DNS response similar to that offered by common cloud providers.</p> <p>The basic architecture for how the CoreDNS integration works is shown in the image below:</p> <p></p>"},{"location":"kuadrant-operator/doc/user-guides/dns/core-dns/#overview","title":"Overview","text":"<p>dns-operator documentation: For detailed CoreDNS configuration including Corefile setup, zone configuration, GeoIP databases, and local development, see the dns-operator CoreDNS documentation.</p> <p>Kuadrant's DNS Operator will create an authoritative DNSRecord for any DNSRecord that reference a CoreDNS provider secret directly or via a \"default\" provider secret. The authoritative record is named and labeled in a deterministic way using the source DNSRecord root host and contains all the endpoints related to that root host which could be coming from multiple DNSRecord sources. The DNS Operator can be configured to read DNSRecords from multiple clusters allowing DNSRecords in the same namespace with the same root host to form a single authoritative merged record set on selected \"primary\" clusters.  Kuadrant's custom CoreDNS plugin, will read and serve the authoritative record.  If there is provider specific meta data for weight and GEO, the kuadrant plugin will apply GEO location filtering (assuming there is an appropriate GEO database configured) and a weighted response to any DNS queries for the dns names in those records.</p> <p>This guide shows the manual steps required to configure the kuadrant CoreDNS integration in a multi cluster setup (Two primary clusters and one secondary).  </p>"},{"location":"kuadrant-operator/doc/user-guides/dns/core-dns/#prerequisites","title":"Prerequisites","text":"<ul> <li>Kubernetes cluster(s) (Three to test all functionality described in this guide)</li> <li>Kuadrant installed on each cluster</li> </ul>"},{"location":"kuadrant-operator/doc/user-guides/dns/core-dns/#local-kind-clusters-optional","title":"Local Kind clusters [Optional]","text":"<p>If you want to see how this works locally and are not using existing clusters, the easiest approach is to use kind to create local clusters.</p> <p>To try this out you can use the local-setup helper from the kuadrant-operator repo: <pre><code>git clone https://github.com/Kuadrant/kuadrant-operator.git\n</code></pre></p> <p>Run the following from the root of the repo: <pre><code>CLUSTER_COUNT=3 ./hack/multicluster.sh local-setup\n</code></pre></p> <p>This will create three local Kind clusters with Kuadrant installed, you can set the context env vars used in the rest of this guide by running the following: <pre><code>export CTX_PRIMARY1=kind-kuadrant-local-1\nexport CTX_PRIMARY2=kind-kuadrant-local-2\nexport CTX_SECONDARY1=kind-kuadrant-local-3\n</code></pre></p>"},{"location":"kuadrant-operator/doc/user-guides/dns/core-dns/#setup-cluster-1-and-2-primary","title":"Setup Cluster 1 and 2 (Primary)","text":"<p>At least one cluster must be configured as a primary. A primary cluster that is intended to be used with the CoreDNS provider should have a CoreDNS instance running with the Kuadrant plugin enabled. A primary cluster should have cluster interconnection secrets added for all other clusters. A primary cluster should have dns provider (coredns) secrets in target namespaces.</p>"},{"location":"kuadrant-operator/doc/user-guides/dns/core-dns/#install-coredns","title":"Install CoreDNS","text":"<p>You can install CoreDNS configured with the kuadrant plugin using the follow kustomize command while kubectl is targeting the desired cluster, this will install CoreDNS into the <code>kuadrant-coredns</code> namespace: <pre><code>kustomize build --enable-helm https://github.com/Kuadrant/dns-operator/config/coredns | kubectl apply --context ${CTX_PRIMARY1} -f -\nkustomize build --enable-helm https://github.com/Kuadrant/dns-operator/config/coredns | kubectl apply --context ${CTX_PRIMARY2} -f -\n\nkubectl wait --timeout=90s --for=condition=Ready=True pods -A -l app.kubernetes.io/name=coredns --context ${CTX_PRIMARY1}\nkubectl wait --timeout=90s --for=condition=Ready=True pods -A -l app.kubernetes.io/name=coredns --context ${CTX_PRIMARY2}\n\nkubectl get deployments -A -l app.kubernetes.io/name=coredns --context ${CTX_PRIMARY1}\nkubectl get deployments -A -l app.kubernetes.io/name=coredns --context ${CTX_PRIMARY2}\n</code></pre></p>"},{"location":"kuadrant-operator/doc/user-guides/dns/core-dns/#openshift-on-aws","title":"OpenShift on AWS","text":"<p>If you are using an OpenShift cluster on AWS you will also need to run the following commands:</p> <pre><code>kubectl patch service kuadrant-coredns --type='json' -p='[{\"op\": \"remove\", \"path\": \"/spec/externalTrafficPolicy\"}]' -n kuadrant-coredns --context ${CTX_PRIMARY1}\nkubectl patch service kuadrant-coredns --type='json' -p='[{\"op\": \"remove\", \"path\": \"/spec/externalTrafficPolicy\"}]' -n kuadrant-coredns --context ${CTX_PRIMARY2}\nkubectl annotate service/kuadrant-coredns service.beta.kubernetes.io/aws-load-balancer-type=nlb -n kuadrant-coredns --context ${CTX_PRIMARY1}\nkubectl annotate service/kuadrant-coredns service.beta.kubernetes.io/aws-load-balancer-type=nlb -n kuadrant-coredns --context ${CTX_PRIMARY2}\n</code></pre> <p>Note: OpenShift on AWS does not currently support exposing a single port on both UDP and TCP, so in this setup only UDP port 53 is exposed via the ELB.</p>"},{"location":"kuadrant-operator/doc/user-guides/dns/core-dns/#verify","title":"Verify","text":"<p>Check that the CoreDNS instances are available and responding to queries: <pre><code>NS1=`kubectl get service/kuadrant-coredns -n kuadrant-coredns -o yaml --context ${CTX_PRIMARY1} | yq '.status.loadBalancer.ingress[0].ip'`\nNS2=`kubectl get service/kuadrant-coredns -n kuadrant-coredns -o yaml --context ${CTX_PRIMARY2} | yq '.status.loadBalancer.ingress[0].ip'`\necho $NS1\necho $NS2\ndig @${NS1} k.example.com SOA\n</code></pre></p> <p>Expected output (before DNSRecords are created): <pre><code>;; ANSWER SECTION:\nk.example.com. 60 IN SOA ns1.k.example.com. hostmaster.k.example.com. 12345 7200 1800 86400 60\n</code></pre></p> <p>The zone is configured but contains no records yet. This is normal.</p> <p>You can also view all zone records using zone transfer: <pre><code>dig @${NS1} -t AXFR k.example.com\ndig @${NS2} -t AXFR k.example.com\n</code></pre></p>"},{"location":"kuadrant-operator/doc/user-guides/dns/core-dns/#zone-configuration","title":"Zone Configuration","text":"<p>A default zone (k.example.com) is created for testing purposes. This can be replaced, or additional zones added, as desired by modifying the \"Corefile\" on each primary cluster.</p> <pre><code>kubectl get configmap/kuadrant-coredns -n kuadrant-coredns -o yaml --context ${CTX_PRIMARY1} | yq .data\nkubectl get configmap/kuadrant-coredns -n kuadrant-coredns -o yaml --context ${CTX_PRIMARY2} | yq .data\n</code></pre> <p>The sample CoreDNS configuration is generated from this file: CoreDNS Configuration. That domain name can be changed or duplicated to add other domains as required.</p> <p>For detailed zone configuration options, NS records, and multi-cluster setup, see the dns-operator CoreDNS documentation.</p> <p>For more information on configuring CoreDNS please refer to their documentation.</p>"},{"location":"kuadrant-operator/doc/user-guides/dns/core-dns/#using-a-geo-ip-database","title":"Using a GEO IP database","text":"<p>The CoreDNS instances will need to be configured to use a GEO IP database, in the example above this is called: <code>GeoLite2-City-demo.mmdb</code>. This is a mock database we provide for illustrative purposes. Change this to refer to your maxmind database file, for more information see here.</p> <p>For testing geographic routing with the demo database, see the subnet-to-location mapping table and testing instructions in the dns-operator CoreDNS documentation.</p> <p>For more information on configuring the CoreDNS geoip plugin please refer to their documentation.</p>"},{"location":"kuadrant-operator/doc/user-guides/dns/core-dns/#corefile-configuration","title":"Corefile Configuration","text":"<p>The CoreDNS configuration (Corefile) defines which plugins execute for each zone. For plugin configuration details, execution order, and complete examples, see the dns-operator CoreDNS documentation.</p>"},{"location":"kuadrant-operator/doc/user-guides/dns/core-dns/#advanced-customizing-soa-rname-optional","title":"Advanced: Customizing SOA RNAME (Optional)","text":"<p>To customize the SOA RNAME email address in DNS records, see the dns-operator CoreDNS documentation.</p>"},{"location":"kuadrant-operator/doc/user-guides/dns/core-dns/#delegate-the-zones-public-cluster-only","title":"Delegate the zones (public cluster only)","text":"<p>This cannot be done when testing locally, but assuming the CoreDNS instance is running on a publicly accessible IP which permits traffic on port 53, then the zone(s) in use will need to be delegated to these nameservers. For testing and evaluation we would recommend creating a fresh zone.</p> <p>This is done by creating an NS record in the zone hosted by the authoritative nameserver.</p> <p>For example, if there is a domain example.com with authoritative nameservers in Route53, and 2 CoreDNS instances are configured with the zone k.example.com (on IPs 1.2.3.4 and 2.3.4.5). Then in the example.com zone in Route53 the following records need to be created: <pre><code>coredns1.example.com. IN A 60 1.2.3.4\ncoredns2.example.com. IN A 60 2.3.4.5\nk.example.com. IN NS 300 coredns1.example.com.\nk.example.com. IN NS 300 coredns2.example.com.\n</code></pre></p> <p>If the CoreDNS instances are not publicly accessible, then we will be able to verify them using the <code>@</code> modifier on a dig command.</p>"},{"location":"kuadrant-operator/doc/user-guides/dns/core-dns/#dns-operator-configuration","title":"DNS Operator Configuration","text":"<p>Clusters being configured as \"primary\" should have the delegation role of the running dns operator set to \"primary\". This is currently the default so nothing needs to be done here.</p>"},{"location":"kuadrant-operator/doc/user-guides/dns/core-dns/#add-cluster-interconnection-secrets","title":"Add Cluster Interconnection Secrets","text":"<p>For each primary cluster to read DNSRecord resources from all other clusters (primary or secondary), a cluster interconnection secret containing kubeconfig data for each of the other clusters must be added.</p> <p>The <code>kubectl kuadrant-dns</code> CLI provides a command to help create a valid cluster secret from the expected service account on the target cluster. There is no alternative method for creating these secrets - the CLI tool must be used to ensure proper formatting and permissions.</p> <p>Refer to the dns-operator documentation for instructions on installing the CLI.</p> <p>Assuming the <code>kubectl kuadrant-dns</code> CLI is installed (or the <code>kubectl-kuadrant_dns</code> binary is in the system path), run the following to connect all clusters to each primary:</p> <pre><code># Set current context to primary 1\nkubectl config use-context ${CTX_PRIMARY1}\nkubectl kuadrant-dns add-cluster-secret --context ${CTX_PRIMARY2} --namespace kuadrant-system\nkubectl kuadrant-dns add-cluster-secret --context ${CTX_SECONDARY1} --namespace kuadrant-system\n# Set current context to primary 2\nkubectl config use-context ${CTX_PRIMARY2}\nkubectl kuadrant-dns add-cluster-secret --context ${CTX_PRIMARY1} --namespace kuadrant-system\nkubectl kuadrant-dns add-cluster-secret --context ${CTX_SECONDARY1} --namespace kuadrant-system\n</code></pre> <p>If you are using Kind clusters (created with <code>./hack/multicluster.sh</code>), the above produces invalid kubeconfig data. As a temporary workaround you can run the following from the root of the kuadrant-operator repository: <pre><code># Run from kuadrant-operator repository root\n./hack/multicluster.sh create-cluster-secret ${CTX_PRIMARY1} ${CTX_PRIMARY2}\n./hack/multicluster.sh create-cluster-secret ${CTX_PRIMARY1} ${CTX_SECONDARY1}\n./hack/multicluster.sh create-cluster-secret ${CTX_PRIMARY2} ${CTX_PRIMARY1}\n./hack/multicluster.sh create-cluster-secret ${CTX_PRIMARY2} ${CTX_SECONDARY1}\n</code></pre></p>"},{"location":"kuadrant-operator/doc/user-guides/dns/core-dns/#verify_1","title":"Verify","text":"<p>Check that the cluster interconnection secrets exist on the primary clusters: <pre><code>kubectl get secret -A -l kuadrant.io/multicluster-kubeconfig=true --context ${CTX_PRIMARY1}\nkubectl get secret -A -l kuadrant.io/multicluster-kubeconfig=true --context ${CTX_PRIMARY2}\nkubectl get secret -A -l kuadrant.io/multicluster-kubeconfig=true --context ${CTX_SECONDARY1}\n</code></pre></p> <p>Check that the cluster interconnection secret content is valid kubeconfig data: <pre><code>kubectl get secret kind-kuadrant-local-2 -n kuadrant-system --context ${CTX_PRIMARY1} -o jsonpath='{.data.kubeconfig}' | base64 -d\n</code></pre></p>"},{"location":"kuadrant-operator/doc/user-guides/dns/core-dns/#create-test-namespace-dnstest","title":"Create test namespace (dnstest)","text":"<pre><code>kubectl create ns dnstest --context ${CTX_PRIMARY1}\nkubectl create ns dnstest --context ${CTX_PRIMARY2}\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/dns/core-dns/#add-coredns-provider-secrets","title":"Add coredns provider secrets","text":"<p>The CoreDNS provider secret should be created with the desired zones configured. In this case we create it for the test zone (k.example.com): <pre><code>kubectl create secret generic dns-provider-coredns --namespace=dnstest --type=kuadrant.io/coredns --from-literal=ZONES=\"k.example.com\" --context ${CTX_PRIMARY1}\nkubectl create secret generic dns-provider-coredns --namespace=dnstest --type=kuadrant.io/coredns --from-literal=ZONES=\"k.example.com\" --context ${CTX_PRIMARY2}\n</code></pre></p> <p>Set the CoreDNS provider as the default allowing it to be selected when none is specified by the DNSPolicy: <pre><code>kubectl label secret/dns-provider-coredns -n dnstest kuadrant.io/default-provider=true --context ${CTX_PRIMARY1}\nkubectl label secret/dns-provider-coredns -n dnstest kuadrant.io/default-provider=true --context ${CTX_PRIMARY2}\n</code></pre></p>"},{"location":"kuadrant-operator/doc/user-guides/dns/core-dns/#setup-cluster-3-secondary","title":"Setup Cluster 3 (Secondary)","text":"<p>Secondary clusters are optional. A secondary does not have CoreDNS installed. A secondary cluster does not have cluster interconnection secrets added. A secondary cluster does not have provider credentials.</p>"},{"location":"kuadrant-operator/doc/user-guides/dns/core-dns/#dns-operator-configuration_1","title":"DNS Operator Configuration","text":"<p>Clusters being configured as \"secondary\" should have the delegation role of the running dns operator set to \"secondary\".</p> <p>This can be done by updating the dns operators configuration configmap(dns-operator-controller-env) in the kuadrant-system namespace and restarting the service: <pre><code>kubectl patch configmap dns-operator-controller-env -n kuadrant-system --type merge -p '{\"data\":{\"DELEGATION_ROLE\":\"secondary\"}}' --context ${CTX_SECONDARY1}\nkubectl scale deployment/dns-operator-controller-manager -n kuadrant-system --replicas=0 --context ${CTX_SECONDARY1}\nkubectl scale deployment/dns-operator-controller-manager -n kuadrant-system --replicas=1 --context ${CTX_SECONDARY1}\nkubectl rollout status deployment/dns-operator-controller-manager -n kuadrant-system --timeout=300s --context ${CTX_SECONDARY1}\nkubectl logs deployment/dns-operator-controller-manager -n kuadrant-system --context ${CTX_SECONDARY1} | grep \"delegationRole\"\n</code></pre></p>"},{"location":"kuadrant-operator/doc/user-guides/dns/core-dns/#create-test-namespace-dnstest_1","title":"Create test namespace (dnstest)","text":"<pre><code>kubectl create ns dnstest --context ${CTX_SECONDARY1}\n</code></pre> <p>Cluster Setup complete, ready to deploy application!!</p>"},{"location":"kuadrant-operator/doc/user-guides/dns/core-dns/#deploy-toystore-application","title":"Deploy Toystore application","text":"<p>Deploy the toystore application on all clusters: <pre><code>kubectl apply -f https://raw.githubusercontent.com/Kuadrant/Kuadrant-operator/main/examples/toystore/toystore.yaml -n dnstest --context ${CTX_PRIMARY1}\nkubectl apply -f https://raw.githubusercontent.com/Kuadrant/Kuadrant-operator/main/examples/toystore/toystore.yaml -n dnstest --context ${CTX_PRIMARY2}\nkubectl apply -f https://raw.githubusercontent.com/Kuadrant/Kuadrant-operator/main/examples/toystore/toystore.yaml -n dnstest --context ${CTX_SECONDARY1}\n\nkubectl -n dnstest wait --for=condition=Available deployments toystore --timeout=60s --context ${CTX_PRIMARY1}\nkubectl -n dnstest wait --for=condition=Available deployments toystore --timeout=60s --context ${CTX_PRIMARY2}\nkubectl -n dnstest wait --for=condition=Available deployments toystore --timeout=60s --context ${CTX_SECONDARY1}\n</code></pre></p>"},{"location":"kuadrant-operator/doc/user-guides/dns/core-dns/#create-an-ingress-gateway","title":"Create an Ingress Gateway","text":"<p>Create a gateway using the coredns zone name as part of a listener hostname on all clusters:</p> <pre><code>gateway=$(cat &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1\nkind: Gateway\nmetadata:\n  name: external\n  namespace: dnstest\n  labels:\n    kuadrant.io/gateway: \"true\"\nspec:\n  gatewayClassName: istio\n  listeners:\n\n    - name: http\n      protocol: HTTP\n      port: 80\n      allowedRoutes:\n        namespaces:\n          from: All\n      hostname: \"api.toystore.k.example.com\" \nEOF)\n\necho \"${gateway}\" | kubectl apply --context ${CTX_PRIMARY1} -f -\necho \"${gateway}\" | kubectl apply --context ${CTX_PRIMARY2} -f -\necho \"${gateway}\" | kubectl apply --context ${CTX_SECONDARY1} -f -\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/dns/core-dns/#setup-toystore-application-httproute","title":"Setup Toystore application HTTPRoute","text":"<pre><code>httproute=$(cat &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: toystore\n  namespace: dnstest\n  labels:\n    deployment: toystore\n    service: toystore\nspec:\n  parentRefs:\n\n  - name: external\n    namespace: dnstest\n  hostnames:\n  - \"api.toystore.k.example.com\"\n  rules:\n  - matches:\n    - method: GET\n      path:\n        type: PathPrefix\n        value: \"/cars\"\n    backendRefs:\n    - name: toystore\n      port: 80  \nEOF\n)\n\necho \"${httproute}\" | kubectl apply --context ${CTX_PRIMARY1} -f -\necho \"${httproute}\" | kubectl apply --context ${CTX_PRIMARY2} -f -\necho \"${httproute}\" | kubectl apply --context ${CTX_SECONDARY1} -f -\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/dns/core-dns/#verify_2","title":"Verify","text":"<pre><code>kubectl get gateway,httproute,service,deployment,all --context ${CTX_PRIMARY1} -n dnstest\nkubectl get gateway,httproute,service,deployment,all --context ${CTX_PRIMARY2} -n dnstest\nkubectl get gateway,httproute,service,deployment,all --context ${CTX_SECONDARY1} -n dnstest\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/dns/core-dns/#enable-dns-on-the-gateway","title":"Enable DNS on the gateway","text":"<p>Create a Kuadrant <code>DNSPolicy</code> to configure DNS on all clusters:</p> <pre><code>dnspolicyeu=$(cat &lt;&lt;EOF\napiVersion: kuadrant.io/v1\nkind: DNSPolicy\nmetadata:\n  name: external-dns\n  namespace: dnstest\nspec:\n  targetRef:\n    name: external\n    group: gateway.networking.k8s.io\n    kind: Gateway\n  loadBalancing:\n    weight: 100\n    geo: GEO-EU\n    defaultGeo: true\n  delegate: true\nEOF\n)\ndnspolicyus=$(cat &lt;&lt;EOF\napiVersion: kuadrant.io/v1\nkind: DNSPolicy\nmetadata:\n  name: external-dns\n  namespace: dnstest\nspec:\n  targetRef:\n    name: external\n    group: gateway.networking.k8s.io\n    kind: Gateway\n  loadBalancing:\n    weight: 125\n    geo: GEO-NA\n    defaultGeo: false\n  delegate: true\nEOF\n)\n\necho \"${dnspolicyeu}\" | kubectl apply --context ${CTX_PRIMARY1} -f -\necho \"${dnspolicyus}\" | kubectl apply --context ${CTX_PRIMARY2} -f -\necho \"${dnspolicyeu}\" | kubectl apply --context ${CTX_SECONDARY1} -f -\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/dns/core-dns/#verify_3","title":"Verify","text":"<p>First, retrieve the CoreDNS nameserver addresses: <pre><code>NS1=`kubectl get service/kuadrant-coredns -n kuadrant-coredns -o yaml --context ${CTX_PRIMARY1} | yq '.status.loadBalancer.ingress[0].ip'`\nNS2=`kubectl get service/kuadrant-coredns -n kuadrant-coredns -o yaml --context ${CTX_PRIMARY2} | yq '.status.loadBalancer.ingress[0].ip'`\necho \"CoreDNS Nameservers:\"\necho \"NS1 (Cluster 1): ${NS1}\"\necho \"NS2 (Cluster 2): ${NS2}\"\n</code></pre></p> <p>Check the DNSRecord resources on each cluster: <pre><code>kubectl get dnsrecord -n dnstest -o wide --context ${CTX_PRIMARY1}\nkubectl get dnsrecord -n dnstest -o wide --context ${CTX_PRIMARY2}\nkubectl get dnsrecord -n dnstest -o wide --context ${CTX_SECONDARY1}\n</code></pre></p> <p>Check the authoritative DNSRecord resources on each primary:</p> <p>Note: The authoritative DNSRecord name is deterministically generated from the root host domain using the pattern <code>authoritative-record-&lt;hash&gt;</code>, where the hash is computed from the domain name. For this guide using the domain <code>k.example.com</code>, the authoritative record will be named <code>authoritative-record-oii1lttl</code>. You can list all DNSRecords to verify the name in your environment.</p> <pre><code># List all DNSRecords to see both source and authoritative records\nkubectl get dnsrecord -n dnstest --context ${CTX_PRIMARY1}\nkubectl get dnsrecord -n dnstest --context ${CTX_PRIMARY2}\n\n# Inspect the authoritative record for k.example.com\nkubectl get dnsrecord/authoritative-record-oii1lttl -n dnstest -o json --context ${CTX_PRIMARY1} | jq -r '.spec.endpoints[] | \"dnsName: \\(.dnsName), recordType: \\(.recordType), targets: \\(.targets)\"'\nkubectl get dnsrecord/authoritative-record-oii1lttl -n dnstest -o json --context ${CTX_PRIMARY2} | jq -r '.spec.endpoints[] | \"dnsName: \\(.dnsName), recordType: \\(.recordType), targets: \\(.targets)\"'\n</code></pre> <p>Check the k.example.com zone on each CoreDNS instance contains the expected records: <pre><code>dig @${NS1} -t AXFR k.example.com\ndig @${NS2} -t AXFR k.example.com\n</code></pre></p> <p>Check the CoreDNS instances respond as expected: <pre><code>dig @${NS1} api.toystore.k.example.com +short\ndig @${NS2} api.toystore.k.example.com +short\n</code></pre></p> <p>Delete DNSPolicy from all clusters: <pre><code>kubectl delete dnspolicy external-dns -n dnstest --context ${CTX_PRIMARY1}\nkubectl delete dnspolicy external-dns -n dnstest --context ${CTX_PRIMARY2}\nkubectl delete dnspolicy external-dns -n dnstest --context ${CTX_SECONDARY1}\n</code></pre></p>"},{"location":"kuadrant-operator/doc/user-guides/dns/core-dns/#cleanup","title":"Cleanup","text":"<p>Exercise caution when running cleanup commands. If you had delegation configured on these clusters before following this guide, the cleanup steps below will disrupt your existing delegation setup. Review each command carefully and skip any that would affect pre-existing resources you want to preserve.</p> <p>To remove all resources created in this guide:</p> <pre><code># Delete DNS policies\nkubectl delete dnspolicy external-dns -n dnstest --context ${CTX_PRIMARY1}\nkubectl delete dnspolicy external-dns -n dnstest --context ${CTX_PRIMARY2}\nkubectl delete dnspolicy external-dns -n dnstest --context ${CTX_SECONDARY1}\n\n# Delete gateway\nkubectl delete gateway external -n dnstest --context ${CTX_PRIMARY1}\nkubectl delete gateway external -n dnstest --context ${CTX_PRIMARY2}\nkubectl delete gateway external -n dnstest --context ${CTX_SECONDARY1}\n\n# Delete httproute\nkubectl delete httproute toystore -n dnstest --context ${CTX_PRIMARY1}\nkubectl delete httproute toystore -n dnstest --context ${CTX_PRIMARY2}\nkubectl delete httproute toystore -n dnstest --context ${CTX_SECONDARY1}\n\n# Delete toystore deployment\nkubectl delete -f https://raw.githubusercontent.com/Kuadrant/kuadrant-operator/main/examples/toystore/toystore.yaml -n dnstest --context ${CTX_PRIMARY1}\nkubectl delete -f https://raw.githubusercontent.com/Kuadrant/kuadrant-operator/main/examples/toystore/toystore.yaml -n dnstest --context ${CTX_PRIMARY2}\nkubectl delete -f https://raw.githubusercontent.com/Kuadrant/kuadrant-operator/main/examples/toystore/toystore.yaml -n dnstest --context ${CTX_SECONDARY1}\n\n# Delete provider secrets\nkubectl delete secret dns-provider-coredns -n dnstest --context ${CTX_PRIMARY1}\nkubectl delete secret dns-provider-coredns -n dnstest --context ${CTX_PRIMARY2}\n\n# Delete test namespace\nkubectl delete ns dnstest --context ${CTX_PRIMARY1}\nkubectl delete ns dnstest --context ${CTX_PRIMARY2}\nkubectl delete ns dnstest --context ${CTX_SECONDARY1}\n\n# Delete cluster interconnection secrets (primary clusters only)\nkubectl delete secret -A -l kuadrant.io/multicluster-kubeconfig=true --context ${CTX_PRIMARY1}\nkubectl delete secret -A -l kuadrant.io/multicluster-kubeconfig=true --context ${CTX_PRIMARY2}\n\n# Delete CoreDNS instances (primary clusters only)\nkubectl delete ns kuadrant-coredns --context ${CTX_PRIMARY1}\nkubectl delete ns kuadrant-coredns --context ${CTX_PRIMARY2}\n\n# Reset DNS Operator to primary mode on secondary cluster (if needed)\nkubectl patch configmap dns-operator-controller-env -n kuadrant-system --type merge -p '{\"data\":{\"DELEGATION_ROLE\":\"primary\"}}' --context ${CTX_SECONDARY1}\nkubectl scale deployment/dns-operator-controller-manager -n kuadrant-system --replicas=0 --context ${CTX_SECONDARY1}\nkubectl scale deployment/dns-operator-controller-manager -n kuadrant-system --replicas=1 --context ${CTX_SECONDARY1}\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/dns/dnshealthchecks/","title":"DNS Health Checks","text":"<p>The DNS health check feature allows you to define a HTTP based health check via the DNSPolicy API that will be executed against targeted gateway listener(s) that have specified none wildcard hostnames. These health checks will flag a published endpoint as healthy or unhealthy based on the defined configuration. When unhealthy an endpoint will not be published if it has not already been published to the DNS provider, will only be unpublished if it is part of a multi-value A record and in all cases can be observable via the DNSPolicy status.</p>"},{"location":"kuadrant-operator/doc/user-guides/dns/dnshealthchecks/#limitations","title":"Limitations","text":"<ul> <li>We do not currently support a health check being targeted to a <code>HTTPRoute</code> resource: DNSPolicy can only target Gateways. </li> <li>As mentioned above, when a record has been published using the load balancing options (GEO and Weighting) via DNSPolicy, a failing health check will not remove the endpoint record from the provider, this is to avoid an accidental NX-Domain response. If the policy is not using the load balancing options and results in a multiple value A record, then unhealthy IPs will be removed from this A record unless it would result in an empty value set. </li> <li>Health checks will not be added to listeners that define a wildcard hostname E.G (*.example.com) as we currently cannot know which host to use to for the health check.</li> </ul>"},{"location":"kuadrant-operator/doc/user-guides/dns/dnshealthchecks/#configuration-of-health-checks","title":"Configuration of Health Checks","text":"<p>To configure a DNS health check, you need to specify the <code>health check</code> section of the DNSPolicy.</p> <p>Below are some examples of DNSPolicy with health checks defined:</p> <p>1) DNSPolicy with a health check that will be applied to all listeners on a gateway that define a none wildcard hostname</p> <pre><code>apiVersion: kuadrant.io/v1\nkind: DNSPolicy\nmetadata:\n  name: gateway-dns\nspec:\n  healthCheck:\n    failureThreshold: 3\n    interval: 5m\n    path: /health\n  ...\n   targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: external  \n</code></pre> <p>2) DNSPolicy with health check  that will be applied for a specific listener with a none wildcard hostname</p> <pre><code>apiVersion: kuadrant.io/v1\nkind: DNSPolicy\nmetadata:\n  name: my-listener-dns\nspec:\n  healthCheck:\n    failureThreshold: 3\n    interval: 5m\n    path: /ok #different path for this listener\n  ...\n   targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: external  \n    sectionName: my-listener #notice the addition of section name here that must match the listener name\n</code></pre> <p>These policies can be combined on a single gateway. The policy with the section name defined will override the gateway policy including the health check.</p>"},{"location":"kuadrant-operator/doc/user-guides/dns/dnshealthchecks/#sending-additional-headers-with-the-health-check-request","title":"Sending additional headers with the health check request","text":"<p>Sometimes, it may be desirable to send some additional headers with the health check request. For example to send API key or service account token that can be defined in the request headers.</p> <p>To do this you will need to create a secret in the same namespace as the DNSPolicy with the keys and values you wish to send:</p> <pre><code>kubectl create secret generic healthheaders --from-literal=token=supersecret -n my-dns-policy-namespace\n</code></pre> <p>Next you will need to update the DNSPolicy to add a reference to this secret:</p> <pre><code>apiVersion: kuadrant.io/v1\nkind: DNSPolicy\nmetadata:\n  name: my-listener-dns\nspec:\n  healthCheck:\n    additionalHeadersRef: #add the following\n      name: healthheaders\n    failureThreshold: 3\n    interval: 5m\n    path: /ok\n  ...\n   targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: external  \n    sectionName: my-listener\n</code></pre> <p>The health check requests will now send the key value pairs in the secret as headers when performing a health check request.</p>"},{"location":"kuadrant-operator/doc/user-guides/dns/dnshealthchecks/#health-check-status","title":"Health Check Status","text":"<p>When all health checks based on a DNSPolicy are passing you will see the following status:</p> <pre><code>    - lastTransitionTime: \"2024-11-14T12:33:13Z\"\n      message: All sub-resources are healthy\n      reason: SubResourcesHealthy\n      status: \"True\"\n      type: SubResourcesHealthy\n</code></pre> <p>If one or more of the health checks are failing you will see a status in the DNSPolicy simiar to the one shown below:</p> <pre><code>   - lastTransitionTime: \"2024-11-15T10:40:15Z\"\n      message: 'DNSPolicy has encountered some issues: not all sub-resources of policy\n        are passing the policy defined health check. Not healthy DNSRecords are: external-t1b '\n      reason: Unknown\n      status: \"False\"\n      type: SubResourcesHealthy\n    observedGeneration: 1\n    recordConditions:\n      t1b.cb.hcpapps.net:\n      - lastTransitionTime: \"2024-11-15T10:40:14Z\"\n        message: 'Not healthy addresses: [aeeba26642f1b47d9816297143e2d260-434484576.eu-west-1.elb.amazonaws.com]'\n        observedGeneration: 1\n        reason: health checksFailed\n        status: \"False\"\n        type: Healthy\n</code></pre> <p>Finally, you can also take a look at the underlying individual health check status by inspecting the <code>dnshealthcheckprobe</code> resource:</p> <p>Note: These resources are for view only interactions as they are controlled by the Kuadrant Operator based on the DNSPolicy API</p> <pre><code>kubectl get dnshealthcheckprobes n my-dns-policy-namespace -o=wide\n</code></pre> <p>If you look at the status of one of these you can see additional information:</p> <pre><code>status:\n  consecutiveFailures: 3\n  healthy: false\n  observedGeneration: 1\n  reason: 'Status code: 503'\n  status: 503\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/dns/dnshealthchecks/#manually-removing-unhealthy-records","title":"Manually removing unhealthy records","text":"<p>If you have a failing health check for one of your gateway listeners and you would like to remove it from the DNS provider, you can do this by deleting the associated DNSRecord resource.</p> <p>Finding the correct record</p> <p>DNSRecord resources are kept in the same namespace as the DNSPolicy that configured and created them.</p> <pre><code>kubectl get dnsrecords.kuadrant.io -n &lt;dns-policy-namespace&gt;\n</code></pre> <p>As shown above, when a health check is failing, the DNSPolicy will show a status for that listener host to surface that failure:</p> <pre><code>recordConditions:\n    t1a.cb.hcpapps.net:\n\n    - lastTransitionTime: \"2024-11-27T14:00:52Z\"\n      message: 'Not healthy addresses: [ae4d131ee5d7b4fb098f4afabf4aba4c-513237325.us-east-1.elb.amazonaws.com]'\n      observedGeneration: 1\n      reason: HealthChecksFailed\n      status: \"False\"\n      type: Healthy\n</code></pre> <p>The DNSRecord resource is named after the gateway and the listener name. So if you have a gateway called <code>ingress</code> and a listener called <code>example</code> you will have a <code>DNSRecord</code> resource named <code>ingress-example</code> in the same namespace as your DNSPolicy. So from this status you can get the hostname and find the associated listener on your gateway. You can then delete the associated DNSRecord resource. </p> <pre><code>kubectl delete dnsrecord.kuadrant.io &lt;gateway-name&gt;-&lt;listener-name&gt; -n &lt;dns policy namespace&gt;\n</code></pre> <p>Removing this resource will remove all of the associated DNS records in the DNS provider and while the health check is failing, the dns operator will not re-publish these records. </p>"},{"location":"kuadrant-operator/doc/user-guides/dns/gateway-dns/","title":"Gateway DNS configuration for routes attached to a ingress gateway","text":"<p>This tutorial walks you through an example of how to configure DNS for all routes attached to an ingress gateway. </p>"},{"location":"kuadrant-operator/doc/user-guides/dns/gateway-dns/#prerequisites","title":"Prerequisites","text":"<ul> <li>Kubernetes cluster with Kuadrant operator installed. See our Getting Started guide for more information.</li> <li>kubectl command line tool.</li> <li>AWS/Azure or GCP with DNS capabilities.</li> </ul>"},{"location":"kuadrant-operator/doc/user-guides/dns/gateway-dns/#setup-environment-variables","title":"Setup environment variables","text":"<p>Set the following environment variables used for convenience in this tutorial:</p> <pre><code>export KUADRANT_GATEWAY_NS=api-gateway # Namespace for the example Gateway\nexport KUADRANT_GATEWAY_NAME=external # Name for the example Gateway\nexport KUADRANT_DEVELOPER_NS=toystore # Namespace for an example toystore app\nexport KUADRANT_AWS_ACCESS_KEY_ID=xxxx # AWS Key ID with access to manage the DNS Zone ID below\nexport KUADRANT_AWS_SECRET_ACCESS_KEY=xxxx # AWS Secret Access Key with access to manage the DNS Zone ID below\nexport KUADRANT_AWS_DNS_PUBLIC_ZONE_ID=xxxx # AWS Route 53 Zone ID for the Gateway\nexport KUADRANT_ZONE_ROOT_DOMAIN=example.com # Root domain associated with the Zone ID above\n</code></pre> <p>Create the namespace the Gateway will be deployed in:</p> <pre><code>kubectl create ns ${KUADRANT_GATEWAY_NS}\n\n\n### Create a DNS provider secret \nCreate AWS provider secret. You should limit the permissions of this credential to only the zones you want us to access.\n\n```bash\nkubectl -n ${KUADRANT_GATEWAY_NS} create secret generic aws-credentials \\\n  --type=kuadrant.io/aws \\\n  --from-literal=AWS_ACCESS_KEY_ID=$KUADRANT_AWS_ACCESS_KEY_ID \\\n  --from-literal=AWS_SECRET_ACCESS_KEY=$KUADRANT_AWS_SECRET_ACCESS_KEY\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/dns/gateway-dns/#create-an-ingress-gateway","title":"Create an Ingress Gateway","text":"<p>Create a gateway using your KUADRANT_ZONE_ROOT_DOMAIN as part of a listener hostname:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1\nkind: Gateway\nmetadata:\n  name: ${KUADRANT_GATEWAY_NAME}\n  namespace: ${KUADRANT_GATEWAY_NS}\n  labels:\n    kuadrant.io/gateway: \"true\"\nspec:\n  gatewayClassName: istio\n  listeners:\n\n    - name: http\n      protocol: HTTP\n      port: 80\n      allowedRoutes:\n        namespaces:\n          from: All\n      hostname: \"api.${KUADRANT_ZONE_ROOT_DOMAIN}\"    \nEOF\n</code></pre> <p>Check the status of the <code>Gateway</code> ensuring the gateway is Accepted and Programmed:</p> <pre><code>kubectl get gateway ${KUADRANT_GATEWAY_NAME} -n ${KUADRANT_GATEWAY_NS} -o=jsonpath='{.status.conditions[?(@.type==\"Accepted\")].message}{\"\\n\"}{.status.conditions[?(@.type==\"Programmed\")].message}{\"\\n\"}'\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/dns/gateway-dns/#enable-dns-on-the-gateway","title":"Enable DNS on the gateway","text":"<p>Create a Kuadrant <code>DNSPolicy</code> to configure DNS:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1\nkind: DNSPolicy\nmetadata:\n  name: ${KUADRANT_GATEWAY_NAME}-dns\n  namespace: ${KUADRANT_GATEWAY_NS}\nspec:\n  targetRef:\n    name: ${KUADRANT_GATEWAY_NAME}\n    group: gateway.networking.k8s.io\n    kind: Gateway\n  providerRefs:  \n\n    - name: aws-credentials\nEOF\n</code></pre> <p>Check that the <code>DNSPolicy</code> has been Accepted and Enforced (This mat take a few minutes):</p> <pre><code>kubectl get dnspolicy ${KUADRANT_GATEWAY_NAME}-dns -n ${KUADRANT_GATEWAY_NS} -o=jsonpath='{.status.conditions[?(@.type==\"Accepted\")].message}{\"\\n\"}{.status.conditions[?(@.type==\"Enforced\")].message}'\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/dns/gateway-dns/#deploy-the-toystore-app","title":"Deploy the Toystore app","text":"<p>Create the namespace for the Toystore application:</p> <pre><code>kubectl create ns ${KUADRANT_DEVELOPER_NS}\n</code></pre> <p>Deploy the Toystore app to the developer namespace:</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/Kuadrant/Kuadrant-operator/main/examples/toystore/toystore.yaml -n ${KUADRANT_DEVELOPER_NS}\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/dns/gateway-dns/#setup-toystore-application-httproute","title":"Setup Toystore application HTTPRoute","text":"<pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: toystore\n  namespace: ${KUADRANT_DEVELOPER_NS}\n  labels:\n    deployment: toystore\n    service: toystore\nspec:\n  parentRefs:\n\n  - name: ${KUADRANT_GATEWAY_NAME}\n    namespace: ${KUADRANT_GATEWAY_NS}\n  hostnames:\n  - \"api.${KUADRANT_ZONE_ROOT_DOMAIN}\"\n  rules:\n  - matches:\n    - method: GET\n      path:\n        type: PathPrefix\n        value: \"/cars\"\n    backendRefs:\n    - name: toystore\n      port: 80  \nEOF\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/dns/gateway-dns/#verify-dns-works-by-sending-requests","title":"Verify DNS works by sending requests","text":"<p>Verify DNS using dig you should see your IP address:</p> <pre><code>dig api.${KUADRANT_ZONE_ROOT_DOMAIN} +short\n</code></pre> <p>Verify DNS using curl you should get a status 200:</p> <pre><code>curl http://api.$KUADRANT_ZONE_ROOT_DOMAIN/cars -i\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/dns/load-balanced-dns/","title":"Load Balanced DNS","text":""},{"location":"kuadrant-operator/doc/user-guides/dns/load-balanced-dns/#overview","title":"Overview","text":"<p>This document will show you how to setup a load balanced DNS configuration using the DNSPolicy API. When we say \"load balanced\", this means we configure the DNS provider (AWS, GCP etc) to return different gateway/loadbalancer addresses to queries from DNS clients based on specific weighting and geo location configuration.</p>"},{"location":"kuadrant-operator/doc/user-guides/dns/load-balanced-dns/#when-should-i-use-a-load-balanced-dns-policy","title":"When should I use a load balanced DNS policy?","text":"<p>It is most useful to use the load balancing options when targeting multiple gateways that share a listener host E.G (api.example.com). It is also perfectly valid to use it when you only have a single gateway; this provides the benefit of allowing you to easily expand beyond this single gateway for a given shared hostname. It is worth knowing that the load balanced DNSpolicy comes with a relatively small additional cost of some added records and lookups during DNS resolution vs a \"simple\" DNSPolicy with no load balancing specified as the latter only sets up a simple A or CNAME record. So in summary if you expect to need multiple gateways for a given listener host then you should take advantage of the load balanced option.</p>"},{"location":"kuadrant-operator/doc/user-guides/dns/load-balanced-dns/#important-considerations","title":"Important Considerations","text":"<ul> <li>When using a DNSPolicy with a load balanced configuration, all DNSPolicies effecting a listener with the same hostname should have load balanced options set. Without the load balanced configuration, Kuadrant's dns controller will try to set up only a simple A or CNAME record.</li> <li>When setting geographic configuration, only ever set one unique GEO as the default GEO across all instances of DNSPolicy targeting a listener with the same hostname. If you set different defaults for a single listener hostname, the dns controllers will constantly attempt to bring the default into the state they each feel is correct. </li> <li>If you want different load balancing options for a particular listener in a gateway, you can target that listener directly with DNSPolicy via the targetRef sectionName property.</li> <li>If you do not use the load balanced configuration, a simple single A or CNAME record is set up. Later if you need to move to load balanced, you will need to delete and recreate your policy.</li> </ul>"},{"location":"kuadrant-operator/doc/user-guides/dns/load-balanced-dns/#dns-provider-setup","title":"DNS Provider Setup","text":"<p>A DNSPolicy acts against a target Gateway or a target listener within a gateway by processing the hostnames on the targeted listeners. Using these it can create dns records using the address exposed in the Gateway's status block. In order for Kuadrant's DNS component to do this, it must be able to access and know which DNS provider to use. This is done through the creation of a dns provider secret containing the needed credentials and the provider identifier and either adding the secret in <code>spec.providerRef</code> array or labeling the secret with <code>kuadrant.io/default-provider=true</code> label.</p> <p>Learn more about how to setup a DNS Provider</p>"},{"location":"kuadrant-operator/doc/user-guides/dns/load-balanced-dns/#loadbalanced-dnspolicy-creation-and-attachment","title":"LoadBalanced DNSPolicy creation and attachment","text":"<p>Once an appropriate provider credential is configured, we can now create and attach a DNSPolicy to start managing DNS for the listeners on our Gateway. Below is an example.</p> <pre><code>apiVersion: kuadrant.io/v1\nkind: DNSPolicy\nmetadata:\n  name: prod-web\n  namespace: ingress-gateway\nspec:\n  targetRef:\n    name: prod-web\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    sectionName: listenerName \n  providerRef:\n    name: my-aws-credentials \n  loadBalancing:\n    weight: 120 \n    geo: GEO-EU \n    defaultGeo: true\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/dns/load-balanced-dns/#load-balancing-section","title":"Load Balancing section","text":"<p>This section must be filled out and indicates to the dns component that the targets of this policy should be setup to handle more than one gateway. It is required to define values for the weighted and geo options. These values are used for the records created by the policy controller based on the target gateway. To read more detail about each of the fields in the loadbalanced section take a look at DNS Overview</p>"},{"location":"kuadrant-operator/doc/user-guides/dns/load-balanced-dns/#locations-supported-per-dns-provider","title":"Locations supported per DNS provider","text":"Supported AWS GCP Continents Country codes States Regions"},{"location":"kuadrant-operator/doc/user-guides/dns/load-balanced-dns/#continents-and-country-codes-supported-by-aws-route-53","title":"Continents and country codes supported by AWS Route 53","text":"<p>:Note:  For more information please the official AWS documentation </p> <p>To see all regions supported by AWS Route 53, please see the official documentation. With Route 53 when setting a continent code use a \"GEO-\" prefix otherwise it will be considered a country code. </p>"},{"location":"kuadrant-operator/doc/user-guides/dns/load-balanced-dns/#regions-supported-by-gcp-cloud-dns","title":"Regions supported by GCP Cloud DNS","text":"<p>To see all regions supported by GCP Cloud DNS, please see the official documentation</p>"},{"location":"kuadrant-operator/doc/user-guides/dns/load-balanced-dns/#regions-and-countries-supported-by-azure-cloud-dns","title":"Regions and Countries supported by Azure Cloud DNS","text":"<p>To see the different values you can use for the geo based DNS with Azure take a look at the following documentation</p>"},{"location":"kuadrant-operator/doc/user-guides/dns/load-balanced-dns/#moving-from-non-load-balanced-to-load-balanced-or-vice-versa","title":"Moving from non load balanced to load balanced or vice versa","text":"<p>It is possible to update a DNSPolicy that has no load balancing options set to one that has these options set and vice versa. Underneath, the DNS Operator will remove the existing records and replace them with the correct set of records based on your configuration. It is important however that when using DNSPolicy across multiple Gateways that share a hostname, the DNSPolicies targeting a listener with a shared hostname all use a load balancing configuration (or absence thereof). It is invalid to have two DNSPolcies targeting a listener with a shared hostname that use different dns <code>strategies</code>. Doing so will cause one of the DNSPolicies to fail to be enforced and report an error caused by an inability to bring the DNS records into a consistent state.</p> <p>Example:</p> <p>If you have <code>gateway1</code> with listener <code>example</code> with a hostname of <code>example.com</code> and you have a separate gateway <code>gateway2</code> with the same listener definition as <code>gateway1</code> (perhaps on a different cluster in a different region), you should ensure that the DNSPolcies targeting these listeners are both using a <code>loadbalanced</code> configuration. Below is an example of valid and invalid configuration. </p> <p>Valid Config</p> <p>Given a gateway deployed on two different cluster in two different locations:</p> <pre><code># example gateway\nkind: Gateway\napiVersion: gateway.networking.k8s.io/v1\nmetadata:\n  name: api-gateway\nspec:\n  gatewayClassName: istio\n  listeners:\n\n    - name: example\n      port: 80\n      hostname: 'api.example.com'\n      protocol: HTTP\n</code></pre> <pre><code># gateway 1\n\napiVersion: kuadrant.io/v1\nkind: DNSPolicy\nmetadata:\n  name: dnspolicy-gateway1\nspec:\n  loadBalancing:\n    weight: 130\n    geo: GEO-EU\n    defaultGeo: true\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: api-gateway\n    sectionName: example\n  providerRefs:\n\n    - name: aws-provider-credentials\n\n# gateway 2\n\napiVersion: kuadrant.io/v1\nkind: DNSPolicy\nmetadata:\n  name: dnspolicy-gateway2\nspec:\n  loadBalancing:\n    weight: 130\n    geo: US\n    defaultGeo: false\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: api-gateway\n    sectionName: example\n  providerRefs:\n\n    - name: aws-provider-credentials\n</code></pre> <p>Invalid Config</p> <pre><code># gateway 1\n\napiVersion: kuadrant.io/v1\nkind: DNSPolicy\nmetadata:\n  name: dnspolicy-gateway1\nspec:\n  loadBalancing:\n    weight: 130\n    geo: GEO-EU\n    defaultGeo: true\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: api-gateway\n    sectionName: example\n  providerRefs:\n\n    - name: aws-provider-credentials\n\n# gateway 2\n\napiVersion: kuadrant.io/v1\nkind: DNSPolicy\nmetadata:\n  name: dnspolicy-gateway2\nspec: #notice no loadbalancing defined\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: api-gateway\n    sectionName: example\n  providerRefs:\n\n    - name: aws-provider-credentials\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/dns/understanding_dns_delegation/","title":"Understanding DNS Policy Delegation","text":"<p>Delegation in context of DNS policy is to pass the reconciliation responsibility to a primary cluster. This is a multi cluster feature, with two clusters types, referred to as primary cluster and secondary cluster.</p> <p>A primary cluster is a cluster that will reconcile delegated dns policies into an authoritative dns record. An authoritative dns record is a dns record that the dns-operator manages, and consists of all the delegated dns records for a root host. The kuadrant-operator translates dns policies into dns records that the dns-operator can understand. As a user of the kuadrant-operator there is no need to interact with the dns records, they are mentioned here for understanding of the workflow.</p> <p>The primary cluster requires a default provider secret, which is labelled with <code>kujadrant.io/default-provider=true</code>. The dns-operator can have the <code>--delegation-role=primary</code> adding to the <code>args</code>, or <code>data.DELEGATION_ROLE: primary</code> to the <code>dns-operator-controller-env</code> configmap. This is not strictly necessary as the default delegation role is primary. Multi cluster communication is done via a secret with the label <code>kuadrant.io/multicluster-kubeconfig=true</code>. These secrets are created within the same namespace as the dns-operator deployment. The secret contains a kubeconfig that allow access to a cluster within the multi cluster setup, and there will be one secret pre secondary cluster. The <code>kubectl_kuadrant-dns</code> plugin provides a command to help with the secret generation. See the CLI documentation, and <code>kubectl_kuadrant-dns add-cluster-secret --help</code> for more information. If there are multiply primary clusters, each cluster must have the same cluster connection secrets, and a cluster connection secrets to the other primary cluster. The primary cluster B will generate an identical authoritative dns record to primary cluster A.</p> <p>A secondary cluster is a cluster that will not reconcile delegated dns policies. The underlining dns-operator pass the reconciliation of the dns records to the primary cluster. Kuatrant-operator will maintain the dns policy as normal. As the secondary cluster does not interact with the dns provider, there is no need for a provider secret. To configure a secondary cluster the dns-opeator deployment requires <code>--delegation-role=secondary</code> added to <code>args</code>. This can be configured within the <code>dns-operator-controller-env</code> configmap with <code>data.DELEGATION_ROLE: secondary</code>. An important note is a cluster in secondary mode can still reconcile dns policies that do not have the delegation field set to true. When a dns polices on a secondary cluster is configured without delegation, the dns-operator works the same as a single cluster install where kuadrant-operator generates the dns record from the dns policy.</p> <p>The delegation of a dns policy is achieved by setting <code>delegate=true</code> in the dns policy spec. Due to limitations of multi cluster communication, the <code>delegate</code> field is immutable, Changing this field requires the removal of the dns policy from the cluster, and recreation with the newer values. The <code>delegate=true</code>, and <code>providerRef</code> are mutually exclusive, and can not be set together. A delegated dns policy works in the same manner on a primary cluster as a secondary. This allows multiply primary clusters to operate on the dns policies, but also allow the resigning of clusters roles at a later stage without having to recreate the dns policy on the cluster.</p>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect/","title":"Secure, protect, and connect APIs with Kuadrant","text":""},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect/#overview","title":"Overview","text":"<p>This tutorial walks you through using Kuadrant to secure, protect, and connect an API exposed by a Gateway (Kubernetes Gateway API) from the personas platform engineer and application developer. For more information on the different personas please see the Gateway API documentation </p>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect/#prerequisites","title":"Prerequisites","text":"<ul> <li>Kubernetes cluster with Kuadrant operator installed. See our Getting Started guide for more information.</li> <li>kubectl command line tool.</li> <li>AWS/Azure or GCP with DNS capabilities.</li> </ul>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect/#set-the-environment-variables","title":"Set the environment variables","text":"<p>Set the following environment variables used for convenience in this tutorial:</p> <pre><code>export KUADRANT_GATEWAY_NS=api-gateway # Namespace for the example Gateway\nexport KUADRANT_GATEWAY_NAME=external # Name for the example Gateway\nexport KUADRANT_DEVELOPER_NS=toystore # Namespace for an example toystore app\nexport KUADRANT_AWS_ACCESS_KEY_ID=xxxx # AWS Key ID with access to manage the DNS Zone ID below\nexport KUADRANT_AWS_SECRET_ACCESS_KEY=xxxx # AWS Secret Access Key with access to manage the DNS Zone ID below\nexport KUADRANT_AWS_DNS_PUBLIC_ZONE_ID=xxxx # AWS Route 53 Zone ID for the Gateway\nexport KUADRANT_ZONE_ROOT_DOMAIN=example.com # Root domain associated with the Zone ID above\nexport KUADRANT_CLUSTER_ISSUER_NAME=self-signed # Name for the ClusterIssuer\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect/#set-up-a-dns-provider","title":"Set up a DNS Provider","text":"<p>The DNS provider declares credentials to access the zone(s) that Kuadrant can use to set up DNS configuration. Ensure that this credential only has access to the zones you want Kuadrant to manage via <code>DNSPolicy</code></p> <p>Create the namespace the Gateway will be deployed in:</p> <pre><code>kubectl create ns ${KUADRANT_GATEWAY_NS}\n</code></pre> <p>Create the secret credentials in the same namespace as the Gateway - these will be used to configure DNS:</p> <pre><code>kubectl -n ${KUADRANT_GATEWAY_NS} create secret generic aws-credentials \\\n  --type=kuadrant.io/aws \\\n  --from-literal=AWS_ACCESS_KEY_ID=$KUADRANT_AWS_ACCESS_KEY_ID \\\n  --from-literal=AWS_SECRET_ACCESS_KEY=$KUADRANT_AWS_SECRET_ACCESS_KEY\n</code></pre> <p>Before adding a TLS issuer, create the secret credentials in the cert-manager namespace:</p> <pre><code>kubectl -n cert-manager create secret generic aws-credentials \\\n  --type=kuadrant.io/aws \\\n  --from-literal=AWS_ACCESS_KEY_ID=$KUADRANT_AWS_ACCESS_KEY_ID \\\n  --from-literal=AWS_SECRET_ACCESS_KEY=$KUADRANT_AWS_SECRET_ACCESS_KEY\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect/#deploy-the-toystore-app","title":"Deploy the Toystore app","text":"<p>Create the namespace for the Toystore application:</p> <pre><code>kubectl create ns ${KUADRANT_DEVELOPER_NS}\n</code></pre> <p>Deploy the Toystore app to the developer namespace:</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/Kuadrant/Kuadrant-operator/main/examples/toystore/toystore.yaml -n ${KUADRANT_DEVELOPER_NS}\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect/#add-a-tls-issuer","title":"Add a TLS issuer","text":"<p>To secure communication to the Gateways, define a TLS issuer for TLS certificates.</p> <p>Note</p> <p>This example uses Let's Encrypt, but you can use any issuer supported by <code>cert-manager</code>.</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: cert-manager.io/v1\nkind: ClusterIssuer\nmetadata:\n  name: ${KUADRANT_CLUSTER_ISSUER_NAME}\nspec:\n  selfSigned: {}\nEOF\n</code></pre> <p>Wait for the <code>ClusterIssuer</code> to become ready.</p> <pre><code>kubectl wait clusterissuer/${KUADRANT_CLUSTER_ISSUER_NAME} --for=condition=ready=true\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect/#deploy-a-gateway","title":"Deploy a Gateway","text":"<pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1\nkind: Gateway\nmetadata:\n  name: ${KUADRANT_GATEWAY_NAME}\n  namespace: ${KUADRANT_GATEWAY_NS}\n  labels:\n    kuadrant.io/gateway: \"true\"\nspec:\n    gatewayClassName: istio\n    listeners:\n\n    - allowedRoutes:\n        namespaces:\n          from: All \n      hostname: \"api.${KUADRANT_ZONE_ROOT_DOMAIN}\"\n      name: api\n      port: 443\n      protocol: HTTPS\n      tls:\n        certificateRefs:\n        - group: \"\"\n          kind: Secret\n          name: api-${KUADRANT_GATEWAY_NAME}-tls\n        mode: Terminate\nEOF\n</code></pre> <p>Check the status of the <code>Gateway</code> ensuring the gateway is Accepted and Programmed:</p> <pre><code>kubectl get gateway ${KUADRANT_GATEWAY_NAME} -n ${KUADRANT_GATEWAY_NS} -o=jsonpath='{.status.conditions[?(@.type==\"Accepted\")].message}{\"\\n\"}{.status.conditions[?(@.type==\"Programmed\")].message}'\n</code></pre> <p>Check the status of the listener, you will see that it is not yet programmed or ready to accept traffic due to bad TLS configuration. This will be fixed in the next step with the <code>TLSPolicy</code>:</p> <pre><code>kubectl get gateway ${KUADRANT_GATEWAY_NAME} -n ${KUADRANT_GATEWAY_NS} -o=jsonpath='{.status.listeners[0].conditions[?(@.type==\"Programmed\")].message}'\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect/#secure-and-protect-the-gateway-with-auth-rate-limit-and-dns-policies","title":"Secure and protect the Gateway with Auth, Rate Limit, and DNS policies.","text":""},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect/#deploy-the-gateway-tls-policy","title":"Deploy the gateway TLS policy","text":"<pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1\nkind: TLSPolicy\nmetadata:\n  name: ${KUADRANT_GATEWAY_NAME}-tls\n  namespace: ${KUADRANT_GATEWAY_NS}\nspec:\n  targetRef:\n    name: ${KUADRANT_GATEWAY_NAME}\n    group: gateway.networking.k8s.io\n    kind: Gateway\n  issuerRef:\n    group: cert-manager.io\n    kind: ClusterIssuer\n    name: ${KUADRANT_CLUSTER_ISSUER_NAME}\nEOF\n</code></pre> <p>Check that the <code>TLSpolicy</code> has an Accepted and Enforced status (This may take a few minutes for certain provider e.g Lets Encrypt):</p> <pre><code>kubectl get tlspolicy ${KUADRANT_GATEWAY_NAME}-tls -n ${KUADRANT_GATEWAY_NS} -o=jsonpath='{.status.conditions[?(@.type==\"Accepted\")].message}{\"\\n\"}{.status.conditions[?(@.type==\"Enforced\")].message}'\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect/#setup-toystore-application-httproute","title":"Setup Toystore application HTTPRoute","text":"<pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: toystore\n  namespace: ${KUADRANT_DEVELOPER_NS}\n  labels:\n    deployment: toystore\n    service: toystore\nspec:\n  parentRefs:\n\n  - name: ${KUADRANT_GATEWAY_NAME}\n    namespace: ${KUADRANT_GATEWAY_NS}\n  hostnames:\n  - \"api.${KUADRANT_ZONE_ROOT_DOMAIN}\"\n  rules:\n  - matches:\n    - method: GET\n      path:\n        type: PathPrefix\n        value: \"/cars\"\n    - method: GET\n      path:\n        type: PathPrefix\n        value: \"/health\"    \n    backendRefs:\n    - name: toystore\n      port: 80  \nEOF\n</code></pre> <p>While the <code>Gateway</code> is now deployed, it currently has exposed endpoints. The next steps will be defining an <code>AuthPolicy</code> to set up a default <code>403</code> response for any unprotected endpoints, as well as a <code>RateLimitPolicy</code> to set up a default unrealistic low global limit to further protect any exposed endpoints.</p>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect/#set-the-deny-all-gateway-authpolicy","title":"Set the <code>Deny all</code> Gateway AuthPolicy","text":"<pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1\nkind: AuthPolicy\nmetadata:\n  name: ${KUADRANT_GATEWAY_NAME}-auth\n  namespace: ${KUADRANT_GATEWAY_NS}\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: ${KUADRANT_GATEWAY_NAME}\n  defaults:\n   when:\n\n     - predicate: \"request.path != '/health'\"\n   rules:\n    authorization:\n      deny-all:\n        opa:\n          rego: \"allow = false\"\n    response:\n      unauthorized:\n        headers:\n          \"content-type\":\n            value: application/json\n        body:\n          value: |\n            {\n              \"error\": \"Forbidden\",\n              \"message\": \"Access denied by default by the gateway operator. If you are the administrator of the service, create a specific auth policy for the route.\"\n            }\nEOF\n</code></pre> <p>Check that the <code>AuthPolicy</code> has Accepted and Enforced status:</p> <pre><code>kubectl get authpolicy ${KUADRANT_GATEWAY_NAME}-auth -n ${KUADRANT_GATEWAY_NS} -o=jsonpath='{.status.conditions[?(@.type==\"Accepted\")].message}{\"\\n\"}{.status.conditions[?(@.type==\"Enforced\")].message}'\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect/#deploy-the-low-limit-gateway-ratelimitpolicy","title":"Deploy the <code>low-limit</code> Gateway RateLimitPolicy","text":"<pre><code>kubectl apply -f  - &lt;&lt;EOF\napiVersion: kuadrant.io/v1\nkind: RateLimitPolicy\nmetadata:\n  name: ${KUADRANT_GATEWAY_NAME}-rlp\n  namespace: ${KUADRANT_GATEWAY_NS}\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: ${KUADRANT_GATEWAY_NAME}\n  defaults:\n    limits:\n      \"low-limit\":\n        rates:\n\n        - limit: 1\n          window: 10s\nEOF\n</code></pre> <p>Check that the <code>RateLimitPolicy</code> has Accepted and Enforced status:</p> <pre><code>kubectl get ratelimitpolicy ${KUADRANT_GATEWAY_NAME}-rlp -n ${KUADRANT_GATEWAY_NS} -o=jsonpath='{.status.conditions[?(@.type==\"Accepted\")].message}{\"\\n\"}{.status.conditions[?(@.type==\"Enforced\")].message}'\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect/#create-the-gateway-dnspolicy","title":"Create the Gateway DNSPolicy","text":"<pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1\nkind: DNSPolicy\nmetadata:\n  name: ${KUADRANT_GATEWAY_NAME}-dnspolicy\n  namespace: ${KUADRANT_GATEWAY_NS}\nspec:\n  healthCheck:\n    failureThreshold: 3\n    interval: 1m\n    path: /health\n  loadBalancing:\n    defaultGeo: true\n    geo: GEO-NA\n    weight: 120\n  targetRef:\n    name: ${KUADRANT_GATEWAY_NAME}\n    group: gateway.networking.k8s.io\n    kind: Gateway\n  providerRefs:\n\n  - name: aws-credentials # Secret created earlier\nEOF\n</code></pre> <p>Check that the <code>DNSPolicy</code> has been Accepted and Enforced (This mat take a few minutes):</p> <pre><code>kubectl get dnspolicy ${KUADRANT_GATEWAY_NAME}-dnspolicy -n ${KUADRANT_GATEWAY_NS} -o=jsonpath='{.status.conditions[?(@.type==\"Accepted\")].message}{\"\\n\"}{.status.conditions[?(@.type==\"Enforced\")].message}'\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect/#dns-health-checks","title":"DNS Health checks","text":"<p>DNS Health checks has been enabled on the DNSPolicy. These health checks will flag a published endpoint as healthy or unhealthy based on the defined configuration. When unhealthy an endpoint will not be published if it has not already been published to the DNS provider, will only be unpublished if it is part of a multi-value A record and in all cases can be observable via the DNSPolicy status. For more information see DNS Health checks documentation</p> <p>Check the status of the health checks as follow:</p> <pre><code>kubectl get dnspolicy ${KUADRANT_GATEWAY_NAME}-dnspolicy -n ${KUADRANT_GATEWAY_NS} -o=jsonpath='{.status.conditions[?(@.type==\"SubResourcesHealthy\")].message}'\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect/#test-the-low-limit-and-deny-all-policies","title":"Test the <code>low-limit</code> and <code>deny all</code> policies","text":"<pre><code>while :; do curl -k --write-out '%{http_code}\\n' --silent --output /dev/null  \"https://api.$KUADRANT_ZONE_ROOT_DOMAIN/cars\" | grep -E --color \"\\b(429)\\b|$\"; sleep 1; done\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect/#override-the-gateways-deny-all-authpolicy","title":"Override the Gateway's deny-all AuthPolicy","text":""},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect/#set-up-api-key-auth-flow","title":"Set up API key auth flow","text":"<p>Set up an example API key for the new users:</p> <pre><code>export KUADRANT_SYSTEM_NS=$(kubectl get kuadrant -A -o jsonpath=\"{.items[0].metadata.namespace}\")\n</code></pre> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: bob-key\n  namespace: ${KUADRANT_SYSTEM_NS}\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    app: toystore\n  annotations:\n    secret.kuadrant.io/user-id: bob\nstringData:\n  api_key: IAMBOB\ntype: Opaque\n---\napiVersion: v1\nkind: Secret\nmetadata:\n  name: alice-key\n  namespace: ${KUADRANT_SYSTEM_NS}\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    app: toystore\n  annotations:\n    secret.kuadrant.io/user-id: alice\nstringData:\n  api_key: IAMALICE\ntype: Opaque\nEOF\n</code></pre> <p>Create a new AuthPolicy in a different namespace that overrides the <code>Deny all</code> created earlier:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1\nkind: AuthPolicy\nmetadata:\n  name: toystore-auth\n  namespace: ${KUADRANT_DEVELOPER_NS}\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: toystore\n  defaults:\n   when:\n\n     - predicate: \"request.path != '/health'\"  \n   rules:\n    authentication:\n      \"api-key-users\":\n        apiKey:\n          selector:\n            matchLabels:\n              app: toystore\n        credentials:\n          authorizationHeader:\n            prefix: APIKEY\n    response:\n      success:\n        filters:\n          \"identity\":\n            json:\n              properties:\n                \"userid\":\n                  selector: auth.identity.metadata.annotations.secret\\.kuadrant\\.io/user-id\nEOF\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect/#override-low-limit-ratelimitpolicy-for-specific-users","title":"Override <code>low-limit</code> RateLimitPolicy for specific users","text":"<p>Create a new <code>RateLimitPolicy</code> in a different namespace to override the default <code>RateLimitPolicy</code> created earlier:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1\nkind: RateLimitPolicy\nmetadata:\n  name: toystore-rlp\n  namespace: ${KUADRANT_DEVELOPER_NS}\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: toystore\n  limits:\n    \"general-user\":\n      rates:\n\n      - limit: 5\n        window: 10s\n      counters:\n      - expression: auth.identity.userid\n      when:\n      - predicate: \"auth.identity.userid != 'bob'\"\n    \"bob-limit\":\n      rates:\n      - limit: 2\n        window: 10s\n      when:\n      - predicate: \"auth.identity.userid == 'bob'\"\nEOF\n</code></pre> <p>The <code>RateLimitPolicy</code> should be Accepted and Enforced:</p> <pre><code>kubectl get ratelimitpolicy -n ${KUADRANT_DEVELOPER_NS} toystore-rlp -o=jsonpath='{.status.conditions[?(@.type==\"Accepted\")].message}{\"\\n\"}{.status.conditions[?(@.type==\"Enforced\")].message}'\n</code></pre> <p>Check the status of the <code>HTTPRoute</code>, is now affected by the <code>RateLimitPolicy</code> in the same namespace:</p> <pre><code>kubectl get httproute toystore -n ${KUADRANT_DEVELOPER_NS} -o=jsonpath='{.status.parents[0].conditions[?(@.type==\"kuadrant.io/RateLimitPolicyAffected\")].message}'\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect/#test-the-new-rate-limit-and-auth-policy","title":"Test the new Rate limit and Auth policy","text":""},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect/#send-requests-as-alice","title":"Send requests as Alice:","text":"<p>You should see status <code>200</code> every second for 5 second followed by stats <code>429</code> every second for 5 seconds</p> <pre><code>while :; do curl -k --write-out '%{http_code}\\n' --silent --output /dev/null -H 'Authorization: APIKEY IAMALICE' \"https://api.$KUADRANT_ZONE_ROOT_DOMAIN/cars\" | grep -E --color \"\\b(429)\\b|$\"; sleep 1; done\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect/#send-requests-as-bob","title":"Send requests as Bob:","text":"<p>You should see status <code>200</code> every second for 2 seconds followed by stats <code>429</code> every second for 8 seconds</p> <pre><code>while :; do curl -k --write-out '%{http_code}\\n' --silent --output /dev/null -H 'Authorization: APIKEY IAMBOB' \"https://api.$KUADRANT_ZONE_ROOT_DOMAIN/cars\" | grep -E --color \"\\b(429)\\b|$\"; sleep 1; done\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect/#next-steps","title":"Next Steps","text":"<ul> <li>mTLS Configuration</li> <li>Configure Observability of Gateway and Kuadrant components</li> </ul>"},{"location":"kuadrant-operator/doc/user-guides/observability/limitador-metrics/","title":"Limitador Metrics Monitoring Guide","text":"<p>This guide explains how to monitor Limitador rate limiting metrics using Prometheus, including how to set up a complete development environment, deploy the observability stack, and generate traffic to see metrics in action.</p>"},{"location":"kuadrant-operator/doc/user-guides/observability/limitador-metrics/#metrics-exposed-by-limitador","title":"Metrics Exposed by Limitador","text":"<p>Limitador exposes the following metrics through its <code>/metrics</code> endpoint on port 8080:</p> Metric Name Type Description Labels Usage <code>limitador_up</code> Gauge Health indicator (always 1 when running) None Service health monitoring <code>authorized_calls</code> Counter Successfully processed (non-rate-limited) requests <code>limitador_namespace</code> Track allowed requests <code>authorized_hits</code> Counter Successfully processed (non-rate-limited) hits <code>limitador_namespace</code> Track allowed number of hits <code>limited_calls</code> Counter Rate-limited (rejected) requests <code>limitador_namespace</code>, <code>limit_name</code> Track blocked requests <code>datastore_partitioned</code> Gauge Datastore connectivity (0=connected, 1=partitioned) None Backend health monitoring <code>datastore_latency</code> Histogram Latency to underlying counter datastore None Performance monitoring <p>Notes:</p> <ul> <li><code>limitador_namespace</code>: Format is <code>\"{k8s_namespace}/{route_name}\"</code> (e.g., <code>\"toystore/toystore\"</code>)</li> <li><code>limit_name</code>: Contains the actual limit name from your RateLimitPolicy (e.g., <code>\"alice-limit\"</code>, <code>\"bob-limit\"</code>) </li> <li><code>authorized_hits</code>, <code>authorized_calls</code> and <code>limited_calls</code> only appear after traffic is processed</li> <li>For regular rate limiting, i.e., on a per-request basis, <code>authorized_hits</code> is equal to <code>authorized_calls</code>.</li> </ul>"},{"location":"kuadrant-operator/doc/user-guides/observability/limitador-metrics/#enabling-limit_name-labels","title":"Enabling <code>limit_name</code> Labels","text":"<p>To include <code>limit_name</code> labels in your Limitador metrics, you need to configure the Limitador instance to use exhaustive telemetry. Set the <code>telemetry</code> field to <code>exhaustive</code> in your Limitador CR:</p> <pre><code>kubectl patch limitador limitador -n kuadrant-system --type='merge' -p='{\"spec\":{\"telemetry\":\"exhaustive\"}}'\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/observability/limitador-metrics/#setting-up-the-development-environment","title":"Setting Up the Development Environment","text":""},{"location":"kuadrant-operator/doc/user-guides/observability/limitador-metrics/#step-1-create-a-local-kubernetes-cluster-with-kuadrant","title":"Step 1: Create a Local Kubernetes Cluster with Kuadrant","text":"<p>Set up a local cluster:</p> <pre><code>make local-setup\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/observability/limitador-metrics/#step-2-create-kuadrant-cr-with-observability-enabled","title":"Step 2: Create Kuadrant CR with Observability Enabled","text":"<p>Create a Kuadrant CR with observability features enabled </p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1beta1\nkind: Kuadrant\nmetadata:\n  name: kuadrant\n  namespace: kuadrant-system\nspec:\n  observability:\n    enable: true\nEOF\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/observability/limitador-metrics/#step-3-deploy-the-observability-stack","title":"Step 3: Deploy the Observability Stack","text":"<p>Deploy Prometheus, Grafana, Alertmanager, and related monitoring infrastructure using the commands from the observability README:</p> <pre><code># Deploy Prometheus Operator and monitoring stack\n./bin/kustomize build ./config/observability/ | docker run --rm -i docker.io/ryane/kfilt -i kind=CustomResourceDefinition | kubectl apply --server-side -f -\n./bin/kustomize build ./config/observability/ | docker run --rm -i docker.io/ryane/kfilt -x kind=CustomResourceDefinition | kubectl apply -f -\n\n# Deploy Thanos for long-term storage (optional)\n./bin/kustomize build ./config/thanos | kubectl apply -f -\n\n# Deploy example dashboards and alerts\n./bin/kustomize build ./examples/dashboards | kubectl apply -f -\n./bin/kustomize build ./examples/alerts | kubectl apply -f -\n\n# Configure gateway-specific monitoring (choose based on your setup)\n# For Istio:\n./bin/kustomize build ./config/observability/prometheus/monitors/istio | kubectl apply -f -\n\n# For Envoy Gateway:\n# ./bin/kustomize build ./config/observability/prometheus/monitors/envoy | kubectl apply -f -\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/observability/limitador-metrics/#step-4-verify-limitador-is-deployed","title":"Step 4: Verify Limitador is Deployed","text":"<p>Ensure Limitador is running in your cluster:</p> <pre><code># Check for Limitador pods\nkubectl get pods -n kuadrant-system -l app=limitador\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/observability/limitador-metrics/#accessing-prometheus-and-grafana","title":"Accessing Prometheus and Grafana","text":"<p>To access the monitoring interfaces, use port forwarding as described in the observability README:</p>"},{"location":"kuadrant-operator/doc/user-guides/observability/limitador-metrics/#access-prometheus","title":"Access Prometheus","text":"<pre><code># Port forward to Prometheus\nkubectl -n monitoring port-forward service/prometheus-k8s 9090:9090\n</code></pre> <p>The Prometheus UI is available at http://127.0.0.1:9090.</p>"},{"location":"kuadrant-operator/doc/user-guides/observability/limitador-metrics/#access-grafana","title":"Access Grafana","text":"<pre><code># Port forward to Grafana  \nkubectl -n monitoring port-forward service/grafana 3000:3000\n</code></pre> <p>The Grafana UI is available at http://127.0.0.1:3000/ with default credentials:</p> <ul> <li>Username: <code>admin</code></li> <li>Password: <code>admin</code></li> </ul>"},{"location":"kuadrant-operator/doc/user-guides/observability/limitador-metrics/#verify-prometheus-discovery","title":"Verify Prometheus Discovery","text":"<p>Check that Prometheus has discovered your Limitador targets:</p> <p>Using the Web UI:</p> <ol> <li>Visit http://localhost:9090/targets</li> <li>Look for: \"kuadrant-system/limitador-metrics\" with state \"UP\"</li> </ol> <p>Using the API: <pre><code>curl -s http://localhost:9090/api/v1/targets | jq '.data.activeTargets[] | select(.labels.job | contains(\"limitador\")) | {job: .labels.job, health: .health, scrapeUrl: .scrapeUrl}'\n</code></pre></p> <p>Expected output: <pre><code>{\n  \"job\": \"kuadrant-system/limitador-metrics\",\n  \"health\": \"up\", \n  \"scrapeUrl\": \"http://10.244.0.29:8080/metrics\"\n}\n</code></pre></p>"},{"location":"kuadrant-operator/doc/user-guides/observability/limitador-metrics/#query-basic-metrics","title":"Query Basic Metrics","text":"<p>Test that metrics are being collected:</p> <pre><code># Check limitador health\ncurl -s \"http://localhost:9090/api/v1/query?query=limitador_up\" | jq '.data.result'\n\n# Check datastore connectivity\ncurl -s \"http://localhost:9090/api/v1/query?query=datastore_partitioned\" | jq '.data.result'\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/observability/limitador-metrics/#generating-traffic-to-populate-rate-limiting-metrics","title":"Generating Traffic to Populate Rate Limiting Metrics","text":"<p>The <code>authorized_hits</code>, <code>authorized_calls</code> and <code>limited_calls</code> metrics only appear after processing requests. Follow this section to generate traffic using the authenticated rate limiting user guide.</p>"},{"location":"kuadrant-operator/doc/user-guides/observability/limitador-metrics/#step-1-set-up-environment","title":"Step 1: Set Up Environment","text":"<p>Set environment variables for the toystore example:</p> <pre><code>export KUADRANT_GATEWAY_NS=api-gateway\nexport KUADRANT_GATEWAY_NAME=external  \nexport KUADRANT_DEVELOPER_NS=toystore\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/observability/limitador-metrics/#step-2-create-gateway-and-application","title":"Step 2: Create Gateway and Application","text":"<p>Create the gateway:</p> <pre><code>kubectl create ns ${KUADRANT_GATEWAY_NS}\n\nkubectl apply -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1\nkind: Gateway\nmetadata:\n  name: ${KUADRANT_GATEWAY_NAME}\n  namespace: ${KUADRANT_GATEWAY_NS}\n  labels:\n    kuadrant.io/gateway: \"true\"\nspec:\n  gatewayClassName: istio\n  listeners:\n\n    - name: http\n      protocol: HTTP\n      port: 80\n      allowedRoutes:\n        namespaces:\n          from: All\nEOF\n</code></pre> <p>Wait for the Gateway to be ready and check its status:</p> <pre><code># Check Gateway status\nkubectl get gateway ${KUADRANT_GATEWAY_NAME} -n ${KUADRANT_GATEWAY_NS} -o yaml\n\n# Verify Gateway is Accepted and Programmed\nkubectl get gateway ${KUADRANT_GATEWAY_NAME} -n ${KUADRANT_GATEWAY_NS} -o=jsonpath='{.status.conditions[?(@.type==\"Accepted\")].message}{\"\\n\"}{.status.conditions[?(@.type==\"Programmed\")].message}{\"\\n\"}'\n</code></pre> <p>Deploy the toystore application:</p> <pre><code>kubectl create ns ${KUADRANT_DEVELOPER_NS}\nkubectl apply -f https://raw.githubusercontent.com/Kuadrant/Kuadrant-operator/main/examples/toystore/toystore.yaml -n ${KUADRANT_DEVELOPER_NS}\n</code></pre> <p>Create the HTTPRoute:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: toystore\n  namespace: ${KUADRANT_DEVELOPER_NS}\nspec:\n  parentRefs:\n\n  - name: ${KUADRANT_GATEWAY_NAME}\n    namespace: ${KUADRANT_GATEWAY_NS}\n  hostnames:\n  - api.toystore.com\n  rules:\n  - matches:\n    - path:\n        type: Exact\n        value: \"/toy\"\n      method: GET\n    backendRefs:\n    - name: toystore\n      port: 80\nEOF\n</code></pre> <p>Get the gateway URL:</p> <pre><code>export KUADRANT_INGRESS_HOST=$(kubectl get gtw ${KUADRANT_GATEWAY_NAME} -n ${KUADRANT_GATEWAY_NS} -o jsonpath='{.status.addresses[0].value}')\nexport KUADRANT_INGRESS_PORT=$(kubectl get gtw ${KUADRANT_GATEWAY_NAME} -n ${KUADRANT_GATEWAY_NS} -o jsonpath='{.spec.listeners[?(@.name==\"http\")].port}')\nexport KUADRANT_GATEWAY_URL=${KUADRANT_INGRESS_HOST}:${KUADRANT_INGRESS_PORT}\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/observability/limitador-metrics/#step-3-configure-authentication","title":"Step 3: Configure Authentication","text":"<p>Create an AuthPolicy:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1\nkind: AuthPolicy\nmetadata:\n  name: toystore\n  namespace: ${KUADRANT_DEVELOPER_NS}\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: toystore\n  rules:\n    authentication:\n      \"api-key-users\":\n        apiKey:\n          selector:\n            matchLabels:\n              app: toystore\n          allNamespaces: true\n        credentials:\n          authorizationHeader:\n            prefix: APIKEY\n    response:\n      success:\n        filters:\n          \"identity\":\n            json:\n              properties:\n                \"userid\":\n                  selector: auth.identity.metadata.annotations.secret\\.kuadrant\\.io/user-id\nEOF\n</code></pre> <p>Create API keys for test users:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: alice-key\n  namespace: ${KUADRANT_DEVELOPER_NS}\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    app: toystore\n  annotations:\n    secret.kuadrant.io/user-id: alice\nstringData:\n  api_key: IAMALICE\ntype: Opaque\n---\napiVersion: v1\nkind: Secret\nmetadata:\n  name: bob-key\n  namespace: ${KUADRANT_DEVELOPER_NS}\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    app: toystore\n  annotations:\n    secret.kuadrant.io/user-id: bob\nstringData:\n  api_key: IAMBOB\ntype: Opaque\nEOF\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/observability/limitador-metrics/#step-4-configure-rate-limiting","title":"Step 4: Configure Rate Limiting","text":"<p>Create a RateLimitPolicy with different limits for Alice and Bob:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1\nkind: RateLimitPolicy\nmetadata:\n  name: toystore\n  namespace: ${KUADRANT_DEVELOPER_NS}\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: toystore\n  limits:\n    \"alice-limit\":\n      rates:\n\n      - limit: 5\n        window: 10s\n      when:\n      - predicate: \"auth.identity.userid == 'alice'\"\n    \"bob-limit\":\n      rates:\n      - limit: 2\n        window: 10s\n      when:\n      - predicate: \"auth.identity.userid == 'bob'\"\nEOF\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/observability/limitador-metrics/#step-5-generate-traffic-to-populate-metrics","title":"Step 5: Generate Traffic to Populate Metrics","text":"<p>Now generate requests to populate the metrics:</p>"},{"location":"kuadrant-operator/doc/user-guides/observability/limitador-metrics/#generate-authorized-requests-alice-within-limits","title":"Generate Authorized Requests (Alice - within limits)","text":"<pre><code># Send 3 requests as Alice (under her 5/10s limit)\nfor i in {1..3}; do \n  echo \"Request $i:\"\n  curl --write-out 'Status: %{http_code}\\n' --silent --output /dev/null \\\n    -H 'Authorization: APIKEY IAMALICE' \\\n    -H 'Host: api.toystore.com' \\\n    http://$KUADRANT_GATEWAY_URL/toy\n  sleep 1\ndone\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/observability/limitador-metrics/#generate-rate-limited-requests-alice-exceed-limits","title":"Generate Rate Limited Requests (Alice - exceed limits)","text":"<pre><code># Send 8 rapid requests as Alice to trigger rate limiting\necho \"Rapid requests (triggering rate limits):\"\nfor i in {1..8}; do \n  curl --write-out '%{http_code} ' --silent --output /dev/null \\\n    -H 'Authorization: APIKEY IAMALICE' \\\n    -H 'Host: api.toystore.com' \\\n    http://$KUADRANT_GATEWAY_URL/toy\ndone\necho \"\"\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/observability/limitador-metrics/#generate-traffic-for-bob","title":"Generate Traffic for Bob","text":"<pre><code># Send requests as Bob (2/10s limit)\necho \"Bob's requests:\"\nfor i in {1..5}; do \n  curl --write-out '%{http_code} ' --silent --output /dev/null \\\n    -H 'Authorization: APIKEY IAMBOB' \\\n    -H 'Host: api.toystore.com' \\\n    http://$KUADRANT_GATEWAY_URL/toy\n  sleep 1\ndone\necho \"\"\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/observability/limitador-metrics/#step-6-monitor-metrics-in-prometheus","title":"Step 6: Monitor Metrics in Prometheus","text":"<p>After generating traffic, check the metrics in Prometheus:</p> <pre><code># Port forward to Prometheus (if not already done)\nkubectl port-forward -n monitoring service/prometheus-k8s 9090:9090\n</code></pre> <p>Visit http://localhost:9090 and run these queries:</p>"},{"location":"kuadrant-operator/doc/user-guides/observability/limitador-metrics/#basic-health-metrics","title":"Basic Health Metrics","text":"<pre><code># Limitador health (should always be 1)\nlimitador_up\n\n# Datastore connectivity (should be 0 for connected)\ndatastore_partitioned\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/observability/limitador-metrics/#rate-limiting-metrics","title":"Rate Limiting Metrics","text":"<pre><code># Total authorized calls\nauthorized_calls\n\n# Total limited calls  \nlimited_calls\n\n# Total authorized hits\nauthorized_hits\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/observability/limitador-metrics/#metrics-by-namespace","title":"Metrics by Namespace","text":"<pre><code># Authorized calls by namespace/route\nauthorized_calls{limitador_namespace=~\".*toystore.*\"}\n\n# Limited calls by namespace/route\nlimited_calls{limitador_namespace=~\".*toystore.*\"}\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/observability/monitors/","title":"Configure Observability of Gateway and Kuadrant components","text":""},{"location":"kuadrant-operator/doc/user-guides/observability/monitors/#overview","title":"Overview","text":"<p>This guide includes steps to enable the Kuadrant observability feature. This feature provides an integration between the Kuadrant components (including any gateways) and the Prometheus Operator if you have it installed in your cluster. The feature works by creating a set of ServiceMonitors and PodMonitors, which instruct prometheus to scrape metrics from the Kuadrant and Gateway components. The scraped metrics are used in the Example Dashboards and Alerts.</p>"},{"location":"kuadrant-operator/doc/user-guides/observability/monitors/#prerequisites","title":"Prerequisites","text":"<ul> <li>You have installed Kuadrant in a Kubernetes cluster.</li> <li>You have installed the Prometheus Operator.</li> </ul>"},{"location":"kuadrant-operator/doc/user-guides/observability/monitors/#enabling-observability","title":"Enabling Observability","text":"<p>To enable observability for Kuadrant and any gateways, set <code>enable: true</code> under the <code>observability</code> section in your Kuadrant CR:</p> <pre><code>apiVersion: kuadrant.io/v1beta1\nkind: Kuadrant\nmetadata:\n  name: kuadrant-sample\nspec:\n  observability:\n    enable: true\n</code></pre> <p>When enabled, Kuadrant creates ServiceMonitors and PodMonitors for its own components in the same namespace as the Kuadrant operator. Pod monitors are also created in each gateway namespace (Envoy Gateway or Istio) to scrape metrics from all gateways in the gateway namespace.</p> <p>You can check all created monitors using this command:</p> <pre><code>kubectl get servicemonitor,podmonitor -A -l kuadrant.io/observability=true\n</code></pre> <p>You can make changes to the monitors after they are created if you need to. Monitors will only ever be created or deleted, not updated or reverted. If you decide the default monitors aren\u2019t suitable, disable the feature by setting <code>enable: false</code> and create your own ServiceMonitor/PodMonitor definitions or configure Prometheus directly. For more details on specific metrics, check out the Metrics reference page.</p>"},{"location":"kuadrant-operator/doc/user-guides/observability/token-metrics/","title":"Token Metrics Monitoring Guide For AI Traffic","text":""},{"location":"kuadrant-operator/doc/user-guides/observability/token-metrics/#overview","title":"Overview","text":"<p>This tutorial walks you through using Kuadrant to monitor token metrics for AI workloads. LLM APIs have varying computational costs based on token usage.</p> <p>The use case is as follows: As a platform engineer, I want token usage and limit metrics to be exposed in Prometheus format so that I can monitor how many tokens are being used per user or route and compare them to defined limits for alerting and capacity planning.</p> <p>This guide covers exposing usage data as metrics suitable for Prometheus collection. These metrics are critical for visibility into LLM costs and usage patterns and will allow platform teams to build dashboards or alerts.</p> <p>This feature is for observability only and does not affect policy enforcement, but it is critical for diagnosing policy effectiveness and model usage behavior.</p>"},{"location":"kuadrant-operator/doc/user-guides/observability/token-metrics/#prerequisites","title":"Prerequisites","text":"<ul> <li>A Kubernetes cluster with the Kuadrant operator installed. See our Getting Started guide, which lets you quickly set up a local cluster for evaluation purposes.</li> <li>A monitoring stack deployed, specifically the Prometheus component for this tutorial.</li> <li>For bare-metal Kubernetes: See Installing Prometheus Operator guide.</li> <li>For OpenShift: See the Configuring user workload monitoring guide.</li> <li>Configure Observability for Gateway and Kuadrant components. See our Configure Observability guide for more information.</li> <li>The kubectl command-line tool.</li> <li>[Optional] The jq command-line tool.</li> </ul>"},{"location":"kuadrant-operator/doc/user-guides/observability/token-metrics/#set-the-environment-variables","title":"Set the environment variables","text":"<p>Set the following environment variables for convenience in this tutorial:</p> <pre><code>export KUADRANT_GATEWAY_NS=api-gateway # Namespace for the example Gateway\nexport KUADRANT_GATEWAY_NAME=external # Name for the example Gateway\nexport KUADRANT_DEVELOPER_NS=llm # Namespace for an example LLM app\nexport KUADRANT_LLM_DOMAIN=llm.example.com # Domain name for an example LLM app\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/observability/token-metrics/#step-1-deploy-an-llm-service","title":"Step 1: Deploy an LLM service","text":"<p>Create the namespace for the LLM service:</p> <pre><code>kubectl create ns ${KUADRANT_DEVELOPER_NS}\n</code></pre> <p>Deploy a simulated LLM service that mimics OpenAI-compatible APIs:</p> <pre><code>kubectl apply -n ${KUADRANT_DEVELOPER_NS} -f - &lt;&lt;EOF\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: llm-sim\n  labels:\n    app: llm-sim\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: llm-sim\n  template:\n    metadata:\n      labels:\n        app: llm-sim\n    spec:\n      containers:\n\n      - name: simulator\n        image: ghcr.io/llm-d/llm-d-inference-sim:v0.1.1\n        args:\n          - --model\n          - meta-llama/Llama-3.1-8B-Instruct\n          - --port\n          - \"8000\"\n        ports:\n          - containerPort: 8000\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: llm-sim\nspec:\n  selector:\n    app: llm-sim\n  ports:\n    - port: 80\n      targetPort: 8000\n      protocol: TCP\nEOF\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/observability/token-metrics/#step-2-create-a-gateway","title":"Step 2: Create a Gateway","text":"<p>Create the namespace for the gateway:</p> <pre><code>kubectl create ns ${KUADRANT_GATEWAY_NS}\n</code></pre> <p>Create a gateway that will accept traffic for the LLM API:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1\nkind: Gateway\nmetadata:\n  name: ${KUADRANT_GATEWAY_NAME}\n  namespace: ${KUADRANT_GATEWAY_NS}\nspec:\n  gatewayClassName: istio\n  listeners:\n\n  - name: http\n    protocol: HTTP\n    port: 80\n    hostname: ${KUADRANT_LLM_DOMAIN}\n    allowedRoutes:\n      namespaces:\n        from: All\nEOF\n</code></pre> <p>Check the gateway status:</p> <pre><code>kubectl get gateway ${KUADRANT_GATEWAY_NAME} -n ${KUADRANT_GATEWAY_NS} -o=jsonpath='{.status.conditions[?(@.type==\"Accepted\")].message}{\"\\n\"}{.status.conditions[?(@.type==\"Programmed\")].message}{\"\\n\"}'\n</code></pre> <p>Export the gateway URL for use in requests:</p> <pre><code>export KUADRANT_INGRESS_HOST=$(kubectl get gtw ${KUADRANT_GATEWAY_NAME} -n ${KUADRANT_GATEWAY_NS} -o jsonpath='{.status.addresses[0].value}')\nexport KUADRANT_INGRESS_PORT=$(kubectl get gtw ${KUADRANT_GATEWAY_NAME} -n ${KUADRANT_GATEWAY_NS} -o jsonpath='{.spec.listeners[?(@.name==\"http\")].port}')\nexport KUADRANT_GATEWAY_URL=${KUADRANT_INGRESS_HOST}:${KUADRANT_INGRESS_PORT}\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/observability/token-metrics/#step-3-expose-the-service-via-httproute","title":"Step 3: Expose the service via HTTPRoute","text":"<p>Create an HTTPRoute to expose the LLM service:</p> <pre><code>kubectl apply -n ${KUADRANT_DEVELOPER_NS} -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: llm-sim\nspec:\n  hostnames:\n\n    - ${KUADRANT_LLM_DOMAIN}\n  parentRefs:\n    - name: ${KUADRANT_GATEWAY_NAME}\n      namespace: ${KUADRANT_GATEWAY_NS}\n  rules:\n    - matches:\n        - path:\n            type: PathPrefix\n            value: \"/\"\n      backendRefs:\n        - name: llm-sim\n          port: 80\nEOF\n</code></pre> <p>Test connectivity to the LLM service:</p> <pre><code>curl --resolve $KUADRANT_LLM_DOMAIN:$KUADRANT_INGRESS_PORT:$KUADRANT_INGRESS_HOST http://$KUADRANT_LLM_DOMAIN:$KUADRANT_INGRESS_PORT/v1/models\n# HTTP/1.1 200 OK\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/observability/token-metrics/#step-4-set-up-api-key-authentication","title":"Step 4: Set up API key authentication","text":"<p>Create API keys for different user tiers. This example creates two tiers: \"free\" and \"gold\":</p> <pre><code># Create a free tier user\nkubectl apply -f - &lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: api-key-free-user-1\n  namespace: ${KUADRANT_DEVELOPER_NS}\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    app: my-llm\n  annotations:\n    kuadrant.io/groups: free\n    kuadrant.io/user-id: user-1\nstringData:\n  api_key: iamafreeuser\ntype: Opaque\nEOF\n</code></pre> <pre><code># Create a gold tier user\nkubectl apply -f - &lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: api-key-gold-user-1\n  namespace: ${KUADRANT_DEVELOPER_NS}\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    app: my-llm\n  annotations:\n    kuadrant.io/groups: gold\n    kuadrant.io/user-id: user-2\nstringData:\n  api_key: iamagolduser\ntype: Opaque\nEOF\n</code></pre> <p>Create an AuthPolicy that validates API keys and extracts user information:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1\nkind: AuthPolicy\nmetadata:\n  name: llm-api-keys\n  namespace: ${KUADRANT_DEVELOPER_NS}\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: llm-sim\n  rules:\n    authentication:\n      \"api-key-users\":\n        apiKey:\n          allNamespaces: true\n          selector:\n            matchLabels:\n              app: my-llm\n        credentials:\n          authorizationHeader:\n            prefix: APIKEY\n    response:\n      success:\n        filters:\n          identity:\n            json:\n              properties:\n                groups:\n                  selector: auth.identity.metadata.annotations.kuadrant\\.io/groups\n                userid:\n                  selector: auth.identity.metadata.annotations.kuadrant\\.io/user-id\n    authorization:\n      \"allow-groups\":\n        opa:\n          rego: |\n            groups := split(object.get(input.auth.identity.metadata.annotations, \"kuadrant.io/groups\", \"\"), \",\")\n            allow { groups[_] == \"free\" }\n            allow { groups[_] == \"gold\" }\nEOF\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/observability/token-metrics/#step-5-apply-token-rate-limiting","title":"Step 5: Apply token rate limiting","text":"<p>Create a <code>TokenRateLimitPolicy</code> with different token limits for each tier:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1alpha1\nkind: TokenRateLimitPolicy\nmetadata:\n  name: token-limits\n  namespace: ${KUADRANT_DEVELOPER_NS}\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: llm-sim\n  limits:\n    free:\n      rates:\n\n        - limit: 100 # 100 tokens per minute for free users (small for testing)\n          window: 1m\n      when:\n        - predicate: request.path == \"/v1/chat/completions\"\n        - predicate: |\n            auth.identity.groups.split(\",\").exists(g, g == \"free\")\n      counters:\n        - expression: auth.identity.userid\n    gold:\n      rates:\n        - limit: 500 # 500 tokens per minute for gold users (small for testing)\n          window: 1m\n      when:\n        - predicate: request.path == \"/v1/chat/completions\"\n        - predicate: |\n            auth.identity.groups.split(\",\").exists(g, g == \"gold\")\n      counters:\n        - expression: auth.identity.userid\nEOF\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/observability/token-metrics/#step-6-apply-telemetrypolicy-to-expose-metrics-usage-per-user-and-tier","title":"Step 6: Apply TelemetryPolicy to expose metrics usage per user and tier","text":"<p>Create a <code>TelemetryPolicy</code>:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: extensions.kuadrant.io/v1alpha1\nkind: TelemetryPolicy\nmetadata:\n  name: user-group\n  namespace: ${KUADRANT_GATEWAY_NS}\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: ${KUADRANT_GATEWAY_NAME}\n  metrics:\n    default:\n      labels:\n        user: auth.identity.userid\n        group: auth.identity.groups\nEOF\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/observability/token-metrics/#step-7-generate-traffic-to-populate-token-metrics","title":"Step 7: Generate Traffic to Populate Token Metrics","text":"<p>Define a bash function to send a chat completion request on behalf of a user (through the API key).</p> <pre><code>function call_llm {\n    curl --resolve $KUADRANT_LLM_DOMAIN:$KUADRANT_INGRESS_PORT:$KUADRANT_INGRESS_HOST \\\n        --write-out 'Status: %{http_code}\\n' --silent --output /dev/null \\\n        -H 'Content-Type: application/json' \\\n        -H \"Authorization: APIKEY $1\" \\\n        -X POST \\\n        -d '{\n           \"model\": \"meta-llama/Llama-3.1-8B-Instruct\",\n           \"messages\": [\n             { \"role\": \"user\", \"content\": \"What is Kubernetes?\" }\n           ],\n           \"max_tokens\": 100,\n           \"stream\": false,\n           \"stream_options\": {\n             \"include_usage\": true\n           }\n         }'  \\\n        http://llm.example.com:$KUADRANT_INGRESS_PORT/v1/chat/completions\n}\n</code></pre> <p>The function accepts one parameter, which is the API key. For example, <code>call_llm iamafreeuser</code>.</p> <p>Send some requests as <code>user-1</code>, which belongs to the <code>free</code> tier.</p> <pre><code>for i in {1..30}; do\n    echo \"Request $i:\"\n    call_llm iamafreeuser\ndone\n</code></pre> <p>Send some requests as <code>user-2</code>, which belongs to the <code>gold</code> tier.</p> <pre><code>for i in {1..30}; do\n    echo \"Request $i:\"\n    call_llm iamagolduser\ndone\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/observability/token-metrics/#step-8-view-token-metrics-in-prometheus","title":"Step 8: View token metrics in Prometheus","text":"<p>The metrics exposed by the rate-limiting service can be found in the Limitador Metrics Monitoring guide.</p> <p>In the current context, <code>authorized_hits</code> will represent the usage of tokens per user and tier.</p>"},{"location":"kuadrant-operator/doc/user-guides/observability/token-metrics/#using-the-web-ui","title":"Using the Web UI:","text":"<ul> <li>Visit http://localhost:9090/graph</li> <li>Create three panels:</li> <li>PromQL: <code>authorized_hits</code></li> <li>PromQL: <code>authorized_calls</code></li> <li>PromQL: <code>limited_calls</code></li> </ul>"},{"location":"kuadrant-operator/doc/user-guides/observability/token-metrics/#using-the-api","title":"Using the API:","text":"<ul> <li><code>authorized_hits</code></li> </ul> <pre><code>curl -s \"http://${PROMETHEUS_HOST}:${PROMETHEUS_PORT}/api/v1/query?query=authorized_hits\" | jq '.data.result'\n</code></pre> <ul> <li><code>authorized_calls</code></li> </ul> <pre><code>curl -s \"http://${PROMETHEUS_HOST}:${PROMETHEUS_PORT}/api/v1/query?query=authorized_calls\" | jq '.data.result'\n</code></pre> <ul> <li><code>limited_calls</code></li> </ul> <pre><code>curl -s \"http://${PROMETHEUS_HOST}:${PROMETHEUS_PORT}/api/v1/query?query=limited_calls\" | jq '.data.result'\n</code></pre> <p>Note: The Prometheus installation documentation should provide the PROMETHEUS_HOST and PROMETHEUS_PORT variables.</p>"},{"location":"kuadrant-operator/doc/user-guides/observability/token-metrics/#next-steps","title":"Next steps","text":"<ul> <li>Experiment with different custom labels in the TelemetryPolicy specification.</li> <li>Integrate with your actual LLM service.</li> </ul>"},{"location":"kuadrant-operator/doc/user-guides/observability/token-metrics/#troubleshooting","title":"Troubleshooting","text":"<p>If requests are being rejected unexpectedly:</p> <ol> <li>Verify that the API key is correct.</li> <li>Ensure the LLM response includes <code>usage.total_tokens</code>.</li> <li>Review the <code>AuthPolicy</code> and <code>TokenRateLimitPolicy</code> statuses.</li> </ol> <pre><code># Check AuthPolicy status\nkubectl get authpolicy -n ${KUADRANT_GATEWAY_NS} llm-api-keys -o=jsonpath='{.status.conditions[?(@.type==\"Accepted\")].message}'\n\n# Check TokenRateLimitPolicy status\nkubectl get tokenratelimitpolicy -n ${KUADRANT_GATEWAY_NS} token-limits -o=jsonpath='{.status.conditions[?(@.type==\"Accepted\")].message}'\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/observability/token-metrics/#cleanup","title":"Cleanup","text":"<p>To remove all resources created in this tutorial:</p> <pre><code># Delete the LLM service namespace\nkubectl delete namespace ${KUADRANT_DEVELOPER_NS}\n\n# Delete the gateway namespace\nkubectl delete namespace ${KUADRANT_GATEWAY_NS}\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/planpolicy/plan-based-rate-limiting/","title":"Plan-based Rate Limiting Tutorial","text":"<p>This tutorial demonstrates how to use the PlanPolicy extension to implement tiered service offerings with different rate limits based on user authentication plans.</p>"},{"location":"kuadrant-operator/doc/user-guides/planpolicy/plan-based-rate-limiting/#overview","title":"Overview","text":"<p>In this tutorial, you will:</p> <ol> <li>Set up a basic Gateway and HTTPRoute</li> <li>Configure authentication with different API keys for different plans</li> <li>Deploy a PlanPolicy to automatically assign rate limits based on user plans</li> <li>Test the plan-based rate limiting functionality</li> </ol>"},{"location":"kuadrant-operator/doc/user-guides/planpolicy/plan-based-rate-limiting/#prerequisites","title":"Prerequisites","text":"<ul> <li>Kubernetes cluster with Kuadrant operator installed. See our Getting Started guide for more information.</li> <li>kubectl command line tool.</li> </ul>"},{"location":"kuadrant-operator/doc/user-guides/planpolicy/plan-based-rate-limiting/#setup-environment-variables","title":"Setup environment variables","text":"<p>Set environment variables for convenience:</p> <pre><code>export KUADRANT_GATEWAY_NS=api-gateway     # Namespace for the Gateway\nexport KUADRANT_GATEWAY_NAME=external      # Name for the Gateway\nexport KUADRANT_DEVELOPER_NS=toystore      # Namespace for the app\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/planpolicy/plan-based-rate-limiting/#deploy-kuadrant-and-gateway","title":"Deploy Kuadrant and Gateway","text":"<p>Deploy the Kuadrant instance:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1beta1\nkind: Kuadrant\nmetadata:\n  name: kuadrant\n  namespace: kuadrant-system\nEOF\n</code></pre> <p>Create the gateway namespace and deploy the Gateway:</p> <pre><code>kubectl create ns ${KUADRANT_GATEWAY_NS}\nkubectl apply -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1\nkind: Gateway\nmetadata:\n  name: ${KUADRANT_GATEWAY_NAME}\n  namespace: ${KUADRANT_GATEWAY_NS}\n  labels:\n    kuadrant.io/gateway: \"true\"\nspec:\n  gatewayClassName: istio\n  listeners:\n\n    - name: http\n      protocol: HTTP\n      port: 80\n      allowedRoutes:\n        namespaces:\n          from: All\nEOF\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/planpolicy/plan-based-rate-limiting/#deploy-the-application","title":"Deploy the Application","text":"<p>Deploy the toystore application and create an HTTPRoute:</p> <pre><code>kubectl create ns ${KUADRANT_DEVELOPER_NS}\nkubectl apply -f https://raw.githubusercontent.com/Kuadrant/Kuadrant-operator/main/examples/toystore/toystore.yaml -n ${KUADRANT_DEVELOPER_NS}\n\nkubectl apply -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: toystore\n  namespace: ${KUADRANT_DEVELOPER_NS}\nspec:\n  parentRefs:\n\n  - name: ${KUADRANT_GATEWAY_NAME}\n    namespace: ${KUADRANT_GATEWAY_NS}\n  hostnames:\n  - api.toystore.com\n  rules:\n  - matches:\n    - path:\n        type: Exact\n        value: \"/toy\"\n      method: GET\n    backendRefs:\n    - name: toystore\n      port: 80\nEOF\n</code></pre> <p>Set up gateway connection variables:</p> <pre><code>export KUADRANT_INGRESS_HOST=$(kubectl get gtw ${KUADRANT_GATEWAY_NAME} -n ${KUADRANT_GATEWAY_NS} -o jsonpath='{.status.addresses[0].value}')\nexport KUADRANT_INGRESS_PORT=$(kubectl get gtw ${KUADRANT_GATEWAY_NAME} -n ${KUADRANT_GATEWAY_NS} -o jsonpath='{.spec.listeners[?(@.name==\"http\")].port}')\nexport KUADRANT_GATEWAY_URL=${KUADRANT_INGRESS_HOST}:${KUADRANT_INGRESS_PORT}\n\n# Wait for the deployment to be ready\nkubectl -n ${KUADRANT_DEVELOPER_NS} wait --for=condition=Available deployments toystore --timeout=90s\n</code></pre> <p>Test the basic connectivity:</p> <pre><code>curl -H 'Host: api.toystore.com' http://$KUADRANT_GATEWAY_URL/toy -i\n# Expected: HTTP/1.1 200 OK\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/planpolicy/plan-based-rate-limiting/#configure-authentication","title":"Configure Authentication","text":"<p>Deploy an AuthPolicy targeting the Gateway with API key authentication:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1\nkind: AuthPolicy\nmetadata:\n  name: toystore\n  namespace: ${KUADRANT_GATEWAY_NS}\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: ${KUADRANT_GATEWAY_NAME}\n  rules:\n    authentication:\n      \"api-key-plan\":\n        apiKey:\n          selector:\n            matchLabels:\n              app: toystore\n          allNamespaces: true\n        credentials:\n          authorizationHeader:\n            prefix: APIKEY\nEOF\n</code></pre> <p>Create API key secrets for different plans:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: gold-key\n  namespace: ${KUADRANT_GATEWAY_NS}\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    app: toystore\n  annotations:\n    secret.kuadrant.io/plan-id: gold\nstringData:\n  api_key: IAMGOLD\ntype: Opaque\n---\napiVersion: v1\nkind: Secret\nmetadata:\n  name: silver-key\n  namespace: ${KUADRANT_GATEWAY_NS}\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    app: toystore\n  annotations:\n    secret.kuadrant.io/plan-id: silver\nstringData:\n  api_key: IAMSILVER\ntype: Opaque\n---\napiVersion: v1\nkind: Secret\nmetadata:\n  name: bronze-key\n  namespace: ${KUADRANT_GATEWAY_NS}\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    app: toystore\n  annotations:\n    secret.kuadrant.io/plan-id: bronze\nstringData:\n  api_key: IAMBRONZE\ntype: Opaque\nEOF\n</code></pre> <p>Test that authentication is working:</p> <pre><code># Without authentication - should fail\ncurl -H 'Host: api.toystore.com' http://$KUADRANT_GATEWAY_URL/toy -i\n# Expected: HTTP/1.1 401 Unauthorized\n\n# With authentication - should succeed\ncurl -H 'Host: api.toystore.com' -H 'Authorization: APIKEY IAMGOLD' http://$KUADRANT_GATEWAY_URL/toy -i\n# Expected: HTTP/1.1 200 OK\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/planpolicy/plan-based-rate-limiting/#deploy-planpolicy","title":"Deploy PlanPolicy","text":"<p>Now deploy the PlanPolicy to implement plan-based rate limiting:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: extensions.kuadrant.io/v1alpha1\nkind: PlanPolicy\nmetadata:\n  name: toystore-plans\n  namespace: ${KUADRANT_DEVELOPER_NS}\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: toystore\n  plans:\n\n    - tier: gold\n      predicate: |\n        has(auth.identity) &amp;&amp; auth.identity.metadata.annotations[\"secret.kuadrant.io/plan-id\"] == \"gold\"\n      limits:\n        daily: 5\n    - tier: silver\n      predicate: |\n        has(auth.identity) &amp;&amp; auth.identity.metadata.annotations[\"secret.kuadrant.io/plan-id\"] == \"silver\"\n      limits:\n        daily: 2\n    - tier: bronze\n      predicate: |\n        has(auth.identity) &amp;&amp; auth.identity.metadata.annotations[\"secret.kuadrant.io/plan-id\"] == \"bronze\"\n      limits:\n        daily: 1\nEOF\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/planpolicy/plan-based-rate-limiting/#verify-plan-based-rate-limiting","title":"Verify Plan-based Rate Limiting","text":"<p>Check that the AuthConfig was updated with plan data:</p> <pre><code>kubectl get authconfig -n kuadrant-system -o yaml\n</code></pre> <p>You should see that the AuthConfig includes plan information in the response section.</p>"},{"location":"kuadrant-operator/doc/user-guides/planpolicy/plan-based-rate-limiting/#test-different-plans","title":"Test Different Plans","text":"<p>Test the bronze plan (1 request per day limit):</p> <pre><code># First request should succeed\ncurl -H 'Host: api.toystore.com' -H 'Authorization: APIKEY IAMBRONZE' http://$KUADRANT_GATEWAY_URL/toy -i\n# Expected: HTTP/1.1 200 OK\n\n# Second request should be rate limited\ncurl -H 'Host: api.toystore.com' -H 'Authorization: APIKEY IAMBRONZE' http://$KUADRANT_GATEWAY_URL/toy -i\n# Expected: HTTP/1.1 429 Too Many Requests (after rate limit is enforced)\n</code></pre> <p>Test the silver plan (2 requests per day limit):</p> <pre><code># First request\ncurl -H 'Host: api.toystore.com' -H 'Authorization: APIKEY IAMSILVER' http://$KUADRANT_GATEWAY_URL/toy -i\n# Expected: HTTP/1.1 200 OK\n\n# Second request\ncurl -H 'Host: api.toystore.com' -H 'Authorization: APIKEY IAMSILVER' http://$KUADRANT_GATEWAY_URL/toy -i\n# Expected: HTTP/1.1 200 OK\n\n# Third request should be rate limited\ncurl -H 'Host: api.toystore.com' -H 'Authorization: APIKEY IAMSILVER' http://$KUADRANT_GATEWAY_URL/toy -i\n# Expected: HTTP/1.1 429 Too Many Requests (after rate limit is enforced)\n</code></pre> <p>Test the gold plan (5 requests per day limit):</p> <pre><code># Multiple requests should succeed up to the limit\nfor i in {1..5}; do\n  curl -H 'Host: api.toystore.com' -H 'Authorization: APIKEY IAMGOLD' http://$KUADRANT_GATEWAY_URL/toy -i\ndone\n# Expected: First 5 requests return HTTP/1.1 200 OK\n\n# Sixth request should be rate limited\ncurl -H 'Host: api.toystore.com' -H 'Authorization: APIKEY IAMGOLD' http://$KUADRANT_GATEWAY_URL/toy -i\n# Expected: HTTP/1.1 429 Too Many Requests (after rate limit is enforced)\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/planpolicy/plan-based-rate-limiting/#understanding-the-planpolicy-configuration","title":"Understanding the PlanPolicy Configuration","text":"<p>The PlanPolicy works by:</p> <ol> <li>Plan Identification: Each plan has a predicate that checks the <code>secret.kuadrant.io/plan-id</code> annotation in the authenticated user's secret</li> <li>Rate Limit Assignment: Based on the identified plan, different rate limits are applied</li> <li>Automatic Enforcement: The policy integrates with Kuadrant's rate limiting infrastructure</li> </ol>"},{"location":"kuadrant-operator/doc/user-guides/planpolicy/plan-based-rate-limiting/#plan-predicates","title":"Plan Predicates","text":"<p>The predicates use CEL expressions to identify which plan a user belongs to:</p> <pre><code>predicate: |\n  has(auth.identity) &amp;&amp; auth.identity.metadata.annotations[\"secret.kuadrant.io/plan-id\"] == \"gold\"\n</code></pre> <p>This checks:</p> <ul> <li><code>has(auth.identity)</code>: Ensures the user is authenticated</li> <li><code>auth.identity.metadata.annotations[\"secret.kuadrant.io/plan-id\"] == \"gold\"</code>: Checks the plan-id annotation</li> </ul>"},{"location":"kuadrant-operator/doc/user-guides/planpolicy/plan-based-rate-limiting/#rate-limits","title":"Rate Limits","text":"<p>Each plan defines different limits:</p> <ul> <li>Bronze: 1 request per day</li> <li>Silver: 2 requests per day  </li> <li>Gold: 5 requests per day</li> </ul> <p>You can also define weekly, monthly, yearly, or custom limits:</p> <pre><code>limits:\n  daily: 100\n  weekly: 500\n  monthly: 2000\n  custom:\n\n    - limit: 10\n      window: \"1m\"  # 10 requests per minute\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/planpolicy/plan-based-rate-limiting/#cleanup","title":"Cleanup","text":"<p>Clean up the resources created in this tutorial:</p> <pre><code>kubectl delete planpolicy toystore-plans -n ${KUADRANT_DEVELOPER_NS}\nkubectl delete authpolicy toystore -n ${KUADRANT_GATEWAY_NS}\nkubectl delete secret gold-key silver-key bronze-key -n ${KUADRANT_GATEWAY_NS}\nkubectl delete -f https://raw.githubusercontent.com/Kuadrant/Kuadrant-operator/main/examples/toystore/toystore.yaml -n ${KUADRANT_DEVELOPER_NS}\nkubectl delete httproute toystore -n ${KUADRANT_DEVELOPER_NS}\nkubectl delete gateway ${KUADRANT_GATEWAY_NAME} -n ${KUADRANT_GATEWAY_NS}\nkubectl delete ns ${KUADRANT_GATEWAY_NS} ${KUADRANT_DEVELOPER_NS}\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/authenticated-rl-for-app-developers/","title":"Authenticated Rate Limiting for Application developers","text":"<p>For more info on the different personas see Gateway API </p> <p>This tutorial walks you through an example of how to configure authenticated rate limiting for an application using Kuadrant.</p> <p>Authenticated rate limiting rate limits the traffic directed to an application based on attributes of the client user, who is authenticated by some authentication method. A few examples of authenticated rate limiting use cases are:</p> <ul> <li>User A can send up to 50rps (\"requests per second\"), while User B can send up to 100rps.</li> <li>Each user can send up to 20rpm (\"request per minute\").</li> <li>Admin users (members of the 'admin' group) can send up to 100rps, while regular users (non-admins) can send up to 20rpm and no more than 5rps.</li> </ul> <p>In this tutorial, we will rate limit a sample REST API called Toy Store. In reality, this API is just an echo service that echoes back to the user whatever attributes it gets in the request. The API exposes an endpoint at <code>GET http://api.toystore.com/toy</code>, to mimic an operation of reading toy records.</p> <p>We will define 2 users of the API, which can send requests to the API at different rates, based on their user IDs. The authentication method used is API key.</p> User ID Rate limit alice 5rp10s (\"5 requests every 10 seconds\") bob 2rp10s (\"2 requests every 10 seconds\")"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/authenticated-rl-for-app-developers/#prerequisites","title":"Prerequisites","text":"<ul> <li>Kubernetes cluster with Kuadrant operator installed. See our Getting Started guide for more information.</li> <li>kubectl command line tool.</li> </ul>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/authenticated-rl-for-app-developers/#setup-environment-variables","title":"Setup environment variables","text":"<p>Set the following environment variables used for convenience in this tutorial:</p> <pre><code>export KUADRANT_GATEWAY_NS=api-gateway # Namespace for the example Gateway\nexport KUADRANT_GATEWAY_NAME=external # Name for the example Gateway\nexport KUADRANT_DEVELOPER_NS=toystore # Namespace for an example toystore app\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/authenticated-rl-for-app-developers/#create-an-ingress-gateway","title":"Create an Ingress Gateway","text":"<p>Create the namespace the Gateway will be deployed in:</p> <pre><code>kubectl create ns ${KUADRANT_GATEWAY_NS}\n</code></pre> <p>Create a gateway using toystore as the listener hostname:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1\nkind: Gateway\nmetadata:\n  name: ${KUADRANT_GATEWAY_NAME}\n  namespace: ${KUADRANT_GATEWAY_NS}\n  labels:\n    kuadrant.io/gateway: \"true\"\nspec:\n  gatewayClassName: istio\n  listeners:\n\n    - name: http\n      protocol: HTTP\n      port: 80\n      allowedRoutes:\n        namespaces:\n          from: All\nEOF\n</code></pre> <p>Check the status of the <code>Gateway</code> ensuring the gateway is Accepted and Programmed:</p> <pre><code>kubectl get gateway ${KUADRANT_GATEWAY_NAME} -n ${KUADRANT_GATEWAY_NS} -o=jsonpath='{.status.conditions[?(@.type==\"Accepted\")].message}{\"\\n\"}{.status.conditions[?(@.type==\"Programmed\")].message}{\"\\n\"}'\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/authenticated-rl-for-app-developers/#deploy-the-toy-store-api","title":"Deploy the Toy Store API","text":"<p>Create the namespace for the Toystore application:</p> <pre><code>kubectl create ns ${KUADRANT_DEVELOPER_NS}\n</code></pre> <p>Deploy the Toystore app to the developer namespace:</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/Kuadrant/Kuadrant-operator/main/examples/toystore/toystore.yaml -n ${KUADRANT_DEVELOPER_NS}\n</code></pre> <p>Create a HTTPRoute to route traffic to the service via Istio Ingress Gateway:</p> <p></p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: toystore\n  namespace: ${KUADRANT_DEVELOPER_NS}\nspec:\n  parentRefs:\n\n  - name: ${KUADRANT_GATEWAY_NAME}\n    namespace: ${KUADRANT_GATEWAY_NS}\n  hostnames:\n  - api.toystore.com\n  rules:\n  - matches:\n    - path:\n        type: Exact\n        value: \"/toy\"\n      method: GET\n    backendRefs:\n    - name: toystore\n      port: 80\nEOF\n</code></pre> <p>Export the gateway hostname and port:</p> <pre><code>export KUADRANT_INGRESS_HOST=$(kubectl get gtw ${KUADRANT_GATEWAY_NAME} -n ${KUADRANT_GATEWAY_NS} -o jsonpath='{.status.addresses[0].value}')\nexport KUADRANT_INGRESS_PORT=$(kubectl get gtw ${KUADRANT_GATEWAY_NAME} -n ${KUADRANT_GATEWAY_NS} -o jsonpath='{.spec.listeners[?(@.name==\"http\")].port}')\nexport KUADRANT_GATEWAY_URL=${KUADRANT_INGRESS_HOST}:${KUADRANT_INGRESS_PORT}\n</code></pre> <p>Verify the route works:</p> <pre><code>curl -H 'Host: api.toystore.com' http://$KUADRANT_GATEWAY_URL/toy -i\n# HTTP/1.1 200 OK\n</code></pre> <p>Note: If the command above fails to hit the Toy Store API on your environment, try forwarding requests to the service and accessing over localhost:</p> <pre><code>kubectl port-forward -n ${KUADRANT_GATEWAY_NS} service/kuadrant-${KUADRANT_GATEWAY_NAME}-istio 9080:80 &gt;/dev/null 2&gt;&amp;1 &amp;\nexport KUADRANT_GATEWAY_URL=localhost:9080\n</code></pre> <pre><code>curl -H 'Host: api.toystore.com' http://$KUADRANT_GATEWAY_URL/toy -i\n# HTTP/1.1 200 OK\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/authenticated-rl-for-app-developers/#enforce-authentication-on-requests-to-the-toy-store-api","title":"Enforce authentication on requests to the Toy Store API","text":"<p>Create a Kuadrant <code>AuthPolicy</code> to configure the authentication:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1\nkind: AuthPolicy\nmetadata:\n  name: toystore\n  namespace: ${KUADRANT_DEVELOPER_NS}\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: toystore\n  rules:\n    authentication:\n      \"api-key-users\":\n        apiKey:\n          selector:\n            matchLabels:\n              app: toystore\n          allNamespaces: true\n        credentials:\n          authorizationHeader:\n            prefix: APIKEY\n    response:\n      success:\n        filters:\n          \"identity\":\n            json:\n              properties:\n                \"userid\":\n                  selector: auth.identity.metadata.annotations.secret\\.kuadrant\\.io/user-id\nEOF\n</code></pre> <p>Verify the authentication works by sending a request to the Toy Store API without API key:</p> <pre><code>curl -H 'Host: api.toystore.com' http://$KUADRANT_GATEWAY_URL/toy -i\n# HTTP/1.1 401 Unauthorized\n# www-authenticate: APIKEY realm=\"api-key-users\"\n# x-ext-auth-reason: \"credential not found\"\n</code></pre> <p>Create API keys for users <code>alice</code> and <code>bob</code> to authenticate:</p> <p>Note: Kuadrant stores API keys as Kubernetes Secret resources. User metadata can be stored in the annotations of the resource.</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: bob-key\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    app: toystore\n  annotations:\n    secret.kuadrant.io/user-id: bob\nstringData:\n  api_key: IAMBOB\ntype: Opaque\n---\napiVersion: v1\nkind: Secret\nmetadata:\n  name: alice-key\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    app: toystore\n  annotations:\n    secret.kuadrant.io/user-id: alice\nstringData:\n  api_key: IAMALICE\ntype: Opaque\nEOF\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/authenticated-rl-for-app-developers/#enforce-authenticated-rate-limiting-on-requests-to-the-toy-store-api","title":"Enforce authenticated rate limiting on requests to the Toy Store API","text":"<p>Create a Kuadrant <code>RateLimitPolicy</code> to configure rate limiting:</p> <p></p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1\nkind: RateLimitPolicy\nmetadata:\n  name: toystore\n  namespace: ${KUADRANT_DEVELOPER_NS}\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: toystore\n  limits:\n    \"alice-limit\":\n      rates:\n\n      - limit: 5\n        window: 10s\n      when:\n      - predicate: \"auth.identity.userid == 'alice'\"\n    \"bob-limit\":\n      rates:\n      - limit: 2\n        window: 10s\n      when:\n      - predicate: \"auth.identity.userid == 'bob'\"\nEOF\n</code></pre> <p>Note: It may take a couple of minutes for the RateLimitPolicy to be applied depending on your cluster.</p> <p>Verify the rate limiting works by sending requests as Alice and Bob.</p> <p>Up to 5 successful (<code>200 OK</code>) requests every 10 seconds allowed for Alice, then <code>429 Too Many Requests</code>:</p> <pre><code>while :; do curl --write-out '%{http_code}\\n' --silent --output /dev/null -H 'Authorization: APIKEY IAMALICE' -H 'Host: api.toystore.com' http://$KUADRANT_GATEWAY_URL/toy | grep -E --color \"\\b(429)\\b|$\"; sleep 1; done\n</code></pre> <p>Up to 2 successful (<code>200 OK</code>) requests every 10 seconds allowed for Bob, then <code>429 Too Many Requests</code>:</p> <pre><code>while :; do curl --write-out '%{http_code}\\n' --silent --output /dev/null -H 'Authorization: APIKEY IAMBOB' -H 'Host: api.toystore.com' http://$KUADRANT_GATEWAY_URL/toy | grep -E --color \"\\b(429)\\b|$\"; sleep 1; done\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/authenticated-rl-with-jwt-and-k8s-authnz/","title":"Authenticated Rate Limiting with JWTs and Kubernetes RBAC","text":"<p>This tutorial walks you through an example of how to use Kuadrant to protect an application with policies to enforce: </p> <ul> <li>authentication based OpenId Connect (OIDC) ID tokens (signed JWTs), issued by a Keycloak server;</li> <li>alternative authentication method by Kubernetes Service Account tokens;</li> <li>authorization delegated to Kubernetes RBAC system;</li> <li>rate limiting by user ID.</li> </ul> <p>In this example, we will protect a sample REST API called Toy Store. In reality, this API is just an echo service that echoes back to the user whatever attributes it gets in the request.</p> <p>The API listens to requests at the hostnames <code>*.toystore.com</code>, where it exposes the endpoints <code>GET /toy*</code>, <code>POST /admin/toy</code> and <code>DELETE /amind/toy</code>, respectively, to mimic operations of reading, creating, and deleting toy records.</p> <p>Any authenticated user/service account can send requests to the Toy Store API, by providing either a valid Keycloak-issued access token or Kubernetes token.</p> <p>Privileges to execute the requested operation (read, create or delete) will be granted according to the following RBAC rules, stored in the Kubernetes authorization system:</p> Operation Endpoint Required role Read <code>GET /toy*</code> <code>toystore-reader</code> Create <code>POST /admin/toy</code> <code>toystore-write</code> Delete <code>DELETE /admin/toy</code> <code>toystore-write</code> <p>Each user will be entitled to a maximum of 5rp10s (5 requests every 10 seconds).</p>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/authenticated-rl-with-jwt-and-k8s-authnz/#prerequisites","title":"Prerequisites","text":"<ul> <li>Kubernetes cluster with Kuadrant operator installed. See our Getting Started guide for more information.</li> <li>kubectl command line tool.</li> </ul>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/authenticated-rl-with-jwt-and-k8s-authnz/#setup-environment-variables","title":"Setup environment variables","text":"<p>Set the following environment variables used for convenience in this tutorial:</p> <pre><code>export KUADRANT_GATEWAY_NS=api-gateway # Namespace for the example Gateway\nexport KUADRANT_GATEWAY_NAME=external # Name for the example Gateway\nexport KUADRANT_DEVELOPER_NS=toystore # Namespace for an example toystore app\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/authenticated-rl-with-jwt-and-k8s-authnz/#create-an-ingress-gateway","title":"Create an Ingress Gateway","text":"<p>Create the namespace the Gateway will be deployed in:</p> <pre><code>kubectl create ns ${KUADRANT_GATEWAY_NS}\n</code></pre> <p>Create a gateway using toystore as the listener hostname:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1\nkind: Gateway\nmetadata:\n  name: ${KUADRANT_GATEWAY_NAME}\n  namespace: ${KUADRANT_GATEWAY_NS}\n  labels:\n    kuadrant.io/gateway: \"true\"\nspec:\n  gatewayClassName: istio\n  listeners:\n\n    - name: http\n      protocol: HTTP\n      port: 80\n      allowedRoutes:\n        namespaces:\n          from: All\nEOF\n</code></pre> <p>Check the status of the <code>Gateway</code> ensuring the gateway is Accepted and Programmed:</p> <pre><code>kubectl get gateway ${KUADRANT_GATEWAY_NAME} -n ${KUADRANT_GATEWAY_NS} -o=jsonpath='{.status.conditions[?(@.type==\"Accepted\")].message}{\"\\n\"}{.status.conditions[?(@.type==\"Programmed\")].message}{\"\\n\"}'\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/authenticated-rl-with-jwt-and-k8s-authnz/#deploy-the-toy-store-api","title":"Deploy the Toy Store API","text":"<p>Create the namespace for the Toystore application:</p> <pre><code>kubectl create ns ${KUADRANT_DEVELOPER_NS}\n</code></pre> <p>Deploy the Toystore app to the developer namespace:</p> <p><pre><code>kubectl apply -f https://raw.githubusercontent.com/Kuadrant/Kuadrant-operator/main/examples/toystore/toystore.yaml -n ${KUADRANT_DEVELOPER_NS}\n</code></pre> Create a HTTPRoute to route traffic to the service via Istio Ingress Gateway:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: toystore\n  namespace: ${KUADRANT_DEVELOPER_NS}\nspec:\n  parentRefs:\n\n  - name: ${KUADRANT_GATEWAY_NAME}\n    namespace: ${KUADRANT_GATEWAY_NS}\n  hostnames:\n  - api.toystore.com\n  rules:\n  - matches:\n    - path:\n        type: Exact\n        value: \"/toy\"\n      method: GET\n    backendRefs:\n    - name: toystore\n      port: 80\nEOF\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/authenticated-rl-with-jwt-and-k8s-authnz/#api-lifecycle","title":"API lifecycle","text":""},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/authenticated-rl-with-jwt-and-k8s-authnz/#try-the-api-unprotected","title":"Try the API unprotected","text":"<p>Export the gateway hostname and port:</p> <pre><code>export KUADRANT_INGRESS_HOST=$(kubectl get gtw ${KUADRANT_GATEWAY_NAME} -n ${KUADRANT_GATEWAY_NS} -o jsonpath='{.status.addresses[0].value}')\nexport KUADRANT_INGRESS_PORT=$(kubectl get gtw ${KUADRANT_GATEWAY_NAME} -n ${KUADRANT_GATEWAY_NS} -o jsonpath='{.spec.listeners[?(@.name==\"http\")].port}')\nexport KUADRANT_GATEWAY_URL=${KUADRANT_INGRESS_HOST}:${KUADRANT_INGRESS_PORT}\n</code></pre> <pre><code>curl -H 'Host: api.toystore.com' http://$KUADRANT_GATEWAY_URL/toy -i\n# HTTP/1.1 200 OK\n</code></pre> <p>It should return <code>200 OK</code>.</p> <p>Note: If the command above fails to hit the Toy Store API on your environment, try forwarding requests to the service and accessing over localhost:</p> <pre><code>kubectl port-forward -n ${KUADRANT_GATEWAY_NS} service/${KUADRANT_GATEWAY_NS}-istio 9080:80 &gt;/dev/null 2&gt;&amp;1 &amp;\nexport KUADRANT_GATEWAY_URL=localhost:9080\n</code></pre> <pre><code>curl -H 'Host: api.toystore.com' http://$KUADRANT_GATEWAY_URL/toy -i\n# HTTP/1.1 200 OK\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/authenticated-rl-with-jwt-and-k8s-authnz/#deploy-keycloak","title":"Deploy Keycloak","text":"<p>Create the namespace for Keycloak:</p> <pre><code>kubectl create namespace keycloak\n</code></pre> <p>Deploy Keycloak with a bootstrap realm, users, and clients:</p> <pre><code>kubectl apply -n keycloak -f https://raw.githubusercontent.com/Kuadrant/authorino-examples/main/keycloak/keycloak-deploy.yaml\n</code></pre> <p>Note: The Keycloak server may take a couple of minutes to be ready.</p>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/authenticated-rl-with-jwt-and-k8s-authnz/#enforce-authentication-and-authorization-for-the-toy-store-api","title":"Enforce authentication and authorization for the Toy Store API","text":"<p>Create a Kuadrant <code>AuthPolicy</code> to configure authentication and authorization:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1\nkind: AuthPolicy\nmetadata:\n  name: toystore-protection\n  namespace: ${KUADRANT_DEVELOPER_NS}\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: toystore\n  rules:\n    authentication:\n      \"keycloak-users\":\n        jwt:\n          issuerUrl: http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant\n      \"k8s-service-accounts\":\n        kubernetesTokenReview:\n          audiences:\n\n          - https://kubernetes.default.svc.cluster.local\n        overrides:\n          \"sub\":\n            selector: auth.identity.user.username\n    authorization:\n      \"k8s-rbac\":\n        kubernetesSubjectAccessReview:\n          user:\n            selector: auth.identity.sub\n    response:\n      success:\n        filters:\n          \"identity\":\n            json:\n              properties:\n                \"userid\":\n                  selector: auth.identity.sub\nEOF\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/authenticated-rl-with-jwt-and-k8s-authnz/#try-the-api-missing-authentication","title":"Try the API missing authentication","text":"<pre><code>curl -H 'Host: api.toystore.com' http://$KUADRANT_GATEWAY_URL/toy -i\n# HTTP/1.1 401 Unauthorized\n# www-authenticate: Bearer realm=\"keycloak-users\"\n# www-authenticate: Bearer realm=\"k8s-service-accounts\"\n# x-ext-auth-reason: {\"k8s-service-accounts\":\"credential not found\",\"keycloak-users\":\"credential not found\"}\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/authenticated-rl-with-jwt-and-k8s-authnz/#try-the-api-without-permission","title":"Try the API without permission","text":"<p>Obtain an access token with the Keycloak server:</p> <pre><code>KUADRANT_ACCESS_TOKEN=$(kubectl run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant/protocol/openid-connect/token -s -d 'grant_type=password' -d 'client_id=demo' -d 'username=john' -d 'password=p' -d 'scope=openid' | jq -r .KUADRANT_ACCESS_TOKEN)\n</code></pre> <p>Send a request to the API as the Keycloak-authenticated user while still missing permissions:</p> <pre><code>curl -H \"Authorization: Bearer $KUADRANT_ACCESS_TOKEN\" -H 'Host: api.toystore.com' http://$KUADRANT_GATEWAY_URL/toy -i\n# HTTP/1.1 403 Forbidden\n</code></pre> <p>Create a Kubernetes Service Account to represent a consumer of the API associated with the alternative source of identities <code>k8s-service-accounts</code>:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: client-app-1\nEOF\n</code></pre> <p>Obtain an access token for the <code>client-app-1</code> service account:</p> <pre><code>KUADRANT_SA_TOKEN=$(kubectl create token client-app-1)\n</code></pre> <p>Send a request to the API as the service account while still missing permissions:</p> <pre><code>curl -H \"Authorization: Bearer $KUADRANT_SA_TOKEN\" -H 'Host: api.toystore.com' http://$KUADRANT_GATEWAY_URL/toy -i\n# HTTP/1.1 403 Forbidden\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/authenticated-rl-with-jwt-and-k8s-authnz/#grant-access-to-the-toy-store-api-for-user-and-service-account","title":"Grant access to the Toy Store API for user and service account","text":"<p>Create the <code>toystore-reader</code> and <code>toystore-writer</code> roles:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: toystore-reader\nrules:\n\n- nonResourceURLs: [\"/toy*\"]\n  verbs: [\"get\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: toystore-writer\nrules:\n- nonResourceURLs: [\"/admin/toy\"]\n  verbs: [\"post\", \"delete\"]\nEOF\n</code></pre> <p>Add permissions to the user and service account:</p> User Kind Roles john User registered in Keycloak <code>toystore-reader</code>, <code>toystore-writer</code> client-app-1 Kuberentes Service Account <code>toystore-reader</code> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: toystore-readers\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: toystore-reader\nsubjects:\n\n- kind: User\n  name: $(jq -R -r 'split(\".\") | .[1] | @base64d | fromjson | .sub' &lt;&lt;&lt; \"$KUADRANT_ACCESS_TOKEN\")\n- kind: ServiceAccount\n  name: client-app-1\n  namespace: default\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: toystore-writers\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: toystore-writer\nsubjects:\n- kind: User\n  name: $(jq -R -r 'split(\".\") | .[1] | @base64d | fromjson | .sub' &lt;&lt;&lt; \"$KUADRANT_ACCESS_TOKEN\")\nEOF\n</code></pre> Q: Can I use <code>Roles</code> and <code>RoleBindings</code> instead of <code>ClusterRoles</code> and <code>ClusterRoleBindings</code>? <p>Yes, you can.</p> <p>The example above is for non-resource URL Kubernetes roles. For using <code>Roles</code> and <code>RoleBindings</code> instead of <code>ClusterRoles</code> and <code>ClusterRoleBindings</code>, thus more flexible resource-based permissions to protect the API, see the spec for Kubernetes SubjectAccessReview authorization in the Authorino docs.</p>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/authenticated-rl-with-jwt-and-k8s-authnz/#try-the-api-with-permission","title":"Try the API with permission","text":"<p>Send requests to the API as the Keycloak-authenticated user:</p> <pre><code>curl -H \"Authorization: Bearer $KUADRANT_ACCESS_TOKEN\" -H 'Host: api.toystore.com' http://$KUADRANT_GATEWAY_URL/toy -i\n# HTTP/1.1 200 OK\n</code></pre> <pre><code>curl -H \"Authorization: Bearer $KUADRANT_ACCESS_TOKEN\" -H 'Host: api.toystore.com' -X POST http://$KUADRANT_GATEWAY_URL/admin/toy -i\n# HTTP/1.1 200 OK\n</code></pre> <p>Send requests to the API as the Kubernetes service account:</p> <pre><code>curl -H \"Authorization: Bearer $KUADRANT_SA_TOKEN\" -H 'Host: api.toystore.com' http://$KUADRANT_GATEWAY_URL/toy -i\n# HTTP/1.1 200 OK\n</code></pre> <pre><code>curl -H \"Authorization: Bearer $KUADRANT_SA_TOKEN\" -H 'Host: api.toystore.com' -X POST http://$KUADRANT_GATEWAY_URL/admin/toy -i\n# HTTP/1.1 403 Forbidden\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/authenticated-rl-with-jwt-and-k8s-authnz/#enforce-rate-limiting-on-requests-to-the-toy-store-api","title":"Enforce rate limiting on requests to the Toy Store API","text":"<p>Create a Kuadrant <code>RateLimitPolicy</code> to configure rate limiting:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1\nkind: RateLimitPolicy\nmetadata:\n  name: toystore\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: toystore\n  limits:\n    \"per-user\":\n      rates:\n\n      - limit: 5\n        window: 10s\n      counters:\n      - expression: auth.identity.userid\nEOF\n</code></pre> <p>Note: It may take a couple of minutes for the RateLimitPolicy to be applied depending on your cluster.</p>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/authenticated-rl-with-jwt-and-k8s-authnz/#try-the-api-rate-limited","title":"Try the API rate limited","text":"<p>Each user should be entitled to a maximum of 5 requests every 10 seconds.</p> <p>Note: If the tokens have expired, you may need to refresh them first.</p> <p>Send requests as the Keycloak-authenticated user:</p> <pre><code>while :; do curl --write-out '%{http_code}\\n' --silent --output /dev/null -H \"Authorization: Bearer $KUADRANT_ACCESS_TOKEN\" -H 'Host: api.toystore.com' http://$KUADRANT_GATEWAY_URL/toy | grep -E --color \"\\b(429)\\b|$\"; sleep 1; done\n</code></pre> <p>Send requests as the Kubernetes service account:</p> <pre><code>while :; do curl --write-out '%{http_code}\\n' --silent --output /dev/null -H \"Authorization: Bearer $KUADRANT_SA_TOKEN\" -H 'Host: api.toystore.com' http://$KUADRANT_GATEWAY_URL/toy | grep -E --color \"\\b(429)\\b|$\"; sleep 1; done\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/gateway-rl-for-cluster-operators/","title":"Gateway Rate Limiting for Cluster Operators","text":"<p>For more info on the different personas see Gateway API </p> <p>This tutorial walks you through an example of how to configure rate limiting for all routes attached to a specific ingress gateway.</p>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/gateway-rl-for-cluster-operators/#prerequisites","title":"Prerequisites","text":"<ul> <li>Kubernetes cluster with Kuadrant operator installed. See our Getting Started guide for more information.</li> <li>kubectl command line tool.</li> </ul>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/gateway-rl-for-cluster-operators/#deploy-the-toystore-example-api","title":"Deploy the Toystore example API:","text":"<pre><code>kubectl apply -f https://raw.githubusercontent.com/Kuadrant/Kuadrant-operator/main/examples/toystore/toystore.yaml\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/gateway-rl-for-cluster-operators/#create-the-ingress-gateways","title":"Create the ingress gateways","text":"<pre><code>kubectl -n gateway-system apply -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1\nkind: Gateway\nmetadata:\n  name: external\n  annotations:\n    kuadrant.io/namespace: kuadrant-system\n    networking.istio.io/service-type: ClusterIP\nspec:\n  gatewayClassName: istio\n  listeners:\n\n  - name: external\n    port: 80\n    protocol: HTTP\n    hostname: '*.io'\n    allowedRoutes:\n      namespaces:\n        from: All\n---\napiVersion: gateway.networking.k8s.io/v1\nkind: Gateway\nmetadata:\n  name: internal\n  annotations:\n    kuadrant.io/namespace: kuadrant-system\n    networking.istio.io/service-type: ClusterIP\nspec:\n  gatewayClassName: istio\n  listeners:\n  - name: local\n    port: 80\n    protocol: HTTP\n    hostname: '*.local'\n    allowedRoutes:\n      namespaces:\n        from: All\nEOF\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/gateway-rl-for-cluster-operators/#enforce-rate-limiting-on-requests-incoming-through-the-external-gateway","title":"Enforce rate limiting on requests incoming through the <code>external</code> gateway","text":"<pre><code>    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 (Gateway) \u2502      \u2502 (Gateway) \u2502\n    \u2502  external \u2502      \u2502  internal \u2502\n    \u2502           \u2502      \u2502           \u2502\n    \u2502   *.io    \u2502      \u2502  *.local  \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n          \u25b2\n          \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 (RateLimitPolicy) \u2502\n\u2502       gw-rlp      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Create a Kuadrant <code>RateLimitPolicy</code> to configure rate limiting:</p> <pre><code>kubectl apply -n gateway-system -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1\nkind: RateLimitPolicy\nmetadata:\n  name: gw-rlp\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: external\n  limits:\n    \"global\":\n      rates:\n\n      - limit: 5\n        window: 10s\nEOF\n</code></pre> <p>Note: It may take a couple of minutes for the RateLimitPolicy to be applied depending on your cluster.</p>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/gateway-rl-for-cluster-operators/#deploy-a-sample-api-to-test-rate-limiting-enforced-at-the-level-of-the-gateway","title":"Deploy a sample API to test rate limiting enforced at the level of the gateway","text":"<pre><code>                           \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u2502 (Gateway) \u2502      \u2502 (Gateway) \u2502\n\u2502 (RateLimitPolicy) \u2502      \u2502  external \u2502      \u2502  internal \u2502\n\u2502       gw-rlp      \u251c\u2500\u2500\u2500\u2500\u2500\u25ba\u2502           \u2502      \u2502           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2502   *.io    \u2502      \u2502  *.local  \u2502\n                           \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518\n                                 \u2502                  \u2502\n                                 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                           \u2502\n                                 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                                 \u2502   (HTTPRoute)    \u2502\n                                 \u2502     toystore     \u2502\n                                 \u2502                  \u2502\n                                 \u2502 *.toystore.io    \u2502\n                                 \u2502 *.toystore.local \u2502\n                                 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                          \u2502\n                                   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                                   \u2502   (Service)  \u2502\n                                   \u2502   toystore   \u2502\n                                   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/gateway-rl-for-cluster-operators/#route-traffic-to-the-api-from-both-gateways","title":"Route traffic to the API from both gateways:","text":"<pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: toystore\nspec:\n  parentRefs:\n\n  - name: external\n    namespace: gateway-system\n  - name: internal\n    namespace: gateway-system\n  hostnames:\n  - \"*.toystore.io\"\n  - \"*.toystore.local\"\n  rules:\n  - backendRefs:\n    - name: toystore\n      port: 80\nEOF\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/gateway-rl-for-cluster-operators/#verify-the-rate-limiting-works-by-sending-requests-in-a-loop","title":"Verify the rate limiting works by sending requests in a loop","text":"<p>Expose the gateways, respectively at the port numbers <code>9081</code> and <code>9082</code> of the local host:</p> <pre><code>kubectl port-forward -n gateway-system service/external-istio 9081:80 &gt;/dev/null 2&gt;&amp;1 &amp;\nkubectl port-forward -n gateway-system service/internal-istio 9082:80 &gt;/dev/null 2&gt;&amp;1 &amp;\n</code></pre> <p>Up to 5 successful (<code>200 OK</code>) requests every 10 seconds through the <code>external</code> ingress gateway (<code>*.io</code>), then <code>429 Too Many Requests</code>:</p> <pre><code>while :; do curl --write-out '%{http_code}\\n' --silent --output /dev/null -H 'Host: api.toystore.io' http://localhost:9081 | grep -E --color \"\\b(429)\\b|$\"; sleep 1; done\n</code></pre> <p>Unlimited successful (<code>200 OK</code>) through the <code>internal</code> ingress gateway (<code>*.local</code>):</p> <pre><code>while :; do curl --write-out '%{http_code}\\n' --silent --output /dev/null -H 'Host: api.toystore.local' http://localhost:9082 | grep -E --color \"\\b(429)\\b|$\"; sleep 1; done\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/multi-auth-rlp-diff-section/","title":"Gateway Rate Limiting","text":"<p>This tutorial walks you through an example of how to configure multiple rate limit polices for different listeners in an ingress gateway. </p>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/multi-auth-rlp-diff-section/#prerequisites","title":"Prerequisites","text":"<ul> <li>Kubernetes cluster with Kuadrant operator installed. See our Getting Started guide for more information.</li> <li>kubectl command line tool.</li> </ul>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/multi-auth-rlp-diff-section/#deploy-the-sample-api","title":"Deploy the sample API:","text":"<pre><code>kubectl apply -f https://raw.githubusercontent.com/Kuadrant/Kuadrant-operator/main/examples/toystore/toystore.yaml\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/multi-auth-rlp-diff-section/#create-the-ingress-gateways","title":"Create the ingress gateways","text":"<pre><code>kubectl -n kuadrant-system apply -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1\nkind: Gateway\nmetadata:\n  name: environment\n  annotations:\n    kuadrant.io/namespace: kuadrant-system\n    networking.istio.io/service-type: ClusterIP\nspec:\n  gatewayClassName: istio\n  listeners:\n\n  - name: external\n    port: 80\n    protocol: HTTP\n    hostname: '*.io'\n    allowedRoutes:\n      namespaces:\n        from: All\n  - name: local\n    port: 80\n    protocol: HTTP\n    hostname: '*.local'\n    allowedRoutes:\n      namespaces:\n        from: All\nEOF\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/multi-auth-rlp-diff-section/#route-traffic-to-the-api-from-both-gateways-listeners","title":"Route traffic to the API from both gateways listeners","text":"<pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: toystore\nspec:\n  parentRefs:\n\n  - name: environment\n    namespace: kuadrant-system\n  hostnames:\n  - \"*.toystore.io\"\n  - \"*.toystore.local\"\n  rules:\n  - backendRefs:\n    - name: toystore\n      port: 80\nEOF\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/multi-auth-rlp-diff-section/#create-a-kuadrant-ratelimitpolicy-to-configure-rate-limiting-for-the-external-listener","title":"Create a Kuadrant <code>RateLimitPolicy</code> to configure rate limiting for the external listener:","text":"<pre><code>kubectl apply -n kuadrant-system -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1\nkind: RateLimitPolicy\nmetadata:\n  name: gw-rlp-external\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: environment\n    sectionName: external\n  defaults:\n    strategy: merge\n    limits:\n      \"external\":\n        rates:\n\n        - limit: 2\n          window: 10s\nEOF\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/multi-auth-rlp-diff-section/#create-a-kuadrant-ratelimitpolicy-to-configure-rate-limiting-for-the-local-listener","title":"Create a Kuadrant <code>RateLimitPolicy</code> to configure rate limiting for the local listener:","text":"<pre><code>kubectl apply -n kuadrant-system -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1\nkind: RateLimitPolicy\nmetadata:\n  name: gw-rlp-local\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: environment\n    sectionName: local\n  defaults:\n    strategy: merge\n    limits:\n      \"local\":\n        rates:\n\n        - limit: 5\n          window: 10s\nEOF\n</code></pre> <p>Note: It may take a couple of minutes for the RateLimitPolicy to be applied depending on your cluster.</p>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/multi-auth-rlp-diff-section/#verify-the-rate-limiting-works-by-sending-requests-in-a-loop","title":"Verify the rate limiting works by sending requests in a loop","text":"<p>Expose the gateways, respectively at the port numbers <code>9081</code> and <code>9082</code> of the local host:</p> <pre><code>kubectl port-forward -n gateway-system service/environment-istio 9081:80 &gt;/dev/null 2&gt;&amp;1 &amp;\n</code></pre> <p>Up to 5 successful (<code>200 OK</code>) requests every 10 seconds through the <code>external</code> ingress gateway (<code>*.io</code>), then <code>429 Too Many Requests</code>:</p> <pre><code>while :; do curl --write-out '%{http_code}\\n' --silent --output /dev/null -H 'Host: api.toystore.io' http://localhost:9081 | grep -E --color \"\\b(429)\\b|$\"; sleep 1; done\n</code></pre> <p>Unlimited successful (<code>200 OK</code>) through the <code>internal</code> ingress gateway (<code>*.local</code>):</p> <pre><code>while :; do curl --write-out '%{http_code}\\n' --silent --output /dev/null -H 'Host: api.toystore.local' http://localhost:9081 | grep -E --color \"\\b(429)\\b|$\"; sleep 1; done\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/multi-auth-rlp-same-section/","title":"Multi authenticated Rate Limiting for an Application","text":"<p>This tutorial walks you through an example of how to configure multiple authenticated rate limiting for an application using Kuadrant. </p> <p>Authenticated rate limiting, rate limits the traffic directed to an application based on attributes of the client user, who is authenticated by some authentication method. A few examples of authenticated rate limiting use cases are:</p> <ul> <li>User A can send up to 50rps (\"requests per second\"), while User B can send up to 100rps.</li> <li>Each user can send up to 20rpm (\"request per minute\").</li> <li>Admin users (members of the 'admin' group) can send up to 100rps, while regular users (non-admins) can send up to 20rpm and no more than 5rps.</li> </ul> <p>In this tutorial, we will rate limit a sample REST API called Toy Store, an echo service that echoes back to the user whatever attributes it gets in the request. The API exposes an endpoint at <code>GET http://api.toystore.com/toy</code>, to mimic an operation of reading toy records.</p> <p>We will define 2 users of the API, which can send requests to the API at different rates, based on their user IDs. The authentication method used is API key.</p> User ID Rate limit alice 5rp10s (\"5 requests every 10 seconds\") bob 2rp10s (\"2 requests every 10 seconds\")"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/multi-auth-rlp-same-section/#prerequisites","title":"Prerequisites","text":"<ul> <li>Kubernetes cluster with Kuadrant operator installed. See our Getting Started guide for more information.</li> <li>kubectl command line tool.</li> </ul>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/multi-auth-rlp-same-section/#setup-environment-variables","title":"Setup environment variables","text":"<p>Set the following environment variables used for convenience in this tutorial:</p> <pre><code>export KUADRANT_GATEWAY_NS=api-gateway # Namespace for the example Gateway\nexport KUADRANT_GATEWAY_NAME=external # Name for the example Gateway\nexport KUADRANT_DEVELOPER_NS=toystore # Namespace for an example toystore app\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/multi-auth-rlp-same-section/#create-an-ingress-gateway","title":"Create an Ingress Gateway","text":"<p>Create the namespace the Gateway will be deployed in:</p> <pre><code>kubectl create ns ${KUADRANT_GATEWAY_NS}\n</code></pre> <p>Create a gateway using toystore as the listener hostname:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1\nkind: Gateway\nmetadata:\n  name: ${KUADRANT_GATEWAY_NAME}\n  namespace: ${KUADRANT_GATEWAY_NS}\n  labels:\n    kuadrant.io/gateway: \"true\"\nspec:\n  gatewayClassName: istio\n  listeners:\n\n    - name: http\n      protocol: HTTP\n      port: 80\n      allowedRoutes:\n        namespaces:\n          from: All\nEOF\n</code></pre> <p>Check the status of the <code>Gateway</code> ensuring the gateway is Accepted and Programmed:</p> <pre><code>kubectl get gateway ${KUADRANT_GATEWAY_NAME} -n ${KUADRANT_GATEWAY_NS} -o=jsonpath='{.status.conditions[?(@.type==\"Accepted\")].message}{\"\\n\"}{.status.conditions[?(@.type==\"Programmed\")].message}{\"\\n\"}'\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/multi-auth-rlp-same-section/#deploy-the-toy-store-api","title":"Deploy the Toy Store API","text":"<pre><code>kubectl apply -f https://raw.githubusercontent.com/Kuadrant/Kuadrant-operator/main/examples/toystore/toystore.yaml\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/multi-auth-rlp-same-section/#create-a-httproute-to-route-traffic-to-the-service-via-istio-ingress-gateway","title":"Create a HTTPRoute to route traffic to the service via Istio Ingress Gateway:","text":"<pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: toystore\nspec:\n  parentRefs:\n\n  - name: ${KUADRANT_GATEWAY_NAME}\n    namespace: ${KUADRANT_GATEWAY_NS}\n  hostnames:\n  - api.toystore.com\n  rules:\n  - matches:\n    - path:\n        type: Exact\n        value: \"/toy\"\n      method: GET\n    - path:\n        type: Exact\n        value: \"/car\"\n      method: GET\n    backendRefs:\n    - name: toystore\n      port: 80\nEOF\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/multi-auth-rlp-same-section/#export-the-gateway-hostname-and-port","title":"Export the gateway hostname and port:","text":"<pre><code>export KUADRANT_INGRESS_HOST=$(kubectl get gtw ${KUADRANT_GATEWAY_NAME} -n ${KUADRANT_GATEWAY_NS} -o jsonpath='{.status.addresses[0].value}')\nexport KUADRANT_INGRESS_PORT=$(kubectl get gtw ${KUADRANT_GATEWAY_NAME} -n ${KUADRANT_GATEWAY_NS} -o jsonpath='{.spec.listeners[?(@.name==\"http\")].port}')\nexport KUADRANT_GATEWAY_URL=${KUADRANT_INGRESS_HOST}:${KUADRANT_INGRESS_PORT}\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/multi-auth-rlp-same-section/#verify-the-route-works","title":"Verify the route works:","text":"<pre><code>curl -H 'Host: api.toystore.com' http://$KUADRANT_GATEWAY_URL/toy -i\n# HTTP/1.1 200 OK\n</code></pre> <p>Note: If the command above fails to hit the Toy Store API on your environment, try forwarding requests to the service and accessing over localhost:</p> <pre><code>kubectl port-forward -n ${KUADRANT_GATEWAY_NS} service/${KUADRANT_GATEWAY_NAME}-istio 9080:80 &gt;/dev/null 2&gt;&amp;1 &amp;\nexport KUADRANT_GATEWAY_URL=localhost:9080\n</code></pre> <pre><code>curl -H 'Host: api.toystore.com' http://$KUADRANT_GATEWAY_URL/toy -i\n# HTTP/1.1 200 OK\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/multi-auth-rlp-same-section/#enforce-authentication-on-requests-to-the-toy-store-api","title":"Enforce authentication on requests to the Toy Store API","text":"<p>Create a Kuadrant <code>AuthPolicy</code> to configure the authentication:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1\nkind: AuthPolicy\nmetadata:\n  name: toystore\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: toystore\n  rules:\n    authentication:\n      \"api-key-users\":\n        apiKey:\n          selector:\n            matchLabels:\n              app: toystore\n          allNamespaces: true\n        credentials:\n          authorizationHeader:\n            prefix: APIKEY\n    response:\n      success:\n        filters:\n          \"identity\":\n            json:\n              properties:\n                \"userid\":\n                  selector: auth.identity.metadata.annotations.secret\\.kuadrant\\.io/user-id\nEOF\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/multi-auth-rlp-same-section/#verify-the-authentication-works-by-sending-a-request-to-the-toy-store-api-without-api-key","title":"Verify the authentication works by sending a request to the Toy Store API without API key:","text":"<pre><code>curl -H 'Host: api.toystore.com' http://$KUADRANT_GATEWAY_URL/toy -i\n# HTTP/1.1 401 Unauthorized\n# www-authenticate: APIKEY realm=\"api-key-users\"\n# x-ext-auth-reason: \"credential not found\"\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/multi-auth-rlp-same-section/#create-api-keys-for-users-alice-and-bob-to-authenticate","title":"Create API keys for users <code>alice</code> and <code>bob</code> to authenticate:","text":"<p>Note: Kuadrant stores API keys as Kubernetes Secret resources. User metadata can be stored in the annotations of the resource.</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: bob-key\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    app: toystore\n  annotations:\n    secret.kuadrant.io/user-id: bob\nstringData:\n  api_key: IAMBOB\ntype: Opaque\n---\napiVersion: v1\nkind: Secret\nmetadata:\n  name: alice-key\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    app: toystore\n  annotations:\n    secret.kuadrant.io/user-id: alice\nstringData:\n  api_key: IAMALICE\ntype: Opaque\nEOF\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/multi-auth-rlp-same-section/#enforce-authenticated-rate-limiting-on-requests-to-the-toy-store-api","title":"Enforce authenticated rate limiting on requests to the Toy Store API","text":"<p>Create Kuadrant <code>RateLimitPolicy's</code> to configure rate limiting for Bob and Alice:</p>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/multi-auth-rlp-same-section/#bob","title":"Bob","text":"<pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1\nkind: RateLimitPolicy\nmetadata:\n  name: toystore\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: toystore\n    sectionName: rule-1\n  defaults:\n    strategy: merge\n    limits:\n      \"bob-limit\":\n        rates:\n\n        - limit: 2\n          window: 10s\n        when:\n        - predicate: \"auth.identity.userid == 'bob'\"\nEOF\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/multi-auth-rlp-same-section/#alice","title":"Alice","text":"<pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1\nkind: RateLimitPolicy\nmetadata:\n  name: toystore-alice\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: toystore\n    sectionName: rule-1\n  defaults:\n    strategy: merge\n    limits:\n      \"alice-limit\":\n        rates:\n\n        - limit: 5\n          window: 10s\n        when:\n        - predicate: \"auth.identity.userid == 'alice'\"\nEOF\n</code></pre> <p>Note: It may take a couple of minutes for the RateLimitPolicy to be applied depending on your cluster.</p> <p>Verify the rate limiting works by sending requests as Alice and Bob.</p> <p>Up to 5 successful (<code>200 OK</code>) requests every 10 seconds allowed for Alice, then <code>429 Too Many Requests</code>:</p> <pre><code>while :; do curl --write-out '%{http_code}\\n' --silent --output /dev/null -H 'Authorization: APIKEY IAMALICE' -H 'Host: api.toystore.com' http://$KUADRANT_GATEWAY_URL/toy | grep -E --color \"\\b(429)\\b|$\"; sleep 1; done\n</code></pre> <p>Up to 2 successful (<code>200 OK</code>) requests every 10 seconds allowed for Bob, then <code>429 Too Many Requests</code>:</p> <pre><code>while :; do curl --write-out '%{http_code}\\n' --silent --output /dev/null -H 'Authorization: APIKEY IAMBOB' -H 'Host: api.toystore.com' http://$KUADRANT_GATEWAY_URL/toy | grep -E --color \"\\b(429)\\b|$\"; sleep 1; done\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/simple-rl-for-app-developers/","title":"Simple Rate Limiting for Application developers","text":"<p>For more info on the different personas see Gateway API </p> <p>This tutorial walks you through an example of how to configure rate limiting for an endpoint of an application using Kuadrant.</p> <p>In this tutorial, we will rate limit a sample REST API called Toy Store. In reality, this API is just an echo service that echoes back to the user whatever attributes it gets in the request. The API listens to requests at the hostname <code>api.toystore.com</code>, where it exposes the endpoints <code>GET /toys*</code> and <code>POST /toys</code>, respectively, to mimic operations of reading and writing toy records.</p> <p>We will rate limit the <code>POST /toys</code> endpoint to a maximum of 5rp10s (\"5 requests every 10 seconds\").</p>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/simple-rl-for-app-developers/#prerequisites","title":"Prerequisites","text":"<ul> <li>Kubernetes cluster with Kuadrant operator installed. See our Getting Started guide for more information.</li> <li>kubectl command line tool.</li> </ul>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/simple-rl-for-app-developers/#setup-environment-variables","title":"Setup environment variables","text":"<p>Set the following environment variables used for convenience in this tutorial:</p> <pre><code>export KUADRANT_GATEWAY_NS=api-gateway # Namespace for the example Gateway\nexport KUADRANT_GATEWAY_NAME=external # Name for the example Gateway\nexport KUADRANT_DEVELOPER_NS=toystore # Namespace for an example toystore app\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/simple-rl-for-app-developers/#create-an-ingress-gateway","title":"Create an Ingress Gateway","text":"<p>Create the namespace the Gateway will be deployed in:</p> <pre><code>kubectl create ns ${KUADRANT_GATEWAY_NS}\n</code></pre> <p>Create a gateway using toystore as the listener hostname:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1\nkind: Gateway\nmetadata:\n  name: ${KUADRANT_GATEWAY_NAME}\n  namespace: ${KUADRANT_GATEWAY_NS}\n  labels:\n    kuadrant.io/gateway: \"true\"\nspec:\n  gatewayClassName: istio\n  listeners:\n\n    - name: http\n      protocol: HTTP\n      port: 80\n      allowedRoutes:\n        namespaces:\n          from: All\nEOF\n</code></pre> <p>Check the status of the <code>Gateway</code> ensuring the gateway is Accepted and Programmed:</p> <pre><code>kubectl get gateway ${KUADRANT_GATEWAY_NAME} -n ${KUADRANT_GATEWAY_NS} -o=jsonpath='{.status.conditions[?(@.type==\"Accepted\")].message}{\"\\n\"}{.status.conditions[?(@.type==\"Programmed\")].message}{\"\\n\"}'\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/simple-rl-for-app-developers/#deploy-the-toy-store-api","title":"Deploy the Toy Store API","text":"<p>Create the deployment:</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/Kuadrant/Kuadrant-operator/main/examples/toystore/toystore.yaml\n</code></pre> <p>Create a HTTPRoute to route traffic to the service via Istio Ingress Gateway:</p> <p></p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: toystore\nspec:\n  parentRefs:\n\n  - name: ${KUADRANT_GATEWAY_NAME}\n    namespace: ${KUADRANT_GATEWAY_NS}\n  hostnames:\n  - api.toystore.com\n  rules:\n  - matches:\n    - method: GET\n      path:\n        type: PathPrefix\n        value: \"/toys\"\n    backendRefs:\n    - name: toystore\n      port: 80\n  - matches: # it has to be a separate HTTPRouteRule so we do not rate limit other endpoints\n    - method: POST\n      path:\n        type: Exact\n        value: \"/toys\"\n    backendRefs:\n    - name: toystore\n      port: 80\nEOF\n</code></pre> <p>Export the gateway hostname and port:</p> <pre><code>export KUADRANT_INGRESS_HOST=$(kubectl get gtw ${KUADRANT_GATEWAY_NAME} -n ${KUADRANT_GATEWAY_NS} -o jsonpath='{.status.addresses[0].value}')\nexport KUADRANT_INGRESS_PORT=$(kubectl get gtw ${KUADRANT_GATEWAY_NAME} -n ${KUADRANT_GATEWAY_NS} -o jsonpath='{.spec.listeners[?(@.name==\"http\")].port}')\nexport KUADRANT_GATEWAY_URL=${KUADRANT_INGRESS_HOST}:${KUADRANT_INGRESS_PORT}\n</code></pre> <p>Verify the route works:</p> <pre><code>curl -H 'Host: api.toystore.com' http://$KUADRANT_GATEWAY_URL/toys -i\n# HTTP/1.1 200 OK\n</code></pre> <p>Note: If the command above fails to hit the Toy Store API on your environment, try forwarding requests to the service and accessing over localhost:</p> <pre><code>kubectl port-forward -n ${KUADRANT_GATEWAY_NS} service/${KUADRANT_GATEWAY_NAME}-istio 9080:80 &gt;/dev/null 2&gt;&amp;1 &amp;\nexport KUADRANT_GATEWAY_URL=localhost:9080\n</code></pre> <pre><code>curl -H 'Host: api.toystore.com' http://$KUADRANT_GATEWAY_URL/toy -i\n# HTTP/1.1 200 OK\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/simple-rl-for-app-developers/#enforce-rate-limiting-on-requests-to-the-toy-store-api","title":"Enforce rate limiting on requests to the Toy Store API","text":"<p>Create a Kuadrant <code>RateLimitPolicy</code> to configure rate limiting:</p> <p></p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1\nkind: RateLimitPolicy\nmetadata:\n  name: toystore\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: toystore\n    sectionName: rule-2\n  limits:\n    \"create-toy\":\n      rates:\n\n      - limit: 5\n        window: 10s\n      when:\n      - predicate: \"request.method == 'POST'\"\nEOF\n</code></pre> <p>Note: It may take a couple of minutes for the RateLimitPolicy to be applied depending on your cluster.</p> <p>Verify the rate limiting works by sending requests in a loop.</p> <p>Up to 5 successful (<code>200 OK</code>) requests every 10 seconds to <code>POST /toys</code>, then <code>429 Too Many Requests</code>:</p> <pre><code>while :; do curl --write-out '%{http_code}\\n' --silent --output /dev/null -H 'Host: api.toystore.com' http://$KUADRANT_GATEWAY_URL/toys -X POST | grep -E --color \"\\b(429)\\b|$\"; sleep 1; done\n</code></pre> <p>Unlimited successful (<code>200 OK</code>) to <code>GET /toys</code>:</p> <pre><code>while :; do curl --write-out '%{http_code}\\n' --silent --output /dev/null -H 'Host: api.toystore.com' http://$KUADRANT_GATEWAY_URL/toys | grep -E --color \"\\b(429)\\b|$\"; sleep 1; done\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/tls/gateway-tls/","title":"Gateway TLS for Cluster Operators","text":"<p>This tutorial walks you through an example of how to configure TLS for all routes attached to an ingress gateway. </p>"},{"location":"kuadrant-operator/doc/user-guides/tls/gateway-tls/#prerequisites","title":"Prerequisites","text":"<ul> <li>Kubernetes cluster with Kuadrant operator installed. See our Getting Started guide for more information.</li> <li>kubectl command line tool.</li> </ul>"},{"location":"kuadrant-operator/doc/user-guides/tls/gateway-tls/#setup","title":"Setup","text":"<pre><code>kubectl create namespace my-gateways\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/tls/gateway-tls/#create-an-ingress-gateway","title":"Create an ingress gateway","text":"<p>Create a gateway:</p> <pre><code>kubectl -n my-gateways apply -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1\nkind: Gateway\nmetadata:\n  name: prod-web\nspec:\n  gatewayClassName: istio\n  listeners:\n\n    - allowedRoutes:\n        namespaces:\n          from: All\n      name: api\n      hostname: \"*.toystore.local\"\n      port: 443\n      protocol: HTTPS\n      tls:\n        mode: Terminate\n        certificateRefs:\n          - name: toystore-local-tls\n            kind: Secret\nEOF\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/tls/gateway-tls/#enable-tls-on-the-gateway","title":"Enable TLS on the gateway","text":"<p>The TLSPolicy requires a reference to an existing CertManager Issuer.</p> <p>Create a CertManager Issuer:</p> <pre><code>kubectl apply -n my-gateways -f - &lt;&lt;EOF\napiVersion: cert-manager.io/v1\nkind: Issuer\nmetadata:\n  name: selfsigned-issuer\nspec:\n  selfSigned: {}\nEOF\n</code></pre> <p>Note: We are using a self-signed issuer here but any supported CerManager issuer or cluster issuer can be used.</p> <pre><code>kubectl get issuer selfsigned-issuer -n my-gateways\n</code></pre> <p>Response:</p> <pre><code>NAME                        READY   AGE\nselfsigned-issuer   True    18s\n</code></pre> <p>Create a Kuadrant <code>TLSPolicy</code> to configure TLS:</p> <pre><code>kubectl apply -n my-gateways -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1\nkind: TLSPolicy\nmetadata:\n  name: prod-web\nspec:\n  targetRef:\n    name: prod-web\n    group: gateway.networking.k8s.io\n    kind: Gateway\n  issuerRef:\n    group: cert-manager.io\n    kind: Issuer\n    name: selfsigned-issuer\nEOF\n</code></pre> <p>Check policy status:</p> <pre><code>kubectl get tlspolicy -o wide -n my-gateways\n</code></pre> <p>Response:</p> <pre><code>NAME       STATUS     TARGETREFKIND   TARGETREFNAME   AGE\nprod-web   Accepted   Gateway         prod-web        13s\n</code></pre> <p>Check a Certificate resource was created:</p> <pre><code>kubectl get certificates -n my-gateways\n</code></pre> <p>Response</p> <pre><code>NAME                 READY   SECRET               AGE\ntoystore-local-tls   True    toystore-local-tls   7m30s\n</code></pre> <p>Check a TLS Secret resource was created:</p> <pre><code>kubectl get secrets -n my-gateways --field-selector=\"type=kubernetes.io/tls\"\n</code></pre> <p>Response:</p> <pre><code>NAME                 TYPE                DATA   AGE\ntoystore-local-tls   kubernetes.io/tls   3      7m42s\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/tls/gateway-tls/#deploy-a-sample-api-to-test-tls","title":"Deploy a sample API to test TLS","text":"<p>Deploy the sample API:</p> <pre><code>kubectl -n my-gateways apply -f https://raw.githubusercontent.com/Kuadrant/Kuadrant-operator/main/examples/toystore/toystore.yaml\nkubectl -n my-gateways wait --for=condition=Available deployments toystore --timeout=60s\n</code></pre> <p>Route traffic to the API from our gateway:</p> <pre><code>kubectl -n my-gateways apply -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: toystore\nspec:\n  parentRefs:\n\n  - name: prod-web\n    namespace: my-gateways\n  hostnames:\n  - \"*.toystore.local\"\n  rules:\n  - backendRefs:\n    - name: toystore\n      port: 80\nEOF\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/tls/gateway-tls/#verify-tls-works-by-sending-requests","title":"Verify TLS works by sending requests","text":"<p>Get the gateway address@</p> <pre><code>GWADDRESS=`kubectl get gateway/prod-web -n my-gateways -o=jsonpath='{.status.addresses[?(@.type==\"IPAddress\")].value}'`\necho $GWADDRESS\n</code></pre> <p>Response:</p> <pre><code>172.18.200.1\n</code></pre> <p>Verify we can access the service via TLS:</p> <pre><code>curl -vkI https://api.toystore.local --resolve \"api.toystore.local:443:$GWADDRESS\"\n</code></pre> <p>Response:</p> <pre><code>* Added api.toystore.local:443:172.18.200.1 to DNS cache\n* Hostname api.toystore.local was found in DNS cache\n*   Trying 172.18.200.1:443...\n* Connected to api.toystore.local (172.18.200.1) port 443 (#0)\n* ALPN: offers h2\n* ALPN: offers http/1.1\n* TLSv1.0 (OUT), TLS header, Certificate Status (22):\n* TLSv1.3 (OUT), TLS handshake, Client hello (1):\n* TLSv1.2 (IN), TLS header, Certificate Status (22):\n* TLSv1.3 (IN), TLS handshake, Server hello (2):\n* TLSv1.2 (IN), TLS header, Finished (20):\n* TLSv1.2 (IN), TLS header, Supplemental data (23):\n* TLSv1.3 (IN), TLS handshake, Encrypted Extensions (8):\n* TLSv1.3 (IN), TLS handshake, Certificate (11):\n* TLSv1.3 (IN), TLS handshake, CERT verify (15):\n* TLSv1.3 (IN), TLS handshake, Finished (20):\n* TLSv1.2 (OUT), TLS header, Finished (20):\n* TLSv1.3 (OUT), TLS change cipher, Change cipher spec (1):\n* TLSv1.2 (OUT), TLS header, Supplemental data (23):\n* TLSv1.3 (OUT), TLS handshake, Finished (20):\n* SSL connection using TLSv1.3 / TLS_AES_256_GCM_SHA384\n* ALPN: server accepted h2\n* Server certificate:\n*  subject: [NONE]\n*  start date: Feb 15 11:46:50 2024 GMT\n*  expire date: May 15 11:46:50 2024 GMT\n* Using HTTP2, server supports multiplexing\n* Copying HTTP/2 data in stream buffer to connection buffer after upgrade: len=0\n* TLSv1.2 (OUT), TLS header, Supplemental data (23):\n* TLSv1.2 (OUT), TLS header, Supplemental data (23):\n* TLSv1.2 (OUT), TLS header, Supplemental data (23):\n* h2h3 [:method: HEAD]\n* h2h3 [:path: /]\n* h2h3 [:scheme: https]\n* h2h3 [:authority: api.toystore.local]\n* h2h3 [user-agent: curl/7.85.0]\n* h2h3 [accept: */*]\n* Using Stream ID: 1 (easy handle 0x5623e4fe5bf0)\n* TLSv1.2 (OUT), TLS header, Supplemental data (23):\n&gt; HEAD / HTTP/2\n&gt; Host: api.toystore.local\n&gt; user-agent: curl/7.85.0\n&gt; accept: */*\n&gt;\n* TLSv1.2 (IN), TLS header, Supplemental data (23):\n* TLSv1.3 (IN), TLS handshake, Newsession Ticket (4):\n* TLSv1.3 (IN), TLS handshake, Newsession Ticket (4):\n* old SSL session ID is stale, removing\n* TLSv1.2 (IN), TLS header, Supplemental data (23):\n* Connection state changed (MAX_CONCURRENT_STREAMS == 2147483647)!\n* TLSv1.2 (OUT), TLS header, Supplemental data (23):\n* TLSv1.2 (IN), TLS header, Supplemental data (23):\n&lt; HTTP/2 200\nHTTP/2 200\n&lt; content-type: application/json\ncontent-type: application/json\n&lt; server: istio-envoy\nserver: istio-envoy\n&lt; date: Thu, 15 Feb 2024 12:13:27 GMT\ndate: Thu, 15 Feb 2024 12:13:27 GMT\n&lt; content-length: 1658\ncontent-length: 1658\n&lt; x-envoy-upstream-service-time: 1\nx-envoy-upstream-service-time: 1\n\n&lt;\n\n* Connection #0 to host api.toystore.local left intact\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/tokenratelimitpolicy/authenticated-token-ratelimiting-tutorial/","title":"Token-based Rate Limiting for Large Language Model APIs","text":"<p>This tutorial walks you through configuring token-based rate limiting using Kuadrant's <code>TokenRateLimitPolicy</code> to protect Large Language Model (LLM) APIs. Unlike traditional request counting, this approach limits API usage based on actual token consumption.</p>"},{"location":"kuadrant-operator/doc/user-guides/tokenratelimitpolicy/authenticated-token-ratelimiting-tutorial/#overview","title":"Overview","text":"<p>Traditional rate limiting counts requests, but LLM APIs have varying computational costs based on token usage. <code>TokenRateLimitPolicy</code> addresses this by:</p> <ul> <li>Counting actual tokens consumed from LLM responses</li> <li>Setting different limits for different user tiers when combined with <code>AuthPolicy</code></li> <li>Integrating seamlessly with authentication policies</li> </ul>"},{"location":"kuadrant-operator/doc/user-guides/tokenratelimitpolicy/authenticated-token-ratelimiting-tutorial/#prerequisites","title":"Prerequisites","text":"<ul> <li>Kubernetes cluster with Kuadrant operator installed. See our Getting Started guide for more information.</li> <li>kubectl command line tool.</li> <li>Basic understanding of Gateway API.</li> </ul> <p>You should also have an instance of <code>Kuadrant</code> installed:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1beta1\nkind: Kuadrant\nmetadata:\n  name: kuadrant\n  namespace: kuadrant-system\nEOF\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/tokenratelimitpolicy/authenticated-token-ratelimiting-tutorial/#environment-variables","title":"Environment variables","text":"<p>Set the following environment variables used throughout this tutorial:</p> <pre><code>export KUADRANT_GATEWAY_NS=gateway-system\nexport KUADRANT_GATEWAY_NAME=trlp-tutorial-gateway\nexport KUADRANT_SYSTEM_NS=$(kubectl get kuadrant -A -o jsonpath='{.items[0].metadata.namespace}')\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/tokenratelimitpolicy/authenticated-token-ratelimiting-tutorial/#step-1-deploy-an-llm-service","title":"Step 1: Deploy an LLM service","text":"<p>Deploy a simulated LLM service that mimics OpenAI-compatible APIs:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: trlp-tutorial-llm-sim\n  labels:\n    app: trlp-tutorial-llm-sim\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: trlp-tutorial-llm-sim\n  template:\n    metadata:\n      labels:\n        app: trlp-tutorial-llm-sim\n    spec:\n      containers:\n\n      - name: simulator\n        image: ghcr.io/llm-d/llm-d-inference-sim:v0.1.1\n        args:\n          - --model\n          - meta-llama/Llama-3.1-8B-Instruct\n          - --port\n          - \"8000\"\n        ports:\n          - containerPort: 8000\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: trlp-tutorial-llm-sim\nspec:\n  selector:\n    app: trlp-tutorial-llm-sim\n  ports:\n    - port: 80\n      targetPort: 8000\n      protocol: TCP\nEOF\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/tokenratelimitpolicy/authenticated-token-ratelimiting-tutorial/#step-2-create-a-gateway","title":"Step 2: Create a Gateway","text":"<p>Create the namespace for the gateway:</p> <pre><code>kubectl create ns ${KUADRANT_GATEWAY_NS}\n</code></pre> <p>Create a gateway that will accept traffic for the LLM API:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1\nkind: Gateway\nmetadata:\n  name: ${KUADRANT_GATEWAY_NAME}\n  namespace: ${KUADRANT_GATEWAY_NS}\nspec:\n  gatewayClassName: istio\n  listeners:\n\n  - name: http\n    protocol: HTTP\n    port: 80\n    hostname: \"trlp-tutorial.example.com\"\n    allowedRoutes:\n      namespaces:\n        from: All\nEOF\n</code></pre> <p>Check the gateway status:</p> <pre><code>kubectl get gateway ${KUADRANT_GATEWAY_NAME} -n ${KUADRANT_GATEWAY_NS} -o=jsonpath='{.status.conditions[?(@.type==\"Accepted\")].message}{\"\\n\"}{.status.conditions[?(@.type==\"Programmed\")].message}{\"\\n\"}'\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/tokenratelimitpolicy/authenticated-token-ratelimiting-tutorial/#step-3-expose-the-service-via-httproute","title":"Step 3: Expose the service via HTTPRoute","text":"<p>Create an HTTPRoute to expose the LLM service:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: trlp-tutorial-llm-sim\nspec:\n  hostnames:\n\n    - trlp-tutorial.example.com\n  parentRefs:\n    - name: ${KUADRANT_GATEWAY_NAME}\n      namespace: ${KUADRANT_GATEWAY_NS}\n  rules:\n    - matches:\n        - path:\n            type: PathPrefix\n            value: \"/\"\n      backendRefs:\n        - name: trlp-tutorial-llm-sim\n          port: 80\nEOF\n</code></pre> <p>Export the gateway URL for use in requests:</p> <pre><code>export KUADRANT_INGRESS_HOST=$(kubectl get gtw ${KUADRANT_GATEWAY_NAME} -n ${KUADRANT_GATEWAY_NS} -o jsonpath='{.status.addresses[0].value}')\nexport KUADRANT_INGRESS_PORT=$(kubectl get gtw ${KUADRANT_GATEWAY_NAME} -n ${KUADRANT_GATEWAY_NS} -o jsonpath='{.spec.listeners[?(@.name==\"http\")].port}')\nexport KUADRANT_GATEWAY_URL=${KUADRANT_INGRESS_HOST}:${KUADRANT_INGRESS_PORT}\n</code></pre> <p>Test connectivity to the service:</p> <pre><code>curl -H 'Host: trlp-tutorial.example.com' http://$KUADRANT_GATEWAY_URL/v1/models -i\n# HTTP/1.1 200 OK\n</code></pre> <p>Note: If the command above fails to hit the service on your environment, try forwarding requests to the gateway and accessing over localhost:</p> <pre><code>kubectl port-forward -n ${KUADRANT_GATEWAY_NS} service/${KUADRANT_GATEWAY_NAME}-istio 9080:80 &gt;/dev/null 2&gt;&amp;1 &amp;\nexport KUADRANT_GATEWAY_URL=localhost:9080\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/tokenratelimitpolicy/authenticated-token-ratelimiting-tutorial/#step-4-set-up-api-key-authentication","title":"Step 4: Set up API key authentication","text":"<p>Create API keys for different user tiers. This example creates two tiers: \"free\" and \"gold\":</p> <pre><code># Create a free tier user\nkubectl apply -f - &lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: trlp-tutorial-api-key-free-user-1\n  namespace: ${KUADRANT_SYSTEM_NS}\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    app: my-llm\n  annotations:\n    kuadrant.io/groups: free\n    secret.kuadrant.io/user-id: user-1\nstringData:\n  api_key: iamafreeuser\ntype: Opaque\nEOF\n</code></pre> <pre><code># Create a gold tier user\nkubectl apply -f - &lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: trlp-tutorial-api-key-gold-user-1\n  namespace: ${KUADRANT_SYSTEM_NS}\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    app: my-llm\n  annotations:\n    kuadrant.io/groups: gold\n    secret.kuadrant.io/user-id: user-2\nstringData:\n  api_key: iamagolduser\ntype: Opaque\nEOF\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/tokenratelimitpolicy/authenticated-token-ratelimiting-tutorial/#step-5-configure-authentication-policy","title":"Step 5: Configure authentication policy","text":"<p>Create an AuthPolicy that validates API keys and extracts user information:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1\nkind: AuthPolicy\nmetadata:\n  name: trlp-tutorial-llm-api-keys\n  namespace: ${KUADRANT_GATEWAY_NS}\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: ${KUADRANT_GATEWAY_NAME}\n  rules:\n    authentication:\n      api-key-users:\n        apiKey:\n          selector:\n            matchLabels:\n              app: my-llm\n        credentials:\n          authorizationHeader:\n            prefix: APIKEY\n    response:\n      success:\n        filters:\n          identity:\n            json:\n              properties:\n                groups:\n                  selector: auth.identity.metadata.annotations.kuadrant\\.io/groups\n                userid:\n                  selector: auth.identity.metadata.annotations.secret\\.kuadrant\\.io/user-id\n    authorization:\n      allow-groups:\n        opa:\n          rego: |\n            groups := split(object.get(input.auth.identity.metadata.annotations, \"kuadrant.io/groups\", \"\"), \",\")\n            allow { groups[_] == \"free\" }\n            allow { groups[_] == \"gold\" }\nEOF\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/tokenratelimitpolicy/authenticated-token-ratelimiting-tutorial/#step-6-apply-token-rate-limiting","title":"Step 6: Apply token rate limiting","text":"<p>Create a <code>TokenRateLimitPolicy</code> with different token limits for each tier:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1alpha1\nkind: TokenRateLimitPolicy\nmetadata:\n  name: trlp-tutorial-token-limits\n  namespace: ${KUADRANT_GATEWAY_NS}\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: ${KUADRANT_GATEWAY_NAME}\n  limits:\n    free:\n      rates:\n\n        - limit: 50 # 50 tokens per minute for free users (small for testing)\n          window: 1m\n      when:\n        - predicate: request.path == \"/v1/chat/completions\"\n        - predicate: |\n            auth.identity.groups.split(\",\").exists(g, g == \"free\")\n      counters:\n        - expression: auth.identity.userid\n    gold:\n      rates:\n        - limit: 200 # 200 tokens per minute for gold users (small for testing)\n          window: 1m\n      when:\n        - predicate: request.path == \"/v1/chat/completions\"\n        - predicate: |\n            auth.identity.groups.split(\",\").exists(g, g == \"gold\")\n      counters:\n        - expression: auth.identity.userid\nEOF\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/tokenratelimitpolicy/authenticated-token-ratelimiting-tutorial/#step-7-test-the-configuration","title":"Step 7: Test the configuration","text":""},{"location":"kuadrant-operator/doc/user-guides/tokenratelimitpolicy/authenticated-token-ratelimiting-tutorial/#test-with-a-free-user","title":"Test with a free user","text":"<p>Make a chat completion request. Note that <code>stream: false</code> is explicitly set to ensure a non-streaming response:</p> <pre><code>curl -H 'Host: trlp-tutorial.example.com' \\\n     -H 'Authorization: APIKEY iamafreeuser' \\\n     -H 'Content-Type: application/json' \\\n     -X POST http://$KUADRANT_GATEWAY_URL/v1/chat/completions \\\n     -d '{\n           \"model\": \"meta-llama/Llama-3.1-8B-Instruct\",\n           \"messages\": [\n             { \"role\": \"user\", \"content\": \"What is Kubernetes?\" }\n           ],\n           \"max_tokens\": 100,\n           \"stream\": false,\n           \"usage\": true\n         }'\n</code></pre> <p>The response includes token usage information:</p> <pre><code>{\n  \"choices\": [...],\n  \"usage\": {\n    \"prompt_tokens\": 5,\n    \"completion_tokens\": 95,\n    \"total_tokens\": 100\n  }\n}\n</code></pre> <p>Note: The <code>TokenRateLimitPolicy</code> automatically extracts the <code>total_tokens</code> value from this response and counts it against the user's limit.</p>"},{"location":"kuadrant-operator/doc/user-guides/tokenratelimitpolicy/authenticated-token-ratelimiting-tutorial/#test-streaming-with-a-free-user","title":"Test streaming with a free user","text":"<p>Make a chat completion request with streaming enabled. Ensure the request includes <code>\"stream\": true</code> and <code>\"stream_options\": { \"include_usage\": true }</code> so that usage is emitted at the end of the stream and can be enforced by the policy:</p> <pre><code>curl -H 'Host: trlp-tutorial.example.com' \\\n     -H 'Authorization: APIKEY iamafreeuser' \\\n     -H 'Content-Type: application/json' \\\n     -X POST http://$KUADRANT_GATEWAY_URL/v1/chat/completions \\\n     -d '{\n           \"model\": \"meta-llama/Llama-3.1-8B-Instruct\",\n           \"messages\": [\n             { \"role\": \"user\", \"content\": \"What is Kubernetes?\" }\n           ],\n           \"max_tokens\": 100,\n           \"stream\": true,\n           \"stream_options\": {\n             \"include_usage\": true\n           }\n         }'\n</code></pre> <p>Note: If <code>stream_options.include_usage</code> is omitted when <code>stream: true</code>, Kuadrant cannot extract token usage from the stream. Depending on the policy <code>failureMode</code>, the request may either be allowed without limiting or rejected.</p>"},{"location":"kuadrant-operator/doc/user-guides/tokenratelimitpolicy/authenticated-token-ratelimiting-tutorial/#test-with-a-gold-user","title":"Test with a gold user","text":"<pre><code>curl -H 'Host: trlp-tutorial.example.com' \\\n     -H 'Authorization: APIKEY iamagolduser' \\\n     -H 'Content-Type: application/json' \\\n     -X POST http://$KUADRANT_GATEWAY_URL/v1/chat/completions \\\n     -d '{\n           \"model\": \"meta-llama/Llama-3.1-8B-Instruct\",\n           \"messages\": [\n             { \"role\": \"user\", \"content\": \"Explain cloud native architecture\" }\n           ],\n           \"max_tokens\": 200,\n           \"stream\": false,\n           \"usage\": true\n         }'\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/tokenratelimitpolicy/authenticated-token-ratelimiting-tutorial/#how-it-works","title":"How it works","text":"<ol> <li>Authentication: The AuthPolicy validates API keys and enriches requests with user metadata</li> <li>Token Extraction: <code>TokenRateLimitPolicy</code> automatically extracts <code>usage.total_tokens</code> from LLM responses</li> <li>Rate Limiting: Tokens are counted against user-specific limits based on their tier</li> <li>Enforcement: When limits are exceeded, requests are rejected with HTTP 429 (Too Many Requests)</li> </ol>"},{"location":"kuadrant-operator/doc/user-guides/tokenratelimitpolicy/authenticated-token-ratelimiting-tutorial/#understanding-the-policy","title":"Understanding the policy","text":"<p>The <code>TokenRateLimitPolicy</code> uses several key concepts:</p> <ul> <li><code>rates</code>: Define the token limits and time windows</li> <li><code>when</code>: Conditions that determine when a limit applies (based on user groups)</li> <li><code>counters</code>: Identify what to count (user ID in this case)</li> <li>Token extraction: Automatically reads <code>usage.total_tokens</code> from non-streaming JSON responses; for streaming requests, requires <code>\"stream\": true</code> and <code>\"stream_options\": { \"include_usage\": true }</code> to extract usage from the final event</li> </ul>"},{"location":"kuadrant-operator/doc/user-guides/tokenratelimitpolicy/authenticated-token-ratelimiting-tutorial/#monitoring-usage","title":"Monitoring usage","text":"<p>Check the generated rate limit configuration:</p> <pre><code># View the generated WasmPlugin configuration\nkubectl get wasmplugin -n ${KUADRANT_GATEWAY_NS} kuadrant-${KUADRANT_GATEWAY_NAME} -o yaml\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/tokenratelimitpolicy/authenticated-token-ratelimiting-tutorial/#next-steps","title":"Next steps","text":"<ul> <li>Experiment with different token limits and time windows</li> <li>Add more user tiers with different limits</li> <li>Integrate with your actual LLM service</li> </ul>"},{"location":"kuadrant-operator/doc/user-guides/tokenratelimitpolicy/authenticated-token-ratelimiting-tutorial/#troubleshooting","title":"Troubleshooting","text":"<p>If requests are being rejected unexpectedly:</p> <ol> <li>Verify the API key is correct</li> <li>Check if the user has exceeded their token limit</li> <li>Ensure the LLM response includes <code>usage.total_tokens</code></li> <li>Review the <code>AuthPolicy</code> and <code>TokenRateLimitPolicy</code> status</li> </ol> <pre><code># Check AuthPolicy status\nkubectl get authpolicy -n ${KUADRANT_GATEWAY_NS} trlp-tutorial-llm-api-keys -o=jsonpath='{.status.conditions[?(@.type==\"Accepted\")].message}'\n\n# Check TokenRateLimitPolicy status\nkubectl get tokenratelimitpolicy -n ${KUADRANT_GATEWAY_NS} trlp-tutorial-token-limits -o=jsonpath='{.status.conditions[?(@.type==\"Accepted\")].message}'\n\n# View full policy details if needed\nkubectl get authpolicy -n ${KUADRANT_GATEWAY_NS} trlp-tutorial-llm-api-keys -o yaml\nkubectl get tokenratelimitpolicy -n ${KUADRANT_GATEWAY_NS} trlp-tutorial-token-limits -o yaml\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/tokenratelimitpolicy/authenticated-token-ratelimiting-tutorial/#cleanup","title":"Cleanup","text":"<p>To remove all resources created in this tutorial:</p> <pre><code># Delete policies\nkubectl delete tokenratelimitpolicy -n ${KUADRANT_GATEWAY_NS} trlp-tutorial-token-limits\nkubectl delete authpolicy -n ${KUADRANT_GATEWAY_NS} trlp-tutorial-llm-api-keys\n\n# Delete API key secrets\nkubectl delete secret -n ${KUADRANT_SYSTEM_NS} trlp-tutorial-api-key-free-user-1 trlp-tutorial-api-key-gold-user-1\n\n# Delete HTTPRoute\nkubectl delete httproute trlp-tutorial-llm-sim\n\n# Delete Gateway\nkubectl delete gateway -n ${KUADRANT_GATEWAY_NS} ${KUADRANT_GATEWAY_NAME}\n\n# Delete LLM service and deployment\nkubectl delete service trlp-tutorial-llm-sim\nkubectl delete deployment trlp-tutorial-llm-sim\n\n# Delete the gateway namespace (if not used by other resources)\n# kubectl delete namespace ${KUADRANT_GATEWAY_NS}\n</code></pre>"},{"location":"kuadrant-operator/examples/otel/","title":"OpenTelemetry for Kuadrant Operator","text":"<p>This example demonstrates how to enable OpenTelemetry logging, tracing, and metrics export from the Kuadrant Operator.</p>"},{"location":"kuadrant-operator/examples/otel/#features","title":"Features","text":"<ul> <li>Dual Logging: Logs to both console (Zap) and remote collector (OTLP) with automatic trace correlation</li> <li>Trace Correlation: Logs include <code>trace_id</code> and <code>span_id</code> for distributed tracing</li> <li>Metrics Bridge: Export existing Prometheus metrics via OTLP without code changes</li> <li>Flexible Configuration: Enable signals independently via endpoint configuration</li> <li>Local Development Stack: Complete observability stack (Loki, Grafana, Tempo, Prometheus) with Docker Compose</li> </ul>"},{"location":"kuadrant-operator/examples/otel/#architecture","title":"Architecture","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502     Kuadrant Operator                   \u2502\n\u2502                                         \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502  \u2502  Zap Logger (Tee Core)           \u2502   \u2502\n\u2502  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502   \u2502\n\u2502  \u2502  \u2502 Console Core\u2502 OTel Core    \u2502  \u2502   \u2502\n\u2502  \u2502  \u2502 (formatted) \u2502 (otelzap     \u2502  \u2502   \u2502\n\u2502  \u2502  \u2502             \u2502  bridge)     \u2502  \u2502   \u2502\n\u2502  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502   \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2502         stdout      OTLP (logs)         \u2502\n\u2502                          \u2502              \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u2502\n\u2502  \u2502  Prometheus Metrics  \u2502          \u2502    \u2502\n\u2502  \u2502  \u2022 controller_runtime_*         \u2502    \u2502\n\u2502  \u2502  \u2022 kuadrant_dns_policy_ready    \u2502    \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2502\n\u2502             \u2502           \u2502               \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u2502\n\u2502  \u2502  OTel Prometheus Bridge         \u2502    \u2502\n\u2502  \u2502  (zero code changes)            \u2502    \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2502\n\u2502             \u2502           \u2502               \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n              \u2502 OTLP (metrics)\n              \u2502           \u2502\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502  OTel Collector                \u2502\n    \u2502  \u2022 Logs pipeline               \u2502\n    \u2502  \u2022 Traces pipeline             \u2502\n    \u2502  \u2022 Metrics pipeline            \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n              \u2502\n      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n      \u2502                          \u2502\n  \u250c\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n  \u2502  Loki  \u2502  \u2502  Tempo   \u2502  \u2502 Prometheus \u2502\n  \u2502 (Logs) \u2502  \u2502 (Traces) \u2502  \u2502 (Metrics)  \u2502\n  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n      \u2502            \u2502              \u2502\n      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                   \u2502\n            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n            \u2502   Grafana   \u2502\n            \u2502 (Dashboards)\u2502\n            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"kuadrant-operator/examples/otel/#quick-start","title":"Quick Start","text":""},{"location":"kuadrant-operator/examples/otel/#1-start-observability-stack","title":"1. Start Observability Stack","text":"<pre><code>docker compose -f examples/otel/docker-compose.yaml up -d\n</code></pre> <p>This starts:</p> <ul> <li>OTel Collector - Receives OTLP logs, traces, and metrics on ports 4317 (gRPC) and 4318 (HTTP)</li> <li>Loki - Stores logs with full-text search and label filtering on port 3100</li> <li>Tempo - Distributed tracing backend on port 3200</li> <li>Jaeger - Alternative distributed tracing UI on port 16686</li> <li>Prometheus - Stores and queries metrics on port 9090</li> <li>Grafana - Unified observability UI on port 3000 (admin/admin)</li> </ul>"},{"location":"kuadrant-operator/examples/otel/#2-run-operator-with-opentelemetry-enabled","title":"2. Run Operator with OpenTelemetry Enabled","text":"<pre><code># Set environment variables\nexport OTEL_EXPORTER_OTLP_ENDPOINT=http://localhost:4318\nexport OTEL_EXPORTER_OTLP_INSECURE=true\nexport OTEL_METRICS_INTERVAL_SECONDS=5\n\n# Alternatively, enable signals individually:\n# export OTEL_EXPORTER_OTLP_LOGS_ENDPOINT=http://localhost:4318\n# export OTEL_EXPORTER_OTLP_TRACES_ENDPOINT=rpc://localhost:4317\n# export OTEL_EXPORTER_OTLP_METRICS_ENDPOINT=http://localhost:4318\n\n# Run the operator\nmake run\n</code></pre>"},{"location":"kuadrant-operator/examples/otel/#3-verify-logs","title":"3. Verify Logs","text":"<p>View logs in Loki via Grafana:</p> <pre><code># Open Grafana\nopen http://localhost:3000  # Login: admin/admin\n\n# Navigate to Explore \u2192 Loki\n# Query: {service_name=\"kuadrant-operator\"}\n</code></pre> <p>View logs in OTel Collector debug output:</p> <pre><code>docker logs -f kuadrant-otel-collector\n</code></pre>"},{"location":"kuadrant-operator/examples/otel/#4-verify-metrics","title":"4. Verify Metrics","text":"<p>Query metrics in Prometheus:</p> <pre><code># Open Prometheus UI\nopen http://localhost:9090\n\n# Or query via API\ncurl 'http://localhost:9090/api/v1/query?query=controller_runtime_active_workers'\n</code></pre> <p>Access operator Prometheus endpoint directly:</p> <pre><code>curl http://localhost:8080/metrics\n</code></pre>"},{"location":"kuadrant-operator/examples/otel/#5-verify-traces","title":"5. Verify Traces","text":"<p>View traces in Tempo via Grafana:</p> <pre><code># Open Grafana\nopen http://localhost:3000\n\n# Navigate to Explore \u2192 Tempo\n# Search by trace ID from logs\n</code></pre> <p>Or view in Jaeger UI:</p> <pre><code># Open Jaeger UI\nopen http://localhost:16686\n\n# Select \"kuadrant-operator\" service\n</code></pre>"},{"location":"kuadrant-operator/examples/otel/#6-unified-observability-in-grafana","title":"6. Unified Observability in Grafana","text":"<p>Grafana provides a unified view across all signals:</p> <ol> <li>Logs (Loki): Full-text search with label filtering</li> <li>Traces (Tempo): Distributed request tracing</li> <li>Metrics (Prometheus): Time-series metrics and dashboards</li> <li>Correlation: Click trace IDs in logs to jump to traces</li> </ol>"},{"location":"kuadrant-operator/examples/otel/#how-it-works","title":"How It Works","text":""},{"location":"kuadrant-operator/examples/otel/#dual-logging-with-trace-correlation","title":"Dual Logging with Trace Correlation","text":"<p>The operator uses a Tee core architecture powered by the official <code>go.opentelemetry.io/contrib/bridges/otelzap</code> library:</p> <p>Console Core:</p> <ul> <li>Formats logs for human readability (JSON or console format based on <code>LOG_MODE</code>)</li> <li>Respects <code>LOG_LEVEL</code> for verbosity filtering</li> <li>Extracts and displays <code>trace_id</code> and <code>span_id</code> from context for correlation</li> <li>Filters out noisy context objects</li> </ul> <p>OTel Core (otelzap bridge):</p> <ul> <li>Sends structured logs to OTLP collector</li> <li>Automatically extracts trace context from <code>context.Context</code> fields</li> <li>Preserves all log attributes and severity levels</li> <li>Enables correlation with traces in Tempo/Jaeger</li> </ul> <p>Usage in code:</p> <pre><code>import (\n    \"context\"\n    \"github.com/kuadrant/policy-machinery/controller\"\n    \"go.opentelemetry.io/otel\"\n)\n\nfunc (r *MyReconciler) Reconcile(ctx context.Context) (controller.Result, error) {\n    // Start a tracing span (required for trace_id/span_id)\n    tracer := otel.Tracer(\"kuadrant-operator\")\n    ctx, span := tracer.Start(ctx, \"MyReconciler.Reconcile\")\n    defer span.End()\n\n    // Get logger from context and attach context for trace extraction\n    logger := controller.LoggerFromContext(ctx).WithValues(\"context\", ctx)\n\n    logger.Info(\"reconciling resource\")  // Automatically includes trace_id and span_id\n    return controller.Result{}, nil\n}\n</code></pre> <p>Important Notes:</p> <ul> <li>The tracing span must be started before getting the logger for trace IDs to be present</li> <li>The <code>tracer.Start()</code> call enriches the context with trace context</li> <li>The <code>.WithValues(\"context\", ctx)</code> passes the enriched context to the logger for extraction</li> </ul> <p>Both cores receive the same log records from the Tee, ensuring consistent logging across console and remote backends.</p>"},{"location":"kuadrant-operator/examples/otel/#dual-metrics-export","title":"Dual Metrics Export","text":"<p>The operator exposes metrics in two ways simultaneously:</p> <ol> <li>Prometheus <code>/metrics</code> endpoint (<code>:8080/metrics</code>) - Native Prometheus scraping</li> <li>OTLP push (when metrics endpoint is configured) - Push to OTel Collector</li> </ol> <p>Both expose the same underlying metrics from the same Prometheus registry. The OTel bridge reads from the Prometheus registry and converts to OTLP format.</p>"},{"location":"kuadrant-operator/examples/otel/#important-avoid-metric-duplication","title":"Important: Avoid Metric Duplication","text":"<p>When configuring Prometheus scraping, choose one of these options:</p> <p>Option 1 (Recommended): Scrape via OTel Collector</p> <pre><code># prometheus.yaml (default in this example)\n\n- job_name: \"kuadrant-operator\"\n  static_configs:\n    - targets: [\"otel-collector:8889\"]\n</code></pre> <p>\u2705 Use when OTLP metrics export is enabled (endpoint configured) \u2705 Allows OTel processing/filtering before Prometheus \u2705 Consistent with OTel-first approach</p> <p>Option 2: Scrape operator directly</p> <pre><code># prometheus.yaml (alternative)\n\n- job_name: \"kuadrant-operator\"\n  static_configs:\n    - targets: [\"host.docker.internal:8080\"]\n</code></pre> <p>\u2705 Use when OTLP metrics export is disabled (no endpoint) \u2705 Traditional Prometheus setup \u2705 No OTel Collector needed</p> <p>\u274c Don't scrape both - This creates duplicate time series with different labels.</p>"},{"location":"kuadrant-operator/examples/otel/#environment-variables","title":"Environment Variables","text":""},{"location":"kuadrant-operator/examples/otel/#shared-opentelemetry-configuration","title":"Shared OpenTelemetry Configuration","text":"Variable Required Default Description <code>OTEL_EXPORTER_OTLP_ENDPOINT</code> No - (disabled) OTLP collector endpoint (enables all signals). Supports <code>http://</code>, <code>https://</code>, <code>rpc://</code> schemes <code>OTEL_EXPORTER_OTLP_LOGS_ENDPOINT</code> No - Override endpoint specifically for logs (enables logs if set) <code>OTEL_EXPORTER_OTLP_TRACES_ENDPOINT</code> No - Override endpoint specifically for traces (enables traces if set) <code>OTEL_EXPORTER_OTLP_METRICS_ENDPOINT</code> No - Override endpoint specifically for metrics (enables metrics if set) <code>OTEL_EXPORTER_OTLP_INSECURE</code> No <code>false</code> Disable TLS for OTLP export (required for <code>rpc://</code> scheme without TLS) <code>OTEL_SERVICE_NAME</code> No <code>kuadrant-operator</code> Service name shown in Grafana/Tempo/Jaeger <code>OTEL_SERVICE_VERSION</code> No Build version Service version (defaults to version from ldflags) <p>Configuration Logic:</p> <ul> <li>If <code>OTEL_EXPORTER_OTLP_ENDPOINT</code> is set, all signals (logs, traces, metrics) are enabled with that endpoint</li> <li>Per-signal endpoints override the global endpoint for that specific signal</li> <li>If no endpoint is configured (neither global nor per-signal), that signal is disabled</li> <li>Endpoint schemes: <code>http://</code> (insecure HTTP), <code>https://</code> (secure HTTP), <code>rpc://</code> (gRPC, use with <code>OTEL_EXPORTER_OTLP_INSECURE=true</code> for plaintext)</li> </ul>"},{"location":"kuadrant-operator/examples/otel/#metrics-specific-configuration","title":"Metrics-Specific Configuration","text":"Variable Default Description <code>OTEL_METRICS_INTERVAL_SECONDS</code> <code>15</code> Export interval in seconds"},{"location":"kuadrant-operator/examples/otel/#available-metrics","title":"Available Metrics","text":""},{"location":"kuadrant-operator/examples/otel/#controller-runtime-metrics","title":"Controller-Runtime Metrics","text":"<p>All standard controller-runtime metrics are automatically exported:</p> <ul> <li><code>controller_runtime_reconcile_total</code> - Total reconciliations per controller</li> <li><code>controller_runtime_reconcile_errors_total</code> - Reconciliation errors</li> <li><code>controller_runtime_reconcile_time_seconds</code> - Reconciliation duration</li> <li><code>controller_runtime_max_concurrent_reconciles</code> - Worker count</li> <li><code>controller_runtime_active_workers</code> - Active workers</li> </ul>"},{"location":"kuadrant-operator/examples/otel/#custom-kuadrant-metrics","title":"Custom Kuadrant Metrics","text":"<ul> <li><code>kuadrant_dns_policy_ready</code> - DNS Policy ready status</li> <li>Labels: <code>dns_policy_name</code>, <code>dns_policy_namespace</code>, <code>dns_policy_condition</code></li> </ul>"},{"location":"kuadrant-operator/examples/otel/#go-runtime-metrics","title":"Go Runtime Metrics","text":"<p>Standard Go metrics from <code>prometheus/client_golang</code>:</p> <ul> <li><code>go_memstats_*</code> - Memory statistics</li> <li><code>go_goroutines</code> - Number of goroutines</li> <li><code>go_threads</code> - Number of OS threads</li> <li><code>process_*</code> - Process metrics</li> </ul>"},{"location":"kuadrant-operator/examples/otel/#kubernetes-deployment","title":"Kubernetes Deployment","text":"<p>Add to your operator deployment:</p> <pre><code>env:\n\n  - name: OTEL_EXPORTER_OTLP_ENDPOINT\n    value: \"https://otel-collector.observability.svc.cluster.local:4318\"\n\n  # Or enable signals individually with different endpoints/protocols:\n  # - name: OTEL_EXPORTER_OTLP_LOGS_ENDPOINT\n  #   value: \"http://loki-gateway.observability.svc.cluster.local:3100\"\n  # - name: OTEL_EXPORTER_OTLP_TRACES_ENDPOINT\n  #   value: \"rpc://tempo.observability.svc.cluster.local:4317\"\n  # - name: OTEL_EXPORTER_OTLP_METRICS_ENDPOINT\n  #   value: \"http://otel-collector.observability.svc.cluster.local:4318\"\n\n\n  - name: OTEL_EXPORTER_OTLP_INSECURE\n    value: \"false\" # Use TLS in production\n  - name: OTEL_SERVICE_NAME\n    value: \"kuadrant-operator\"\n  - name: OTEL_METRICS_INTERVAL_SECONDS\n    value: \"60\"\n</code></pre>"},{"location":"kuadrant-operator/examples/otel/#configuration","title":"Configuration","text":""},{"location":"kuadrant-operator/examples/otel/#otel-collector","title":"OTel Collector","text":"<p>Edit <code>otel-collector-config.yaml</code> to add remote OTLP export:</p> <pre><code>exporters:\n  debug:\n    verbosity: detailed\n  prometheus:\n    endpoint: \"0.0.0.0:8889\"\n\n  # Add remote OTLP exporter\n  otlphttp:\n    endpoint: https://your-observability-backend.com\n    headers:\n      authorization: \"Bearer &lt;your-api-key&gt;\"\n\nservice:\n  pipelines:\n    logs:\n      receivers: [otlp]\n      processors: [batch, resource]\n      exporters: [debug, otlphttp] # Export logs to multiple backends\n\n    traces:\n      receivers: [otlp]\n      processors: [batch, resource]\n      exporters: [debug, otlphttp] # Export traces to multiple backends\n\n    metrics:\n      receivers: [otlp]\n      processors: [batch, resource]\n      exporters: [debug, prometheus, otlphttp] # Export metrics to multiple backends\n</code></pre>"},{"location":"kuadrant-operator/examples/otel/#implementation-details","title":"Implementation Details","text":""},{"location":"kuadrant-operator/examples/otel/#logging-architecture","title":"Logging Architecture","text":"<p>The operator uses a sophisticated logging setup that provides:</p> <ol> <li>Official OTel Integration: Uses <code>go.opentelemetry.io/contrib/bridges/otelzap</code> for robust OTel support</li> <li>Tee Core Pattern: Single Zap logger with two cores (console + OTel) via <code>zapcore.NewTee()</code></li> <li>Trace Context Extraction: Custom <code>contextFilterCore</code> extracts <code>trace_id</code> and <code>span_id</code> for console output</li> <li>Clean Console Output: Filters noisy context objects while preserving trace correlation</li> <li>Zero Overhead When Disabled: Standard Zap logger when no endpoint is configured</li> </ol> <p>Key Files:</p> <ul> <li><code>internal/log/otel.go</code> - OTel logging setup with Tee architecture and <code>contextFilterCore</code></li> <li><code>internal/log/log.go</code> - Standard logging setup</li> <li><code>cmd/main.go</code> - Conditional OTel initialization based on env vars</li> </ul>"},{"location":"kuadrant-operator/examples/otel/#trace-context-propagation","title":"Trace Context Propagation","text":"<p>To enable trace correlation in logs, you must start a tracing span and attach the context to the logger:</p> <pre><code>import \"go.opentelemetry.io/otel\"\n\n// Without tracing span - no trace context\nlogger := controller.LoggerFromContext(ctx).WithValues(\"context\", ctx)\nlogger.Info(\"message\")  // No trace_id (no active span)\n\n// With tracing span - full trace correlation\ntracer := otel.Tracer(\"kuadrant-operator\")\nctx, span := tracer.Start(ctx, \"MyOperation\")\ndefer span.End()\n\nlogger := controller.LoggerFromContext(ctx).WithValues(\"context\", ctx)\nlogger.Info(\"message\")  // Includes trace_id and span_id\n</code></pre> <p>The <code>contextFilterCore</code> in <code>internal/log/otel.go</code> handles the context field differently for each core:</p> <ul> <li>Console core: Extracts <code>trace_id</code> and <code>span_id</code> as readable strings, filters out noisy context object</li> <li>OTel core: Uses official otelzap bridge to include full trace context in OTLP records</li> </ul>"},{"location":"kuadrant-operator/examples/otel/#cleanup","title":"Cleanup","text":"<pre><code>docker compose -f examples/otel/docker-compose.yaml down\n</code></pre>"},{"location":"authorino/docs/","title":"Documentation","text":""},{"location":"authorino/docs/#getting-started","title":"Getting started","text":""},{"location":"authorino/docs/#terminology","title":"Terminology","text":""},{"location":"authorino/docs/#architecture","title":"Architecture","text":""},{"location":"authorino/docs/#feature-description","title":"Feature description","text":""},{"location":"authorino/docs/#user-guides","title":"User guides","text":""},{"location":"authorino/docs/#developers-guide","title":"Developer\u2019s guide","text":""},{"location":"authorino/docs/architecture/","title":"Architecture","text":""},{"location":"authorino/docs/architecture/#overview","title":"Overview","text":"<p>There are a few concepts to understand Authorino's architecture. The main components are: Authorino, Envoy and the Upstream service to be protected. Envoy proxies requests to the configured virtual host upstream service, first contacting with Authorino to decide on authN/authZ.</p> <p>The topology can vary from centralized proxy and centralized authorization service, to dedicated sidecars, with the nuances in between. Read more about the topologies in the Topologies section below.</p> <p>Authorino is deployed using the Authorino Operator, from an <code>Authorino</code> Kubernetes custom resource. Then, from another kind of custom resource, the <code>AuthConfig</code> CRs, each Authorino instance reads and adds to the index the exact rules of authN/authZ to enforce for each protected host (\"index reconciliation\").</p> <p>Everything that the AuthConfig reconciler can fetch in reconciliation-time is stored in the index. This is the case of static parameters such as signing keys, authentication secrets and authorization policies from external policy registries.</p> <p><code>AuthConfig</code>s can refer to identity providers (IdP) and trusted auth servers whose access tokens will be accepted to authenticate to the protected host. Consumers obtain an authentication token (short-lived access token or long-lived API key) and send those in the requests to the protected service.</p> <p>When Authorino is triggered by Envoy via the gRPC interface, it starts evaluating the Auth Pipeline, i.e. it applies to the request the parameters to verify the identity and to enforce authorization, as found in the index for the requested host (See host lookup for details).</p> <p>Apart from static rules, these parameters can include instructions to contact online with external identity verifiers, external sources of metadata and policy decision points (PDPs).</p> <p>On every request, Authorino's \"working memory\" is called Authorization JSON, a data structure that holds information about the context (the HTTP request) and objects from each phase of the auth pipeline: i.e., authentication verification (phase i), ad-hoc metadata fetching (phase ii), authorization policy enforcement (phase iii), dynamic response (phase iv), and callbacks (phase v). The evaluators in each of these phases can both read and write from the Authorization JSON for dynamic steps and decisions of authN/authZ.</p>"},{"location":"authorino/docs/architecture/#topologies","title":"Topologies","text":"<p>Typically, upstream APIs are deployed to the same Kubernetes cluster and namespace where the Envoy proxy and Authorino is running (although not necessarily). Whatever is the case, Envoy must be proxying to the upstream API (see Envoy's HTTP route components and virtual hosts) and pointing to Authorino in the external authorization filter.</p> <p>This can be achieved with different topologies:</p> <ul> <li>Envoy can be a centralized gateway with one dedicated instance of Authorino, proxying to one or more upstream services</li> <li>Envoy can be deployed as a sidecar of each protected service, but still contacting from a centralized Authorino authorization service</li> <li>Both Envoy and Authorino deployed as sidecars of the protected service, restricting all communication between them to localhost</li> </ul> <p>Each topology above induces different measures for security.</p>"},{"location":"authorino/docs/architecture/#centralized-gateway","title":"Centralized gateway","text":"<p>Recommended in the protected services to validate the origin of the traffic. It must have been proxied by Envoy. See Authorino JSON injection for an extra validation option using a shared secret passed in HTTP header.</p>"},{"location":"authorino/docs/architecture/#centralized-authorization-service","title":"Centralized authorization service","text":"<p>Protected service should only listen on <code>localhost</code> and all traffic can be considered safe.</p>"},{"location":"authorino/docs/architecture/#sidecars","title":"Sidecars","text":"<p>Recommended <code>namespaced</code> instances of Authorino with fine-grained label selectors to avoid unnecessary caching of <code>AuthConfig</code>s.</p> <p>Apart from that, protected service should only listen on <code>localhost</code> and all traffic can be considered safe.</p>"},{"location":"authorino/docs/architecture/#cluster-wide-vs-namespaced-instances","title":"Cluster-wide vs. Namespaced instances","text":"<p>Authorino instances can run in either cluster-wide or namespaced mode.</p> <p>Namespace-scoped instances only watch resources (<code>AuthConfig</code>s and <code>Secret</code>s) created in a given namespace. This deployment mode does not require admin privileges over the Kubernetes cluster to deploy the instance of the service (given Authorino's CRDs have been installed beforehand, such as when Authorino is installed using the Authorino Operator).</p> <p>Cluster-wide deployment mode, in contraposition, deploys instances of Authorino that watch resources across the entire cluster, consolidating all resources into a multi-namespace index of auth configs. Admin privileges over the Kubernetes cluster is required to deploy Authorino in cluster-wide mode.</p> <p>Be careful to avoid superposition when combining multiple Authorino instances and instance modes in the same Kubernetes cluster. Apart from caching unnecessary auth config data in the instances depending on your routing settings, the leaders of each instance (set of replicas) may compete for updating the status of the custom resources that are reconciled. See Resource reconciliation and status update for more information.</p> <p>If necessary, use label selectors to narrow down the space of resources watched and reconciled by each Authorino instance. Check out the Sharding section below for details.</p>"},{"location":"authorino/docs/architecture/#the-authorino-authconfig-custom-resource-definition-crd","title":"The Authorino <code>AuthConfig</code> Custom Resource Definition (CRD)","text":"<p>The desired protection for a service is declaratively stated by applying an <code>AuthConfig</code> Custom Resource to the Kubernetes cluster running Authorino.</p> <p>An <code>AuthConfig</code> resource typically looks like the following:</p> <pre><code>apiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: my-api-protection\nspec:\n    # The list of public host names of the services protected by this AuthConfig resource.\n    # Authorino uses the host name provided in the payload of external authorization request to lookup for the corresponding AuthConfig to enforce.\n  # Hostname collisions are prevented by rejecting to index a hostname already taken by another AuthConfig.\n  # Format: hostname[:port]\n  hosts:\n\n  - my-api.io:443 # north-south traffic\n  - my-api.ns.svc.cluster.local # east-west traffic\n\n  # Set of stored named patterns to be reused in conditions and pattern-matching authorization rules\n  patterns: {\"name\" \u2192 {selector, operator, value}, \u2026}\n\n  # Top-level conditions for the AuthConfig to be enforced.\n  # If omitted, the AuthConfig will be enforced at all requests.\n  # If present, all conditions must match for the AuthConfig to be enforced; otherwise, Authorino skips the AuthConfig and returns to the auth request with status OK.\n  when: [{selector, operator, value | named pattern ref}, \u2026]\n\n  # List of one or more trusted sources of identity:\n  # - Configurations to verify JSON Web Tokens (JWTs) issued by an OpenID Connect (OIDC) server\n  # - Endpoints for OAuth 2.0 token introspection\n  # - Attributes for the Kubernetes `TokenReview` API\n  # - Label selectors for API keys (stored in Kubernetes `Secret`s)\n  # - Label selectors trusted x509 issuer certificates (stored in Kubernetes `Secret`s)\n  # - Selectors for plain identity objects supplied in the payload of the authorization request\n  # - Anonymous access configs\n  authentication: {\"name\" \u2192 {\u2026}, \u2026}\n\n  # List of sources of external metadata for the authorization (optional):\n  # - Endpoints for HTTP GET or GET-by-POST requests\n  # - OIDC UserInfo endpoints (associated with an OIDC token issuer specified in the authentication configs)\n  # - User-Managed Access (UMA) resource registries\n  metadata: {\"name\" \u2192 {\u2026}, \u2026}\n\n  # List of authorization policies to be enforced (optional):\n  # - Pattern-matching rules (e.g. `context.request.http.path eq '/pets'`)\n  # - Open Policy Agent (OPA) inline or external Rego policies\n  # - Attributes for the Kubernetes `SubjectAccessReview` API\n  # \u2013 Attributes for authorization with an external SpiceDB server\n  authorization: {\"name\" \u2192 {\u2026}, \u2026}\n\n  # Customization to the response to the external authorization request (optional)\n  response:\n    # List of dynamic response elements into the request on success authoization (optional):\n    # - Plain text\n    # - JSON objects\n    # - Festival Wristbands (signed JWTs issued by Authorino)\n    success:\n      # List of HTTP headers to inject into the request post-authorization (optional):\n      headers: {\"name\" \u2192 {\u2026}, \u2026}\n\n      # List of Envoy Dynamic Metadata to inject into the request post-authorization (optional):\n      dynamicMetadata: {\"name\" \u2192 {\u2026}, \u2026}\n\n    # Custom HTTP status code, message and headers to replace the default `401 Unauthorized` response (optional)\n    unauthenticated:\n      code: 302\n      message: Redirecting to login\n      headers:\n        \"Location\":\n          value: https://my-app.io/login\n\n    # Custom HTTP status code, message and headers to replace the default `and `403 Forbidden` response (optional)\n    unauthorized: {code, message, headers, body}\n\n  # List of callback targets:\n  # - Endpoints for HTTP requests\n  callbacks: {\"name\" \u2192 {\u2026}, \u2026}\n</code></pre> <p>Check out the OAS of the <code>AuthConfig</code> CRD for a formal specification of the options for <code>authentication</code> verification, external <code>metadata</code> fetching, <code>authorization</code> policies, and dynamic <code>response</code>, as well as any other host protection capability implemented by Authorino.</p> <p>You can also read the specification from the CLI using the <code>kubectl explain</code> command. The Authorino CRD is required to have been installed in Kubernetes cluster. E.g. <code>kubectl explain authconfigs.spec.authentication.overrides</code>.</p> <p>A complete description of supported features and corresponding configuration options within an <code>AuthConfig</code> CR can be found in the Features page.</p> <p>More concrete examples of <code>AuthConfig</code>s for specific use-cases can be found in the User guides.</p>"},{"location":"authorino/docs/architecture/#resource-reconciliation-and-status-update","title":"Resource reconciliation and status update","text":"<p>The instances of the Authorino authorization service workload, following the Operator pattern, watch events related to the <code>AuthConfig</code> custom resources, to build and reconcile an in-memory index of configs. Whenever a replica receives traffic for authorization request, it looks up in the index of <code>AuthConfig</code>s and then triggers the \"Auth Pipeline\", i.e. enforces the associated auth spec onto the request.</p> <p>An instance can be a single authorization service workload or a set of replicas. All replicas watch and reconcile the same set of resources that match the <code>--auth-config-label-selector</code> and <code>--secret-label-selector</code> configuration options. (See both Cluster-wide vs. Namespaced instances and Sharding, for details about defining the reconciliation space of Authorino instances.)</p> <p>The above means that all replicas of an Authorino instance should be able to receive traffic for authorization requests.</p> <p>Among the multiple replicas of an instance, Authorino elects one replica to be leader. The leader is responsible for updating the status of reconciled <code>AuthConfig</code>s. If the leader eventually becomes unavailable, the instance will automatically elect another replica take its place as the new leader.</p> <p>The status of an <code>AuthConfig</code> tells whether the resource is \"ready\" (i.e. indexed). It also includes summary information regarding the numbers of authentication configs, metadata configs, authorization configs and response configs within the spec, as well as whether Festival Wristband tokens are being issued by the Authorino instance as by spec.</p> <p>Apart from watching events related to <code>AuthConfig</code> custom resources, Authorino also watches events related to Kubernetes <code>Secret</code>s, as part of Authorino's API key authentication feature. <code>Secret</code> resources that store API keys are linked to their corresponding <code>AuthConfig</code>s in the index. Whenever the Authorino instance detects a change in the set of API key <code>Secret</code>s linked to an <code>AuthConfig</code>s, the instance reconciles the index.</p> <p>Authorino only watches events related to <code>Secret</code>s whose <code>metadata.labels</code> match the label selector <code>--secret-label-selector</code> of the Authorino instance. The default values of the label selector for Kubernetes <code>Secret</code>s representing Authorino API keys is <code>authorino.kuadrant.io/managed-by=authorino</code>.</p>"},{"location":"authorino/docs/architecture/#the-auth-pipeline-aka-enforcing-protection-in-request-time","title":"The \"Auth Pipeline\" (aka: enforcing protection in request-time)","text":"<p>In each request to the protected API, Authorino triggers the so-called \"Auth Pipeline\", a set of configured evaluators that are organized in a 5-phase pipeline:</p> <ul> <li>(i) Authentication phase: at least one source of identity (i.e., one authentication config) must resolve the supplied credential in the request into a valid identity or Authorino will otherwise reject the request as unauthenticated (401 HTTP response status).</li> <li>(ii) Metadata phase: optional fetching of additional data from external sources, to add up to context and identity information, and used in authorization policies, dynamic responses and callback requests (phases iii to v).</li> <li>(iii) Authorization phase: all unskipped policies must evaluate to a positive result (\"authorized\"), or Authorino will otherwise reject the request as unauthorized (403 HTTP response code).</li> <li>(iv) Response phase \u2013 Authorino builds all user-defined response items (dynamic JSON objects and/or Festival Wristband OIDC tokens), which are supplied back to the external authorization client within added HTTP headers or as Envoy Dynamic Metadata</li> <li>(v) Callbacks phase \u2013 Authorino sends callbacks to specified HTTP endpoints.</li> </ul> <p>Each phase is sequential to the other, from (i) to (v), while the evaluators within each phase are triggered concurrently or as prioritized. The Authentication phase (i) is the only one required to list at least one evaluator (i.e. 1+ authentication configs); Metadata, Authorization and Response phases can have any number of evaluators (including zero, and even be omitted in this case).</p>"},{"location":"authorino/docs/architecture/#host-lookup","title":"Host lookup","text":"<p>Authorino reads the request host from <code>Attributes.Http.Host</code> of Envoy's <code>CheckRequest</code> type, and uses it as key to lookup in the index of <code>AuthConfig</code>s, matched against <code>spec.hosts</code>.</p> <p>Alternatively to <code>Attributes.Http.Host</code>, a <code>host</code> entry can be supplied in the <code>Attributes.ContextExtensions</code> map of the external authorino request. This will take precedence before the host attribute of the HTTP request.</p> <p>The <code>host</code> context extension is useful to support use cases such as of path prefix-based lookup and wildcard subdomains lookup with lookup strongly dictated by the external authorization client (e.g. Envoy), which often knows about routing and the expected <code>AuthConfig</code> to enforce beyond what Authorino can infer strictly based on the host name.</p> <p>Wildcards can also be used in the host names specified in the <code>AuthConfig</code>, resolved by Authorino. E.g. if <code>*.pets.com</code> is in <code>spec.hosts</code>, Authorino will match the concrete host names <code>dogs.pets.com</code>, <code>cats.pets.com</code>, etc. In case, of multiple possible matches, Authorino will try the longest match first (in terms of host name labels) and fall back to the closest wildcard upwards in the domain tree (if any).</p> <p>When more than one host name is specified in the <code>AuthConfig</code>, all of them can be used as key, i.e. all of them can be requested in the authorization request and will be mapped to the same config.</p> <p>Example. Host lookup with wildcards.</p> <p></p> <p>The domain tree above induces the following relation:</p> <ul> <li><code>foo.nip.io</code> \u2192 <code>authconfig-1</code> (matches <code>*.io</code>)</li> <li><code>talker-api.nip.io</code> \u2192 <code>authconfig-2</code> (matches <code>talker-api.nip.io</code>)</li> <li><code>dogs.pets.com</code> \u2192 <code>authconfig-2</code> (matches <code>*.pets.com</code>)</li> <li><code>api.acme.com</code> \u2192 <code>authconfig-3</code> (matches <code>api.acme.com</code>)</li> <li><code>www.acme.com</code> \u2192 <code>authconfig-4</code> (matches <code>*.acme.com</code>)</li> <li><code>foo.org</code> \u2192 <code>404 Not found</code></li> </ul> <p></p> <p>The host can include the port number (i.e. <code>hostname:port</code>) or it can be just the name of the host name. Authorino will first try finding in the index a config associated to <code>hostname:port</code>, as supplied in the authorization request; if the index misses an entry for <code>hostname:port</code>, Authorino will then remove the <code>:port</code> suffix and repeat the lookup using just <code>hostname</code> as key. This provides implicit support for multiple port numbers for a same host without having to list all combinations in the <code>AuthConfig</code>.</p>"},{"location":"authorino/docs/architecture/#avoiding-host-name-collision","title":"Avoiding host name collision","text":"<p>Authorino tries to prevent host name collision between <code>AuthConfig</code>s by rejecting to link in the index any <code>AuthConfig</code> and host name if the host name is already linked to a different <code>AuthConfig</code> in the index. This was intentionally designed to prevent users from superseding each other's <code>AuthConfig</code>s, partially or fully, by just picking the same host names or overlapping host names as others.</p> <p>When wildcards are involved, a host name that matches a host wildcard already linked in the index to another <code>AuthConfig</code> will be considered taken, and therefore the newest <code>AuthConfig</code> will be rejected to be linked to that host.</p> <p>This behavior can be disabled to allow <code>AuthConfig</code>s to partially supersede each others' host names (limited to strict host subsets), by supplying the <code>--allow-superseding-host-subsets</code> command-line flag when running the Authorino instance.</p>"},{"location":"authorino/docs/architecture/#the-authorization-json","title":"The Authorization JSON","text":"<p>On every Auth Pipeline, Authorino builds the Authorization JSON, a \"working-memory\" data structure composed of <code>context</code> (information about the request, as supplied by the Envoy proxy to Authorino) and <code>auth</code> (objects resolved in phases (i) to (v) of the pipeline). The evaluators of each phase can read from the Authorization JSON and implement dynamic properties and decisions based on its values.</p> <p>At phase (iii), the authorization evaluators count on an Authorization JSON payload that looks like the following:</p> <pre><code>// The authorization JSON combined along Authorino's auth pipeline for each request\n{\n  \"context\": { // the input from the proxy\n    \"origin\": {\u2026},\n    \"request\": {\n      \"http\": {\n        \"method\": \"\u2026\",\n        \"headers\": {\u2026},\n        \"path\": \"/\u2026\",\n        \"host\": \"\u2026\",\n        \u2026\n      }\n    }\n  },\n  \"auth\": {\n    \"identity\": {\n      // the identity resolved, from the supplied credentials, by one of the evaluators of phase (i)\n    },\n    \"metadata\": {\n      // each metadata object/collection resolved by the evaluators of phase (ii), by name of the evaluator\n    }\n  }\n}\n</code></pre> <p>The policies evaluated can use any data from the authorization JSON to define authorization rules.</p> <p>After phase (iii), Authorino appends to the authorization JSON the results of this phase as well, and the payload available for phase (iv) becomes:</p> <pre><code>// The authorization JSON combined along Authorino's auth pipeline for each request\n{\n  \"context\": { // the input from the proxy\n    \"origin\": {\u2026},\n    \"request\": {\n      \"http\": {\n        \"method\": \"\u2026\",\n        \"headers\": {\u2026},\n        \"path\": \"/\u2026\",\n        \"host\": \"\u2026\",\n        \u2026\n      }\n    }\n  },\n  \"auth\": {\n    \"identity\": {\n      // the identity resolved, from the supplied credentials, by one of the evaluators of phase (i)\n    },\n    \"metadata\": {\n      // each metadata object/collection resolved by the evaluators of phase (ii), by name of the evaluator\n    },\n    \"authorization\": {\n      // each authorization policy result resolved by the evaluators of phase (iii), by name of the evaluator\n    }\n  }\n}\n</code></pre> <p>Festival Wristbands and Dynamic JSON responses can include dynamic values (custom claims/properties) fetched from the authorization JSON. These can be returned to the external authorization client in added HTTP headers or as Envoy Well Known Dynamic Metadata. Check out Custom response features for details.</p> <p>For information about reading and fetching data from the Authorization JSON (syntax, functions, etc), check out Common Expression Language (CEL).</p>"},{"location":"authorino/docs/architecture/#raw-http-authorization-interface","title":"Raw HTTP Authorization interface","text":"<p>Besides providing the gRPC authorization interface \u2013 that implements the Envoy gRPC authorization server \u2013, Authorino also provides another interface for raw HTTP authorization. This second interface responds to <code>GET</code> and <code>POST</code> HTTP requests sent to <code>:5001/check</code>, and is suitable for other forms of integration, such as:</p> <ul> <li>using Authorino as Kubernetes ValidatingWebhook service (example);</li> <li>other HTTP proxies and API gateways;</li> <li>old versions of Envoy incompatible with the latest version of gRPC external authorization protocol (Authorino is based on v3.19.1 of Envoy external authorization API)</li> </ul> <p>In the raw HTTP interface, the host used to lookup for an <code>AuthConfig</code> must be supplied in the <code>Host</code> HTTP header of the request. Other attributes of the HTTP request are also passed in the context to evaluate the <code>AuthConfig</code>, including the body of the request.</p>"},{"location":"authorino/docs/architecture/#caching","title":"Caching","text":""},{"location":"authorino/docs/architecture/#openid-connect-and-user-managed-access-configs","title":"OpenID Connect and User-Managed Access configs","text":"<p>OpenID Connect and User-Managed Access configurations, discovered usually at reconciliation-time from well-known discovery endpoints.</p> <p>Cached individual OpenID Connect configurations discovered by Authorino can be configured to be auto-refreshed, by setting the corresponding <code>spec.authentication.jwt.ttl</code> field in the AuthConfig (given in seconds, default: <code>0</code> \u2013 i.e. no cache update).</p>"},{"location":"authorino/docs/architecture/#json-web-keys-jwks-and-json-web-key-sets-jwks","title":"JSON Web Keys (JWKs) and JSON Web Key Sets (JWKS)","text":"<p>JSON signature verification certificates linked by discovered OpenID Connect configurations, fetched usually at reconciliation-time.</p>"},{"location":"authorino/docs/architecture/#revoked-access-tokens","title":"Revoked access tokens","text":"Not implemented - In analysis (#19) <p>Caching of access tokens identified and or notified as revoked prior to expiration.</p>"},{"location":"authorino/docs/architecture/#external-metadata","title":"External metadata","text":"Not implemented - Planned (#21) <p>Caching of resource data obtained in previous requests.</p>"},{"location":"authorino/docs/architecture/#compiled-rego-policies","title":"Compiled Rego policies","text":"<p>Performed automatically by Authorino at reconciliation-time for the authorization policies based on the built-in OPA module.</p> <p>Precompiled and cached individual Rego policies originally pulled by Authorino from external registries can be configured to be auto-refreshed, by setting the corresponding <code>spec.authorization.opa.externalRegistry.ttl</code> field in the AuthConfig (given in seconds, default: <code>0</code> \u2013 i.e. no cache update).</p>"},{"location":"authorino/docs/architecture/#repeated-requests","title":"Repeated requests","text":"Not implemented - In analysis (#20) <p>For consecutive requests performed, within a given period of time, by a same user that request for a same resource, such that the result of the auth pipeline can be proven that would not change.</p>"},{"location":"authorino/docs/architecture/#sharding","title":"Sharding","text":"<p>By default, Authorino instances will watch <code>AuthConfig</code> CRs in the entire space (namespace or entire cluster; see Cluster-wide vs. Namespaced instances for details). To support combining multiple Authorino instances and instance modes in the same Kubernetes cluster, and yet avoiding superposition between the instances (i.e. multiple instances reconciling the same <code>AuthConfig</code>s), Authorino offers support for data sharding, i.e. to horizontally narrow down the space of reconciliation of an Authorino instance to a subset of that space.</p> <p>The benefits of limiting the space of reconciliation of an Authorino instance include avoiding unnecessary caching and workload in instances that do not receive corresponding traffic (according to your routing settings) and preventing leaders of multiple instances (sets of replicas) to compete on resource status updates (see Resource reconciliation and status update for details).</p> <p>Use-cases for sharding of <code>AuthConfig</code>s:</p> <ul> <li>Horizontal load balancing of traffic of authorization requests</li> <li>Supporting for managed centralized instances of Authorino to API owners who create and maintain their own <code>AuthConfig</code>s within their own user namespaces.</li> </ul> <p>Authorino's custom controllers filter the <code>AuthConfig</code>-related events to be reconciled using Kubernetes label selectors, defined for the Authorino instance via <code>--auth-config-label-selector</code> command-line flag. By default, <code>--auth-config-label-selector</code> is empty, meaning all <code>AuthConfig</code>s in the space are watched; this variable can be set to any value parseable as a valid label selector, causing Authorino to then watch only events of <code>AuthConfig</code>s whose <code>metadata.labels</code> match the selector.</p> <p>The following are all valid examples of <code>AuthConfig</code> label selector filters:</p> <pre><code>--auth-config-label-selector=\"authorino.kuadrant.io/managed-by=authorino\"\n--auth-config-label-selector=\"authorino.kuadrant.io/managed-by=authorino,other-label=other-value\"\n--auth-config-label-selector=\"authorino.kuadrant.io/managed-by in (authorino,kuadrant)\"\n--auth-config-label-selector=\"authorino.kuadrant.io/managed-by!=authorino-v0.4\"\n--auth-config-label-selector=\"!disabled\"\n</code></pre>"},{"location":"authorino/docs/architecture/#rbac","title":"RBAC","text":"<p>The table below describes the roles and role bindings defined by the Authorino service:</p> Role Kind Scope(*) Description Permissions <code>authorino-manager-role</code> <code>ClusterRole</code> C/N Role of the Authorino manager service Watch and reconcile <code>AuthConfig</code>s and <code>Secret</code>s <code>authorino-manager-k8s-auth-role</code> <code>ClusterRole</code> C/N Role for the Kubernetes auth features Create <code>TokenReview</code>s and <code>SubjectAccessReview</code>s (Kubernetes auth) <code>authorino-leader-election-role</code> <code>Role</code> N Leader election role Create/update the <code>ConfigMap</code> used to coordinate which replica of Authorino is the leader <code>authorino-authconfig-editor-role</code> <code>ClusterRole</code> - <code>AuthConfig</code> editor R/W <code>AuthConfig</code>s; Read <code>AuthConfig/status</code> <code>authorino-authconfig-viewer-role</code> <code>ClusterRole</code> - <code>AuthConfig</code> viewer Read <code>AuthConfig</code>s and <code>AuthConfig/status</code> <code>authorino-proxy-role</code> <code>ClusterRole</code> C/N Kube-rbac-proxy-role (sidecar)'s role Create <code>TokenReview</code>s and <code>SubjectAccessReview</code>s to check permissions to the <code>/metrics</code> endpoint <code>authorino-metrics-reader</code> <code>ClusterRole</code> - Metrics reader <code>GET /metrics</code> <p>(*) C - Cluster-wide | N - Authorino namespace | C/N - Cluster-wide or Authorino namespace (depending on the deployment mode).</p>"},{"location":"authorino/docs/architecture/#observability","title":"Observability","text":"<p>Please refer to the Observability user guide for info on Prometheus metrics exported by Authorino, readiness probe, logging, tracing, etc.</p>"},{"location":"authorino/docs/contributing/","title":"Developer's Guide","text":""},{"location":"authorino/docs/contributing/#technology-stack-for-developers","title":"Technology stack for developers","text":"<p>Minimum requirements to contribute to Authorino are:</p> <ul> <li>Golang v1.25+</li> <li>Docker or Podman</li> </ul> <p>Authorino's code was originally bundled using the Operator SDK (v1.9.0).</p> <p>The following tools can be installed as part of the development workflow:</p> <ul> <li> <p>Installed with <code>go install</code> to the <code>$PROJECT_DIR/bin</code> directory:</p> <ul> <li>controller-gen: for building custom types and manifests</li> <li>Kustomize: for assembling flavoured manifests and installing/deploying</li> <li>setup-envtest: for running the tests \u2013 extra tools installed to <code>./testbin</code></li> <li>benchstat: for human-friendly test benchmark reports</li> <li>mockgen: to generate mocks for tests \u2013 e.g. <code>./bin/mockgen -source=pkg/auth/auth.go -destination=pkg/auth/mocks/mock_auth.go</code></li> <li>Kind: for deploying a containerized Kubernetes cluster for integration testing purposes</li> </ul> </li> <li> <p>Other recommended tools to have installed:</p> <ul> <li>jq</li> <li>yq</li> <li>gnu-sed</li> </ul> </li> </ul>"},{"location":"authorino/docs/contributing/#workflow","title":"Workflow","text":""},{"location":"authorino/docs/contributing/#check-the-issues","title":"Check the issues","text":"<p>Start by checking the list of issues in GitHub.</p> <p>In case you want to contribute with an idea for enhancement, a bug fix, or question, please make sure to describe the issue so we can start a conversation together and help you find the best way to get your contribution merged.</p>"},{"location":"authorino/docs/contributing/#clone-the-repo-and-setup-the-local-environment","title":"Clone the repo and setup the local environment","text":"<p>Fork/clone the repo:</p> <pre><code>git clone git@github.com:kuadrant/authorino.git &amp;&amp; cd authorino\n</code></pre> <p>Download the Golang dependencies: <pre><code>make vendor\n</code></pre></p> <p>For additional automation provided, check:</p> <pre><code>make help\n</code></pre>"},{"location":"authorino/docs/contributing/#make-your-changes","title":"Make your changes","text":"<p>Good changes...</p> <ul> <li>follow the Golang conventions</li> <li>have proper test coverage</li> <li>address corresponding updates to the docs</li> <li>help us fix wherever we failed to do the above \ud83d\ude1c</li> </ul>"},{"location":"authorino/docs/contributing/#run-the-tests","title":"Run the tests","text":"<p>To run the tests:</p> <pre><code>make test\n</code></pre>"},{"location":"authorino/docs/contributing/#try-locally","title":"Try locally","text":""},{"location":"authorino/docs/contributing/#build-deploy-and-try-authorino-in-a-local-cluster","title":"Build, deploy and try Authorino in a local cluster","text":"<p>The following command will:</p> <ul> <li>Start a local Kubernetes cluster (using Kind)</li> <li>Install cert-manager in the cluster</li> <li>Install the Authorino Operator and Authorino CRDs</li> <li>Build an image of Authorino based on the current branch</li> <li>Push the freshly built image to the cluster's registry</li> <li>Generate TLS certificates for the Authorino service</li> <li>Deploy an instance of Authorino</li> <li>Deploy the example application Talker API, a simple HTTP API that echoes back whatever it gets in the request</li> <li>Setup Envoy for proxying to the Talker API and using Authorino for external authorization</li> </ul> <pre><code>make local-setup\n</code></pre> <p>You will be prompted to edit the <code>Authorino</code> custom resource.</p> <p>The main workload composed of Authorino instance and user apps (Envoy, Talker API) will be deployed to the <code>default</code> Kubernetes namespace.</p> <p>Once the deployment is ready, you can forward the requests on port 8000 to the Envoy service</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 &amp;\n</code></pre> Pro tips <ol> <li>Change the default workload namespace by supplying the <code>NAMESPACE</code> argument to your <code>make local-setup</code> and other deployment, apps and local cluster related targets. If the namespace does not exist, it will be created.</li> <li>Switch to TLS disabled by default when deploying locally by supplying <code>TLS_ENABLED=0</code> to your <code>make local-setup</code> and <code>make deploy</code> commands. E.g. <code>make local-setup TLS_ENABLED=0</code>.</li> <li>Skip being prompted to edit the <code>Authorino</code> CR and default to an Authorino deployment with TLS enabled, debug/development log level/mode, and standard name 'authorino', by supplying <code>FF=1</code> to your <code>make local-setup</code> and <code>make deploy</code> commands. E.g. <code>make local-setup FF=1</code></li> <li>Supply <code>DEPLOY_IDPS=1</code> to <code>make local-setup</code> and <code>make user-apps</code> to deploy Keycloak and Dex to the cluster. <code>DEPLOY_KEYCLOAK</code> and <code>DEPLOY_DEX</code> are also available. Read more about additional tools for specific use cases in the section below.</li> <li>Saving the ID of the process (PID) of the port-forward command spawned in the background can be useful to later kill and restart the process. E.g. <code>kubectl port-forward deployment/envoy 8000:8000 &amp;;PID=$!</code>; then <code>kill $PID</code>.</li> </ol>"},{"location":"authorino/docs/contributing/#additional-tools-for-specific-use-cases","title":"Additional tools (for specific use-cases)","text":"Limitador <p>To deploy Limitador \u2013 pre-configured in Envoy for rate-limiting the Talker API to 5 hits per minute per <code>user_id</code> when available in the cluster workload \u2013, run:</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/limitador/limitador-deploy.yaml\n</code></pre> Keycloak <p>Authorino examples include a bundle of Keycloak preloaded with the following realm setup:</p> <ul> <li>Admin console: http://localhost:8080/admin  (admin/p)</li> <li>Preloaded realm: kuadrant</li> <li>Preloaded clients:<ul> <li>demo: to which API consumers delegate access and therefore the one which access tokens are issued to</li> <li>authorino: used by Authorino to fetch additional user info with <code>client_credentials</code> grant type</li> <li>talker-api: used by Authorino to fetch UMA-protected resource data associated with the Talker API</li> </ul> </li> <li>Preloaded resources:<ul> <li><code>/hello</code></li> <li><code>/greetings/1</code> (owned by user john)</li> <li><code>/greetings/2</code> (owned by user jane)</li> <li><code>/goodbye</code></li> </ul> </li> <li>Realm roles:<ul> <li>member (default to all users)</li> <li>admin</li> </ul> </li> <li>Preloaded users:<ul> <li>john/p (member)</li> <li>jane/p (admin)</li> <li>peter/p (member, email not verified)</li> </ul> </li> </ul> <p>To deploy, run:</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/keycloak/keycloak-deploy.yaml\n</code></pre> <p>Forward local requests to the instance of Keycloak running in the cluster:</p> <pre><code>kubectl port-forward deployment/keycloak 8080:8080 &amp;\n</code></pre> Dex <p>Authorino examples include a bundle of Dex preloaded with the following setup:</p> <ul> <li>Preloaded clients:<ul> <li>demo: to which API consumers delegate access and therefore the one which access tokens are issued to (Client secret: aaf88e0e-d41d-4325-a068-57c4b0d61d8e)</li> </ul> </li> <li>Preloaded users:<ul> <li>marta@localhost/password</li> </ul> </li> </ul> <p>To deploy, run:</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/dex/dex-deploy.yaml\n</code></pre> <p>Forward local requests to the instance of Dex running in the cluster:</p> <pre><code>kubectl port-forward deployment/dex 5556:5556 &amp;\n</code></pre> a12n-server <p>Authorino examples include a bundle of a12n-server and corresponding MySQL database, preloaded with the following setup:</p> <ul> <li>Admin console: http://a12n-server:8531 (admin/123456)</li> <li>Preloaded clients:<ul> <li>service-account-1: to obtain access tokens via <code>client_credentials</code> OAuth2 grant type, to consume the Talker API (Client secret: DbgXROi3uhWYCxNUq_U1ZXjGfLHOIM8X3C2bJLpeEdE); includes metadata privilege: <code>{ \"talker-api\": [\"read\"] }</code> that can be used to write authorization policies</li> <li>talker-api: to authenticate to the token introspect endpoint (Client secret: V6g-2Eq2ALB1_WHAswzoeZofJ_e86RI4tdjClDDDb4g)</li> </ul> </li> </ul> <p>To deploy, run:</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/a12n-server/a12n-server-deploy.yaml\n</code></pre> <p>Forward local requests to the instance of a12n-server running in the cluster:</p> <pre><code>kubectl port-forward deployment/a12n-server 8531:8531 &amp;\n</code></pre>"},{"location":"authorino/docs/contributing/#re-build-and-rollout-latest","title":"Re-build and rollout latest","text":"<p>Re-build and rollout latest Authorino image:</p> <pre><code>make local-rollout\n</code></pre> <p>If you made changes to the CRD between iterations, re-install by running:</p> <pre><code>make install\n</code></pre>"},{"location":"authorino/docs/contributing/#clean-up","title":"Clean-up","text":"<p>The following command deletes the entire Kubernetes cluster started with Kind:</p> <pre><code>make local-cleanup\n</code></pre>"},{"location":"authorino/docs/contributing/#sign-your-commits","title":"Sign your commits","text":"<p>All commits to be accepted to Authorino's code are required to be signed. Refer to this page about signing your commits.</p>"},{"location":"authorino/docs/contributing/#logging-policy","title":"Logging policy","text":"<p>A few guidelines for adding logging messages in your code:</p> <ol> <li>Make sure you understand Authorino's Logging architecture and policy regarding log levels, log modes, tracing IDs, etc.</li> <li>Respect controller-runtime's Logging Guidelines.</li> <li>Do not add sensitive data to your <code>info</code> log messages; instead, redact all sensitive data in your log messages or use <code>debug</code> log level by mutating the logger with <code>V(1)</code> before outputting the message.</li> </ol>"},{"location":"authorino/docs/contributing/#additional-resources","title":"Additional resources","text":"<p>Here in the repo:</p> <ul> <li>Getting started</li> <li>Terminology</li> <li>Architecture</li> <li>Feature description</li> </ul> <p>Other repos:</p> <ul> <li>Authorino Operator</li> <li>Authorino examples</li> </ul>"},{"location":"authorino/docs/contributing/#reach-out","title":"Reach out","text":"<p>#kuadrant channel on kubernetes.slack.com.</p>"},{"location":"authorino/docs/features/","title":"Features","text":""},{"location":"authorino/docs/features/#overview","title":"Overview","text":"<p>We call features of Authorino the different things one can do to enforce identity verification &amp; authentication and authorization on requests to protected services. These can be a specific identity verification method based on a supported authentication protocol, or a method to fetch additional auth metadata in request-time, etc.</p> <p>Most features of Authorino relate to the different phases of the Auth Pipeline and therefore are configured in the Authorino <code>AuthConfig</code>. An identity verification/authentication feature usually refers to a functionality of Authorino such as the API key-based authentication, the validation of JWTs/OIDC ID tokens, and authentication based on Kubernetes TokenReviews. Analogously, OPA, pattern-matching and Kubernetes SubjectAccessReview are examples of authorization features of Authorino.</p> <p>At a deeper level, a feature can also be an additional functionality within a bigger feature, usually applicable to the whole class the bigger feature belongs to. For instance, the configuration of how auth credentials expected to be carried in the request, which is broadly available for any identity verification method. Other examples are: Identity extension and Priorities.</p> <p>A full specification of all features of Authorino that can be configured in an <code>AuthConfig</code> can be found in the official spec of the custom resource definition.</p> <p>You can also learn about Authorino features by using the <code>kubectl explain</code> command in a Kubernetes cluster where the Authorino CRD has been installed. E.g. <code>kubectl explain authconfigs.spec.authentication.credentials</code>.</p>"},{"location":"authorino/docs/features/#common-feature-json-paths-selector","title":"Common feature: JSON paths (<code>selector</code>)","text":"<p>Deprecated: Prefer <code>predicate</code> and <code>expression</code>, based on Common Expression Language (CEL), instead.</p> <p>The first feature of Authorino to learn about is a common functionality used in the specification of many other features. JSON paths are selectors of data from the Authorization JSON used in parts of an AuthConfig for referring to dynamic values of each authorization request.</p> <p>Usage examples of JSON paths are: dynamic URLs and request parameters when fetching metadata from external sources, dynamic authorization policy rules, and dynamic authorization response attributes (e.g. injected HTTP headers, Festival Wristband token claims, etc).</p>"},{"location":"authorino/docs/features/#syntax","title":"Syntax","text":"<p>The syntax to fetch data from the Authorization JSON with JSON paths is based on GJSON. Refer to GJSON Path Syntax page for more information.</p>"},{"location":"authorino/docs/features/#string-modifiers","title":"String modifiers","text":"<p>On top of GJSON, Authorino defines a few string modifiers.</p> <p>Examples below provided for the following Authorization JSON:</p> <pre><code>{\n  \"context\": {\n    \"request\": {\n      \"http\": {\n        \"path\": \"/pets/123\",\n        \"headers\": {\n          \"authorization\": \"Basic amFuZTpzZWNyZXQK\" // jane:secret\n          \"baggage\": \"eyJrZXkxIjoidmFsdWUxIn0=\" // {\"key1\":\"value1\"}\n        }\n      }\n    }\n  },\n  \"auth\": {\n    \"identity\": {\n      \"username\": \"jane\",\n      \"fullname\": \"Jane Smith\",\n      \"email\": \"\\u0006jane\\u0012@petcorp.com\\n\"\n    },\n  },\n}\n</code></pre> <p><code>@strip</code> Strips out any non-printable characters such as carriage return. E.g. <code>auth.identity.email.@strip</code> \u2192 <code>\"jane@petcorp.com\"</code>.</p> <p><code>@case:upper|lower</code> Changes the case of a string. E.g. <code>auth.identity.username.@case:upper</code> \u2192 <code>\"JANE\"</code>.</p> <p><code>@replace:{\"old\":string,\"new\":string}</code> Replaces a substring within a string. E.g. <code>auth.identity.username.@replace:{\"old\":\"Smith\",\"new\":\"Doe\"}</code> \u2192 <code>\"Jane Doe\"</code>.</p> <p><code>@extract:{\"sep\":string,\"pos\":int}</code> Splits a string at occurrences of a separator (default: <code>\" \"</code>) and selects the substring at the <code>pos</code>-th position (default: <code>0</code>). E.g. <code>context.request.path.@extract:{\"sep\":\"/\",\"pos\":2}</code> \u2192 <code>123</code>.</p> <p><code>@base64:encode|decode</code> base64-encodes or decodes a string value. E.g. <code>auth.identity.username.decoded.@base64:encode</code> \u2192 <code>\"amFuZQo=\"</code>.</p> <p>In combination with <code>@extract</code>, <code>@base64</code> can be used to extract the username in an HTTP Basic Authentication request. E.g. <code>context.request.headers.authorization.@extract:{\"pos\":1}|@base64:decode|@extract:{\"sep\":\":\",\"pos\":1}</code> \u2192 <code>\"jane\"</code>.</p>"},{"location":"authorino/docs/features/#interpolation","title":"Interpolation","text":"<p>JSON paths can be interpolated into strings to build template-like dynamic values. E.g. <code>\"Hello, {auth.identity.name}!\"</code>.</p>"},{"location":"authorino/docs/features/#common-feature-common-expression-language-cel","title":"Common feature: Common Expression Language (CEL)","text":"<p>Similar to JSON Paths, Authorino supports Common Expression Language (CEL) for selecting data from the Authorization JSON and representing predicates. This is a more powerful, properly typed alternative to JSON Paths, with a well-documented syntax.</p> <p>String extension functions, such as <code>split</code>, <code>substring</code>, <code>indexOf</code>, etc, are also supported.</p> <p>Use the <code>expression</code> field for selecting values from the Authorization JSON. The type of the selected value will be converted to a JSON-compatible equivalent. Complex types without a direct JSON equivalent may be converted to objects (e.g. <code>google.golang.org/protobuf/types/known/timestamppb.Timestamp</code> gets converted to <code>{ \"seconds\": Number, \"nanos\": Number }</code>)</p> <p>The most common applications of <code>expression</code> are for building dynamic URLs and request parameters when fetching metadata from external sources, extending properties of identity objects, and dynamic authorization response attributes (e.g. injected HTTP headers, etc).</p> <p>Use <code>predicate</code> for expressions that return a boolean value, such as in <code>when</code> conditions and pattern-matching authorization rules.</p>"},{"location":"authorino/docs/features/#identity-verification-authentication-features-authentication","title":"Identity verification &amp; authentication features (<code>authentication</code>)","text":""},{"location":"authorino/docs/features/#api-key-authenticationapikey","title":"API key (<code>authentication.apiKey</code>)","text":"<p>Authorino relies on Kubernetes <code>Secret</code> resources to represent API keys.</p> <p>To define an API key, create a <code>Secret</code> in the cluster containing an <code>api_key</code> entry that holds the value of the API key.</p> <p>API key secrets must be created in the same namespace of the <code>AuthConfig</code> (default) or <code>spec.authentication.apiKey.allNamespaces</code> must be set to <code>true</code> (only works with cluster-wide Authorino instances).</p> <p>API key secrets must be labeled with the labels that match the selectors specified in <code>spec.authentication.apiKey.selector</code> in the <code>AuthConfig</code>.</p> <p>Whenever an <code>AuthConfig</code> is indexed, Authorino will also index all matching API key secrets. In order for Authorino to also watch events related to API key secrets individually (e.g. new <code>Secret</code> created, updates, deletion/revocation), <code>Secret</code>s must also include a label that matches Authorino's bootstrap configuration <code>--secret-label-selector</code> (default: <code>authorino.kuadrant.io/managed-by=authorino</code>). This label may or may not be present to <code>spec.authentication.apiKey.selector</code> in the <code>AuthConfig</code> without implications for the caching of the API keys when triggered by the reconciliation of the <code>AuthConfig</code>; however, if not present, individual changes related to the API key secret (i.e. without touching the <code>AuthConfig</code>) will be ignored by the reconciler.</p> <p>Example. For the following <code>AuthConfig</code>:</p> <pre><code>apiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: my-api-protection\n  namespace: authorino-system\nspec:\n  hosts:\n\n  - my-api.io\n  authentication:\n    \"api-key-users\":\n      apiKey:\n        selector:\n          matchLabels: # the key-value set used to select the matching `Secret`s; resources including these labels will be accepted as valid API keys to authenticate to this service\n            group: friends # some custom label\n        allNamespaces: true # only works with cluster-wide Authorino instances; otherwise, create the API key secrets in the same namespace of the AuthConfig\n</code></pre> <p>The following Kubernetes <code>Secret</code> represents a valid API key:</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: user-1-api-key-1\n  namespace: default\n  labels:\n    authorino.kuadrant.io/managed-by: authorino # so the Authorino controller reconciles events related to this secret\n    group: friends\nstringData:\n  api_key: &lt;some-randomly-generated-api-key-value&gt;\ntype: Opaque\n</code></pre> <p>The resolved identity object, added to the authorization JSON following an API key identity source evaluation, is the Kubernetes <code>Secret</code> resource (as JSON).</p>"},{"location":"authorino/docs/features/#kubernetes-tokenreview-authenticationkubernetestokenreview","title":"Kubernetes TokenReview (<code>authentication.kubernetesTokenReview</code>)","text":"<p>Authorino can verify Kubernetes-valid access tokens (using Kubernetes TokenReview API).</p> <p>These tokens can be either <code>ServiceAccount</code> tokens such as the ones issued by kubelet as part of Kubernetes Service Account Token Volume Projection, or any valid user access tokens issued to users of the Kubernetes server API.</p> <p>The list of <code>audiences</code> of the token must include the requested host and port of the protected API (default), or all audiences specified in the Authorino <code>AuthConfig</code> custom resource. For example:</p> <p>For the following <code>AuthConfig</code> CR, the Kubernetes token must include the audience <code>my-api.io</code>:</p> <pre><code>apiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: my-api-protection\nspec:\n  hosts:\n\n  - my-api.io\n  authentication:\n    \"cluster-users\":\n      kubernetesTokenReview: {}\n</code></pre> <p>Whereas for the following <code>AuthConfig</code> CR, the Kubernetes token audiences must include foo and bar:</p> <pre><code>apiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: my-api-protection\nspec:\n  hosts:\n\n  - my-api.io\n  authentication:\n    \"cluster-users\":\n      kubernetesTokenReview:\n        audiences:\n        - foo\n        - bar\n</code></pre> <p>The resolved identity object added to the authorization JSON following a successful Kubernetes authentication identity evaluation is the <code>status</code> field of TokenReview response (see TokenReviewStatus for reference).</p>"},{"location":"authorino/docs/features/#jwt-verification-authenticationjwt","title":"JWT verification (<code>authentication.jwt</code>)","text":"<p>JWT authentication comes in two forms:</p> <ol> <li> <p>For token issuers that implement OpenId Connect: At reconciliation-time, using OpenID Connect Discovery well-known endpoint, Authorino automatically discovers and caches OpenID Connect configurations for all OpenID Connect issuers declared in an <code>AuthConfig</code>. At request-time, Authorino fetches the JSON Web Key Sets (JWKS) if needed, using the <code>jwks_uri</code> obtained from the OpenId configuration. Then, it verifies the JSON Web Signature (JWS) and checks the time validity of signed JSON Web Tokens (JWT) supplied in the request. Activate this form with <code>authentication.jwt.issuerUrl</code>.</p> <p></p> <ul> <li>OpenID Connect configurations can be configured to be automatically refreshed (i.e., pulled again from the OpenID Connect Discovery well-known endpoint), by setting the <code>authentication.jwt.ttl</code> field. The value of the field is given in seconds and it defaults to <code>0</code> (i.e. auto-refresh of the OIDC config disabled).</li> </ul> </li> <li> <p>For token issuers that do NOT implement OpenId Connect: At request-time, whenever needed, Authorino fetches the JSON Web Key Sets (JWKS) directly from a user-provided URI, without using any discovery or server metadata manifest. Then, it verifies the JSON Web Signature (JWS) and checks the time validity of signed JSON Web Tokens (JWT) supplied in the request. Activate this form with <code>authentication.jwt.jwksUrl</code>.</p> <p></p> </li> </ol> <p>The <code>kid</code> claim stated in the JWT header must match one of the keys cached by Authorino. JSON Web Key Sets are automatically updated whenever the service sees a new <code>kid</code> that is not listed in the cache. This enables support for JWK rotation and it is the strategy recommended in the spec (https://openid.net/specs/openid-connect-core-1_0.html#RotateSigKeys).</p> <p>After veryfing and validating a JWT, the decoded payload of the JWT is appended to the authorization JSON as the resolved identity object.</p> <p>Important! Authorino does not implement OAuth2 grants nor OIDC authentication flows. As a common recommendation of good practice, obtaining and refreshing access tokens is for clients to negotiate directly with the auth servers and token issuers. Authorino will only validate those tokens using the parameters provided by the trusted issuer authorities.</p> <p>For an excellent summary of the underlying concepts and standards that relate OpenID Connect and JSON Object Signing and Encryption (JOSE), see this article by Jan Rusnacko. For official specification and RFCs, see OpenID Connect Core, OpenID Connect Discovery, JSON Web Token (JWT) (RFC7519), and JSON Object Signing and Encryption (JOSE).</p>"},{"location":"authorino/docs/features/#oauth-20-introspection-authenticationoauth2introspection","title":"OAuth 2.0 introspection (<code>authentication.oauth2Introspection</code>)","text":"<p>For bare OAuth 2.0 implementations, Authorino can perform token introspection on the access tokens supplied in the requests to protected APIs.</p> <p>Authorino does not implement any of OAuth 2.0 grants for the applications to obtain the token. However, it can verify supplied tokens with the OAuth server, including opaque tokens, as long as the server exposes the <code>token_introspect</code> endpoint (RFC 7662).</p> <p>Developers must set the token introspection endpoint in the <code>AuthConfig</code>, as well as a reference to the Kubernetes secret storing the credentials of the OAuth client to be used by Authorino when requesting the introspect.</p> <p></p> <p>The response returned by the OAuth2 server to the token introspection request is the resolved identity appended to the authorization JSON.</p>"},{"location":"authorino/docs/features/#x509-client-certificate-authentication-authenticationx509","title":"X.509 client certificate authentication (<code>authentication.x509</code>)","text":"<p>Authorino can verify X.509 certificates presented by clients for authentication on the request to the protected APIs, at application level.</p> <p>Trusted root Certificate Authorities (CA) are stored in Kubernetes Secrets labeled according to selectors specified in the AuthConfig, watched and indexed by Authorino. Make sure to create proper <code>kubernetes.io/tls</code>-typed Kubernetes Secrets, containing the public certificates of the CA stored in either a <code>tls.crt</code> or <code>ca.crt</code> entry inside the secret.</p> <p>Trusted root CA secrets must be created in the same namespace of the <code>AuthConfig</code> (default) or <code>spec.authentication.x509.allNamespaces</code> must be set to <code>true</code> (only works with cluster-wide Authorino instances).</p> <p>Client certificates must include x509 v3 extension specifying 'Client Authentication' extended key usage.</p> <p>The identity object resolved out of a client x509 certificate is equal to the subject field of the certificate, and it serializes as JSON within the Authorization JSON usually as follows:</p> <pre><code>{\n    \"auth\": {\n        \"identity\": {\n            \"CommonName\": \"aisha\",\n            \"Country\": [\"PK\"],\n            \"ExtraNames\": null,\n            \"Locality\": [\"Islamabad\"],\n            \"Names\": [\n                { \"Type\": [2, 5, 4, 3], \"Value\": \"aisha\" },\n                { \"Type\": [2, 5, 4, 6], \"Value\": \"PK\" },\n                { \"Type\": [2, 5, 4, 7], \"Value\": \"Islamabad\" },\n                { \"Type\": [2, 5, 4,10], \"Value\": \"ACME Inc.\" },\n                { \"Type\": [2, 5, 4,11], \"Value\": \"Engineering\" }\n            ],\n            \"Organization\": [\"ACME Inc.\"],\n            \"OrganizationalUnit\": [\"Engineering\"],\n            \"PostalCode\": null,\n            \"Province\": null,\n            \"SerialNumber\": \"\",\n            \"StreetAddress\": null\n        }\n  }\n}\n</code></pre>"},{"location":"authorino/docs/features/#plain-authenticationplain","title":"Plain (<code>authentication.plain</code>)","text":"<p>Authorino can read plain identity objects, based on authentication tokens provided and verified beforehand using other means (e.g. Envoy JWT Authentication filter, Kubernetes API server authentication), and injected into the payload to the external authorization service.</p> <p>The plain identity object is retrieved from the Authorization JSON. See Common Expression Language (CEL).</p> <p>This feature is particularly useful in cases where authentication/identity verification is handled before invoking the authorization service and its resolved value injected in the payload can be trusted. Examples of applications for this feature include:</p> <ul> <li>Authentication handled in Envoy leveraging the Envoy JWT Authentication filter (decoded JWT injected as 'metadata_context')</li> <li>Use of Authorino as Kubernetes ValidatingWebhook service (Kubernetes 'userInfo' injected in the body of the <code>AdmissionReview</code> request)</li> </ul> <p>Example of <code>AuthConfig</code> to retrieve plain identity object from the Authorization JSON.</p> <pre><code>spec:\n  authentication:\n    \"pre-validated-jwt\":\n      plain:\n        expression: metadata.filter_metadata['envoy.filters.http.jwt_authn'].verified_jwt\n</code></pre> <p>If the specified JSON path does not exist in the Authorization JSON or the value is <code>null</code>, the identity verification will fail and, unless other identity config succeeds, Authorino will halt the Auth Pipeline with the usual <code>401 Unauthorized</code>.</p>"},{"location":"authorino/docs/features/#anonymous-access-authenticationanonymous","title":"Anonymous access (<code>authentication.anonymous</code>)","text":"<p>Literally a no-op evaluator for the identity verification phase that returns a static identity object <code>{\"anonymous\":true}</code>.</p> <p>It allows to implement <code>AuthConfigs</code> that bypasses the identity verification phase of Authorino, to such as:</p> <ul> <li>enable anonymous access to protected services (always or combined with Priorities)</li> <li>postpone authentication in the Auth Pipeline to be resolved as part of an OPA policy</li> </ul> <p>Example of <code>AuthConfig</code> spec that falls back to anonymous access when OIDC authentication fails, enforcing read-only access to the protected service in such cases:</p> <pre><code>spec:\n  authentication:\n    \"jwt\":\n      jwt:\n        issuerUrl: \"\u2026\"\n    \"anonymous\":\n      priority: 1 # expired oidc token, missing creds, etc. default to anonymous access\n      anonymous: {}\n  authorization:\n    \"read-only-access-if-authn-fails\":\n      when:\n\n      - predicate: auth.identity.anonymous?\n      patternMatching:\n        patterns:\n        - predicate: request.method == 'GET'\n</code></pre>"},{"location":"authorino/docs/features/#festival-wristband-authentication","title":"Festival Wristband authentication","text":"<p>Authorino-issued Festival Wristband tokens can be validated as any other signed JWT using Authorino's JWT verification.</p> <p>The value of the issuer must be the same issuer specified in the custom resource for the protected API originally issuing wristband. Eventually, this can be the same custom resource where the wristband is configured as a valid source of identity, but not necessarily.</p>"},{"location":"authorino/docs/features/#extra-auth-credentials-authenticationcredentials","title":"Extra: Auth credentials (<code>authentication.credentials</code>)","text":"<p>All the identity verification methods supported by Authorino can be configured regarding the location where access tokens and credentials (i.e. authentication secrets) fly within the request.</p> <p>By default, authentication secrets are expected to be supplied in the <code>Authorization</code> HTTP header, with the default <code>Bearer</code> prefix and the plain authentication secret separated by space.</p> <p>The full list of supported options is exemplified below:</p> <pre><code>spec:\n  authentication:\n    \"creds-in-the-authz-header\":\n      credentials:\n        authorizationHeader:\n          prefix: JWT\n\n    \"creds-in-a-custom-header\":\n      credentials:\n        customHeader:\n          name: X-MY-CUSTOM-HEADER\n          prefix: \"\"\n\n    \"creds-in-a-query-param\":\n      queryString:\n        name: my_param\n\n    \"creds-in-a-cookie-entry\":\n      cookie:\n        name: cookie-key\n</code></pre>"},{"location":"authorino/docs/features/#extra-identity-extension-authenticationdefaults-and-authenticationoverrides","title":"Extra: Identity extension (<code>authentication.defaults</code> and <code>authentication.overrides</code>)","text":"<p>Resolved identity objects can be extended with user-defined JSON properties. Values can be static or fetched from the Authorization JSON.</p> <p>A typical use-case for this feature is token normalization. Say you have more than one identity source listed in your <code>AuthConfig</code> but each source issues an access token with a different JSON structure \u2013 e.g. two OIDC issuers that use different names for custom JWT claims of similar meaning; when two different identity verification/authentication methods are combined, such as API keys (whose identity objects are the corresponding Kubernetes <code>Secret</code>s) and Kubernetes tokens (whose identity objects are Kubernetes UserInfo data).</p> <p>In such cases, identity extension can be used to normalize the token to always include the same set of JSON properties of interest, regardless of the source of identity that issued the original token verified by Authorino. This simplifies the writing of authorization policies and configuration of dynamic responses.</p> <p>In case of extending an existing property of the identity object (replacing), the API allows to control whether to overwrite the value or not. This is particularly useful for normalizing tokens of a same identity source that nonetheless may occasionally differ in structure, such as in the case of JWT claims that sometimes may not be present but can be safely replaced with another (e.g. <code>username</code> or <code>sub</code>).</p>"},{"location":"authorino/docs/features/#external-auth-metadata-features-metadata","title":"External auth metadata features (<code>metadata</code>)","text":""},{"location":"authorino/docs/features/#http-getget-by-post-metadatahttp","title":"HTTP GET/GET-by-POST (<code>metadata.http</code>)","text":"<p>Generic HTTP adapter that sends a request to an external service. It can be used to fetch external metadata for the authorization policies (phase ii of the Authorino Auth Pipeline), or as a web hook.</p> <p>The adapter allows issuing requests either by GET or POST methods; in both cases with URL and parameters defined by the user in the spec. Dynamic values fetched from the Authorization JSON can be used.</p> <p>POST request parameters as well as the encoding of the content can be controlled using the <code>bodyParameters</code> and <code>contentType</code> fields of the config, respectively. The Content-Type of POST requests can be either <code>application/x-www-form-urlencoded</code> (default) or <code>application/json</code>.</p> <p>Authentication of Authorino with the external metadata server can be set either via long-lived shared secret stored in a Kubernetes Secret or via OAuth2 client credentials grant. For long-lived shared secret, set the <code>sharedSecretRef</code> field. For OAuth2 client credentials grant, use the <code>oauth2</code> option.</p> <p>In both cases, the location where the secret (long-lived or OAuth2 access token) travels in the request performed to the external HTTP service can be specified in the <code>credentials</code> field. By default, the authentication secret is supplied in the <code>Authorization</code> header with the <code>Bearer</code> prefix.</p> <p>Custom headers can be set with the <code>headers</code> field. Nevertheless, headers such as <code>Content-Type</code> and <code>Authorization</code> (or eventual custom header used for carrying the authentication secret, set instead via the <code>credentials</code> option) will be superseded by the respective values defined for the fields <code>contentType</code> and <code>sharedSecretRef</code>.</p>"},{"location":"authorino/docs/features/#oidc-userinfo-metadatauserinfo","title":"OIDC UserInfo (<code>metadata.userInfo</code>)","text":"<p>Online fetching of OpenID Connect (OIDC) UserInfo data (phase ii of the Authorino Auth Pipeline), associated with an OIDC identity source configured and resolved in phase (i).</p> <p>Apart from possibly complementing information of the JWT, fetching OpenID Connect UserInfo in request-time can be particularly useful for remote checking the state of the session, as opposed to only verifying the JWT/JWS offline.</p> <p>Implementation requires a JWT verification authentication config (<code>spec.authentication.jwt</code>) in the same <code>AuthConfig</code>, so the well-known configuration of the OpenId Connect (OIDC) issuer can be reused.</p> <p>The response returned by the OIDC server to the UserInfo request is appended (as JSON) to <code>auth.metadata</code> in the authorization JSON.</p>"},{"location":"authorino/docs/features/#user-managed-access-uma-resource-registry-metadatauma","title":"User-Managed Access (UMA) resource registry (<code>metadata.uma</code>)","text":"<p>User-Managed Access (UMA) is an OAuth-based protocol for resource owners to allow other users to access their resources. Since the UMA-compliant server is expected to know about the resources, Authorino includes a client that fetches resource data from the server and adds that as metadata of the authorization payload.</p> <p>This enables the implementation of resource-level Attribute-Based Access Control (ABAC) policies. Attributes of the resource fetched in a UMA flow can be, e.g., the owner of the resource, or any business-level attributes stored in the UMA-compliant server.</p> <p>A UMA-compliant server is an external authorization server (e.g., Keycloak) where the protected resources are registered. It can be as well the upstream API itself, as long as it implements the UMA protocol, with initial authentication by <code>client_credentials</code> grant to exchange for a Protected API Token (PAT).</p> <p></p> <p>It's important to notice that Authorino does NOT manage resources in the UMA-compliant server. As shown in the flow above, Authorino's UMA client is only to fetch data about the requested resources. Authorino exchanges client credentials for a Protected API Token (PAT), then queries for resources whose URI match the path of the HTTP request (as passed to Authorino by the Envoy proxy) and fetches data of each matching resource.</p> <p>The resources data is added as metadata of the authorization payload and passed as input for the configured authorization policies. All resources returned by the UMA-compliant server in the query by URI are passed along. They are available in the PDPs (authorization payload) as <code>input.auth.metadata.custom-name =&gt; Array</code>. (See The \"Auth Pipeline\" for details.)</p>"},{"location":"authorino/docs/features/#authorization-features-authorization","title":"Authorization features (<code>authorization</code>)","text":""},{"location":"authorino/docs/features/#pattern-matching-authorization-authorizationpatternmatching","title":"Pattern-matching authorization (<code>authorization.patternMatching</code>)","text":"<p>Grant/deny access based on simple pattern-matching expressions (\"patterns\") compared against values selected from the Authorization JSON.</p> <p>Each expression is composed of exactly one of the following options:</p> <ol> <li>a <code>predicate</code> field - Common Expression Language (CEL) expression that evaluates to a boolean value;</li> <li>a tuple composed of:</li> <li><code>selector</code>: a JSON path to fetch a value from the Authorization JSON</li> <li><code>operator</code>: one of: <code>eq</code> (equals), <code>neq</code> (not equal); <code>incl</code> (includes) and <code>excl</code> (excludes), for arrays; and <code>matches</code>, for regular expressions</li> <li><code>value</code>: a static string value to compare the value selected from the Authorization JSON with;</li> <li>a <code>patternRef</code> field \u2013 value that maps to a predefined set of <code>{ selector, operator, value }</code> tuples stored at the top-level of the AuthConfig spec (<code>patterns</code>).</li> </ol> <p>Rules can mix and combine literal expressions and references to expression sets (\"named patterns\") defined at the upper level of the <code>AuthConfig</code> spec. (See Common feature: Conditions)</p> <pre><code>spec:\n  authorization:\n    \"my-simple-json-pattern-matching-policy\":\n      patternMatching:\n        patterns: # All patterns must match for access to be granted\n\n        - predicate: auth.identity.email_verified\n        - patternRef: admin\n\n  patterns:\n    admin: # a named pattern that can be reused in other sets of rules or conditions\n\n    - selector: auth.identity.roles\n      operator: incl\n      value: admin\n</code></pre>"},{"location":"authorino/docs/features/#open-policy-agent-opa-rego-policies-authorizationopa","title":"Open Policy Agent (OPA) Rego policies (<code>authorization.opa</code>)","text":"<p>You can model authorization policies in Rego language and add them as part of the protection of your APIs.</p> <p>Policies can be either declared in-line in Rego language (<code>rego</code>) or as an HTTP endpoint where Authorino will fetch the source code of the policy in reconciliation-time (<code>externalPolicy</code>).</p> <p>Policies pulled from external registries can be configured to be automatically refreshed (pulled again from the external registry), by setting the <code>authorization.opa.externalPolicy.ttl</code> field (given in seconds, default: <code>0</code> \u2013 i.e. auto-refresh disabled).</p> <p>Authorino's built-in OPA module precompiles the policies during reconciliation of the AuthConfig and caches the precompiled policies for fast evaluation in runtime, where they receive the Authorization JSON as input.</p> <p></p> <p>An optional field <code>allValues: boolean</code> makes the values of all rules declared in the Rego document to be returned in the OPA output after policy evaluation. When disabled (default), only the boolean value <code>allow</code> is returned. Values of internal rules of the Rego document can be referenced in subsequent policies/phases of the Auth Pipeline.</p>"},{"location":"authorino/docs/features/#kubernetes-subjectaccessreview-authorizationkubernetessubjectaccessreview","title":"Kubernetes SubjectAccessReview (<code>authorization.kubernetesSubjectAccessReview</code>)","text":"<p>Access control enforcement based on rules defined in the Kubernetes authorization system, i.e. <code>Role</code>, <code>ClusterRole</code>, <code>RoleBinding</code> and <code>ClusterRoleBinding</code> resources of Kubernetes RBAC.</p> <p>Authorino issues a SubjectAccessReview (SAR) inquiry that checks with the underlying Kubernetes server whether the user can access a particular resource, resource kind or generic URL.</p> <p>It supports resource attributes authorization check (parameters defined in the <code>AuthConfig</code>) and non-resource attributes authorization check (HTTP endpoint inferred from the original request).</p> <ul> <li>Resource attributes: adequate for permissions set at namespace level, defined in terms of common attributes of operations on Kubernetes resources (namespace, API group, kind, name, subresource, verb)</li> <li>Non-resource attributes: adequate for permissions set at cluster scope, defined for protected endpoints of a generic HTTP API (URL path + verb)</li> </ul> <p>Example of Kubernetes role for resource attributes authorization:</p> <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: pet-reader\nrules:\n\n- apiGroups: [\"pets.io\"]\n  resources: [\"pets\"]\n  verbs: [\"get\"]\n</code></pre> <p>Example of Kubernetes cluster role for non-resource attributes authorization:</p> <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: pet-editor\nrules:\n\n- nonResourceURLs: [\"/pets/*\"]\n  verbs: [\"put\", \"delete\"]\n</code></pre> <p>Kubernetes' authorization policy configs look like the following in an Authorino <code>AuthConfig</code>:</p> <pre><code>authorization:\n  \"kubernetes-rbac\":\n    kubernetesSubjectAccessReview:\n      user: # values of the parameter can be fixed (`value`) or fetched from the Authorization JSON (`selector`)\n        expression: auth.identity.metadata.annotations.userid\n\n      groups: [] # user groups to test for.\n\n      # for resource attributes permission checks; omit it to perform a non-resource attributes SubjectAccessReview with path and method/verb assumed from the original request\n      # if included, use the resource attributes, where the values for each parameter can be fixed (`value`) or fetched from the Authorization JSON (`selector`)\n      resourceAttributes:\n        namespace:\n          value: default\n        group:\n          value: pets.io # the api group of the protected resource to be checked for permissions for the user\n        resource:\n          value: pets # the resource kind\n        name:\n          expression: request.path.split('/')[2] # resource name \u2013 e.g., the {id} in `/pets/{id}`\n        verb:\n          expression: request.method.lowerAscii() # api operation \u2013 e.g., copying from the context to use the same http method of the request\n</code></pre> <p><code>user</code> and properties of <code>resourceAttributes</code> can be defined from fixed values or patterns of the Authorization JSON.</p> <p>An array of <code>groups</code> (optional) can as well be set. When defined, it will be used in the <code>SubjectAccessReview</code> request.</p>"},{"location":"authorino/docs/features/#spicedb-authorizationspicedb","title":"SpiceDB (<code>authorization.spicedb</code>)","text":"<p>Check permission requests via gRPC with an external Google Zanzibar-inspired SpiceDB server, by Authzed.</p> <p>Subject, resource and permission parameters can be set to static values or read from the Authorization JSON.</p> <pre><code>spec:\n  authorization:\n    \"spicedb\":\n      spicedb:\n        endpoint: spicedb:50051\n        insecure: true # disables TLS\n        sharedSecretRef:\n          name: spicedb\n          key: token\n        subject:\n          kind:\n            value: blog/user\n          name:\n            expression: auth.identity.sub\n        resource:\n          kind:\n            value: blog/post\n          name:\n            expression: request.path.split('/')[2] # /posts/{id}\n        permission:\n          expression: request.method\n</code></pre>"},{"location":"authorino/docs/features/#custom-response-features-response","title":"Custom response features (<code>response</code>)","text":""},{"location":"authorino/docs/features/#custom-response-forms-successful-authorization-vs-custom-denial-status","title":"Custom response forms: successful authorization vs custom denial status","text":"<p>The response to the external authorization request can be customized in the following fashion:</p> <ul> <li>Successful authorization (<code>response.success</code>)</li> <li>Added HTTP headers (<code>response.success.headers</code>)</li> <li>Envoy Dynamic Metadata (<code>response.success.dynamicMetadata</code>)</li> <li>Custom denial status</li> <li>Unauthenticated (<code>response.unauthenticated</code>)</li> <li>Unauthorized (<code>response.unauthorized</code>)</li> </ul> <p>Successful authorization custom responses can be set based on any of the supported custom authorization methods:</p> <ul> <li>Plain text value</li> <li>JSON injection</li> <li>Festival Wristband Tokens</li> </ul>"},{"location":"authorino/docs/features/#added-http-headers","title":"Added HTTP headers","text":"<p>Set custom responses as HTTP headers injected in the request post-successful authorization by specifying one of the supported methods under <code>response.success.headers</code>.</p> <p>The name of the response config (default) or the value of the <code>key</code> option (if provided) will used as the name of the header.</p>"},{"location":"authorino/docs/features/#envoy-dynamic-metadata","title":"Envoy Dynamic Metadata","text":"<p>Authorino custom response methods can also be used to propagate Envoy Dynamic Metadata. To do so, set one of the supported methods under <code>response.success.dynamicMetadata</code>.</p> <p>The name of the response config (default) or the value of the <code>key</code> option (if provided) will used as the name of the root property of the dynamic metadata content.</p> <p>A custom response exported as Envoy Dynamic Metadata can be set in the Envoy route or virtual host configuration as input to a consecutive filter in the filter chain.</p> <p>E.g., to read metadata emitted by the authorization service with scheme <code>{ \"auth-data\": { \"api-key-ns\": string, \"api-key-name\": string } }</code>, as input in a rate limit configuration placed in the filter chain after the external authorization, the Envoy config may look like the following:</p> <pre><code># Envoy config snippet to inject `user_namespace` and `username` rate limit descriptors from metadata emitted by Authorino\nrate_limits:\n\n- actions:\n  - metadata:\n      metadata_key:\n        key: \"envoy.filters.http.ext_authz\"\n        path:\n        - key: auth-data # root of the dynamic metadata object, as declared in a custom response config of the AuthConfig (name or key)\n        - key: api-key-ns\n      descriptor_key: user_namespace\n  - metadata:\n      metadata_key:\n        key: \"envoy.filters.http.ext_authz\"\n        path:\n        - key: auth-data # root of the dynamic metadata object, as declared in a custom response config of the AuthConfig (name or key)\n        - key: api-key-name\n      descriptor_key: username\n</code></pre>"},{"location":"authorino/docs/features/#custom-denial-status-responseunauthenticated-and-responseunauthorized","title":"Custom denial status (<code>response.unauthenticated</code> and <code>response.unauthorized</code>)","text":"<p>By default, Authorino will inform Envoy to respond with <code>401 Unauthorized</code> or <code>403 Forbidden</code> respectively when the identity verification (phase i of the Auth Pipeline) or authorization (phase ii) fail. These can be customized respectively by specifying <code>spec.response.unauthanticated</code> and <code>spec.response.unauthorized</code> in the <code>AuthConfig</code>.</p>"},{"location":"authorino/docs/features/#custom-response-methods","title":"Custom response methods","text":""},{"location":"authorino/docs/features/#plain-text-responsesuccessheadersdynamicmetadataplain","title":"Plain text (<code>response.success.&lt;headers|dynamicMetadata&gt;.plain</code>)","text":"<p>Simpler, yet more generalized form, for extending the authorization response for header mutation and Envoy Dynamic Metadata, based on plain text values.</p> <p>The value can be static:</p> <pre><code>response:\n  success:\n    headers:\n      \"x-auth-service\"\n        plain:\n          value: Authorino\n</code></pre> <p>or fetched dynamically from the Authorization JSON (which includes support for interpolation):</p> <pre><code>response:\n  success:\n    headers:\n      \"x-username\":\n        plain:\n          expression: auth.identity.username\n</code></pre>"},{"location":"authorino/docs/features/#json-injection-responsesuccessheadersdynamicmetadatajson","title":"JSON injection (<code>response.success.&lt;headers|dynamicMetadata&gt;.json</code>)","text":"<p>User-defined dynamic JSON objects generated by Authorino in the response phase, from static or dynamic data of the auth pipeline, and passed back to the external authorization client within added HTTP headers or Dynamic Metadata.</p> <p>The following Authorino <code>AuthConfig</code> custom resource is an example that defines 3 dynamic JSON response items, where two items are returned to the client, stringified, in added HTTP headers, and the third as Envoy Dynamic Metadata. Envoy proxy can be configured to propagate the dynamic metadata emitted by Authorino into another filter \u2013 e.g. the rate limit filter.</p> <pre><code>apiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  namespace: my-namespace\n  name: my-api-protection\nspec:\n  hosts:\n\n  - my-api.io\n  authentication:\n    \"edge\":\n      apiKey:\n        selector:\n          matchLabels:\n            authorino.kuadrant.io/managed-by: authorino\n      credentials:\n        authorizationHeader:\n          prefix: APIKEY\n  response:\n    success:\n      headers:\n        \"x-my-custom-header\":\n          json:\n            properties:\n              \"prop1\":\n                value: value1\n              \"prop2\":\n                expression: some.path.within.auth.json\n        \"x-ext-auth-other-json\":\n          json:\n            properties:\n              \"propX\":\n                value: valueX\n\n      dynamicMetadata:\n        \"auth-data\":\n          json:\n            properties:\n              \"api-key-ns\":\n                expression: auth.identity.metadata.namespace\n              \"api-key-name\":\n                expression: auth.identity.metadata.name\n</code></pre>"},{"location":"authorino/docs/features/#festival-wristband-tokens-responsesuccessheadersdynamicmetadatawristband","title":"Festival Wristband tokens (<code>response.success.&lt;headers|dynamicMetadata&gt;.wristband</code>)","text":"<p>Festival Wristbands are signed OpenID Connect JSON Web Tokens (JWTs) issued by Authorino at the end of the auth pipeline and passed back to the client, typically in added HTTP response header. It is an opt-in feature that can be used to implement Edge Authentication Architecture (EAA) and enable token normalization. Authorino wristbands include minimal standard JWT claims such as <code>iss</code>, <code>iat</code>, and <code>exp</code>, and optional user-defined custom claims, whose values can be static or dynamically fetched from the authorization JSON.</p> <p>The Authorino <code>AuthConfig</code> custom resource below sets an API protection that issues a wristband after a successful authentication via API key. Apart from standard JWT claims, the wristband contains 2 custom claims: a static value <code>aud=internal</code> and a dynamic value <code>born</code> that fetches from the authorization JSON the date/time of creation of the secret that represents the API key used to authenticate.</p> <pre><code>apiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  namespace: my-namespace\n  name: my-api-protection\nspec:\n  hosts:\n\n  - my-api.io\n  authentication:\n    \"edge\":\n      apiKey:\n        selector:\n          matchLabels:\n            authorino.kuadrant.io/managed-by: authorino\n      credentials:\n        authorizationHeader:\n          prefix: APIKEY\n  response:\n    success:\n      headers:\n        \"x-wristband\":\n          wristband:\n            issuer: https://authorino-oidc.default.svc:8083/my-namespace/my-api-protection/x-wristband\n            customClaims:\n              \"aud\":\n                value: internal\n              \"age\":\n                expression: int(request.time.seconds) - (timestamp(auth.identity.metadata.creationTimestamp) - timestamp(\"1970-01-01T00:00:00Z\")).getSeconds()\n            tokenDuration: 300\n            signingKeyRefs:\n            - name: my-signing-key\n              algorithm: ES256\n            - name: my-old-signing-key\n              algorithm: RS256\n</code></pre> <p>The signing key names listed in <code>signingKeyRefs</code> must match the names of Kubernetes <code>Secret</code> resources created in the same namespace, where each secret contains a <code>key.pem</code> entry that holds the value of the private key that will be used to sign the wristbands issued, formatted as PEM. The first key in this list will be used to sign the wristbands, while the others are kept to support key rotation.</p> <p>For each protected API configured for the Festival Wristband issuing, Authorino exposes the following OpenID Connect Discovery well-known endpoints (available for requests within the cluster):</p> <ul> <li>OpenID Connect configuration:   https://authorino-oidc.default.svc:8083/{namespace}/{api-protection-name}/{response-config-name}/.well-known/openid-configuration</li> <li>JSON Web Key Set (JWKS) well-known endpoint:   https://authorino-oidc.default.svc:8083/{namespace}/{api-protection-name}/{response-config-name}/.well-known/openid-connect/certs</li> </ul>"},{"location":"authorino/docs/features/#callbacks-callbacks","title":"Callbacks (<code>callbacks</code>)","text":""},{"location":"authorino/docs/features/#http-endpoints-callbackshttp","title":"HTTP endpoints (<code>callbacks.http</code>)","text":"<p>Sends requests to specified HTTP endpoints at the end of the auth pipeline.</p> <p>The scheme of the <code>http</code> field is the same as of <code>metadata.http</code>.</p> <p>Example:</p> <pre><code>spec:\n  authentication: [\u2026]\n  authorization: [\u2026]\n\n  callbacks:\n    \"log\":\n      http:\n        url: http://logsys\n        method: POST\n        body:\n          expression: |\n            { \"requestId\": request.id, \"username\": auth.identity.username, \"authorizationResult\": auth.authorization }\n    \"important-forbidden\":\n      when:\n\n      - predicate: \"!auth.authorization.important-policy\"\n      http:\n        urlExpression: |\n          \"http://monitoring/important?forbidden-user=\" + auth.identity.username\n</code></pre>"},{"location":"authorino/docs/features/#common-feature-priorities","title":"Common feature: Priorities","text":"<p>Priorities allow to set sequence of execution for blocks of concurrent evaluators within phases of the Auth Pipeline.</p> <p>Evaluators of same priority execute concurrently to each other \"in a block\". After syncing that block (i.e. after all evaluators of the block have returned), the next block of evaluator configs of consecutive priority is triggered.</p> <p>Use cases for priorities are:</p> <ol> <li>Saving expensive tasks to be triggered when there's a high chance of returning immediately after finishing executing a less expensive one \u2013 e.g.<ul> <li>an identity config that calls an external IdP to verify a token that is rarely used, compared to verifying JWTs preferred by most users of the service;</li> <li>an authorization policy that performs some quick checks first, such as verifying allowed paths, and only if it passes, moves to the evaluation of a more expensive policy.</li> </ul> </li> <li>Establishing dependencies between evaluators - e.g.<ul> <li>an external metadata request that needs to wait until a previous metadata responds first (in order to use data from the response)</li> </ul> </li> </ol> <p>Priorities can be set using the <code>priority</code> property available in all evaluator configs of all phases of the Auth Pipeline (identity, metadata, authorization and response). The lower the number, the highest the priority. By default, all evaluators have priority 0 (i.e. highest priority).</p> <p>Consider the following example to understand how priorities work:</p> <pre><code>apiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n\n  - talker-api\n  authentication:\n    \"tier-1\":\n      priority: 0\n      apiKey:\n        selector:\n          matchLabels:\n            tier: \"1\"\n    \"tier-2\":\n      priority: 1\n      apiKey:\n        selector:\n          matchLabels:\n            tier: \"2\"\n    \"tier-3\":\n      priority: 1\n      apiKey:\n        selector:\n          matchLabels:\n            tier: \"3\"\n  metadata:\n    \"first\":\n      http:\n        url: http://talker-api:3000\n    \"second\":\n      priority: 1\n      http:\n        url: http://talker-api:3000/first_uuid={auth.metadata.first.uuid}\n  authorization:\n    \"allowed-endpoints\":\n      when:\n      - predicate: |\n          !(request.path in ['/hi', '/hello', '/aloha', '/ciao'])\n      patternMatching:\n        patterns:\n        - pattern: \"true\"\n    \"more-expensive-policy\": # no point in evaluating this one if it's not an allowed endpoint\n      priority: 1\n      opa:\n        rego: |\n          allow { true }\n  response:\n    success:\n      headers:\n        \"x-auth-data\":\n          json:\n            properties:\n              \"tier\":\n                expression: auth.identity.metadata.labels.tier\n              \"first-uuid\":\n                expression: auth.metadata.first.uuid\n              \"second-uuid\":\n                expression: auth.metadata.second.uuid\n              \"second-path\":\n                expression: auth.metadata.second.path\n</code></pre> <p>For the <code>AuthConfig</code> above,</p> <ul> <li> <p>Identity configs <code>tier-2</code> and <code>tier-3</code> (priority 1) will only trigger (concurrently) in case <code>tier-1</code> (priority 0) fails to validate the authentication token first. (This behavior happens without prejudice of context canceling between concurrent evaluators \u2013 i.e. evaluators that are triggered concurrently to another, such as <code>tier-2</code> and <code>tier-3</code>, continue to cancel the context of each other if any of them succeeds validating the token first.)</p> </li> <li> <p>Metadata source <code>second</code> (priority 1) uses the response of the request issued by metadata source <code>first</code> (priority 0), so it will wait for <code>first</code> to finish by triggering only in the second block.</p> </li> <li> <p>Authorization policy <code>allowed-endpoints</code> (priority 0) is considered to be a lot less expensive than <code>more-expensive-policy</code> (priority 1) and has a high chance of denying access to the protected service (if the path is not one of the allowed endpoints). By setting different priorities to these policies we ensure the more expensive policy if triggered in sequence of the less expensive one, instead of concurrently.</p> </li> </ul>"},{"location":"authorino/docs/features/#common-feature-conditions-when","title":"Common feature: Conditions (<code>when</code>)","text":"<p>Conditions, identified by the <code>when</code> field in the AuthConfig API, are logical expressions (\"predicates\") that can be used to condition the evaluation of a particular auth rule, as well as of the AuthConfig altogether (\"top-level conditions\").</p> <p>The predicates are evaluated against the Authorization JSON, where each predicate is composed of exactly one of the following options:</p> <ol> <li>a <code>predicate</code> field \u2013 CEL expression that evaluates to a boolean value;</li> <li>a tuple composed of:</li> <li><code>selector</code>: a JSON path to fetch a value from the Authorization JSON</li> <li><code>operator</code>: one of: <code>eq</code> (equals); <code>neq</code> (not equal); <code>incl</code> (includes) and <code>excl</code> (excludes), for when the value fetched from the Authorization JSON is expected to be an array; <code>matches</code>, for regular expressions</li> <li><code>value</code>: a static string value to compare the value selected from the Authorization JSON with;</li> <li>a <code>patternRef</code> field \u2013 value that maps to a predefined set of <code>{ selector, operator, value }</code> tuples stored at the top-level of the AuthConfig spec (<code>patterns</code>).</li> </ol> <p>An expression contains one or more patterns and they must either all evaluate to true (\"AND\" operator, declared by grouping the patterns within an <code>all</code> block) or at least one of the patterns must be true (\"OR\" operator, when grouped within an <code>any</code> block.) Patterns not explicitly grouped are AND'ed by default.</p> <p>Examples of <code>when</code> conditions</p> <p>i) to skip an entire <code>AuthConfig</code> based on the context (AND operator assumed by default):</p> <pre><code>spec:\n  when: # auth enforced only on requests to POST /resources/*\n\n  - predicate: request.method == 'POST' &amp;&amp; request.path.matches(\"^/resources/.*\")\n</code></pre> <p>ii) equivalent to the above using <code>{ selector, operator, value }</code> tuples and an explicit AND operator (<code>all</code>):</p> <pre><code>spec:\n  when: # auth enforced only on requests to POST /resources/*\n\n  - all:\n    - selector: request.method\n      operator: eq\n      value: POST\n    - selector: request.path\n      operator: matches\n      value: ^/resources/.*\n</code></pre> <p>iii) OR condition (<code>any</code>) using <code>{ selector, operator, value }</code> tuples:</p> <pre><code>spec:\n  when: # auth enforced only on requests with HTTP method equals to POST or PUT\n\n  - any:\n    - selector: request.method\n      operator: eq\n      value: POST\n    - selector: request.method\n      operator: eq\n      value: PUT\n</code></pre> <p>iv) complex expression with nested operations using <code>{ selector, operator, value }</code> tuples:</p> <pre><code>spec:\n  when: # auth enforced only on requests to POST /resources/* or PUT /resources/*\n\n  - any:\n    - all:\n      - selector: request.method\n        operator: eq\n        value: POST\n      - selector: request.path\n        operator: matches\n        value: ^/resources/.*\n    - all:\n      - selector: request.method\n        operator: eq\n        value: PUT\n      - selector: request.path\n        operator: matches\n        value: ^/resources/.*\n</code></pre> <p>v) more concise equivalent of the above using CEL:</p> <pre><code>spec:\n  when: # auth enforced only on requests to /resources/* path with method equals to POST or PUT\n\n  - predicate: request.path .matches(\"^/resources/.*\") &amp;&amp; request.method in ['POST', 'PUT']\n</code></pre> <p>vi) to skip part of an AuthConfig (i.e., a specific auth rule):</p> <pre><code>spec:\n  metadata:\n    \"metadata-source\":\n      http:\n        url: https://my-metadata-source.io\n      when: # only fetch the external metadata if the context is HTTP method other than OPTIONS\n\n      - predicate: request.method != 'OPTIONS'\n</code></pre> <p>vii) skipping part of an AuthConfig will not affect other auth rules:</p> <pre><code>spec:\n  authentication:\n    \"authn-meth-1\":\n      apiKey: {\u2026} # this auth rule only triggers for POST requests to /foo[/*]\n      when:\n\n      - predicate: request.method == 'POST' &amp;&amp; request.path.matches(\"^/foo(/.*)?$\")\n\n    \"authn-meth-2\": # this auth rule triggerred regardless\n      jwt: {\u2026}\n</code></pre> <p>viii) concrete use-case: evaluating only the necessary identity checks based on the user's indication of the preferred authentication method (prefix of the value supplied in the HTTP <code>Authorization</code> request header):</p> <pre><code>spec:\n  authentication:\n    \"jwt\":\n      when:\n\n      - predicate: request.headers['authorization'].startsWith('JWT')\n      jwt: {\u2026}\n\n    \"api-key\":\n      when:\n\n      - predicate: request.headers['authorization'].startsWith('APIKEY')\n      apiKey: {\u2026}\n</code></pre> <p>ix) to avoid repetition while defining patterns for conditions:</p> <pre><code>spec:\n  patterns:\n    a-pet: # a named pattern that can be reused in sets of conditions\n\n    - selector: context.request.http.path\n      operator: matches\n      value: ^/pets/\\d+(/.*)$\n\n  metadata:\n    \"pets-info\":\n      when:\n\n      - patternRef: a-pet\n      http:\n        urlExpression: |\n          \"https://pets-info.io?petId=\" + request.path.split('/')[2]\n\n  authorization:\n    \"pets-owners-only\":\n      when:\n\n      - patternRef: a-pet\n      opa:\n        rego: |\n          allow { input.metadata[\"pets-info\"].ownerid == input.auth.identity.userid }\n</code></pre> <p>x) combining literals and refs \u2013 concrete case: authentication required for selected operations:</p> <pre><code>spec:\n  patterns:\n    api-base-path:\n\n    - selector: request.path\n      operator: matches\n      value: ^/api/.*\n\n    authenticated-user:\n\n    - selector: auth.identity.anonymous\n      operator: neq\n      value: \"true\"\n\n  authentication:\n    api-users: # tries to authenticate all requests to path /api/*\n      when:\n\n      - patternRef: api-base-path\n      jwt: {\u2026}\n\n    others: # defaults to anonymous access when authentication fails or not /api/* path\n      anonymous: {}\n      priority: 1\n\n  authorization:\n    api-write-access-requires-authentication: # POST/PUT/DELETE requests to /api/* path cannot be anonymous\n      when:\n\n      - patternRef: api-base-path\n      - predicate: request.method in ['POST', 'PUT', 'DELETE']\n      opa:\n        patternMatching:\n          rules:\n          - patternRef: authenticated-user\n\n  response: # bonus: export user data if available\n    success:\n      dynamicMetadata:\n        \"user-data\":\n          when:\n\n          - patternRef: authenticated-user\n          json:\n            properties:\n              jwt-claims:\n                expression: auth.identity\n</code></pre>"},{"location":"authorino/docs/features/#common-feature-caching-cache","title":"Common feature: Caching (<code>cache</code>)","text":"<p>Objects resolved at runtime in an Auth Pipeline can be cached \"in-memory\", and avoided being evaluated again at a subsequent request, until it expires. A lookup cache key and a TTL can be set individually for any evaluator config in an AuthConfig.</p> <p>Each cache config induces a completely independent cache table (or \"cache namespace\"). Consequently, different evaluator configs can use the same cache key and there will be no collision between entries from different evaluators.</p> <p>E.g.:</p> <pre><code>spec:\n  hosts:\n\n  - my-api.io\n\n  authentication: [\u2026]\n\n  metadata:\n    \"external-metadata\":\n      http:\n        urlExpression: |\n          \"http://my-external-source?search=\" + request.path\n      cache:\n        key:\n          expression: request.path\n        ttl: 300\n\n  authorization:\n    \"complex-policy\":\n      opa:\n        externalPolicy:\n          url: http://my-policy-registry\n      cache:\n        key:\n          expression: auth.identity.group + '-' + request.method + '-' + request.path\n        ttl: 60\n</code></pre> <p>The example above sets caching for the 'external-metadata' metadata config and for the 'complex-policy' authorization policy. In the case of 'external-metadata', the cache key is the path of the original HTTP request being authorized by Authorino (fetched dynamically from the Authorization JSON); i.e., after obtaining a metadata object from the external source for a given contextual HTTP path one first time, whenever that same HTTP path repeats in a subsequent request, Authorino will use the cached object instead of sending a request again to the external source of metadata. After 5 minutes (300 seconds), the cache entry will expire and Authorino will fetch again from the source if requested.</p> <p>As for the 'complex-policy' authorization policy, the cache key is a string composed the 'group' the identity belongs to, the method of the HTTP request and the path of the HTTP request. Whenever these repeat, Authorino will use the result of the policy that was evaluated and cached priorly. Cache entries in this namespace expire after 60 seconds.</p> <p>Notes on evaluator caching</p> <p>Capacity - By default, each cache namespace is limited to 1 mb. Entries will be evicted following First-In-First-Out (FIFO) policy to release space. The individual capacity of cache namespaces is set at the level of the Authorino instance (via <code>--evaluator-cache-size</code> command-line flag or <code>spec.evaluatorCacheSize</code> field of the <code>Authorino</code> CR).</p> <p>Usage - Avoid caching objects whose evaluation is considered to be relatively cheap. Examples of operations associated to Authorino auth features that are usually NOT worth caching: validation of JSON Web Tokens (JWT), Kubernetes TokenReviews and SubjectAccessReviews, API key validation, simple JSON pattern-matching authorization rules, simple OPA policies. Examples of operations where caching may be desired: OAuth2 token introspection, fetching of metadata from external sources (via HTTP request), complex OPA policies.</p>"},{"location":"authorino/docs/features/#common-feature-metrics-metrics","title":"Common feature: Metrics (<code>metrics</code>)","text":"<p>By default, Authorino will only export metrics down to the level of the AuthConfig. Deeper metrics at the level of each evaluator within an AuthConfig can be activated by setting the common field <code>metrics: true</code> of the evaluator config.</p> <p>E.g.:</p> <pre><code>apiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: my-authconfig\n  namespace: my-ns\nspec:\n  metadata:\n    \"my-external-metadata\":\n      http:\n        url: http://my-external-source?search={request.path}\n      metrics: true\n</code></pre> <p>The above will enable the metrics <code>auth_server_evaluator_duration_seconds</code> (histogram) and <code>auth_server_evaluator_total</code> (counter) with labels <code>namespace=\"my-ns\"</code>, <code>authconfig=\"my-authconfig\"</code>, <code>evaluator_type=\"METADATA_GENERIC_HTTP\"</code> and <code>evaluator_name=\"my-external-metadata\"</code>.</p> <p>The same pattern works for other types of evaluators. Find below the list of all types and corresponding label constant used in the metric:</p> Evaluator type Metric's <code>evaluator_type</code> label <code>authentication.apiKey</code> IDENTITY_APIKEY <code>authentication.kubernetesTokenReview</code> IDENTITY_KUBERNETES <code>authentication.jwt</code> IDENTITY_JWT <code>authentication.oauth2Introspection</code> IDENTITY_OAUTH2 <code>authentication.x509</code> IDENTITY_MTLS <code>authentication.plain</code> IDENTITY_PLAIN <code>authentication.anonymous</code> IDENTITY_NOOP <code>metadata.http</code> METADATA_GENERIC_HTTP <code>metadata.userInfo</code> METADATA_USERINFO <code>metadata.uma</code> METADATA_UMA <code>authorization.patternMatching</code> AUTHORIZATION_JSON <code>authorization.opa</code> AUTHORIZATION_OPA <code>authorization.kubernetesSubjectAccessReview</code> AUTHORIZATION_KUBERNETES <code>authorization.spicedb</code> AUTHORIZATION_AUTHZED <code>response.success..plain</code> RESPONSE_PLAIN <code>response.success..json</code> RESPONSE_JSON <code>response.success..wristband</code> RESPONSE_WRISTBAND <p>Metrics at the level of the evaluators can also be enforced to an entire Authorino instance, by setting the <code>--deep-metrics-enabled</code> command-line flag. In this case, regardless of the value of the field <code>spec.(authentication|metadata|authorization|response).metrics</code> in the AuthConfigs, individual metrics for all evaluators of all AuthConfigs will be exported.</p> <p>For more information about metrics exported by Authorino, see Observability.</p>"},{"location":"authorino/docs/getting-started/","title":"Getting started","text":"<p>This page covers requirements and instructions to deploy Authorino on a Kubernetes cluster, as well as the steps to declare, apply and try out a protection layer of authentication and authorization over your service, clean-up and complete uninstallation.</p> <p>If you prefer learning with an example, check out our Hello World.</p>"},{"location":"authorino/docs/getting-started/#requirements","title":"Requirements","text":""},{"location":"authorino/docs/getting-started/#platform-requirements","title":"Platform requirements","text":"<p>These are the platform requirements to use Authorino:</p> <ul> <li> <p>Kubernetes server (recommended v1.21 or later), with permission to create Kubernetes Custom Resource Definitions (CRDs) (for bootstrapping Authorino and Authorino Operator)</p> <p> Alternative: K8s distros and platforms <p>Alternatively to upstream Kubernetes, you should be able to use any other Kubernetes distribution or Kubernetes Management Platform (KMP) with support for Kubernetes Custom Resources Definitions (CRD) and custom controllers, such as Red Hat OpenShift, IBM Cloud Kubernetes Service (IKS), Google Kubernetes Engine (GKE), Amazon Elastic Kubernetes Service (EKS) and Azure Kubernetes Service (AKS). </p> <li> <p>Envoy proxy (recommended v1.19 or later), to wire up Upstream services (i.e. the services to be protected with Authorino) and external authorization filter (Authorino) for integrations based on the reverse-proxy architecture - example</p> <p> Alternative: Non-reverse-proxy integration <p>Technically, any client that implements Envoy's external authorization gRPC protocol should be compatible with Authorino. For integrations based on the reverse-proxy architecture nevertheless, we strongly recommended that you leverage Envoy alongside Authorino. </p>"},{"location":"authorino/docs/getting-started/#feature-specific-requirements","title":"Feature-specific requirements","text":"<p>A few examples are:</p> <ul> <li> <p>For OpenID Connect, make sure you have access to an identity provider (IdP) and an authority that can issue ID tokens (JWTs). Check out Keycloak which can solve both and connect to external identity sources and user federation like LDAP.</p> </li> <li> <p>For Kubernetes authentication tokens, platform support for the TokenReview and SubjectAccessReview APIs of Kubernetes shall be required. In case you want to be able to requests access tokens for clients running outside the custer, you may also want to check out the requisites for using Kubernetes TokenRequest API (GA in v1.20).</p> </li> <li> <p>For User-Managed Access (UMA) resource data, you will need a UMA-compliant server running as well. This can be an implementation of the UMA protocol by each upstream API itself or (more typically) an external server that knows about the resources. Again, Keycloak can be a good fit here as well. Just keep in mind that, whatever resource server you choose, changing-state actions commanded in the upstream APIs or other parties will have to be reflected in the resource server. Authorino will not do that for you.</p> </li> </ul> <p>Check out the Feature specification page for more feature-specific requirements.</p>"},{"location":"authorino/docs/getting-started/#installation","title":"Installation","text":""},{"location":"authorino/docs/getting-started/#step-install-the-authorino-operator","title":"Step: Install the Authorino Operator","text":"<p>The simplest way to install the Authorino Operator is by applying the manifest bundle:</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre> <p>The above will install the latest build of the Authorino Operator and latest version of the manifests (CRDs and RBAC), which by default points as well to the latest build of Authorino, both based on the <code>main</code> branches of each component. To install a stable released version of the Operator and therefore also defaults to its latest compatible stable release of Authorino, replace <code>main</code> with another tag of a proper release of the Operator, e.g. 'v0.2.0'.</p> <p>This step will also install cert-manager in the cluster (required).</p> <p>Alternatively, you can deploy the Authorino Operator using the Operator Lifecycle Manager bundles. For instructions, check out Installing via OLM.</p>"},{"location":"authorino/docs/getting-started/#step-request-an-authorino-instance","title":"Step: Request an Authorino instance","text":"<p>Choose either cluster-wide or namespaced deployment mode and whether you want TLS termination enabled for the Authorino endpoints (gRPC authorization, raw HTTP authorization, and OIDC Festival Wristband Discovery listeners), and follow the corresponding instructions below.</p> <p>The instructions here are for centralized gateway or centralized authorization service architecture. Check out the Topologies section of the docs for alternatively running Authorino in a sidecar container.</p> Cluster-wide (with TLS) <p>Create the namespace:   <pre><code>kubectl create namespace authorino\n</code></pre></p> <p>Create the TLS certificates (requires cert-manager; skip if you already have certificates and certificate keys created and stored in Kubernetes <code>Secret</code>s in the namespace):   <pre><code>curl -sSL https://raw.githubusercontent.com/Kuadrant/authorino/main/deploy/certs.yaml | sed \"s/\\$(AUTHORINO_INSTANCE)/authorino/g;s/\\$(NAMESPACE)/authorino/g\" | kubectl -n authorino apply -f -\n</code></pre></p> <p>Deploy Authorino:   <pre><code>kubectl -n authorino apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  replicas: 1\n  clusterWide: true\n  listener:\n    tls:\n      enabled: true\n      certSecretRef:\n        name: authorino-server-cert\n  oidcServer:\n    tls:\n      enabled: true\n      certSecretRef:\n        name: authorino-oidc-server-cert\nEOF\n</code></pre></p> Cluster-wide (without TLS) <pre><code>kubectl create namespace authorino\nkubectl -n authorino apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  image: quay.io/kuadrant/authorino:latest\n  replicas: 1\n  clusterWide: true\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre> Namespaced (with TLS) <p>Create the namespace:   <pre><code>kubectl create namespace myapp\n</code></pre></p> <p>Create the TLS certificates (requires cert-manager; skip if you already have certificates and certificate keys created and stored in Kubernetes <code>Secret</code>s in the namespace):   <pre><code>curl -sSL https://raw.githubusercontent.com/Kuadrant/authorino/main/deploy/certs.yaml | sed \"s/\\$(AUTHORINO_INSTANCE)/authorino/g;s/\\$(NAMESPACE)/myapp/g\" | kubectl -n myapp apply -f -\n</code></pre></p> <p>Deploy Authorino:   <pre><code>kubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  image: quay.io/kuadrant/authorino:latest\n  replicas: 1\n  clusterWide: false\n  listener:\n    tls:\n      enabled: true\n      certSecretRef:\n        name: authorino-server-cert\n  oidcServer:\n    tls:\n      enabled: true\n      certSecretRef:\n        name: authorino-oidc-server-cert\nEOF\n</code></pre></p> Namespaced (without TLS) <pre><code>kubectl create namespace myapp\nkubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  image: quay.io/kuadrant/authorino:latest\n  replicas: 1\n  clusterWide: false\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre>"},{"location":"authorino/docs/getting-started/#protect-a-service","title":"Protect a service","text":"<p>The most typical integration to protect services with Authorino is by putting the service (upstream) behind a reverse-proxy or API gateway, enabled with an authorization filter that ensures all requests to the service are first checked with the authorization server (Authorino).</p> <p>To do that, make sure you have your upstream service deployed and running, usually in the same Kubernetes server where you installed Authorino. Then, setup an Envoy proxy and create an Authorino <code>AuthConfig</code> for your service.</p> <p>Authorino exposes 2 interfaces to serve the authorization requests:</p> <ul> <li>a gRPC interface that implements Envoy's External Authorization protocol;</li> <li>a raw HTTP authorization interface, suitable for using Authorino with Kubernetes ValidatingWebhook, for Envoy external authorization via HTTP, and other integrations (e.g. other proxies).</li> </ul> <p>To use Authorino as a simple satellite (sidecar) Policy Decision Point (PDP), applications can integrate directly via any of these interfaces. By integrating via a proxy or API gateway, the combination makes Authorino to perform as an external Policy Enforcement Point (PEP) completely decoupled from the application.</p>"},{"location":"authorino/docs/getting-started/#life-cycle","title":"Life cycle","text":""},{"location":"authorino/docs/getting-started/#step-setup-envoy","title":"Step: Setup Envoy","text":"<p>To configure Envoy for proxying requests targeting the upstream service and authorizing with Authorino, setup an Envoy configuration that enables Envoy's external authorization HTTP filter. Store the configuration in a <code>ConfigMap</code>.</p> <p>These are the important bits in the Envoy configuration to activate Authorino:</p> <pre><code>static_resources:\n  listeners:\n\n  - address: {\u2026} # TCP socket address and port of the proxy\n    filter_chains:\n    - filters:\n      - name: envoy.http_connection_manager\n        typed_config:\n          \"@type\": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager\n          route_config: {\u2026} # routing configs - virtual host domain and endpoint matching patterns and corresponding upstream services to redirect the traffic\n          http_filters:\n          - name: envoy.filters.http.ext_authz # the external authorization filter\n            typed_config:\n              \"@type\": type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthz\n              transport_api_version: V3\n              failure_mode_allow: false # ensures only authenticated and authorized traffic goes through\n              grpc_service:\n                envoy_grpc:\n                  cluster_name: authorino\n                timeout: 1s\n  clusters:\n  - name: authorino\n    connect_timeout: 0.25s\n    type: strict_dns\n    lb_policy: round_robin\n    http2_protocol_options: {}\n    load_assignment:\n      cluster_name: authorino\n      endpoints:\n      - lb_endpoints:\n        - endpoint:\n            address:\n              socket_address:\n                address: authorino-authorino-authorization # name of the Authorino service deployed \u2013 it can be the fully qualified name with `.&lt;namespace&gt;.svc.cluster.local` suffix (e.g. `authorino-authorino-authorization.myapp.svc.cluster.local`)\n                port_value: 50051\n    transport_socket: # in case TLS termination is enabled in Authorino; omit it otherwise\n      name: envoy.transport_sockets.tls\n      typed_config:\n        \"@type\": type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext\n        common_tls_context:\n          validation_context:\n            trusted_ca:\n              filename: /etc/ssl/certs/authorino-ca-cert.crt\n</code></pre> <p>For a complete Envoy <code>ConfigMap</code> containing an upstream API protected with Authorino, with TLS enabled and option for rate limiting with Limitador, plus a webapp served with under the same domain of the protected API, check out this example.</p> <p>After creating the <code>ConfigMap</code> with the Envoy configuration, create an Envoy <code>Deployment</code> and <code>Service</code>. E.g.:</p> <pre><code>kubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: envoy\n  labels:\n    app: envoy\nspec:\n  selector:\n    matchLabels:\n      app: envoy\n  template:\n    metadata:\n      labels:\n        app: envoy\n    spec:\n      containers:\n\n        - name: envoy\n          image: envoyproxy/envoy:v1.19-latest\n          command: [\"/usr/local/bin/envoy\"]\n          args:\n            - --config-path /usr/local/etc/envoy/envoy.yaml\n            - --service-cluster front-proxy\n            - --log-level info\n            - --component-log-level filter:trace,http:debug,router:debug\n          ports:\n            - name: web\n              containerPort: 8000 # matches the address of the listener in the envoy config\n          volumeMounts:\n            - name: config\n              mountPath: /usr/local/etc/envoy\n              readOnly: true\n            - name: authorino-ca-cert # in case TLS termination is enabled in Authorino; omit it otherwise\n              subPath: ca.crt\n              mountPath: /etc/ssl/certs/authorino-ca-cert.crt\n              readOnly: true\n      volumes:\n        - name: config\n          configMap:\n            name: envoy\n            items:\n              - key: envoy.yaml\n                path: envoy.yaml\n        - name: authorino-ca-cert # in case TLS termination is enabled in Authorino; omit it otherwise\n          secret:\n            defaultMode: 420\n            secretName: authorino-ca-cert\n  replicas: 1\nEOF\n</code></pre> <pre><code>kubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Service\nmetadata:\n  name: envoy\nspec:\n  selector:\n    app: envoy\n  ports:\n\n    - name: web\n      port: 8000\n      protocol: TCP\nEOF\n</code></pre>"},{"location":"authorino/docs/getting-started/#step-apply-an-authconfig","title":"Step: Apply an <code>AuthConfig</code>","text":"<p>Check out the docs for a full description of Authorino's <code>AuthConfig</code> Custom Resource Definition (CRD) and its features.</p> <p>For examples based on specific use-cases, check out the User guides.</p> <p>For authentication based on OpenID Connect (OIDC) JSON Web Tokens (JWT), plus one simple JWT claim authorization check, a typical <code>AuthConfig</code> custom resource looks like the following:</p> <pre><code>kubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: my-api-protection\nspec:\n  hosts: # any hosts that resolve to the envoy service and envoy routing config where the external authorization filter is enabled\n\n  - my-api.io # north-south traffic through a Kubernetes `Ingress` or OpenShift `Route`\n  - my-api.myapp.svc.cluster.local # east-west traffic (between applications within the cluster)\n  authentication:\n    \"idp-users\":\n      jwt:\n        issuerUrl: https://my-idp.com/auth/realm\n  authorization:\n    \"check-claim\":\n      patternMatching:\n        patterns:\n        - selector: auth.identity.group\n          operator: eq\n          value: allowed-users\nEOF\n</code></pre> <p>After applying the <code>AuthConfig</code>, consumers of the protected service should be able to start sending requests.</p>"},{"location":"authorino/docs/getting-started/#clean-up","title":"Clean-up","text":""},{"location":"authorino/docs/getting-started/#remove-protection","title":"Remove protection","text":"<p>Delete the <code>AuthConfig</code>:</p> <pre><code>kubectl -n myapp delete authconfig/my-api-protection\n</code></pre> <p>Decommission the Authorino instance:</p> <pre><code>kubectl -n myapp delete authorino/authorino\n</code></pre>"},{"location":"authorino/docs/getting-started/#uninstall","title":"Uninstall","text":"<p>To completely remove Authorino CRDs, run from the Authorino Operator directory:</p> <pre><code>make uninstall\n</code></pre>"},{"location":"authorino/docs/getting-started/#next-steps","title":"Next steps","text":"<ol> <li>Read the docs. The Architecture page and the Features page are good starting points to learn more about how Authorino works and its functionalities.</li> <li>Check out the User guides for several examples of <code>AuthConfig</code>s based on specific use-cases</li> </ol>"},{"location":"authorino/docs/terminology/","title":"Terminology","text":"<p>Here we define some terms that are used in the project, with the goal of avoiding confusion and facilitating more accurate conversations related to <code>Authorino</code>.</p> <p>If you see terms used that are not here (or are used in place of terms here) please consider contributing a definition to this doc with a PR, or modifying the use elsewhere to align with these terms.</p>"},{"location":"authorino/docs/terminology/#terms","title":"Terms","text":"<p>Access token Type of temporary password (security token), tied to an authenticated identity, issued by an auth server as of request from either the identity subject itself or a registered auth client known by the auth server, and that delegates to a party powers to operate on behalf of that identity before a resource server; it can be formatted  as an opaque data string or as an encoded JSON Web Token (JWT).</p> <p>Application Programming Interface (API) Interface that defines interactions between multiple software applications; (in HTTP communication) set of endpoints and specification to expose resources hosted by a resource server, to be consumed by client applications; the access facade of a resource server.</p> <p>Attribute-based Access Control (ABAC) Authorization model that grants/denies access to resources based on evaluation of authorization policies which combine attributes together (from claims, from the request, from the resource, etc).</p> <p>Auth Usually employed as a short for authentication and authorization together (AuthN/AuthZ).</p> <p>Auth client Application client (software) that uses an auth server, either in the process of authenticating and/or authorizing identity subjects (including self) who want to consume resources from a resources server or auth server.</p> <p>Auth server Server where auth clients, users, roles, scopes, resources, policies and permissions can be stored and managed.</p> <p>Authentication (AuthN) Process of verifying that a given credential belongs to a claimed-to-be identity; usually resulting in the issuing of an access token.</p> <p>Authorization (AuthZ) Process of granting (or denying) access over a resource to a party based on the set of authorization rules, policies and/or permissions enforced.</p> <p>Authorization header HTTP request header frequently used to carry credentials to authenticate a user in an HTTP communication, like in requests sent to an API; alternatives usually include credentials carried in another (custom) HTTP header, query string parameter or HTTP cookie.</p> <p>Capability Usually employed to refer to a management feature of a Kubernetes-native system, based on the definition and use of Kubernetes Custom Resources (CRDs and CRs), that enables that system to one of the following \u201ccapability levels\u201d: Basic Install, Seamless Upgrades, Full Lifecycle, Deep Insights, Auto Pilot.</p> <p>Claim Attribute packed in a security token which represents a claim that one who bears the token is making about an entity, usually an identity subject.</p> <p>Client ID Unique identifier of an auth client within an auth server domain (or auth server realm).</p> <p>Client secret Password presented by auth clients together with their Client IDs while authenticating with an auth server, either when requesting access tokens to be issued or when consuming services from the auth servers in general.</p> <p>Delegation Process of granting a party (usually an auth client) with powers to act, often with limited scope, on behalf of an identity, to access resources from a resource server. See also OAuth2.</p> <p>Hash-based Message Authentication Code (HMAC) Specific type of message authentication code (MAC) that involves a cryptographic hash function and a shared secret cryptographic key; it can be used to verify the authenticity of a message and therefore as an authentication method.</p> <p>Identity Set of properties that qualifies a subject as a strong identifiable entity (usually a user), who can be authenticated by an auth server. See also Claims.</p> <p>Identity and Access Management (IAM) system Auth system that implements and/or connects with sources of identity (IdP) and offers interfaces for managing access (authorization policies and permissions). See also Auth server.</p> <p>Identity Provider (IdP) Source of identity; it can be a feature of an auth server or external source connected to an auth server.</p> <p>ID token Special type of access token; an encoded JSON Web Token (JWT) that packs claims about an identity.</p> <p>JSON Web Token (JWT) JSON Web Tokens are an open, industry standard RFC 7519 method for representing claims securely between two parties.</p> <p>JSON Web Signature (JWS) Standard for signing arbitrary data, especially JSON Web Tokens (JWT).</p> <p>JSON Web Key Set (JWKS) Set of keys containing the public keys used to verify any JSON Web Token (JWT).</p> <p>Keycloak Open source auth server to allow single sign-on with identity and access management.</p> <p>Lightweight Directory Access Protocol (LDAP) Open standard for distributed directory information services for sharing of information about users, systems, networks, services and applications.</p> <p>Mutual Transport Layer Security (mTLS) Protocol for the mutual authentication of client-server communication, i.e., the client authenticates the server and the server authenticates the client, based on the acceptance of the X.509 certificates of each party.</p> <p>OAuth 2.0 (OAuth2) Industry-standard protocol for delegation.</p> <p>OpenID Connect (OIDC) Simple identity verification (authentication) layer built on top of the OAuth2 protocol.</p> <p>Open Policy Agent (OPA) Authorization policy agent that enables the usage of declarative authorization policies written in Rego language.</p> <p>Opaque token Security token devoid of explicit meaning (e.g. random string); it requires the usage of lookup mechanism to be translated into a meaningful set claims representing an identity.</p> <p>Permission Association between a protected resource the authorization policies that must be evaluated whether access should be granted; e.g. <code>&lt;user|group|role&gt;</code> CAN DO <code>&lt;action&gt;</code> ON RESOURCE <code>&lt;X&gt;</code>.</p> <p>Policy Rule or condition (authorization policy) that must be satisfied to grant access to a resource; strongly related to the different access control mechanisms (ACMs) and strategies one can use to protect resources, e.g. attribute-based access control (ABAC), role-based access control (RBAC), context-based access control, user-based access control (UBAC).</p> <p>Policy Administration Point (PAP) Set of UIs and APIs to manage resources servers, resources, scopes, policies and permissions; it is where the auth system is configured.</p> <p>Policy Decision Point (PDP) Where the authorization requests are sent, with permissions being requested, and authorization policies are evaluated accordingly.</p> <p>Policy Enforcement Point (PEP) Where the authorization is effectively enforced, usually at the resource server or at a proxy, based on a response provided by the Policy Decision Point (PDP).</p> <p>Policy storage Where policies are stored and from where they can be fetched, perhaps to be cached.</p> <p>Red Hat SSO Auth server; downstream product created from the Keycloak Open Source project.</p> <p>Refresh token Special type of security token, often provided together with an access token in an OAuth2 flow, used to renew the duration of an access token before it expires; it requires client authentication.</p> <p>Request Party Token (RPT) JSON Web Token (JWT) digitally signed using JSON Web Signature (JWS), issued by the Keycloak auth server.</p> <p>Resource One or more endpoints of a system, API or server, that can be protected.</p> <p>Resource-level Access Control (RLAC) Authorization model that takes into consideration attributes of each specific request resource to grant/deny access to those resources (e.g. the resource's owner).</p> <p>Resource server Server that hosts protected resources.</p> <p>Role Aspect of a user\u2019s identity assigned to the user to indicate the level of access they should have to the system; essentially, roles represent collections of permissions</p> <p>Role-based Access Control (RBAC) Authorization model that grants/denies access to resources based on the roles of authenticated users (rather than on complex attributes/policy rules).</p> <p>Scope Mechanism that defines the specific operations that applications can be allowed to do or information that they can request on an identity\u2019s behalf; often presented as a parameter when access is requested as a way to communicate what access is needed, and used by auth server to respond what actual access is granted.</p> <p>Single Page Application (SPA) Web application or website that interacts with the user by dynamically rewriting the current web page with new data from the web server.</p> <p>Single Sign-on (SSO) Authentication scheme that allows a user to log in with a single ID and password to any of several related, yet independent, software systems.</p> <p>Upstream (In the context of authentication/authorization) API whose endpoints must be protected by the auth system; the unprotected service in front of which a protection layer is added (by connecting with a Policy Decision Point).</p> <p>User-based Access Control (UBAC) Authorization model that grants/denies access to resources based on claims of the identity (attributes of the user).</p> <p>User-Managed Access (UMA) OAuth2-based access management protocol, used for users of an auth server to control the authorization process, i.e. directly granting/denying access to user-owned resources to other requesting parties.</p>"},{"location":"authorino/docs/user-guides/","title":"User guides","text":"<ul> <li> <p>Hello World The basics of protecting an API with Authorino.</p> </li> <li> <p>Authentication with Kubernetes tokens (TokenReview API) Validate Kubernetes Service Account tokens to authenticate requests to your protected hosts.</p> </li> <li> <p>Authentication with API keys Issue API keys stored in Kubernetes <code>Secret</code>s for clients to authenticate with your protected hosts.</p> </li> <li> <p>Authentication with X.509 certificates and mTLS Verify client X.509 certificates against trusted root CAs.</p> </li> <li> <p>OpenID Connect Discovery and authentication with JWTs Validate JSON Web Tokens (JWT) issued and signed by an OpenID Connect server; leverage OpenID Connect Discovery to automatically fetch JSON Web Key Sets (JWKS).</p> </li> <li> <p>OAuth 2.0 token introspection (RFC 7662) Introspect OAuth 2.0 access tokens (e.g. opaque tokens) for online user data and token validation in request-time.</p> </li> <li> <p>Passing credentials (<code>Authorization</code> header, cookie headers and others) Customize where credentials are supplied in the request by each trusted source of identity.</p> </li> <li> <p>HTTP \"Basic\" Authentication (RFC 7235) Turn Authorino API key <code>Secret</code>s settings into HTTP basic auth.</p> </li> <li> <p>Anonymous access Bypass identity verification or fall back to anonymous access when credentials fail to validate</p> </li> <li> <p>Token normalization Normalize identity claims from trusted sources and reduce complexity in your policies.</p> </li> <li> <p>Edge Authentication Architecture (EAA) Exchange satellite (outer-layer) authentication tokens for \"Festival Wristbands\" accepted ubiquitously at the inside of your network. Normalize from multiple and varied sources of identity and authentication methods in the edge of your architecture; filter privacy data, limit the scope of permissions, and simplify authorization rules to your internal microservices.</p> </li> <li> <p>Fetching auth metadata from external sources Get online data from remote HTTP services to enhance authorization rules.</p> </li> <li> <p>OpenID Connect UserInfo Fetch user info for OpenID Connect ID tokens in request-time for extra metadata for your policies and online verification of token validity.</p> </li> <li> <p>Resource-level authorization with User-Managed Access (UMA) resource registry Fetch resource attributes relevant for authorization from a User-Managed Access (UMA) resource registry such as Keycloak resource server clients.</p> </li> <li> <p>Simple pattern-matching authorization policies Write simple authorization rules based on JSON patterns matched against Authorino's Authorization JSON; check contextual information of the request, validate JWT claims, cross metadata fetched from external sources, etc.</p> </li> <li> <p>OpenID Connect (OIDC) and Role-Based Access Control (RBAC) with Authorino and Keycloak Combine OpenID Connect (OIDC) authentication and Role-Based Access Control (RBAC) authorization rules leveraging Keycloak and Authorino working together.</p> </li> <li> <p>Open Policy Agent (OPA) Rego policies Leverage the power of Open Policy Agent (OPA) policies, evaluated against Authorino's Authorization JSON in a built-in runtime compiled together with Authorino; pre-cache policies defined in Rego language inline or fetched from an external policy registry.</p> </li> <li> <p>Kubernetes RBAC for service authorization (SubjectAccessReview API) Manage permissions in the Kubernetes RBAC and let Authorino to check them in request-time with the authorization system of the cluster.</p> </li> <li> <p>Authorization with Keycloak Authorization Services Use Authorino as an adapter for Keycloak Authorization Services without importing any library or rebuilding your application code.</p> </li> <li> <p>Integration with Authzed/SpiceDB Permission requests sent to a Google Zanzibar-based Authzed/SpiceDB instance, via gRPC.</p> </li> <li> <p>Injecting data in the request Inject HTTP headers with serialized JSON content.</p> </li> <li> <p>Authenticated rate limiting (with Envoy Dynamic Metadata) Provide Envoy with dynamic metadata from the external authorization process to be injected and used by consecutive filters, such as by a rate limiting service.</p> </li> <li> <p>Redirecting to a login page Customize response status code and headers on failed requests. E.g. redirect users of a web application protected with Authorino to a login page instead of a <code>401 Unauthorized</code>; mask resources on access denied behind a <code>404 Not Found</code> response instead of <code>403 Forbidden</code>.</p> </li> <li> <p>Mixing Envoy built-in filter for auth and Authorino Have JWT validation handled by Envoy beforehand and the JWT payload injected into the request to Authorino, to be used in custom authorization policies defined in a AuthConfig.</p> </li> <li> <p>Host override via context extension Induce the lookup of an AuthConfig by supplying extended host context, for use cases such as of path prefix-based lookup and wildcard subdomains lookup.</p> </li> <li> <p>Using Authorino as ValidatingWebhook service Use Authorino as a generic Kubernetes ValidatingWebhook service where the rules to validate a request to the Kubernetes API are written in an AuthConfig.</p> </li> <li> <p>Reducing the operational space: sharding, noise and multi-tenancy Have multiple instances of Authorino running in the same space (Kubernetes namespace or cluster-scoped), yet watching particular sets of resources.</p> </li> <li> <p>Caching Cache auth objects resolved at runtime for any configuration bit of an AuthConfig, for easy access in subsequent requests whenever an arbitrary cache key repeats, until the cache entry expires.</p> </li> <li> <p>Observability Prometheus metrics exported by Authorino, readiness probe, logging, tracing, etc.</p> </li> </ul>"},{"location":"authorino/docs/user-guides/anonymous-access/","title":"User guide: Anonymous access","text":"<p>Bypass identity verification or fall back to anonymous access when credentials fail to validate</p> Authorino capabilities featured in this guide: <ul> <li>Identity verification &amp; authentication \u2192 Anonymous access</li> </ul> <p>For further details about Authorino features in general, check the docs.</p> <p></p>"},{"location":"authorino/docs/user-guides/anonymous-access/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC)</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p></p> <p>The next steps walk you through installing Authorino, deploying and configuring a sample service called Talker API to be protected by the authorization service.</p> Using Kuadrant <p>If you are a user of Kuadrant and already have your workload cluster configured and sample service application deployed, as well as your Gateway API network resources applied to route traffic to your service, skip straight to step \u277a.</p> <p>At step \u277a, instead of creating an <code>AuthConfig</code> custom resource, create a Kuadrant <code>AuthPolicy</code> one. The schema of the AuthConfig's <code>spec</code> matches the one of the AuthPolicy's, except <code>spec.host</code>, which is not available in the Kuadrant AuthPolicy. Host names in a Kuadrant AuthPolicy are inferred automatically from the Kubernetes network object referred in <code>spec.targetRef</code> and route selectors declared in the policy.</p> <p>For more about using Kuadrant to enforce authorization, check out Kuadrant auth.</p> <p></p>"},{"location":"authorino/docs/user-guides/anonymous-access/#install-the-authorino-operator-cluster-admin-required","title":"\u2776 Install the Authorino Operator (cluster admin required)","text":"<p>The following command will install the Authorino Operator in the Kubernetes cluster. The operator manages instances of the Authorino authorization service.</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/anonymous-access/#deploy-authorino","title":"\u2777 Deploy Authorino","text":"<p>The following command will request an instance of Authorino as a separate service<sup>1</sup> that watches for <code>AuthConfig</code> resources in the <code>default</code> namespace<sup>2</sup>, with TLS disabled<sup>3</sup>.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/anonymous-access/#deploy-the-talker-api","title":"\u2778 Deploy the Talker API","text":"<p>The Talker API is a simple HTTP service that echoes back in the response whatever it gets in the request. We will use it in this guide as the sample service to be protected by Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/docs/user-guides/anonymous-access/#setup-envoy","title":"\u2779 Setup Envoy","text":"<p>The following bundle from the Authorino examples deploys the Envoy proxy and configuration to wire up the Talker API behind the reverse-proxy, with external authorization enabled with the Authorino instance.<sup>4</sup></p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The command above creates an <code>Ingress</code> with host name <code>talker-api.127.0.0.1.nip.io</code>. If you are using a local Kubernetes cluster created with Kind, forward requests from your local port 8000 to the Envoy service running inside the cluster:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre>"},{"location":"authorino/docs/user-guides/anonymous-access/#create-an-authconfig","title":"\u277a Create an <code>AuthConfig</code>","text":"<p>Create an Authorino <code>AuthConfig</code> custom resource declaring the auth rules to be enforced:</p> Kuadrant users \u2013         Remember to create an <code>AuthPolicy</code> instead of an AuthConfig.         For more, see Kuadrant auth.        <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n\n  - talker-api.127.0.0.1.nip.io\n  authentication:\n    \"public\":\n      anonymous: {}\nEOF\n</code></pre> <p>The example above enables anonymous access (i.e. removes authentication), without adding any extra layer of protection to the API. This is virtually equivalent to setting a top-level condition to the <code>AuthConfig</code> that always skips the configuration, or to switching authentication/authorization off completely in the route to the API.</p> <p>For more sophisticated use cases of anonymous access with Authorino, consider combining this feature with other identity sources in the <code>AuthConfig</code> while playing with the priorities of each source, as well as combination with <code>when</code> conditions, and/or adding authorization policies that either cover authentication or address anonymous access with proper rules (e.g. enforcing read-only access).</p> <p>Check out the docs for the Anonymous access feature for an example of an <code>AuthConfig</code> that falls back to anonymous access when a priority OIDC/JWT-based authentication fails, and enforces a read-only policy in such cases.</p>"},{"location":"authorino/docs/user-guides/anonymous-access/#consume-the-api","title":"\u277b Consume the API","text":"<pre><code>curl http://talker-api.127.0.0.1.nip.io:8000/hello\n# HTTP/1.1 200 OK\n</code></pre>"},{"location":"authorino/docs/user-guides/anonymous-access/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete authconfig/talker-api-protection\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\nkubectl delete authorino/authorino\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <ol> <li> <p>In contrast to a dedicated sidecar of the protected service and other architectures. Check out Architecture &gt; Topologies for all options.\u00a0\u21a9</p> </li> <li> <p><code>namespaced</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> <li> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. If you are running your ingress gateway in Kubernetes and wants to avoid setting up and configuring your proxy manually, check out Kuadrant.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/api-key-authentication/","title":"User guide: Authentication with API keys","text":"<p>Issue API keys stored in Kubernetes <code>Secret</code>s for clients to authenticate with your protected hosts.</p> Authorino capabilities featured in this guide: <ul> <li>Identity verification &amp; authentication \u2192 API key</li> </ul> <p>In Authorino, API keys are stored as Kubernetes <code>Secret</code>s. Each resource must contain an <code>api_key</code> entry with the value of the API key, and labeled to match the selectors specified in <code>spec.identity.apiKey.selector</code> of the <code>AuthConfig</code>.</p> <p>API key <code>Secret</code>s must also include labels that match the <code>secretLabelSelector</code> field of the Authorino instance. See Resource reconciliation and status update for details.</p> <p>For further details about Authorino features in general, check the docs.</p> <p></p>"},{"location":"authorino/docs/user-guides/api-key-authentication/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC)</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p></p> <p>The next steps walk you through installing Authorino, deploying and configuring a sample service called Talker API to be protected by the authorization service.</p> Using Kuadrant <p>If you are a user of Kuadrant and already have your workload cluster configured and sample service application deployed, as well as your Gateway API network resources applied to route traffic to your service, skip straight to step \u277a.</p> <p>At step \u277a, instead of creating an <code>AuthConfig</code> custom resource, create a Kuadrant <code>AuthPolicy</code> one. The schema of the AuthConfig's <code>spec</code> matches the one of the AuthPolicy's, except <code>spec.host</code>, which is not available in the Kuadrant AuthPolicy. Host names in a Kuadrant AuthPolicy are inferred automatically from the Kubernetes network object referred in <code>spec.targetRef</code> and route selectors declared in the policy.</p> <p>For more about using Kuadrant to enforce authorization, check out Kuadrant auth.</p> <p></p>"},{"location":"authorino/docs/user-guides/api-key-authentication/#install-the-authorino-operator-cluster-admin-required","title":"\u2776 Install the Authorino Operator (cluster admin required)","text":"<p>The following command will install the Authorino Operator in the Kubernetes cluster. The operator manages instances of the Authorino authorization service.</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/api-key-authentication/#deploy-authorino","title":"\u2777 Deploy Authorino","text":"<p>The following command will request an instance of Authorino as a separate service<sup>1</sup> that watches for <code>AuthConfig</code> resources in the <code>default</code> namespace<sup>2</sup>, with TLS disabled<sup>3</sup>.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/api-key-authentication/#deploy-the-talker-api","title":"\u2778 Deploy the Talker API","text":"<p>The Talker API is a simple HTTP service that echoes back in the response whatever it gets in the request. We will use it in this guide as the sample service to be protected by Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/docs/user-guides/api-key-authentication/#setup-envoy","title":"\u2779 Setup Envoy","text":"<p>The following bundle from the Authorino examples deploys the Envoy proxy and configuration to wire up the Talker API behind the reverse-proxy, with external authorization enabled with the Authorino instance.<sup>4</sup></p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The command above creates an <code>Ingress</code> with host name <code>talker-api.127.0.0.1.nip.io</code>. If you are using a local Kubernetes cluster created with Kind, forward requests from your local port 8000 to the Envoy service running inside the cluster:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre>"},{"location":"authorino/docs/user-guides/api-key-authentication/#create-an-authconfig","title":"\u277a Create an <code>AuthConfig</code>","text":"<p>Create an Authorino <code>AuthConfig</code> custom resource declaring the auth rules to be enforced:</p> Kuadrant users \u2013         Remember to create an <code>AuthPolicy</code> instead of an AuthConfig.         For more, see Kuadrant auth.        <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n\n  - talker-api.127.0.0.1.nip.io\n  authentication:\n    \"friends\":\n      apiKey:\n        selector:\n          matchLabels:\n            group: friends\n      credentials:\n        authorizationHeader:\n          prefix: APIKEY\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/api-key-authentication/#create-an-api-key","title":"\u277b Create an API key","text":"<pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: api-key-1\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    group: friends\nstringData:\n  api_key: ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx\ntype: Opaque\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/api-key-authentication/#consume-the-api","title":"\u277c Consume the API","text":"<p>With a valid API key:</p> <pre><code>curl -H 'Authorization: APIKEY ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx' http://talker-api.127.0.0.1.nip.io:8000/hello\n# HTTP/1.1 200 OK\n</code></pre> <p>With missing or invalid API key:</p> <pre><code>curl -H 'Authorization: APIKEY invalid' http://talker-api.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 401 Unauthorized\n# www-authenticate: APIKEY realm=\"friends\"\n# x-ext-auth-reason: the API Key provided is invalid\n</code></pre>"},{"location":"authorino/docs/user-guides/api-key-authentication/#delete-an-api-key-revoke-access-to-the-api","title":"\u277d Delete an API key (revoke access to the API)","text":"<pre><code>kubectl delete secret/api-key-1\n</code></pre>"},{"location":"authorino/docs/user-guides/api-key-authentication/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete authconfig/talker-api-protection\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\nkubectl delete authorino/authorino\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <ol> <li> <p>In contrast to a dedicated sidecar of the protected service and other architectures. Check out Architecture &gt; Topologies for all options.\u00a0\u21a9</p> </li> <li> <p><code>namespaced</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> <li> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. If you are running your ingress gateway in Kubernetes and wants to avoid setting up and configuring your proxy manually, check out Kuadrant.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/authenticated-rate-limiting-envoy-dynamic-metadata/","title":"User guide: Authenticated rate limiting (with Envoy Dynamic Metadata)","text":"<p>Provide Envoy with dynamic metadata about the external authorization process to be injected into the rate limiting filter.</p> Authorino capabilities featured in this guide: <ul> <li>Dynamic response \u2192 Response wrappers \u2192 Envoy Dynamic Metadata</li> <li>Dynamic response \u2192 JSON injection</li> <li>Identity verification &amp; authentication \u2192 API key</li> </ul> <p>Dynamic JSON objects built out of static values and values fetched from the Authorization JSON can be wrapped to be returned to the reverse-proxy as Envoy Well Known Dynamic Metadata content. Envoy can use those to inject data returned by the external authorization service into the other filters, such as the rate limiting filter.</p> <p>Check out as well the user guides about Injecting data in the request and Authentication with API keys.</p> <p>For further details about Authorino features in general, check the docs.</p> <p></p>"},{"location":"authorino/docs/user-guides/authenticated-rate-limiting-envoy-dynamic-metadata/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC)</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p></p> <p>The next steps walk you through installing Authorino, deploying and configuring a sample service called Talker API to be protected by the authorization service.</p> Using Kuadrant <p>If you are a user of Kuadrant and already have your workload cluster configured and sample service application deployed, as well as your Gateway API network resources applied to route traffic to your service, skip straight to step \u277b.</p> <p>At step \u277b, instead of creating an <code>AuthConfig</code> custom resource, create a Kuadrant <code>AuthPolicy</code> one. The schema of the AuthConfig's <code>spec</code> matches the one of the AuthPolicy's, except <code>spec.host</code>, which is not available in the Kuadrant AuthPolicy. Host names in a Kuadrant AuthPolicy are inferred automatically from the Kubernetes network object referred in <code>spec.targetRef</code> and route selectors declared in the policy.</p> <p>For more about using Kuadrant to enforce authorization, check out Kuadrant auth.</p> <p></p>"},{"location":"authorino/docs/user-guides/authenticated-rate-limiting-envoy-dynamic-metadata/#install-the-authorino-operator-cluster-admin-required","title":"\u2776 Install the Authorino Operator (cluster admin required)","text":"<p>The following command will install the Authorino Operator in the Kubernetes cluster. The operator manages instances of the Authorino authorization service.</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/authenticated-rate-limiting-envoy-dynamic-metadata/#deploy-authorino","title":"\u2777 Deploy Authorino","text":"<p>The following command will request an instance of Authorino as a separate service<sup>1</sup> that watches for <code>AuthConfig</code> resources in the <code>default</code> namespace<sup>2</sup>, with TLS disabled<sup>3</sup>.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/authenticated-rate-limiting-envoy-dynamic-metadata/#deploy-limitador","title":"\u2778 Deploy Limitador","text":"<p>Limitador is a lightweight rate limiting service that can be used with Envoy.</p> <p>On this bundle, we will deploy Limitador pre-configured to limit requests to the <code>talker-api</code> domain up to 5 requests per interval of 60 seconds per <code>user_id</code>. Envoy will be configured to recognize the presence of Limitador and activate it on requests to the Talker API.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/limitador/limitador-deploy.yaml\n</code></pre>"},{"location":"authorino/docs/user-guides/authenticated-rate-limiting-envoy-dynamic-metadata/#deploy-the-talker-api","title":"\u2779 Deploy the Talker API","text":"<p>The Talker API is a simple HTTP service that echoes back in the response whatever it gets in the request. We will use it in this guide as the sample service to be protected by Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/docs/user-guides/authenticated-rate-limiting-envoy-dynamic-metadata/#setup-envoy","title":"\u277a Setup Envoy","text":"<p>The following bundle from the Authorino examples deploys the Envoy proxy and configuration to wire up the Talker API behind the reverse-proxy, with external authorization enabled with the Authorino instance.<sup>4</sup></p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The command above creates an <code>Ingress</code> with host name <code>talker-api.127.0.0.1.nip.io</code>. If you are using a local Kubernetes cluster created with Kind, forward requests from your local port 8000 to the Envoy service running inside the cluster:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre>"},{"location":"authorino/docs/user-guides/authenticated-rate-limiting-envoy-dynamic-metadata/#create-an-authconfig","title":"\u277b Create an <code>AuthConfig</code>","text":"<p>Create an Authorino <code>AuthConfig</code> custom resource declaring the auth rules to be enforced.</p> <p>An annotation <code>auth-data/username</code> will be read from the Kubernetes API Key secret and passed as dynamic metadata <code>{ \"ext_auth_data\": { \"username\": \u00abannotations.auth-data/username\u00bb } }</code>.</p> Kuadrant users \u2013         Remember to create an <code>AuthPolicy</code> instead of an AuthConfig.         For more, see Kuadrant auth.        <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n\n  - talker-api.127.0.0.1.nip.io\n  authentication:\n    \"friends\":\n      apiKey:\n        selector:\n          matchLabels:\n            group: friends\n      credentials:\n        authorizationHeader:\n          prefix: APIKEY\n  response:\n    success:\n      dynamicMetadata:\n        \"rate-limit\":\n          json:\n            properties:\n              \"username\":\n                expression: auth.identity.metadata.annotations['auth-data/username']\n          key: ext_auth_data # how this bit of dynamic metadata from the ext authz service is named in the Envoy config\nEOF\n</code></pre> <p>Check out the docs about using Common Expression Language (CEL) for reading from the Authorization JSON.</p>"},{"location":"authorino/docs/user-guides/authenticated-rate-limiting-envoy-dynamic-metadata/#create-the-api-keys","title":"\u277c Create the API keys","text":"<p>For user John:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: api-key-1\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    group: friends\n  annotations:\n    auth-data/username: john\nstringData:\n  api_key: ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx\ntype: Opaque\nEOF\n</code></pre> <p>For user Jane:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: api-key-2\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    group: friends\n  annotations:\n    auth-data/username: jane\nstringData:\n  api_key: 7BNaTmYGItSzXiwQLNHu82+x52p1XHgY\ntype: Opaque\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/authenticated-rate-limiting-envoy-dynamic-metadata/#consume-the-api","title":"\u277d Consume the API","text":"<p>As John:</p> <pre><code>curl -H 'Authorization: APIKEY ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx' http://talker-api.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 200 OK\n</code></pre> <p>Repeat the request a few more times within the 60-second time window, until the response status is <code>429 Too Many Requests</code>.</p> <p>While the API is still limited to John, send requests as Jane:</p> <pre><code>curl -H 'Authorization: APIKEY 7BNaTmYGItSzXiwQLNHu82+x52p1XHgY' http://talker-api.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 200 OK\n</code></pre>"},{"location":"authorino/docs/user-guides/authenticated-rate-limiting-envoy-dynamic-metadata/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete secret/api-key-1\nkubectl delete secret/api-key-2\nkubectl delete authconfig/talker-api-protection\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/limitador/limitador-deploy.yaml\nkubectl delete authorino/authorino\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <ol> <li> <p>In contrast to a dedicated sidecar of the protected service and other architectures. Check out Architecture &gt; Topologies for all options.\u00a0\u21a9</p> </li> <li> <p><code>namespaced</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> <li> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. If you are running your ingress gateway in Kubernetes and wants to avoid setting up and configuring your proxy manually, check out Kuadrant.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/authzed/","title":"User guide: Integration with Authzed/SpiceDB","text":"<p>Permission requests sent to a Google Zanzibar-based Authzed/SpiceDB instance, via gRPC.</p> Authorino capabilities featured in this guide: <ul> <li>Authorization \u2192 SpiceDB</li> <li>Identity verification &amp; authentication \u2192 API key</li> </ul> <p></p>"},{"location":"authorino/docs/user-guides/authzed/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC)</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p></p> <p>The next steps walk you through installing Authorino, deploying and configuring a sample service called Talker API to be protected by the authorization service.</p> Using Kuadrant <p>If you are a user of Kuadrant and already have your workload cluster configured and sample service application deployed, as well as your Gateway API network resources applied to route traffic to your service, skip straight to step \u277b.</p> <p>At step \u277b, instead of creating an <code>AuthConfig</code> custom resource, create a Kuadrant <code>AuthPolicy</code> one. The schema of the AuthConfig's <code>spec</code> matches the one of the AuthPolicy's, except <code>spec.host</code>, which is not available in the Kuadrant AuthPolicy. Host names in a Kuadrant AuthPolicy are inferred automatically from the Kubernetes network object referred in <code>spec.targetRef</code> and route selectors declared in the policy.</p> <p>For more about using Kuadrant to enforce authorization, check out Kuadrant auth.</p> <p></p>"},{"location":"authorino/docs/user-guides/authzed/#install-the-authorino-operator-cluster-admin-required","title":"\u2776 Install the Authorino Operator (cluster admin required)","text":"<p>The following command will install the Authorino Operator in the Kubernetes cluster. The operator manages instances of the Authorino authorization service.</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/authzed/#deploy-authorino","title":"\u2777 Deploy Authorino","text":"<p>The following command will request an instance of Authorino as a separate service<sup>1</sup> that watches for <code>AuthConfig</code> resources in the <code>default</code> namespace<sup>2</sup>, with TLS disabled<sup>3</sup>.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/authzed/#deploy-the-talker-api","title":"\u2778 Deploy the Talker API","text":"<p>The Talker API is a simple HTTP service that echoes back in the response whatever it gets in the request. We will use it in this guide as the sample service to be protected by Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/docs/user-guides/authzed/#setup-envoy","title":"\u2779 Setup Envoy","text":"<p>The following bundle from the Authorino examples deploys the Envoy proxy and configuration to wire up the Talker API behind the reverse-proxy, with external authorization enabled with the Authorino instance.<sup>4</sup></p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The command above creates an <code>Ingress</code> with host name <code>talker-api.127.0.0.1.nip.io</code>. If you are using a local Kubernetes cluster created with Kind, forward requests from your local port 8000 to the Envoy service running inside the cluster:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre>"},{"location":"authorino/docs/user-guides/authzed/#create-the-permission-database","title":"\u277a Create the permission database","text":"<p>Create the namespace:</p> <pre><code>kubectl create namespace spicedb\n</code></pre> <p>Create the SpiceDB instance:</p> <pre><code>kubectl -n spicedb apply -f -&lt;&lt;EOF\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: spicedb\n  labels:\n    app: spicedb\nspec:\n  selector:\n    matchLabels:\n      app: spicedb\n  template:\n    metadata:\n      labels:\n        app: spicedb\n    spec:\n      containers:\n\n      - name: spicedb\n        image: authzed/spicedb\n        args:\n        - serve\n        - \"--grpc-preshared-key\"\n        - secret\n        - \"--http-enabled\"\n        ports:\n        - containerPort: 50051\n        - containerPort: 8443\n  replicas: 1\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: spicedb\nspec:\n  selector:\n    app: spicedb\n  ports:\n    - name: grpc\n      port: 50051\n      protocol: TCP\n    - name: http\n      port: 8443\n      protocol: TCP\nEOF\n</code></pre> <p>Forward local request to the SpiceDB service inside the cluster:</p> <pre><code>kubectl -n spicedb port-forward service/spicedb 8443:8443 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre> <p>Create the permission schema:</p> <pre><code>curl -X POST http://localhost:8443/v1/schema/write \\\n  -H 'Authorization: Bearer secret' \\\n  -H 'Content-Type: application/json' \\\n  -d @- &lt;&lt; EOF\n{\n  \"schema\": \"definition blog/user {}\\ndefinition blog/post {\\n\\trelation reader: blog/user\\n\\trelation writer: blog/user\\n\\n\\tpermission read = reader + writer\\n\\tpermission write = writer\\n}\"\n}\nEOF\n</code></pre> <p>Create the relationships:</p> <ul> <li><code>blog/user:emilia</code> \u2192 <code>writer</code> of <code>blog/post:1</code></li> <li><code>blog/user:beatrice</code> \u2192 <code>reader</code> of <code>blog/post:1</code></li> </ul> <pre><code>curl -X POST http://localhost:8443/v1/relationships/write \\\n  -H 'Authorization: Bearer secret' \\\n  -H 'Content-Type: application/json' \\\n  -d @- &lt;&lt; EOF\n{\n  \"updates\": [\n    {\n      \"operation\": \"OPERATION_CREATE\",\n      \"relationship\": {\n        \"resource\": {\n          \"objectType\": \"blog/post\",\n          \"objectId\": \"1\"\n        },\n        \"relation\": \"writer\",\n        \"subject\": {\n          \"object\": {\n            \"objectType\": \"blog/user\",\n            \"objectId\": \"emilia\"\n          }\n        }\n      }\n    },\n    {\n      \"operation\": \"OPERATION_CREATE\",\n      \"relationship\": {\n        \"resource\": {\n          \"objectType\": \"blog/post\",\n          \"objectId\": \"1\"\n        },\n        \"relation\": \"reader\",\n        \"subject\": {\n          \"object\": {\n            \"objectType\": \"blog/user\",\n            \"objectId\": \"beatrice\"\n          }\n        }\n      }\n    }\n  ]\n}\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/authzed/#create-an-authconfig","title":"\u277a Create an <code>AuthConfig</code>","text":"<p>Create an Authorino <code>AuthConfig</code> custom resource declaring the auth rules to be enforced.</p> Kuadrant users \u2013         Remember to create an <code>AuthPolicy</code> instead of an AuthConfig.         For more, see Kuadrant auth.        <p>Store the shared token for Authorino to authenticate with the SpiceDB instance in a Service:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: spicedb\n  labels:\n    app: spicedb\nstringData:\n  grpc-preshared-key: secret\nEOF\n</code></pre> <p>Create the AuthConfig:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n\n  - talker-api.127.0.0.1.nip.io\n  authentication:\n    \"blog-users\":\n      apiKey:\n        selector:\n          matchLabels:\n            app: talker-api\n      credentials:\n        authorizationHeader:\n          prefix: APIKEY\n  authorization:\n    \"authzed-spicedb\":\n      spicedb:\n        endpoint: spicedb.spicedb.svc.cluster.local:50051\n        insecure: true\n        sharedSecretRef:\n          name: spicedb\n          key: grpc-preshared-key\n        subject:\n          kind:\n            value: blog/user\n          name:\n            selector: auth.identity.metadata.annotations.username\n        resource:\n          kind:\n            value: blog/post\n          name:\n            selector: context.request.http.path.@extract:{\"sep\":\"/\",\"pos\":2}\n        permission:\n          selector: context.request.http.method.@replace:{\"old\":\"GET\",\"new\":\"read\"}.@replace:{\"old\":\"POST\",\"new\":\"write\"}\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/authzed/#create-the-api-keys","title":"\u277c Create the API keys","text":"<p>For Emilia (writer):</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: api-key-writer\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    app: talker-api\n  annotations:\n    username: emilia\nstringData:\n  api_key: IAMEMILIA\nEOF\n</code></pre> <p>For Beatrice (reader):</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: api-key-reader\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    app: talker-api\n  annotations:\n    username: beatrice\nstringData:\n  api_key: IAMBEATRICE\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/authzed/#consume-the-api","title":"\u277d Consume the API","text":"<p>As Emilia, send a GET request:</p> <pre><code>curl -H 'Authorization: APIKEY IAMEMILIA' \\\n     -X GET \\\n     http://talker-api.127.0.0.1.nip.io:8000/posts/1 -i\n# HTTP/1.1 200 OK\n</code></pre> <p>As Emilia, send a POST request:</p> <pre><code>curl -H 'Authorization: APIKEY IAMEMILIA' \\\n     -X POST \\\n     http://talker-api.127.0.0.1.nip.io:8000/posts/1 -i\n# HTTP/1.1 200 OK\n</code></pre> <p>As Beatrice, send a GET request:</p> <pre><code>curl -H 'Authorization: APIKEY IAMBEATRICE' \\\n     -X GET \\\n     http://talker-api.127.0.0.1.nip.io:8000/posts/1 -i\n# HTTP/1.1 200 OK\n</code></pre> <p>As Beatrice, send a POST request:</p> <pre><code>curl -H 'Authorization: APIKEY IAMBEATRICE' \\\n     -X POST \\\n     http://talker-api.127.0.0.1.nip.io:8000/posts/1 -i\n# HTTP/1.1 403 Forbidden\n# x-ext-auth-reason: PERMISSIONSHIP_NO_PERMISSION;token=GhUKEzE2NzU3MDE3MjAwMDAwMDAwMDA=\n</code></pre>"},{"location":"authorino/docs/user-guides/authzed/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete secret/api-key-1\nkubectl delete authconfig/talker-api-protection\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\nkubectl delete authorino/authorino\nkubectl delete namespace spicedb\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <ol> <li> <p>In contrast to a dedicated sidecar of the protected service and other architectures. Check out Architecture &gt; Topologies for all options.\u00a0\u21a9</p> </li> <li> <p><code>namespaced</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> <li> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. If you are running your ingress gateway in Kubernetes and wants to avoid setting up and configuring your proxy manually, check out Kuadrant.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/caching/","title":"User guide: Caching","text":"<p>Cache auth objects resolved at runtime for any configuration bit of an AuthConfig (i.e. any evaluator), of any phase (identity, metadata, authorization and dynamic response), for easy access in subsequent requests, whenever an arbitrary (user-defined) cache key repeats, until the cache entry expires.</p> <p>This is particularly useful for configuration bits whose evaluation is significantly more expensive than accessing the cache. E.g.:</p> <ul> <li>Caching of metadata fetched from external sources in general</li> <li>Caching of previously validated identity access tokens (e.g. for OAuth2 opaque tokens that involve consuming the token introspection endpoint of an external auth server)</li> <li>Caching of complex Rego policies that involve sending requests to external services</li> </ul> <p>Cases where one will NOT want to enable caching, due to relatively cheap compared to accessing and managing the cache:</p> <ul> <li>Validation of OIDC/JWT access tokens</li> <li>OPA/Rego policies that do not involve external requests</li> <li>JSON pattern-matching authorization</li> <li>Dynamic JSON responses</li> <li>Anonymous access</li> </ul> Authorino capabilities featured in this guide: <ul> <li>Common feature \u2192 Caching</li> <li>Identity verification &amp; authentication \u2192 Anonymous access</li> <li>External auth metadata \u2192 HTTP GET/GET-by-POST</li> <li>Authorization \u2192 Open Policy Agent (OPA) Rego policies</li> <li>Dynamic response \u2192 JSON injection</li> </ul> <p>For further details about Authorino features in general, check the docs.</p> <p></p>"},{"location":"authorino/docs/user-guides/caching/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC)</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p></p> <p>The next steps walk you through installing Authorino, deploying and configuring a sample service called Talker API to be protected by the authorization service.</p> Using Kuadrant <p>If you are a user of Kuadrant and already have your workload cluster configured and sample service application deployed, as well as your Gateway API network resources applied to route traffic to your service, skip straight to step \u277a.</p> <p>At step \u277a, instead of creating an <code>AuthConfig</code> custom resource, create a Kuadrant <code>AuthPolicy</code> one. The schema of the AuthConfig's <code>spec</code> matches the one of the AuthPolicy's, except <code>spec.host</code>, which is not available in the Kuadrant AuthPolicy. Host names in a Kuadrant AuthPolicy are inferred automatically from the Kubernetes network object referred in <code>spec.targetRef</code> and route selectors declared in the policy.</p> <p>For more about using Kuadrant to enforce authorization, check out Kuadrant auth.</p> <p></p>"},{"location":"authorino/docs/user-guides/caching/#install-the-authorino-operator-cluster-admin-required","title":"\u2776 Install the Authorino Operator (cluster admin required)","text":"<p>The following command will install the Authorino Operator in the Kubernetes cluster. The operator manages instances of the Authorino authorization service.</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/caching/#deploy-authorino","title":"\u2777 Deploy Authorino","text":"<p>The following command will request an instance of Authorino as a separate service<sup>1</sup> that watches for <code>AuthConfig</code> resources in the <code>default</code> namespace<sup>2</sup>, with TLS disabled<sup>3</sup>.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/caching/#deploy-the-talker-api","title":"\u2778 Deploy the Talker API","text":"<p>The Talker API is a simple HTTP service that echoes back in the response whatever it gets in the request. We will use it in this guide as the sample service to be protected by Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/docs/user-guides/caching/#setup-envoy","title":"\u2779 Setup Envoy","text":"<p>The following bundle from the Authorino examples deploys the Envoy proxy and configuration to wire up the Talker API behind the reverse-proxy, with external authorization enabled with the Authorino instance.<sup>4</sup></p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The command above creates an <code>Ingress</code> with host name <code>talker-api.127.0.0.1.nip.io</code>. If you are using a local Kubernetes cluster created with Kind, forward requests from your local port 8000 to the Envoy service running inside the cluster:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre>"},{"location":"authorino/docs/user-guides/caching/#create-an-authconfig","title":"\u277a Create an <code>AuthConfig</code>","text":"<p>Create an Authorino <code>AuthConfig</code> custom resource declaring the auth rules to be enforced.</p> <p>The example below enables caching for the external source of metadata, which in this case, for convenience, is the same upstream API protected by Authorino (i.e. the Talker API), though consumed directly by Authorino, without passing through the proxy. This API generates a <code>uuid</code> random hash that it injects in the JSON response. This value is different in every request processed by the API.</p> <p>The example also enables caching of returned OPA virtual documents. <code>cached-authz</code> is a trivial Rego policy that always grants access, but generates a timestamp, which Authorino will cache.</p> <p>In both cases, the path of the HTTP request is used as cache key. I.e., whenever the path repeats, Authorino reuse the values stored previously in each cache table (<code>cached-metadata</code> and <code>cached-authz</code>), respectively saving a request to the external source of metadata and the evaluation of the OPA policy. Cache entries will expire in both cases after 60 seconds they were stored in the cache.</p> <p>The cached values will be visible in the response returned by the Talker API in <code>x-authz-data</code> header injected by Authorino. This way, we can tell when an existing value in the cache was used and when a new one was generated and stored.</p> Kuadrant users \u2013         Remember to create an <code>AuthPolicy</code> instead of an AuthConfig.         For more, see Kuadrant auth.        <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n\n  - talker-api.127.0.0.1.nip.io\n  authentication:\n    \"anonymous\":\n      anonymous: {}\n  metadata:\n    \"cached-metadata\":\n      http:\n        url: \"http://talker-api.default.svc.cluster.local:3000/metadata/{context.request.http.path}\"\n      cache:\n        key:\n          selector: context.request.http.path\n        ttl: 60\n  authorization:\n    \"cached-authz\":\n      opa:\n        rego: |\n          now = time.now_ns()\n          allow = true\n        allValues: true\n      cache:\n        key:\n          selector: context.request.http.path\n        ttl: 60\n  response:\n    success:\n      headers:\n        \"x-authz-data\":\n          json:\n            properties:\n              \"cached-metadata\":\n                selector: auth.metadata.cached-metadata.uuid\n              \"cached-authz\":\n                selector: auth.authorization.cached-authz.now\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/caching/#consume-the-api","title":"\u277b Consume the API","text":"<ol> <li>To <code>/hello</code></li> </ol> <pre><code>curl http://talker-api.127.0.0.1.nip.io:8000/hello\n# [\u2026]\n#  \"X-Authz-Data\": \"{\\\"cached-authz\\\":\\\"1649343067462380300\\\",\\\"cached-metadata\\\":\\\"92c111cd-a10f-4e86-8bf0-e0cd646c6f79\\\"}\",\n# [\u2026]\n</code></pre> <ol> <li>To a different path</li> </ol> <pre><code>curl http://talker-api.127.0.0.1.nip.io:8000/goodbye\n# [\u2026]\n#  \"X-Authz-Data\": \"{\\\"cached-authz\\\":\\\"1649343097860450300\\\",\\\"cached-metadata\\\":\\\"37fce386-1ee8-40a7-aed1-bf8a208f283c\\\"}\",\n# [\u2026]\n</code></pre> <ol> <li>To <code>/hello</code> again before the cache entry expires (60 seconds from the first request sent to this path)</li> </ol> <pre><code>curl http://talker-api.127.0.0.1.nip.io:8000/hello\n# [\u2026]\n#  \"X-Authz-Data\": \"{\\\"cached-authz\\\":\\\"1649343067462380300\\\",\\\"cached-metadata\\\":\\\"92c111cd-a10f-4e86-8bf0-e0cd646c6f79\\\"}\",  &lt;=== same cache-id as before\n# [\u2026]\n</code></pre> <ol> <li>To <code>/hello</code> again after the cache entry expires (60 seconds from the first request sent to this path)</li> </ol> <pre><code>curl http://talker-api.127.0.0.1.nip.io:8000/hello\n# [\u2026]\n#  \"X-Authz-Data\": \"{\\\"cached-authz\\\":\\\"1649343135702743800\\\",\\\"cached-metadata\\\":\\\"e708a3a6-5caf-4028-ab5c-573ad9be7188\\\"}\",  &lt;=== different cache-id\n# [\u2026]\n</code></pre>"},{"location":"authorino/docs/user-guides/caching/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete authconfig/talker-api-protection\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\nkubectl delete authorino/authorino\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <ol> <li> <p>In contrast to a dedicated sidecar of the protected service and other architectures. Check out Architecture &gt; Topologies for all options.\u00a0\u21a9</p> </li> <li> <p><code>namespaced</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> <li> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. If you are running your ingress gateway in Kubernetes and wants to avoid setting up and configuring your proxy manually, check out Kuadrant.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/deny-with-redirect-to-login/","title":"User guide: Redirecting to a login page","text":"<p>Customize response status code and headers on failed requests to redirect users of a web application protected with Authorino to a login page instead of a <code>401 Unauthorized</code>.</p> Authorino capabilities featured in this guide: <ul> <li>Dynamic response \u2192 Custom denial status</li> <li>Identity verification &amp; authentication \u2192 API key</li> <li>Identity verification &amp; authentication \u2192 JWT verification</li> </ul> <p>Authorino's default response status codes, messages and headers for unauthenticated (<code>401</code>) and unauthorized (<code>403</code>) requests can be customized with static values and values fetched from the Authorization JSON.</p> <p>Check out as well the user guides about HTTP \"Basic\" Authentication (RFC 7235) and OpenID Connect Discovery and authentication with JWTs.</p> <p>For further details about Authorino features in general, check the docs.</p> <p></p>"},{"location":"authorino/docs/user-guides/deny-with-redirect-to-login/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC)</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p></p> <p>The next steps walk you through installing Authorino, deploying and configuring a sample web application called Matrix Quotes to be protected by the authorization service.</p> Using Kuadrant <p>If you are a user of Kuadrant and already have your workload cluster configured and sample service application deployed, as well as your Gateway API network resources applied to route traffic to your service, skip straight to step \u277a.</p> <p>At step \u277a, instead of creating an <code>AuthConfig</code> custom resource, create a Kuadrant <code>AuthPolicy</code> one. The schema of the AuthConfig's <code>spec</code> matches the one of the AuthPolicy's, except <code>spec.host</code>, which is not available in the Kuadrant AuthPolicy. Host names in a Kuadrant AuthPolicy are inferred automatically from the Kubernetes network object referred in <code>spec.targetRef</code> and route selectors declared in the policy.</p> <p>For more about using Kuadrant to enforce authorization, check out Kuadrant auth.</p> <p></p>"},{"location":"authorino/docs/user-guides/deny-with-redirect-to-login/#install-the-authorino-operator-cluster-admin-required","title":"\u2776 Install the Authorino Operator (cluster admin required)","text":"<p>The following command will install the Authorino Operator in the Kubernetes cluster. The operator manages instances of the Authorino authorization service.</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/deny-with-redirect-to-login/#deploy-authorino","title":"\u2777 Deploy Authorino","text":"<p>The following command will request an instance of Authorino as a separate service<sup>1</sup> that watches for <code>AuthConfig</code> resources in the <code>default</code> namespace<sup>2</sup>, with TLS disabled<sup>3</sup>.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/deny-with-redirect-to-login/#deploy-the-matrix-quotes-web-application","title":"\u2778 Deploy the Matrix Quotes web application","text":"<p>The Matrix Quotes is a static web application that contains quotes from the film The Matrix.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/matrix-quotes/matrix-quotes-deploy.yaml\n</code></pre>"},{"location":"authorino/docs/user-guides/deny-with-redirect-to-login/#setup-envoy","title":"\u2779 Setup Envoy","text":"<p>The following bundle from the Authorino examples deploys the Envoy proxy and configuration to wire up the Matrix Quotes webapp behind the reverse-proxy, with external authorization enabled with the Authorino instance.<sup>4</sup></p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/matrix-quotes/envoy-deploy.yaml\n</code></pre> <p>The command above creates an <code>Ingress</code> with host name <code>matrix-quotes.127.0.0.1.nip.io</code>. If you are using a local Kubernetes cluster created with Kind, forward requests from your local port 8000 to the Envoy service running inside the cluster:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre>"},{"location":"authorino/docs/user-guides/deny-with-redirect-to-login/#create-an-authconfig","title":"\u277a Create an <code>AuthConfig</code>","text":"<p>Create an Authorino <code>AuthConfig</code> custom resource declaring the auth rules to be enforced:</p> Kuadrant users \u2013         Remember to create an <code>AuthPolicy</code> instead of an AuthConfig.         For more, see Kuadrant auth.        <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: matrix-quotes-protection\nspec:\n  hosts:\n\n  - matrix-quotes.127.0.0.1.nip.io\n  authentication:\n    \"browser-users\":\n      apiKey:\n        selector:\n          matchLabels:\n            group: users\n      credentials:\n        cookie:\n          name: TOKEN\n    \"http-basic-auth\":\n      apiKey:\n        selector:\n          matchLabels:\n            group: users\n      credentials:\n        authorizationHeader:\n          prefix: Basic\n  response:\n    unauthenticated:\n      code: 302\n      headers:\n        \"Location\":\n          expression: |\n            'http://matrix-quotes.127.0.0.1.nip.io:8000/login.html?redirect_to=' + request.path\nEOF\n</code></pre> <p>Check out the docs about using Common Expression Language (CEL) for reading from the Authorization JSON.</p>"},{"location":"authorino/docs/user-guides/deny-with-redirect-to-login/#create-an-api-key","title":"\u277b Create an API key","text":"<pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: user-credential-1\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    group: users\nstringData:\n  api_key: am9objpw # john:p\ntype: Opaque\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/deny-with-redirect-to-login/#consume-the-application","title":"\u277c Consume the application","text":"<p>On a web browser, navigate to http://matrix-quotes.127.0.0.1.nip.io:8000.</p> <p>Click on the cards to read quotes from characters of the movie. You should be redirected to login page.</p> <p>Log in using John's credentials:</p> <ul> <li>Username: john</li> <li>Password: p</li> </ul> <p>Click again on the cards and check that now you are able to access the inner pages.</p> <p>You can also consume a protected endpoint of the application using HTTP Basic Authentication:</p> <pre><code>curl -u john:p http://matrix-quotes.127.0.0.1.nip.io:8000/neo.html\n# HTTP/1.1 200 OK\n</code></pre>"},{"location":"authorino/docs/user-guides/deny-with-redirect-to-login/#optional-modify-the-authconfig-to-authenticate-with-oidc","title":"\u277d (Optional) Modify the <code>AuthConfig</code> to authenticate with OIDC","text":""},{"location":"authorino/docs/user-guides/deny-with-redirect-to-login/#setup-a-keycloak-server","title":"Setup a Keycloak server","text":"<p>Deploy a Keycloak server preloaded with a realm named <code>kuadrant</code>:</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/keycloak/keycloak-deploy.yaml\n</code></pre> <p>Resolve local Keycloak domain so it can be accessed from the local host and inside the cluster with the name: (This will be needed to redirect to Keycloak's login page and at the same time validate issued tokens.)</p> <pre><code>echo '127.0.0.1 keycloak' &gt;&gt; /etc/hosts\n</code></pre> <p>Forward local requests to the instance of Keycloak running in the cluster:</p> <pre><code>kubectl port-forward deployment/keycloak 8080:8080 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre> <p>Create a client:</p> <pre><code>curl -H \"Authorization: Bearer $(curl http://keycloak:8080/realms/master/protocol/openid-connect/token -s -d 'grant_type=password' -d 'client_id=admin-cli' -d 'username=admin' -d 'password=p' | jq -r .access_token)\" \\\n     -H 'Content-type: application/json' \\\n     -d '{ \"name\": \"matrix-quotes\", \"clientId\": \"matrix-quotes\", \"publicClient\": true, \"redirectUris\": [\"http://matrix-quotes.127.0.0.1.nip.io:8000/auth*\"], \"enabled\": true }' \\\n     http://keycloak:8080/admin/realms/kuadrant/clients\n</code></pre>"},{"location":"authorino/docs/user-guides/deny-with-redirect-to-login/#reconfigure-the-matrix-quotes-app-to-use-keycloaks-login-page","title":"Reconfigure the Matrix Quotes app to use Keycloak's login page","text":"<pre><code>kubectl set env deployment/matrix-quotes KEYCLOAK_REALM=http://keycloak:8080/realms/kuadrant CLIENT_ID=matrix-quotes\n</code></pre>"},{"location":"authorino/docs/user-guides/deny-with-redirect-to-login/#apply-the-changes-to-the-authconfig","title":"Apply the changes to the <code>AuthConfig</code>","text":"<pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: matrix-quotes-protection\nspec:\n  hosts:\n\n  - matrix-quotes.127.0.0.1.nip.io\n  authentication:\n    \"idp-users\":\n      jwt:\n        issuerUrl: http://keycloak:8080/realms/kuadrant\n      credentials:\n        cookie:\n          name: TOKEN\n  response:\n    unauthenticated:\n      code: 302\n      headers:\n        \"Location\":\n          expression: |\n            'http://keycloak:8080/realms/kuadrant/protocol/openid-connect/auth?client_id=matrix-quotes&amp;redirect_uri=http://matrix-quotes.127.0.0.1.nip.io:8000/auth?redirect_to=' + request.path + '&amp;scope=openid&amp;response_type=code'\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/deny-with-redirect-to-login/#consume-the-application-again","title":"Consume the application again","text":"<p>Refresh the browser window or navigate again to http://matrix-quotes.127.0.0.1.nip.io:8000.</p> <p>Click on the cards to read quotes from characters of the movie. You should be redirected to login page this time served by the Keycloak server.</p> <p>Log in as Jane (a user of the Keycloak realm):</p> <ul> <li>Username: jane</li> <li>Password: p</li> </ul> <p>Click again on the cards and check that now you are able to access the inner pages.</p>"},{"location":"authorino/docs/user-guides/deny-with-redirect-to-login/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete secret/user-credential-1\nkubectl delete authconfig/matrix-quotes-protection\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/matrix-quotes/matrix-quotes-deploy.yaml\nkubectl delete authorino/authorino\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/keycloak/keycloak-deploy.yaml\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <ol> <li> <p>In contrast to a dedicated sidecar of the protected service and other architectures. Check out Architecture &gt; Topologies for all options.\u00a0\u21a9</p> </li> <li> <p><code>namespaced</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> <li> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. If you are running your ingress gateway in Kubernetes and wants to avoid setting up and configuring your proxy manually, check out Kuadrant.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/edge-authentication-architecture-festival-wristbands/","title":"User guide: Edge Authentication Architecture (EAA)","text":"<p>Edge Authentication Architecture (EAA) is a pattern where more than extracting authentication logics and specifics from the application codebase to a proper authN/authZ layer, this is pushed to the edge of your cloud network, without violating the Zero Trust principle nevertheless.</p> <p>The very definition of \"edge\" is subject to discussion, but the underlying idea is that clients (e.g. API clients, IoT devices, etc.) authenticate with a layer that, before moving traffic to inside the network:</p> <ul> <li>understands the complexity of all the different methods of authentication supported;</li> <li>sometimes some token normalization is involved;</li> <li>eventually enforces some preliminary authorization policies; and</li> <li>possibly filters data bits that are sensitive to privacy concerns (e.g. to comply with local legislation such as GRPD, CCPA, etc)</li> </ul> <p>As a minimum, EAA allows to simplify authentication between applications and microservices inside the network, as well as to reduce authorization to domain-specific rules and policies, rather than having to deal all the complexity to support all types of clients in every node.</p> Authorino capabilities featured in this guide: <ul> <li>Dynamic response \u2192 Festival Wristband tokens</li> <li>Identity verification &amp; authentication \u2192 Identity extension</li> <li>Identity verification &amp; authentication \u2192 API key</li> <li>Identity verification &amp; authentication \u2192 JWT verification</li> </ul> <p>Festival Wristbands are OpenID Connect ID tokens (signed JWTs) issued by Authorino by the end of the Auth Pipeline, for authorized requests. It can be configured to include claims based on static values and values fetched from the Authorization JSON.</p> <p>Check out as well the user guides about Token normalization, Authentication with API keys and OpenID Connect Discovery and authentication with JWTs.</p> <p>For further details about Authorino features in general, check the docs.</p> <p></p>"},{"location":"authorino/docs/user-guides/edge-authentication-architecture-festival-wristbands/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC)</li> <li>Identity Provider (IdP) that implements OpenID Connect authentication and OpenID Connect Discovery (e.g. Keycloak)</li> <li>jq, to extract parts of JSON responses</li> <li>jwt, to inspect JWTs (optional)</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p>Deploy the identity provider and authentication server by executing the command below. For the examples in this guide, we are going to use a Keycloak server preloaded with all required realm settings.</p> <pre><code>kubectl create namespace keycloak\nkubectl -n keycloak apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/keycloak/keycloak-deploy.yaml\n</code></pre> <p></p> <p>The next steps walk you through installing Authorino and configuring 2 environments of an architecture, <code>edge</code> and <code>internal</code>.</p> <p>The first environment is a facade for handling the first layer of authentication and exchanging any valid presented authentication token for a Festival Wristband token. In the second, we will deploy a sample service called Talker API that the authorization service will ensure to receive only authenticated traffic presented with a valid Festival Wristband.</p> Using Kuadrant <p>If you are a user of Kuadrant and already have your workload cluster configured and sample service application deployed, as well as your Gateway API network resources applied to route traffic to your service, skip straight to step \u2779.</p> <p>At steps \u2779 and \u277a, instead of creating an <code>AuthConfig</code> custom resource, create a Kuadrant <code>AuthPolicy</code> one. The schema of the AuthConfig's <code>spec</code> matches the one of the AuthPolicy's, except <code>spec.host</code>, which is not available in the Kuadrant AuthPolicy. Host names in a Kuadrant AuthPolicy are inferred automatically from the Kubernetes network object referred in <code>spec.targetRef</code> and route selectors declared in the policy.</p> <p>For more about using Kuadrant to enforce authorization, check out Kuadrant auth.</p> <p></p>"},{"location":"authorino/docs/user-guides/edge-authentication-architecture-festival-wristbands/#install-the-authorino-operator-cluster-admin-required","title":"\u2776 Install the Authorino Operator (cluster admin required)","text":"<p>The following command will install the Authorino Operator in the Kubernetes cluster. The operator manages instances of the Authorino authorization service.</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/edge-authentication-architecture-festival-wristbands/#create-the-namespaces","title":"\u2777 Create the namespaces","text":"<p>For simplicity, this examples will set up edge and internal nodes in different namespaces of the same Kubernetes cluster. Those will share a same single cluster-wide Authorino instance. In real-life scenarios, it does not have to be like that.</p> <pre><code>kubectl create namespace authorino\nkubectl create namespace edge\nkubectl create namespace internal\n</code></pre>"},{"location":"authorino/docs/user-guides/edge-authentication-architecture-festival-wristbands/#deploy-authorino","title":"\u2778 Deploy Authorino","text":"<p>The following command will request an instance of Authorino as a separate service<sup>1</sup> that watches for <code>AuthConfig</code> resources cluster-wide<sup>2</sup>, with TLS disabled<sup>3</sup>.</p> <pre><code>kubectl -n authorino apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  clusterWide: true\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/edge-authentication-architecture-festival-wristbands/#setup-the-edge","title":"\u2779 Setup the Edge","text":""},{"location":"authorino/docs/user-guides/edge-authentication-architecture-festival-wristbands/#setup-envoy","title":"Setup Envoy","text":"<p>The following bundle from the Authorino examples deploys the Envoy proxy and configuration to wire up external authorization with the Authorino instance.<sup>4</sup></p> <pre><code>kubectl -n edge apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/eaa/envoy-edge-deploy.yaml\n</code></pre> <p>The command above creates an <code>Ingress</code> with host name <code>edge.127.0.0.1.nip.io</code>. If you are using a local Kubernetes cluster created with Kind, forward requests from your local port 9000 to the Envoy service running inside the cluster:</p> <pre><code>kubectl -n edge port-forward deployment/envoy 9000:9000 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre>"},{"location":"authorino/docs/user-guides/edge-authentication-architecture-festival-wristbands/#create-the-authconfig","title":"Create the <code>AuthConfig</code>","text":"<p>Create a required secret that will be used by Authorino to sign the Festival Wristband tokens:</p> <pre><code>kubectl -n edge apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: wristband-signing-key\nstringData:\n  key.pem: |\n    -----BEGIN EC PRIVATE KEY-----\n    MHcCAQEEIDHvuf81gVlWGo0hmXGTAnA/HVxGuH8vOc7/8jewcVvqoAoGCCqGSM49\n    AwEHoUQDQgAETJf5NLVKplSYp95TOfhVPqvxvEibRyjrUZwwtpDuQZxJKDysoGwn\n    cnUvHIu23SgW+Ee9lxSmZGhO4eTdQeKxMA==\n    -----END EC PRIVATE KEY-----\ntype: Opaque\nEOF\n</code></pre> <p>Create the config:</p> Kuadrant users \u2013         Remember to create an <code>AuthPolicy</code> instead of an AuthConfig.         For more, see Kuadrant auth.        <pre><code>kubectl -n edge apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: edge-auth\nspec:\n  hosts:\n\n  - edge.127.0.0.1.nip.io\n  authentication:\n    \"api-clients\":\n      apiKey:\n        selector:\n          matchLabels:\n            authorino.kuadrant.io/managed-by: authorino\n        allNamespaces: true\n      credentials:\n        authorizationHeader:\n          prefix: APIKEY\n      overrides:\n        \"username\":\n          selector: auth.identity.metadata.annotations.authorino\\.kuadrant\\.io/username\n    \"idp-users\":\n      jwt:\n        issuerUrl: http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant\n      defaults:\n        \"username\":\n          selector: auth.identity.preferred_username\n  response:\n    success:\n      dynamicMetadata:\n        \"wristband\":\n          wristband:\n            issuer: http://authorino-authorino-oidc.authorino.svc.cluster.local:8083/edge/edge-auth/wristband\n            customClaims:\n              \"username\":\n                selector: auth.identity.username\n            tokenDuration: 300\n            signingKeyRefs:\n            - name: wristband-signing-key\n              algorithm: ES256\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/edge-authentication-architecture-festival-wristbands/#setup-the-internal-workload","title":"\u277a Setup the internal workload","text":""},{"location":"authorino/docs/user-guides/edge-authentication-architecture-festival-wristbands/#deploy-the-talker-api","title":"Deploy the Talker API","text":"<p>The Talker API is a simple HTTP service that echoes back in the response whatever it gets in the request. We will use it in this guide as the sample service to be protected by Authorino.</p> <pre><code>kubectl -n internal apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/docs/user-guides/edge-authentication-architecture-festival-wristbands/#setup-envoy_1","title":"Setup Envoy","text":"<p>This other bundle from the Authorino examples deploys the Envoy proxy and configuration to wire up the Talker API behind the reverse-proxy, with external authorization enabled with the Authorino instance.</p> <pre><code>kubectl -n internal apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/eaa/envoy-node-deploy.yaml\n</code></pre> <p>The command above creates an <code>Ingress</code> with host name <code>talker-api.127.0.0.1.nip.io</code>. If you are using a local Kubernetes cluster created with Kind, forward requests from your local port 8000 to the Envoy service running inside the cluster:</p> <pre><code>kubectl -n internal port-forward deployment/envoy 8000:8000 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre>"},{"location":"authorino/docs/user-guides/edge-authentication-architecture-festival-wristbands/#create-the-authconfig_1","title":"Create the <code>AuthConfig</code>","text":"Kuadrant users \u2013         Remember to create an <code>AuthPolicy</code> instead of an AuthConfig.         For more, see Kuadrant auth.        <pre><code>kubectl -n internal apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n\n  - talker-api.127.0.0.1.nip.io\n  authentication:\n    \"edge-authenticated\":\n      jwt:\n        issuerUrl: http://authorino-authorino-oidc.authorino.svc.cluster.local:8083/edge/edge-auth/wristband\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/edge-authentication-architecture-festival-wristbands/#create-an-api-key","title":"\u277b Create an API key","text":"<pre><code>kubectl -n edge apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: api-key-1\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n  annotations:\n    authorino.kuadrant.io/username: alice\n    authorino.kuadrant.io/email: alice@host\nstringData:\n  api_key: ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx\ntype: Opaque\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/edge-authentication-architecture-festival-wristbands/#consume-the-api","title":"\u277c Consume the API","text":""},{"location":"authorino/docs/user-guides/edge-authentication-architecture-festival-wristbands/#using-the-api-key-to-authenticate","title":"Using the API key to authenticate","text":"<p>Authenticate at the edge:</p> <pre><code>WRISTBAND_TOKEN=$(curl -H 'Authorization: APIKEY ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx' http://edge.127.0.0.1.nip.io:9000/auth -is | tr -d '\\r' | sed -En 's/^x-wristband-token: (.*)/\\1/p')\n</code></pre> <p>Consume the API:</p> <pre><code>curl -H \"Authorization: Bearer $WRISTBAND_TOKEN\" http://talker-api.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 200 OK\n</code></pre> <p>Try to consume the API with authentication token that is only accepted in the edge:</p> <pre><code>curl -H \"Authorization: APIKEY ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx\" http://talker-api.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 401 Unauthorized\n# www-authenticate: Bearer realm=\"edge-authenticated\"\n# x-ext-auth-reason: credential not found\n</code></pre> <p>(Optional) Inspect the wristband token and verify that it only contains restricted info to authenticate and authorize with internal apps.</p> <pre><code>jwt decode $WRISTBAND_TOKEN\n# [...]\n#\n# Token claims\n# ------------\n# {\n#   \"exp\": 1638452051,\n#   \"iat\": 1638451751,\n#   \"iss\": \"http://authorino-authorino-oidc.authorino.svc.cluster.local:8083/edge/edge-auth/wristband\",\n#   \"sub\": \"02cb51ea0e1c9f3c0960197a2518c8eb4f47e1b9222a968ffc8d4c8e783e4d19\",\n#   \"username\": \"alice\"\n# }\n</code></pre>"},{"location":"authorino/docs/user-guides/edge-authentication-architecture-festival-wristbands/#authenticating-with-the-keycloak-server","title":"Authenticating with the Keycloak server","text":"<p>Obtain an access token with the Keycloak server for Jane:</p> <p>The <code>AuthConfig</code> deployed in the previous step is suitable for validating access tokens requested inside the cluster. This is because Keycloak's <code>iss</code> claim added to the JWTs matches always the host used to request the token and Authorino will later try to match this host to the host that provides the OpenID Connect configuration.</p> <p>Obtain an access token from within the cluster for the user Jane, whose e-mail has been verified:</p> <pre><code>ACCESS_TOKEN=$(kubectl -n edge run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant/protocol/openid-connect/token -s -d 'grant_type=password' -d 'client_id=demo' -d 'username=jane' -d 'password=p' -d 'scope=openid' | jq -r .access_token)\n</code></pre> <p>If your Keycloak server is reachable from outside the cluster, feel free to obtain the token directly. Make sure the host name set in the OIDC issuer endpoint in the <code>AuthConfig</code> matches the one used to obtain the token and is as well reachable from within the cluster.</p> <p>(Optional) Inspect the access token issue by Keycloak and verify and how it contains more details about the identity than required to authenticate and authorize with internal apps.</p> <pre><code>jwt decode $ACCESS_TOKEN\n# [...]\n#\n# Token claims\n# ------------\n# { [...]\n#   \"email\": \"jane@kuadrant.io\",\n#   \"email_verified\": true,\n#   \"exp\": 1638452220,\n#   \"family_name\": \"Smith\",\n#   \"given_name\": \"Jane\",\n#   \"iat\": 1638451920,\n#   \"iss\": \"http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant\",\n#   \"jti\": \"699f6e49-dea4-4f29-ae2a-929a3a18c94b\",\n#   \"name\": \"Jane Smith\",\n#   \"preferred_username\": \"jane\",\n#   \"realm_access\": {\n#     \"roles\": [\n#       \"offline_access\",\n#       \"member\",\n#       \"admin\",\n#       \"uma_authorization\"\n#     ]\n#   },\n# [...]\n</code></pre> <p>As Jane, obtain a limited wristband token at the edge:</p> <pre><code>WRISTBAND_TOKEN=$(curl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://edge.127.0.0.1.nip.io:9000/auth -is | tr -d '\\r' | sed -En 's/^x-wristband-token: (.*)/\\1/p')\n</code></pre> <p>Consume the API:</p> <pre><code>curl -H \"Authorization: Bearer $WRISTBAND_TOKEN\" http://talker-api.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 200 OK\n</code></pre>"},{"location":"authorino/docs/user-guides/edge-authentication-architecture-festival-wristbands/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete namespace edge\nkubectl delete namespace internal\nkubectl delete namespace authorino\nkubectl delete namespace keycloak\n</code></pre> <p>To uninstall the Authorino and Authorino Operator manifests, run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <ol> <li> <p>In contrast to a dedicated sidecar of the protected service and other architectures. Check out Architecture &gt; Topologies for all options.\u00a0\u21a9</p> </li> <li> <p><code>cluster-wide</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> <li> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. If you are running your ingress gateway in Kubernetes and wants to avoid setting up and configuring your proxy manually, check out Kuadrant.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/envoy-jwt-authn-and-authorino/","title":"User guide: Mixing Envoy built-in filter for auth and Authorino","text":"<p>Have JWT validation handled by Envoy beforehand and the JWT payload injected into the request to Authorino, to be used in custom authorization policies defined in a AuthConfig.</p> <p>In this user guide, we will set up Envoy and Authorino to protect a service called the Talker API service, with JWT authentication handled in Envoy and a more complex authorization policy enforced in Authorino.</p> <p>The policy defines a geo-fence by which only requests originated in Great Britain (country code: GB) will be accepted, unless the user is bound to a role called 'admin' in the auth server, in which case no geofence is enforced.</p> <p>All requests to the Talker API will be authenticated in Envoy. However, requests to <code>/global</code> will not trigger the external authorization.</p> Authorino capabilities featured in this guide: <ul> <li>Identity verification &amp; authentication \u2192 Plain</li> <li>External auth metadata \u2192 HTTP GET/GET-by-POST</li> <li>Authorization \u2192 Pattern-matching authorization</li> <li>Dynamic response \u2192 Custom denial status</li> </ul> <p>For further details about Authorino features in general, check the docs.</p> <p></p>"},{"location":"authorino/docs/user-guides/envoy-jwt-authn-and-authorino/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC)</li> <li>Identity Provider (IdP) that implements OpenID Connect authentication and OpenID Connect Discovery (e.g. Keycloak)</li> <li>jq, to extract parts of JSON responses</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p>Deploy the identity provider and authentication server by executing the command below. For the examples in this guide, we are going to use a Keycloak server preloaded with all required realm settings.</p> <pre><code>kubectl create namespace keycloak\nkubectl -n keycloak apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/keycloak/keycloak-deploy.yaml\n</code></pre> <p></p> <p>The next steps walk you through installing Authorino, deploying and configuring a sample service called Talker API to be protected by the authorization service.</p> Using Kuadrant <p>If you are a user of Kuadrant and already have your workload cluster configured and sample service application deployed, as well as your Gateway API network resources applied to route traffic to your service, skip straight to step \u277b.</p> <p>At step \u277b, instead of creating an <code>AuthConfig</code> custom resource, create a Kuadrant <code>AuthPolicy</code> one. The schema of the AuthConfig's <code>spec</code> matches the one of the AuthPolicy's, except <code>spec.host</code>, which is not available in the Kuadrant AuthPolicy. Host names in a Kuadrant AuthPolicy are inferred automatically from the Kubernetes network object referred in <code>spec.targetRef</code> and route selectors declared in the policy.</p> <p>For more about using Kuadrant to enforce authorization, check out Kuadrant auth.</p> <p></p>"},{"location":"authorino/docs/user-guides/envoy-jwt-authn-and-authorino/#install-the-authorino-operator-cluster-admin-required","title":"\u2776 Install the Authorino Operator (cluster admin required)","text":"<p>The following command will install the Authorino Operator in the Kubernetes cluster. The operator manages instances of the Authorino authorization service.</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/envoy-jwt-authn-and-authorino/#deploy-authorino","title":"\u2777 Deploy Authorino","text":"<p>The following command will request an instance of Authorino as a separate service<sup>1</sup> that watches for <code>AuthConfig</code> resources in the <code>default</code> namespace<sup>2</sup>, with TLS disabled<sup>3</sup>.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/envoy-jwt-authn-and-authorino/#deploy-the-talker-api","title":"\u2778 Deploy the Talker API","text":"<p>The Talker API is a simple HTTP service that echoes back in the response whatever it gets in the request. We will use it in this guide as the sample service to be protected by Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/docs/user-guides/envoy-jwt-authn-and-authorino/#setup-envoy","title":"\u2779 Setup Envoy","text":"<p>The following command deploys the Envoy proxy and configuration to wire up the Talker API behind the reverse-proxy, with external authorization enabled with the Authorino instance.<sup>4</sup></p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  labels:\n    app: authorino\n  name: envoy\ndata:\n  envoy.yaml: |\n    static_resources:\n      clusters:\n\n      - name: talker-api\n        connect_timeout: 0.25s\n        type: strict_dns\n        lb_policy: round_robin\n        load_assignment:\n          cluster_name: talker-api\n          endpoints:\n          - lb_endpoints:\n            - endpoint:\n                address:\n                  socket_address:\n                    address: talker-api\n                    port_value: 3000\n      - name: keycloak\n        connect_timeout: 0.25s\n        type: logical_dns\n        lb_policy: round_robin\n        load_assignment:\n          cluster_name: keycloak\n          endpoints:\n          - lb_endpoints:\n            - endpoint:\n                address:\n                  socket_address:\n                    address: keycloak.keycloak.svc.cluster.local\n                    port_value: 8080\n      - name: authorino\n        connect_timeout: 0.25s\n        type: strict_dns\n        lb_policy: round_robin\n        http2_protocol_options: {}\n        load_assignment:\n          cluster_name: authorino\n          endpoints:\n          - lb_endpoints:\n            - endpoint:\n                address:\n                  socket_address:\n                    address: authorino-authorino-authorization\n                    port_value: 50051\n      listeners:\n      - address:\n          socket_address:\n            address: 0.0.0.0\n            port_value: 8000\n        filter_chains:\n        - filters:\n          - name: envoy.http_connection_manager\n            typed_config:\n              \"@type\": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager\n              stat_prefix: local\n              route_config:\n                name: local_route\n                virtual_hosts:\n                - name: local_service\n                  domains: ['*']\n                  routes:\n                  - match: { path_separated_prefix: /global }\n                    route: { cluster: talker-api }\n                    typed_per_filter_config:\n                      envoy.filters.http.ext_authz:\n                        \"@type\": type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthzPerRoute\n                        disabled: true\n                  - match: { prefix: / }\n                    route: { cluster: talker-api }\n              http_filters:\n              - name: envoy.filters.http.jwt_authn\n                typed_config:\n                  \"@type\": type.googleapis.com/envoy.extensions.filters.http.jwt_authn.v3.JwtAuthentication\n                  providers:\n                    keycloak:\n                      issuer: http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant\n                      remote_jwks:\n                        http_uri:\n                          uri: http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant/protocol/openid-connect/certs\n                          cluster: keycloak\n                          timeout: 5s\n                        cache_duration:\n                          seconds: 300\n                      payload_in_metadata: verified_jwt\n                  rules:\n                  - match: { prefix: / }\n                    requires: { provider_name: keycloak }\n              - name: envoy.filters.http.ext_authz\n                typed_config:\n                  \"@type\": type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthz\n                  transport_api_version: V3\n                  failure_mode_allow: false\n                  metadata_context_namespaces:\n                  - envoy.filters.http.jwt_authn\n                  grpc_service:\n                    envoy_grpc:\n                      cluster_name: authorino\n                    timeout: 1s\n              - name: envoy.filters.http.router\n                typed_config:\n                  \"@type\": type.googleapis.com/envoy.extensions.filters.http.router.v3.Router\n              use_remote_address: true\n    admin:\n      access_log_path: \"/tmp/admin_access.log\"\n      address:\n        socket_address:\n          address: 0.0.0.0\n          port_value: 8001\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  labels:\n    app: authorino\n    svc: envoy\n  name: envoy\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: authorino\n      svc: envoy\n  template:\n    metadata:\n      labels:\n        app: authorino\n        svc: envoy\n    spec:\n      containers:\n      - args:\n        - --config-path /usr/local/etc/envoy/envoy.yaml\n        - --service-cluster front-proxy\n        - --log-level info\n        - --component-log-level filter:trace,http:debug,router:debug\n        command:\n        - /usr/local/bin/envoy\n        image: envoyproxy/envoy:v1.22-latest\n        name: envoy\n        ports:\n        - containerPort: 8000\n          name: web\n        - containerPort: 8001\n          name: admin\n        volumeMounts:\n        - mountPath: /usr/local/etc/envoy\n          name: config\n          readOnly: true\n      volumes:\n      - configMap:\n          items:\n          - key: envoy.yaml\n            path: envoy.yaml\n          name: envoy\n        name: config\n---\napiVersion: v1\nkind: Service\nmetadata:\n  labels:\n    app: authorino\n  name: envoy\nspec:\n  ports:\n  - name: web\n    port: 8000\n    protocol: TCP\n  selector:\n    app: authorino\n    svc: envoy\n---\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: ingress-wildcard-host\nspec:\n  rules:\n  - host: talker-api.127.0.0.1.nip.io\n    http:\n      paths:\n      - backend:\n          service:\n            name: envoy\n            port:\n              number: 8000\n        path: /\n        pathType: Prefix\nEOF\n</code></pre> <p>The command above creates an <code>Ingress</code> with host name <code>talker-api.127.0.0.1.nip.io</code>. If you are using a local Kubernetes cluster created with Kind, forward requests from your local port 8000 to the Envoy service running inside the cluster:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre>"},{"location":"authorino/docs/user-guides/envoy-jwt-authn-and-authorino/#deploy-the-ip-location-service","title":"\u277a Deploy the IP Location service","text":"<p>The IP Location service is a simple service that resolves an IPv4 address into geo location info.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/Kuadrant/authorino-examples/main/ip-location/ip-location-deploy.yaml\n</code></pre>"},{"location":"authorino/docs/user-guides/envoy-jwt-authn-and-authorino/#create-an-authconfig","title":"\u277b Create an <code>AuthConfig</code>","text":"<p>Create an Authorino <code>AuthConfig</code> custom resource declaring the auth rules to be enforced:</p> Kuadrant users \u2013         Remember to create an <code>AuthPolicy</code> instead of an AuthConfig.         For more, see Kuadrant auth.        <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n\n  - talker-api.127.0.0.1.nip.io\n  authentication:\n    \"jwt\":\n      plain:\n        selector: context.metadata_context.filter_metadata.envoy\\.filters\\.http\\.jwt_authn|verified_jwt\n  metadata:\n    \"geoinfo\":\n      http:\n        url: 'http://ip-location.default.svc.cluster.local:3000/{context.request.http.headers.x-forwarded-for.@extract:{\"sep\":\",\"}}'\n        headers:\n          \"Accept\":\n            value: application/json\n      cache:\n        key:\n          selector: \"context.request.http.headers.x-forwarded-for.@extract:{\\\"sep\\\":\\\",\\\"}\"\n  authorization:\n    \"geofence\":\n      when:\n      - selector: auth.identity.realm_access.roles\n        operator: excl\n        value: admin\n      patternMatching:\n        patterns:\n        - selector: auth.metadata.geoinfo.country_iso_code\n          operator: eq\n          value: \"GB\"\n  response:\n    unauthorized:\n      message:\n        selector: \"The requested resource is not available in {auth.metadata.geoinfo.country_name}\"\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/envoy-jwt-authn-and-authorino/#obtain-a-token-and-consume-the-api","title":"\u277c Obtain a token and consume the API","text":""},{"location":"authorino/docs/user-guides/envoy-jwt-authn-and-authorino/#obtain-an-access-token-and-consume-the-api-as-john-member","title":"Obtain an access token and consume the API as John (member)","text":"<p>Obtain an access token with the Keycloak server for John:</p> <p>The <code>AuthConfig</code> deployed in the previous step is suitable for validating access tokens requested inside the cluster. This is because Keycloak's <code>iss</code> claim added to the JWTs matches always the host used to request the token and Authorino will later try to match this host to the host that provides the OpenID Connect configuration.</p> <p>Obtain an access token from within the cluster for the user John, a non-admin (member) user:</p> <pre><code>ACCESS_TOKEN=$(kubectl run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant/protocol/openid-connect/token -s -d 'grant_type=password' -d 'client_id=demo' -d 'username=john' -d 'password=p' -d 'scope=openid' | jq -r .access_token)\n</code></pre> <p>If your Keycloak server is reachable from outside the cluster, feel free to obtain the token directly. Make sure the host name set in the OIDC issuer endpoint in the <code>AuthConfig</code> matches the one used to obtain the token and is as well reachable from within the cluster.</p> <p>As John, consume the API inside the area where the policy applies:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" \\\n     -H 'X-Forwarded-For: 79.123.45.67' \\\n     http://talker-api.127.0.0.1.nip.io:8000 -i\n# HTTP/1.1 200 OK\n</code></pre> <p>As John, consume the API outside the area where the policy applies:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" \\\n     -H 'X-Forwarded-For: 109.69.200.56' \\\n     http://talker-api.127.0.0.1.nip.io:8000 -i\n# HTTP/1.1 403 Forbidden\n# x-ext-auth-reason: The requested resource is not available in Italy\n</code></pre> <p>As John, consume a path of the API that will cause Envoy to skip external authorization:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" \\\n     -H 'X-Forwarded-For: 109.69.200.56' \\\n     http://talker-api.127.0.0.1.nip.io:8000/global -i\n# HTTP/1.1 200 OK\n</code></pre>"},{"location":"authorino/docs/user-guides/envoy-jwt-authn-and-authorino/#obtain-an-access-token-and-consume-the-api-as-jane-admin","title":"Obtain an access token and consume the API as Jane (admin)","text":"<p>Obtain an access token with the Keycloak server for Jane, an admin user:</p> <pre><code>ACCESS_TOKEN=$(kubectl run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant/protocol/openid-connect/token -s -d 'grant_type=password' -d 'client_id=demo' -d 'username=jane' -d 'password=p' -d 'scope=openid' | jq -r .access_token)\n</code></pre> <p>As Jane, consume the API inside the area where the policy applies:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" \\\n     -H 'X-Forwarded-For: 79.123.45.67' \\\n     http://talker-api.127.0.0.1.nip.io:8000 -i\n# HTTP/1.1 200 OK\n</code></pre> <p>As Jane, consume the API outside the area where the policy applies:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" \\\n     -H 'X-Forwarded-For: 109.69.200.56' \\\n     http://talker-api.127.0.0.1.nip.io:8000 -i\n# HTTP/1.1 200 OK\n</code></pre> <p>As Jane, consume a path of the API that will cause Envoy to skip external authorization:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" \\\n     -H 'X-Forwarded-For: 109.69.200.56' \\\n     http://talker-api.127.0.0.1.nip.io:8000/global -i\n# HTTP/1.1 200 OK\n</code></pre>"},{"location":"authorino/docs/user-guides/envoy-jwt-authn-and-authorino/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete authconfig/talker-api-protection\nkubectl delete ingress/ingress-wildcard-host\nkubectl delete service/envoy\nkubectl delete deployment/envoy\nkubectl delete configmap/envoy\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\nkubectl delete authorino/authorino\nkubectl delete namespace keycloak\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <ol> <li> <p>In contrast to a dedicated sidecar of the protected service and other architectures. Check out Architecture &gt; Topologies for all options.\u00a0\u21a9</p> </li> <li> <p><code>namespaced</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> <li> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. If you are running your ingress gateway in Kubernetes and wants to avoid setting up and configuring your proxy manually, check out Kuadrant.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/external-metadata/","title":"User guide: Fetching auth metadata from external sources","text":"<p>Get online data from remote HTTP services to enhance authorization rules.</p> Authorino capabilities featured in this guide: <ul> <li>External auth metadata \u2192 HTTP GET/GET-by-POST</li> <li>Identity verification &amp; authentication \u2192 API key</li> <li>Authorization \u2192 Open Policy Agent (OPA) Rego policies</li> </ul> <p>You can configure Authorino to fetch additional metadata from external sources in request-time, by sending either GET or POST request to an HTTP service. The service is expected to return a JSON content which is appended to the Authorization JSON, thus becoming available for usage in other configs of the Auth Pipeline, such as in authorization policies or custom responses.</p> <p>URL, parameters and headers of the request to the external source of metadata can be configured, including with dynamic values. Authentication between Authorino and the service can be set as part of these configuration options, or based on shared authentication token stored in a Kubernetes <code>Secret</code>.</p> <p>Check out as well the user guides about Authentication with API keys and Open Policy Agent (OPA) Rego policies.</p> <p>For further details about Authorino features in general, check the docs.</p> <p></p>"},{"location":"authorino/docs/user-guides/external-metadata/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC)</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p></p> <p>The next steps walk you through installing Authorino, deploying and configuring a sample service called Talker API to be protected by the authorization service.</p> Using Kuadrant <p>If you are a user of Kuadrant and already have your workload cluster configured and sample service application deployed, as well as your Gateway API network resources applied to route traffic to your service, skip straight to step \u277a.</p> <p>At step \u277a, instead of creating an <code>AuthConfig</code> custom resource, create a Kuadrant <code>AuthPolicy</code> one. The schema of the AuthConfig's <code>spec</code> matches the one of the AuthPolicy's, except <code>spec.host</code>, which is not available in the Kuadrant AuthPolicy. Host names in a Kuadrant AuthPolicy are inferred automatically from the Kubernetes network object referred in <code>spec.targetRef</code> and route selectors declared in the policy.</p> <p>For more about using Kuadrant to enforce authorization, check out Kuadrant auth.</p> <p></p>"},{"location":"authorino/docs/user-guides/external-metadata/#install-the-authorino-operator-cluster-admin-required","title":"\u2776 Install the Authorino Operator (cluster admin required)","text":"<p>The following command will install the Authorino Operator in the Kubernetes cluster. The operator manages instances of the Authorino authorization service.</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/external-metadata/#deploy-authorino","title":"\u2777 Deploy Authorino","text":"<p>The following command will request an instance of Authorino as a separate service<sup>1</sup> that watches for <code>AuthConfig</code> resources in the <code>default</code> namespace<sup>2</sup>, with TLS disabled<sup>3</sup>.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/external-metadata/#deploy-the-talker-api","title":"\u2778 Deploy the Talker API","text":"<p>The Talker API is a simple HTTP service that echoes back in the response whatever it gets in the request. We will use it in this guide as the sample service to be protected by Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/docs/user-guides/external-metadata/#setup-envoy","title":"\u2779 Setup Envoy","text":"<p>The following bundle from the Authorino examples deploys the Envoy proxy and configuration to wire up the Talker API behind the reverse-proxy, with external authorization enabled with the Authorino instance.<sup>4</sup></p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The command above creates an <code>Ingress</code> with host name <code>talker-api.127.0.0.1.nip.io</code>. If you are using a local Kubernetes cluster created with Kind, forward requests from your local port 8000 to the Envoy service running inside the cluster:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre>"},{"location":"authorino/docs/user-guides/external-metadata/#create-an-authconfig","title":"\u277a Create an <code>AuthConfig</code>","text":"<p>Create an Authorino <code>AuthConfig</code> custom resource declaring the auth rules to be enforced.</p> <p>In this example, we will implement a geofence policy for the API, using OPA and metadata fetching from an external service that returns geolocalization JSON data for a given IP address. The policy establishes that only <code>GET</code> requests are allowed and the path of the request should be in the form <code>/{country-code}/*</code>, where <code>{country-code}</code> is the 2-character code of the country where the client is identified as being physically present.</p> <p>The implementation relies on the <code>X-Forwarded-For</code> HTTP header to read the client's IP address.</p> Kuadrant users \u2013         Remember to create an <code>AuthPolicy</code> instead of an AuthConfig.         For more, see Kuadrant auth.        <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n\n  - talker-api.127.0.0.1.nip.io\n  authentication:\n    \"friends\":\n      apiKey:\n        selector:\n          matchLabels:\n            group: friends\n      credentials:\n        authorizationHeader:\n          prefix: APIKEY\n  metadata:\n    \"geo\":\n      http:\n        urlExpression: |\n          'http://ip-api.com/json/' + request.headers['x-forwarded-for'].split(',')[0] + '?fields=countryCode'\n        headers:\n          \"Accept\":\n            expression: '\"application/json\"'\n  authorization:\n    \"geofence\":\n      opa:\n        rego: |\n          import input.context.request.http\n\n          allow {\n            http.method = \"GET\"\n            split(http.path, \"/\") = [_, requested_country, _]\n            lower(requested_country) == lower(object.get(input.auth.metadata.geo, \"countryCode\", \"\"))\n          }\nEOF\n</code></pre> <p>Check out the docs about using Common Expression Language (CEL) for reading from the Authorization JSON.</p>"},{"location":"authorino/docs/user-guides/external-metadata/#create-an-api-key","title":"\u277b Create an API key","text":"<pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: api-key-1\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    group: friends\nstringData:\n  api_key: ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx\ntype: Opaque\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/external-metadata/#consume-the-api","title":"\u277c Consume the API","text":"<p>From an IP address assigned to the United Kingdom of Great Britain and Northern Ireland (country code GB):</p> <pre><code>curl -H 'Authorization: APIKEY ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx' \\\n     -H 'X-Forwarded-For: 79.123.45.67' \\\n     http://talker-api.127.0.0.1.nip.io:8000/gb/hello -i\n# HTTP/1.1 200 OK\n</code></pre> <pre><code>curl -H 'Authorization: APIKEY ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx' \\\n     -H 'X-Forwarded-For: 79.123.45.67' \\\n     http://talker-api.127.0.0.1.nip.io:8000/it/hello -i\n# HTTP/1.1 403 Forbidden\n</code></pre> <p>From an IP address assigned to Italy (country code IT):</p> <pre><code>curl -H 'Authorization: APIKEY ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx' \\\n     -H 'X-Forwarded-For: 109.112.34.56' \\\n     http://talker-api.127.0.0.1.nip.io:8000/gb/hello -i\n# HTTP/1.1 403 Forbidden\n</code></pre> <pre><code>curl -H 'Authorization: APIKEY ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx' \\\n     -H 'X-Forwarded-For: 109.112.34.56' \\\n     http://talker-api.127.0.0.1.nip.io:8000/it/hello -i\n# HTTP/1.1 200 OK\n</code></pre>"},{"location":"authorino/docs/user-guides/external-metadata/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete secret/api-key-1\nkubectl delete authconfig/talker-api-protection\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\nkubectl delete authorino/authorino\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <ol> <li> <p>In contrast to a dedicated sidecar of the protected service and other architectures. Check out Architecture &gt; Topologies for all options.\u00a0\u21a9</p> </li> <li> <p><code>namespaced</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> <li> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. If you are running your ingress gateway in Kubernetes and wants to avoid setting up and configuring your proxy manually, check out Kuadrant.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/hello-world/","title":"User guide: Hello World","text":""},{"location":"authorino/docs/user-guides/hello-world/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC)</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p>The next steps walk you through installing Authorino, deploying and configuring a sample service called Talker API to be protected by the authorization service.</p> Using Kuadrant <p>If you are a user of Kuadrant, you can skip step \u2778. You may already have Authorino installed and running as well. In this case, skip also step \u277a. If you even have your workload cluster configured, with sample service application deployed, as well as your Gateway API network resources applied to route traffic to your service, go straight to step \u277c.</p> <p>At step \u277c, instead of creating an <code>AuthConfig</code> custom resource, create a Kuadrant <code>AuthPolicy</code> one. The schema of the AuthConfig's <code>spec</code> matches the one of the AuthPolicy's, except <code>spec.host</code>, which is not available in the Kuadrant AuthPolicy. Host names in a Kuadrant AuthPolicy are inferred automatically from the Kubernetes network object referred in <code>spec.targetRef</code> and route selectors declared in the policy.</p> <p>For more about using Kuadrant to enforce authorization, check out Kuadrant auth.</p>"},{"location":"authorino/docs/user-guides/hello-world/#create-the-namespace","title":"\u2776 Create the namespace","text":"<pre><code>kubectl create namespace hello-world\n# namespace/hello-world created\n</code></pre>"},{"location":"authorino/docs/user-guides/hello-world/#deploy-the-talker-api","title":"\u2777 Deploy the Talker API","text":"<p>The Talker API is a simple HTTP service that echoes back in the response whatever it gets in the request. We will use it in this guide as the sample service to be protected by Authorino.</p> <pre><code>kubectl -n hello-world apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n# deployment.apps/talker-api created\n# service/talker-api created\n</code></pre>"},{"location":"authorino/docs/user-guides/hello-world/#setup-envoy","title":"\u2778 Setup Envoy","text":"<p>The following bundle from the Authorino examples deploys the Envoy proxy and configuration to wire up the Talker API behind the reverse-proxy, with external authorization enabled with the Authorino instance.<sup>1</sup></p> <pre><code>kubectl -n hello-world apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/hello-world/envoy-deploy.yaml\n# configmap/envoy created\n# deployment.apps/envoy created\n# service/envoy created\n</code></pre> <p>The command above creates an <code>Ingress</code> with host name <code>talker-api.127.0.0.1.nip.io</code>. If you are using a local Kubernetes cluster created with Kind, forward requests from your local port 8000 to the Envoy service running inside the cluster:</p> <pre><code>kubectl -n hello-world port-forward deployment/envoy 8000:8000 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre>"},{"location":"authorino/docs/user-guides/hello-world/#consume-the-api-unprotected","title":"\u2779 Consume the API (unprotected)","text":"<pre><code>curl http://talker-api.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 200 OK\n</code></pre>"},{"location":"authorino/docs/user-guides/hello-world/#protect-the-api","title":"\u277a Protect the API","text":""},{"location":"authorino/docs/user-guides/hello-world/#install-the-authorino-operator","title":"Install the Authorino Operator","text":"<pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/hello-world/#deploy-authorino","title":"Deploy Authorino","text":"<p>The following command will request an instance of Authorino as a separate service<sup>2</sup> that watches for <code>AuthConfig</code> resources in the <code>hello-world</code> namespace<sup>3</sup>, with TLS disabled<sup>4</sup>.</p> <pre><code>kubectl -n hello-world apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/hello-world/authorino.yaml\n# authorino.operator.authorino.kuadrant.io/authorino created\n</code></pre>"},{"location":"authorino/docs/user-guides/hello-world/#consume-the-api-behind-envoy-and-authorino","title":"\u277b Consume the API behind Envoy and Authorino","text":"<pre><code>curl http://talker-api.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 404 Not Found\n# x-ext-auth-reason: Service not found\n</code></pre> <p>Authorino does not know about the <code>talker-api.127.0.0.1.nip.io</code> host, hence the <code>404 Not Found</code>. Let's teach Authorino about this host by applying an <code>AuthConfig</code>.</p>"},{"location":"authorino/docs/user-guides/hello-world/#apply-the-authconfig","title":"\u277c Apply the <code>AuthConfig</code>","text":"<p>Create an Authorino <code>AuthConfig</code> custom resource declaring the auth rules to be enforced:</p> Kuadrant users \u2013         Remember to create an <code>AuthPolicy</code> instead of an AuthConfig.         For more, see Kuadrant auth.        <pre><code>kubectl -n hello-world apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/hello-world/authconfig.yaml\n# authconfig.authorino.kuadrant.io/talker-api-protection created\n</code></pre>"},{"location":"authorino/docs/user-guides/hello-world/#consume-the-api-without-credentials","title":"\u277d Consume the API without credentials","text":"<pre><code>curl http://talker-api.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 401 Unauthorized\n# www-authenticate: APIKEY realm=\"api-clients\"\n# x-ext-auth-reason: credential not found\n</code></pre>"},{"location":"authorino/docs/user-guides/hello-world/#grant-access-to-the-api-with-a-tailor-made-security-scheme","title":"Grant access to the API with a tailor-made security scheme","text":"<p>Check out other user guides for several use-cases of authentication and authorization, and the instructions to implement them using Authorino.</p> <p>A few examples of available ser guides:</p> <ul> <li>Authentication with API keys</li> <li>Authentication with JWTs and OpenID Connect Discovery</li> <li>Authentication with Kubernetes tokens (TokenReview API)</li> <li>Authorization with Open Policy Agent (OPA) Rego policies</li> <li>Authorization with simple JSON pattern-matching rules (e.g. JWT claims)</li> <li>Authorization with Kubernetes RBAC (SubjectAccessReview API)</li> <li>Fetching auth metadata from external sources</li> <li>Token normalization</li> </ul>"},{"location":"authorino/docs/user-guides/hello-world/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the namespaces created in step 1 and 5:</p> <pre><code>kubectl delete namespace hello-world\nkubectl delete namespace authorino-operator\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <ol> <li> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. If you are running your ingress gateway in Kubernetes and wants to avoid setting up and configuring your proxy manually, check out Kuadrant.\u00a0\u21a9</p> </li> <li> <p>In contrast to a dedicated sidecar of the protected service and other architectures. Check out Architecture &gt; Topologies for all options.\u00a0\u21a9</p> </li> <li> <p><code>namespaced</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/host-override/","title":"Host override via context extension","text":"<p>By default, Authorino uses the host information of the HTTP request (<code>Attributes.Http.Host</code>) to lookup for an indexed AuthConfig to be enforced<sup>1</sup>. The host info be overridden by supplying a <code>host</code> entry as a (per-route) context extension (<code>Attributes.ContextExtensions</code>), which takes precedence whenever present.</p> <p>Overriding the host attribute of the HTTP request can be useful to support use cases such as of path prefix-based lookup and wildcard subdomains lookup.</p> \u26a0\ufe0f Important:         This feature may not be available to users of Authorino via Kuadrant.        <p></p> <p>In this guide:</p> <ul> <li>Example of host override for path prefix-based lookup</li> <li>Example of host override for wildcard subdomain lookup</li> </ul>"},{"location":"authorino/docs/user-guides/host-override/#example-of-host-override-for-path-prefix-based-lookup","title":"Example of host override for path prefix-based lookup","text":"<p>In this use case, 2 different APIs (i.e. Dogs API and Cats API) are served under the same base domain, and differentiated by the path prefix:</p> <ul> <li><code>pets.com/dogs</code> \u2192  Dogs API</li> <li><code>pets.com/cats</code> \u2192  Cats API</li> </ul> <p>Edit the Envoy config to extend the external authorization settings at the level of the routes, with the <code>host</code> value that will be favored by Authorino before the actual host attribute of the HTTP request:</p> <pre><code>virtual_hosts:\n\n- name: pets-api\n  domains: ['pets.com']\n  routes:\n  - match:\n      prefix: /dogs\n    route:\n      cluster: dogs-api\n    typed_per_filter_config:\n      envoy.filters.http.ext_authz:\n        \\\"@type\\\": type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthzPerRoute\n        check_settings:\n          context_extensions:\n            host: dogs.pets.com\n  - match:\n      prefix: /cats\n    route:\n      cluster: cats-api\n    typed_per_filter_config:\n      envoy.filters.http.ext_authz:\n        \\\"@type\\\": type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthzPerRoute\n        check_settings:\n          context_extensions:\n            host: cats.pets.com\n</code></pre> <p>Create the AuthConfig for the Pets API:</p> <pre><code>apiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: dogs-api-protection\nspec:\n  hosts:\n\n  - dogs.pets.com\n\n  authentication: [...]\n</code></pre> <p>Create the AuthConfig for the Cats API:</p> <pre><code>apiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: cats-api-protection\nspec:\n  hosts:\n\n  - cats.pets.com\n\n  authentication: [...]\n</code></pre> <p>Notice that the host subdomains <code>dogs.pets.com</code> and <code>cats.pets.com</code> are not really requested by the API consumers. Rather, users send requests to <code>pets.com/dogs</code> and <code>pets.com/cats</code>. When routing those requests, Envoy makes sure to inject the corresponding context extensions that will induce the right lookup in Authorino.</p>"},{"location":"authorino/docs/user-guides/host-override/#example-of-host-override-for-wildcard-subdomain-lookup","title":"Example of host override for wildcard subdomain lookup","text":"<p>In this use case, a single Pets API serves requests for any subdomain that matches <code>*.pets.com</code>, e.g.:</p> <ul> <li><code>dogs.pets.com</code> \u2192  Pets API</li> <li><code>cats.pets.com</code> \u2192  Pets API</li> </ul> <p>Edit the Envoy config to extend the external authorization settings at the level of the virtual host, with the <code>host</code> value that will be favored by Authorino before the actual host attribute of the HTTP request:</p> <pre><code>virtual_hosts:\n\n- name: pets-api\n  domains: ['*.pets.com']\n  typed_per_filter_config:\n    envoy.filters.http.ext_authz:\n      \\\"@type\\\": type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthzPerRoute\n      check_settings:\n        context_extensions:\n          host: pets.com\n  routes:\n  - match:\n      prefix: /\n    route:\n      cluster: pets-api\n</code></pre> <p>The <code>host</code> context extension used above is any key that matches one of the hosts listed in the targeted AuthConfig.</p> <p>Create the AuthConfig for the Pets API:</p> <pre><code>apiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: pets-api-protection\nspec:\n  hosts:\n\n  - pets.com\n\n  authentication: [...]\n</code></pre> <p>Notice that requests to <code>dogs.pets.com</code> and to <code>cats.pets.com</code> are all routed by Envoy to the same API, with same external authorization configuration. in all the cases, Authorino will lookup for the indexed AuthConfig associated with <code>pets.com</code>. The same is valid for a request sent, e.g., to <code>birds.pets.com</code>.</p> <ol> <li> <p>For further details about Authorino lookup of AuthConfig, check out Host lookup.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/http-basic-authentication/","title":"User guide: HTTP \"Basic\" Authentication (RFC 7235)","text":"<p>Turn Authorino API key <code>Secret</code>s settings into HTTP basic auth.</p> Authorino capabilities featured in this guide: <ul> <li>Identity verification &amp; authentication \u2192 API key</li> <li>Authorization \u2192 Pattern-matching authorization</li> </ul> <p>HTTP \"Basic\" Authentication (RFC 7235) is not recommended if you can afford other more secure methods such as OpenID Connect. To support legacy nonetheless it is sometimes necessary to implement it.</p> <p>In Authorino, HTTP \"Basic\" Authentication can be modeled leveraging the API key authentication feature (stored as Kubernetes <code>Secret</code>s with an <code>api_key</code> entry and labeled to match selectors specified in <code>spec.identity.apiKey.selector</code> of the <code>AuthConfig</code>).</p> <p>Check out as well the user guide about Authentication with API keys.</p> <p>For further details about Authorino features in general, check the docs.</p> <p></p>"},{"location":"authorino/docs/user-guides/http-basic-authentication/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC)</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p></p> <p>The next steps walk you through installing Authorino, deploying and configuring a sample service called Talker API to be protected by the authorization service.</p> Using Kuadrant <p>If you are a user of Kuadrant and already have your workload cluster configured and sample service application deployed, as well as your Gateway API network resources applied to route traffic to your service, skip straight to step \u277a.</p> <p>At step \u277a, instead of creating an <code>AuthConfig</code> custom resource, create a Kuadrant <code>AuthPolicy</code> one. The schema of the AuthConfig's <code>spec</code> matches the one of the AuthPolicy's, except <code>spec.host</code>, which is not available in the Kuadrant AuthPolicy. Host names in a Kuadrant AuthPolicy are inferred automatically from the Kubernetes network object referred in <code>spec.targetRef</code> and route selectors declared in the policy.</p> <p>For more about using Kuadrant to enforce authorization, check out Kuadrant auth.</p> <p></p>"},{"location":"authorino/docs/user-guides/http-basic-authentication/#install-the-authorino-operator-cluster-admin-required","title":"\u2776 Install the Authorino Operator (cluster admin required)","text":"<p>The following command will install the Authorino Operator in the Kubernetes cluster. The operator manages instances of the Authorino authorization service.</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/http-basic-authentication/#deploy-authorino","title":"\u2777 Deploy Authorino","text":"<p>The following command will request an instance of Authorino as a separate service<sup>1</sup> that watches for <code>AuthConfig</code> resources in the <code>default</code> namespace<sup>2</sup>, with TLS disabled<sup>3</sup>.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/http-basic-authentication/#deploy-the-talker-api","title":"\u2778 Deploy the Talker API","text":"<p>The Talker API is a simple HTTP service that echoes back in the response whatever it gets in the request. We will use it in this guide as the sample service to be protected by Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/docs/user-guides/http-basic-authentication/#setup-envoy","title":"\u2779 Setup Envoy","text":"<p>The following bundle from the Authorino examples deploys the Envoy proxy and configuration to wire up the Talker API behind the reverse-proxy, with external authorization enabled with the Authorino instance.<sup>4</sup></p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The command above creates an <code>Ingress</code> with host name <code>talker-api.127.0.0.1.nip.io</code>. If you are using a local Kubernetes cluster created with Kind, forward requests from your local port 8000 to the Envoy service running inside the cluster:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre>"},{"location":"authorino/docs/user-guides/http-basic-authentication/#create-an-authconfig","title":"\u277a Create an <code>AuthConfig</code>","text":"<p>Create an Authorino <code>AuthConfig</code> custom resource declaring the auth rules to be enforced.</p> <p>The config uses API Key secrets to store base64-encoded <code>username:password</code> HTTP \"Basic\" authentication credentials. The config also specifies an Access Control List (ACL) by which only user <code>john</code> is authorized to consume the <code>/bye</code> endpoint of the API.</p> Kuadrant users \u2013         Remember to create an <code>AuthPolicy</code> instead of an AuthConfig.         For more, see Kuadrant auth.        <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n\n  - talker-api.127.0.0.1.nip.io\n  authentication:\n    \"http-basic-auth\":\n      apiKey:\n        selector:\n          matchLabels:\n            group: users\n      credentials:\n        authorizationHeader:\n          prefix: Basic\n  authorization:\n    \"acl\":\n      when:\n      - predicate: request.path == '/bye'\n      patternMatching:\n        patterns:\n        - selector: context.request.http.headers.authorization.@extract:{\"pos\":1}|@base64:decode|@extract:{\"sep\":\":\"}\n          operator: eq\n          value: john\nEOF\n</code></pre> <p>Check out the docs about using Common Expression Language (CEL) for reading from the Authorization JSON. Check out as well the common feature Conditions about skipping parts of an <code>AuthConfig</code> in the auth pipeline based on context.</p>"},{"location":"authorino/docs/user-guides/http-basic-authentication/#create-user-credentials","title":"\u277b Create user credentials","text":"<p>To create credentials for HTTP \"Basic\" Authentication, store each <code>username:password</code>, base64-encoded, in the <code>api_key</code> value of the Kubernetes <code>Secret</code> resources. E.g.:</p> <pre><code>printf \"john:ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx\" | base64\n# am9objpuZHlCenJlVXpGNHpxRFFzcVNQTUhrUmhyaUVPdGNSeA==\n</code></pre> <p>Create credentials for user John:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: basic-auth-1\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    group: users\nstringData:\n  api_key: am9objpuZHlCenJlVXpGNHpxRFFzcVNQTUhrUmhyaUVPdGNSeA== # john:ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx\ntype: Opaque\nEOF\n</code></pre> <p>Create credentials for user Jane:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: basic-auth-2\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    group: users\nstringData:\n  api_key: amFuZTpkTnNScnNhcHkwbk5Dd210NTM3ZkhGcHl4MGNCc0xFcA== # jane:dNsRrsapy0nNCwmt537fHFpyx0cBsLEp\ntype: Opaque\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/http-basic-authentication/#consume-the-api","title":"\u277c Consume the API","text":"<p>As John (authorized in the ACL):</p> <pre><code>curl -u john:ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx http://talker-api.127.0.0.1.nip.io:8000/hello\n# HTTP/1.1 200 OK\n</code></pre> <pre><code>curl -u john:ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx http://talker-api.127.0.0.1.nip.io:8000/bye\n# HTTP/1.1 200 OK\n</code></pre> <p>As Jane (NOT authorized in the ACL):</p> <pre><code>curl -u jane:dNsRrsapy0nNCwmt537fHFpyx0cBsLEp http://talker-api.127.0.0.1.nip.io:8000/hello\n# HTTP/1.1 200 OK\n</code></pre> <pre><code>curl -u jane:dNsRrsapy0nNCwmt537fHFpyx0cBsLEp http://talker-api.127.0.0.1.nip.io:8000/bye -i\n# HTTP/1.1 403 Forbidden\n</code></pre> <p>With an invalid user/password:</p> <pre><code>curl -u unknown:invalid http://talker-api.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 401 Unauthorized\n# www-authenticate: Basic realm=\"http-basic-auth\"\n</code></pre>"},{"location":"authorino/docs/user-guides/http-basic-authentication/#revoke-access-to-the-api","title":"\u277d Revoke access to the API","text":"<pre><code>kubectl delete secret/basic-auth-1\n</code></pre>"},{"location":"authorino/docs/user-guides/http-basic-authentication/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete secret/basic-auth-1\nkubectl delete secret/basic-auth-2\nkubectl delete authconfig/talker-api-protection\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\nkubectl delete authorino/authorino\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <ol> <li> <p>In contrast to a dedicated sidecar of the protected service and other architectures. Check out Architecture &gt; Topologies for all options.\u00a0\u21a9</p> </li> <li> <p><code>namespaced</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> <li> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. If you are running your ingress gateway in Kubernetes and wants to avoid setting up and configuring your proxy manually, check out Kuadrant.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/injecting-data/","title":"User guide: Injecting data in the request","text":"<p>Inject HTTP headers with serialized JSON content.</p> Authorino capabilities featured in this guide: <ul> <li>Dynamic response \u2192 JSON injection</li> <li>Identity verification &amp; authentication \u2192 API key</li> </ul> <p>Inject serialized custom JSON objects as HTTP request headers. Values can be static or fetched from the Authorization JSON.</p> <p>Check out as well the user guide about Authentication with API keys.</p> <p>For further details about Authorino features in general, check the docs.</p> <p></p>"},{"location":"authorino/docs/user-guides/injecting-data/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC)</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p></p> <p>The next steps walk you through installing Authorino, deploying and configuring a sample service called Talker API to be protected by the authorization service.</p> Using Kuadrant <p>If you are a user of Kuadrant and already have your workload cluster configured and sample service application deployed, as well as your Gateway API network resources applied to route traffic to your service, skip straight to step \u277a.</p> <p>At step \u277a, instead of creating an <code>AuthConfig</code> custom resource, create a Kuadrant <code>AuthPolicy</code> one. The schema of the AuthConfig's <code>spec</code> matches the one of the AuthPolicy's, except <code>spec.host</code>, which is not available in the Kuadrant AuthPolicy. Host names in a Kuadrant AuthPolicy are inferred automatically from the Kubernetes network object referred in <code>spec.targetRef</code> and route selectors declared in the policy.</p> <p>For more about using Kuadrant to enforce authorization, check out Kuadrant auth.</p> <p></p>"},{"location":"authorino/docs/user-guides/injecting-data/#install-the-authorino-operator-cluster-admin-required","title":"\u2776 Install the Authorino Operator (cluster admin required)","text":"<p>The following command will install the Authorino Operator in the Kubernetes cluster. The operator manages instances of the Authorino authorization service.</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/injecting-data/#deploy-authorino","title":"\u2777 Deploy Authorino","text":"<p>The following command will request an instance of Authorino as a separate service<sup>1</sup> that watches for <code>AuthConfig</code> resources in the <code>default</code> namespace<sup>2</sup>, with TLS disabled<sup>3</sup>.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/injecting-data/#deploy-the-talker-api","title":"\u2778 Deploy the Talker API","text":"<p>The Talker API is a simple HTTP service that echoes back in the response whatever it gets in the request. We will use it in this guide as the sample service to be protected by Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/docs/user-guides/injecting-data/#setup-envoy","title":"\u2779 Setup Envoy","text":"<p>The following bundle from the Authorino examples deploys the Envoy proxy and configuration to wire up the Talker API behind the reverse-proxy, with external authorization enabled with the Authorino instance.<sup>4</sup></p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The command above creates an <code>Ingress</code> with host name <code>talker-api.127.0.0.1.nip.io</code>. If you are using a local Kubernetes cluster created with Kind, forward requests from your local port 8000 to the Envoy service running inside the cluster:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre>"},{"location":"authorino/docs/user-guides/injecting-data/#create-an-authconfig","title":"\u277a Create an <code>AuthConfig</code>","text":"<p>Create an Authorino <code>AuthConfig</code> custom resource declaring the auth rules to be enforced.</p> <p>The following defines a JSON object to be injected as an added HTTP header into the request, named after the response config <code>x-ext-auth-data</code>. The object includes 3 properties:</p> <ol> <li>a static value <code>authorized: true</code>;</li> <li>a dynamic value <code>request-time</code>, from Envoy-supplied contextual data present in the Authorization JSON; and</li> <li>a greeting message <code>geeting-message</code> that interpolates a dynamic value read from an annotation of the Kubernetes <code>Secret</code> resource that represents the API key used to authenticate into a static string.</li> </ol> Kuadrant users \u2013         Remember to create an <code>AuthPolicy</code> instead of an AuthConfig.         For more, see Kuadrant auth.        <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n\n  - talker-api.127.0.0.1.nip.io\n  authentication:\n    \"friends\":\n      apiKey:\n        selector:\n          matchLabels:\n            group: friends\n      credentials:\n        authorizationHeader:\n          prefix: APIKEY\n  response:\n    success:\n      headers:\n        \"x-ext-auth-data\":\n          json:\n            properties:\n              \"authorized\":\n                expression: \"true\"\n              \"request-time\":\n                expression: request.time.seconds\n              \"greeting-message\":\n                expression: |\n                  'Hello, ' + auth.identity.metadata.annotations['auth-data/name']\nEOF\n</code></pre> <p>Check out the docs about using Common Expression Language (CEL) for reading from the Authorization JSON.</p>"},{"location":"authorino/docs/user-guides/injecting-data/#create-an-api-key","title":"\u277b Create an API key","text":"<pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: api-key-1\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    group: friends\n  annotations:\n    auth-data/name: Rita\nstringData:\n  api_key: ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx\ntype: Opaque\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/injecting-data/#consume-the-api","title":"\u277c Consume the API","text":"<pre><code>curl -H 'Authorization: APIKEY ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx' http://talker-api.127.0.0.1.nip.io:8000/hello\n# {\n#   \"method\": \"GET\",\n#   \"path\": \"/hello\",\n#   \"query_string\": null,\n#   \"body\": \"\",\n#   \"headers\": {\n#     \u2026\n#     \"X-Ext-Auth-Data\": \"{\\\"authorized\\\":true,\\\"greeting-message\\\":\\\"Hello, Rita!\\\",\\\"request-time\\\":1637954644}\",\n#   },\n#   \u2026\n# }\n</code></pre>"},{"location":"authorino/docs/user-guides/injecting-data/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete secret/api-key-1\nkubectl delete authconfig/talker-api-protection\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\nkubectl delete authorino/authorino\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <ol> <li> <p>In contrast to a dedicated sidecar of the protected service and other architectures. Check out Architecture &gt; Topologies for all options.\u00a0\u21a9</p> </li> <li> <p><code>namespaced</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> <li> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. If you are running your ingress gateway in Kubernetes and wants to avoid setting up and configuring your proxy manually, check out Kuadrant.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/json-pattern-matching-authorization/","title":"User guide: Simple pattern-matching authorization policies","text":"<p>Write simple authorization rules based on JSON patterns matched against Authorino's Authorization JSON; check contextual information of the request, validate JWT claims, cross metadata fetched from external sources, etc.</p> Authorino capabilities featured in this guide: <ul> <li>Authorization \u2192 Pattern-matching authorization</li> <li>Identity verification &amp; authentication \u2192 JWT verification</li> </ul> <p>Authorino provides a built-in authorization module to check simple pattern-matching rules against the Authorization JSON. This is an alternative to OPA when all you want is to check for some simple rules, without complex logics, such as match the value of a JWT claim.</p> <p>Check out as well the user guide about OpenID Connect Discovery and authentication with JWTs.</p> <p>For further details about Authorino features in general, check the docs.</p> <p></p>"},{"location":"authorino/docs/user-guides/json-pattern-matching-authorization/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC)</li> <li>Identity Provider (IdP) that implements OpenID Connect authentication and OpenID Connect Discovery (e.g. Keycloak)</li> <li>jq, to extract parts of JSON responses</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p>Deploy the identity provider and authentication server by executing the command below. For the examples in this guide, we are going to use a Keycloak server preloaded with all required realm settings.</p> <pre><code>kubectl create namespace keycloak\nkubectl -n keycloak apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/keycloak/keycloak-deploy.yaml\n</code></pre> <p></p> <p>The next steps walk you through installing Authorino, deploying and configuring a sample service called Talker API to be protected by the authorization service.</p> Using Kuadrant <p>If you are a user of Kuadrant and already have your workload cluster configured and sample service application deployed, as well as your Gateway API network resources applied to route traffic to your service, skip straight to step \u277a.</p> <p>At step \u277a, instead of creating an <code>AuthConfig</code> custom resource, create a Kuadrant <code>AuthPolicy</code> one. The schema of the AuthConfig's <code>spec</code> matches the one of the AuthPolicy's, except <code>spec.host</code>, which is not available in the Kuadrant AuthPolicy. Host names in a Kuadrant AuthPolicy are inferred automatically from the Kubernetes network object referred in <code>spec.targetRef</code> and route selectors declared in the policy.</p> <p>For more about using Kuadrant to enforce authorization, check out Kuadrant auth.</p> <p></p>"},{"location":"authorino/docs/user-guides/json-pattern-matching-authorization/#install-the-authorino-operator-cluster-admin-required","title":"\u2776 Install the Authorino Operator (cluster admin required)","text":"<p>The following command will install the Authorino Operator in the Kubernetes cluster. The operator manages instances of the Authorino authorization service.</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/json-pattern-matching-authorization/#deploy-authorino","title":"\u2777 Deploy Authorino","text":"<p>The following command will request an instance of Authorino as a separate service<sup>1</sup> that watches for <code>AuthConfig</code> resources in the <code>default</code> namespace<sup>2</sup>, with TLS disabled<sup>3</sup>.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/json-pattern-matching-authorization/#deploy-the-talker-api","title":"\u2778 Deploy the Talker API","text":"<p>The Talker API is a simple HTTP service that echoes back in the response whatever it gets in the request. We will use it in this guide as the sample service to be protected by Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/docs/user-guides/json-pattern-matching-authorization/#setup-envoy","title":"\u2779 Setup Envoy","text":"<p>The following bundle from the Authorino examples deploys the Envoy proxy and configuration to wire up the Talker API behind the reverse-proxy, with external authorization enabled with the Authorino instance.<sup>4</sup></p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The command above creates an <code>Ingress</code> with host name <code>talker-api.127.0.0.1.nip.io</code>. If you are using a local Kubernetes cluster created with Kind, forward requests from your local port 8000 to the Envoy service running inside the cluster:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre>"},{"location":"authorino/docs/user-guides/json-pattern-matching-authorization/#create-an-authconfig","title":"\u277a Create an <code>AuthConfig</code>","text":"<p>Create an Authorino <code>AuthConfig</code> custom resource declaring the auth rules to be enforced.</p> <p>The <code>email-verified-only</code> authorization policy ensures that users consuming the API from a given network (IP range 192.168.1/24) must have their emails verified.</p> <p>The <code>email_verified</code> claim is a property of the identity added to the JWT by the OpenID Connect issuer.</p> <p>The implementation relies on the <code>X-Forwarded-For</code> HTTP header to read the client's IP address.</p> Kuadrant users \u2013         Remember to create an <code>AuthPolicy</code> instead of an AuthConfig.         For more, see Kuadrant auth.        <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n\n  - talker-api.127.0.0.1.nip.io\n  authentication:\n    \"keycloak-kuadrant-realm\":\n      jwt:\n        issuerUrl: http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant\n  authorization:\n    \"email-verified-only\":\n      when:\n      - predicate: |\n          request.headers['x-forwarded-for'].split(',')[0].matches(\"^192\\\\\\.168\\\\\\.1\\\\\\.\\\\\\d+$\")\n      patternMatching:\n        patterns:\n        - predicate: auth.identity.email_verified\nEOF\n</code></pre> <p>Check out the doc about using Common Expression Language (CEL) for reading from the Authorization JSON. Check out as well the common feature Conditions about skipping parts of an <code>AuthConfig</code> in the auth pipeline based on context.</p>"},{"location":"authorino/docs/user-guides/json-pattern-matching-authorization/#obtain-an-access-token-and-consume-the-api","title":"\u277b Obtain an access token and consume the API","text":""},{"location":"authorino/docs/user-guides/json-pattern-matching-authorization/#obtain-an-access-token-and-consume-the-api-as-jane-email-verified","title":"Obtain an access token and consume the API as Jane (email verified)","text":"<p>Obtain an access token with the Keycloak server for Jane:</p> <p>The <code>AuthConfig</code> deployed in the previous step is suitable for validating access tokens requested inside the cluster. This is because Keycloak's <code>iss</code> claim added to the JWTs matches always the host used to request the token and Authorino will later try to match this host to the host that provides the OpenID Connect configuration.</p> <p>Obtain an access token from within the cluster for the user Jane, whose e-mail has been verified:</p> <pre><code>ACCESS_TOKEN=$(kubectl run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant/protocol/openid-connect/token -s -d 'grant_type=password' -d 'client_id=demo' -d 'username=jane' -d 'password=p' -d 'scope=openid' | jq -r .access_token)\n</code></pre> <p>If your Keycloak server is reachable from outside the cluster, feel free to obtain the token directly. Make sure the host name set in the OIDC issuer endpoint in the <code>AuthConfig</code> matches the one used to obtain the token and is as well reachable from within the cluster.</p> <p>As Jane, consume the API outside the area where the policy applies:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" \\\n     -H 'X-Forwarded-For: 123.45.6.78' \\\n     http://talker-api.127.0.0.1.nip.io:8000/hello\n# HTTP/1.1 200 OK\n</code></pre> <p>As Jane, consume the API inside the area where the policy applies:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" \\\n     -H 'X-Forwarded-For: 192.168.1.10' \\\n     http://talker-api.127.0.0.1.nip.io:8000/hello\n# HTTP/1.1 200 OK\n</code></pre>"},{"location":"authorino/docs/user-guides/json-pattern-matching-authorization/#obtain-an-access-token-and-consume-the-api-as-peter-email-not-verified","title":"Obtain an access token and consume the API as Peter (email NOT verified)","text":"<p>Obtain an access token with the Keycloak server for Peter:</p> <pre><code>ACCESS_TOKEN=$(kubectl run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant/protocol/openid-connect/token -s -d 'grant_type=password' -d 'client_id=demo' -d 'username=peter' -d 'password=p' -d 'scope=openid' | jq -r .access_token)\n</code></pre> <p>As Peter, consume the API outside the area where the policy applies:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" \\\n     -H 'X-Forwarded-For: 123.45.6.78' \\\n     http://talker-api.127.0.0.1.nip.io:8000/hello\n# HTTP/1.1 200 OK\n</code></pre> <p>As Peter, consume the API inside the area where the policy applies:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" \\\n     -H 'X-Forwarded-For: 192.168.1.10' \\\n     http://talker-api.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 403 Forbidden\n# x-ext-auth-reason: Unauthorized\n</code></pre>"},{"location":"authorino/docs/user-guides/json-pattern-matching-authorization/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete authconfig/talker-api-protection\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\nkubectl delete namespace keycloak\nkubectl delete authorino/authorino\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <ol> <li> <p>In contrast to a dedicated sidecar of the protected service and other architectures. Check out Architecture &gt; Topologies for all options.\u00a0\u21a9</p> </li> <li> <p><code>namespaced</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> <li> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. If you are running your ingress gateway in Kubernetes and wants to avoid setting up and configuring your proxy manually, check out Kuadrant.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/keycloak-authorization-services/","title":"User guide: Authorization with Keycloak Authorization Services","text":"<p>Keycloak provides a powerful set of tools (REST endpoints and administrative UIs), also known as Keycloak Authorization Services, to manage and enforce authorization, workflows for multiple access control mechanisms, including discretionary user access control and user-managed permissions.</p> <p>This user guide is an example of how to use Authorino as an adapter to Keycloak Authorization Services while still relying on the reverse-proxy integration pattern, thus not involving importing an authorization library nor rebuilding the application's code.</p> Authorino capabilities featured in this guide: <ul> <li>Identity verification &amp; authentication \u2192 JWT verification</li> <li>Authorization \u2192 Open Policy Agent (OPA) Rego policies</li> </ul> <p>For further details about Authorino features in general, check the docs.</p> <p></p>"},{"location":"authorino/docs/user-guides/keycloak-authorization-services/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC)</li> <li>Keycloak server</li> <li>jq, to extract parts of JSON responses</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p>Deploy the identity provider and authentication server by executing the command below. For the examples in this guide, we are going to use a Keycloak server preloaded with all required realm settings.</p> <pre><code>kubectl create namespace keycloak\nkubectl -n keycloak apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/keycloak/keycloak-deploy.yaml\n</code></pre> <p>Forward local requests to Keycloak running inside the cluster (if using Kind):</p> <pre><code>kubectl -n keycloak port-forward deployment/keycloak 8080:8080 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre> <p></p> <p>The next steps walk you through installing Authorino, deploying and configuring a sample service called Talker API to be protected by the authorization service.</p> Using Kuadrant <p>If you are a user of Kuadrant and already have your workload cluster configured and sample service application deployed, as well as your Gateway API network resources applied to route traffic to your service, skip straight to step \u277a.</p> <p>At step \u277a, instead of creating an <code>AuthConfig</code> custom resource, create a Kuadrant <code>AuthPolicy</code> one. The schema of the AuthConfig's <code>spec</code> matches the one of the AuthPolicy's, except <code>spec.host</code>, which is not available in the Kuadrant AuthPolicy. Host names in a Kuadrant AuthPolicy are inferred automatically from the Kubernetes network object referred in <code>spec.targetRef</code> and route selectors declared in the policy.</p> <p>For more about using Kuadrant to enforce authorization, check out Kuadrant auth.</p> <p></p>"},{"location":"authorino/docs/user-guides/keycloak-authorization-services/#install-the-authorino-operator-cluster-admin-required","title":"\u2776 Install the Authorino Operator (cluster admin required)","text":"<p>The following command will install the Authorino Operator in the Kubernetes cluster. The operator manages instances of the Authorino authorization service.</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/keycloak-authorization-services/#deploy-authorino","title":"\u2777 Deploy Authorino","text":"<p>The following command will request an instance of Authorino as a separate service<sup>1</sup> that watches for <code>AuthConfig</code> resources in the <code>default</code> namespace<sup>2</sup>, with TLS disabled<sup>3</sup>.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/keycloak-authorization-services/#deploy-the-talker-api","title":"\u2778 Deploy the Talker API","text":"<p>The Talker API is a simple HTTP service that echoes back in the response whatever it gets in the request. We will use it in this guide as the sample service to be protected by Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/docs/user-guides/keycloak-authorization-services/#setup-envoy","title":"\u2779 Setup Envoy","text":"<p>The following bundle from the Authorino examples deploys the Envoy proxy and configuration to wire up the Talker API behind the reverse-proxy, with external authorization enabled with the Authorino instance.<sup>4</sup></p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The command above creates an <code>Ingress</code> with host name <code>talker-api.127.0.0.1.nip.io</code>. If you are using a local Kubernetes cluster created with Kind, forward requests from your local port 8000 to the Envoy service running inside the cluster:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre>"},{"location":"authorino/docs/user-guides/keycloak-authorization-services/#create-an-authconfig","title":"\u277a Create an <code>AuthConfig</code>","text":"<p>Create an Authorino <code>AuthConfig</code> custom resource declaring the auth rules to be enforced.</p> <p>In this example, Authorino will accept access tokens (JWTs) issued by the Keycloak server. These JWTs can be either normal Keycloak ID tokens or Requesting Party Tokens (RPT).</p> <p>RPTs include claims about the permissions of the user regarding protected resources and scopes associated with a Keycloak authorization client that the user can access.</p> <p>When the supplied access token is an RPT, Authorino will just validate whether the user's granted permissions present in the token include the requested resource ID (translated from the path) and scope (inferred from the HTTP method). If the token does not contain a <code>permissions</code> claim (i.e. it is not an RPT), Authorino will negotiate a User-Managed Access (UMA) ticket on behalf of the user and try to obtain an RPT on that UMA ticket.</p> <p>In cases of asynchronous user-managed permission control, the first request to the API using a normal Keycloak ID token is denied by Authorino. The user that owns the resource acknowledges the access request in the Keycloak UI. If access is granted, the new permissions will be reflected in subsequent RPTs obtained by Authorino on behalf of the requesting party.</p> <p>Whenever an RPT with proper permissions is obtained by Authorino, the RPT is supplied back to the API consumer, so it can be used in subsequent requests thus skipping new negotiations of UMA tickets.</p> Kuadrant users \u2013         Remember to create an <code>AuthPolicy</code> instead of an AuthConfig.         For more, see Kuadrant auth.        <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n\n  - talker-api.127.0.0.1.nip.io\n  authentication:\n    \"keycloak-kuadrant-realm\":\n      jwt:\n        issuerUrl: http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant\n  authorization:\n    \"uma\":\n      opa:\n        rego: |\n          pat := http.send({\"url\":\"http://talker-api:523b92b6-625d-4e1e-a313-77e7a8ae4e88@keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant/protocol/openid-connect/token\",\"method\": \"post\",\"headers\":{\"Content-Type\":\"application/x-www-form-urlencoded\"},\"raw_body\":\"grant_type=client_credentials\"}).body.access_token\n          resource_id := http.send({\"url\":concat(\"\",[\"http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant/authz/protection/resource_set?uri=\",input.context.request.http.path]),\"method\":\"get\",\"headers\":{\"Authorization\":concat(\" \",[\"Bearer \",pat])}}).body[0]\n          scope := lower(input.context.request.http.method)\n          access_token := trim_prefix(input.context.request.http.headers.authorization, \"Bearer \")\n\n          default rpt = \"\"\n          rpt = access_token { object.get(input.auth.identity, \"authorization\", {}).permissions }\n          else = rpt_str {\n            ticket := http.send({\"url\":\"http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant/authz/protection/permission\",\"method\":\"post\",\"headers\":{\"Authorization\":concat(\" \",[\"Bearer \",pat]),\"Content-Type\":\"application/json\"},\"raw_body\":concat(\"\",[\"[{\\\"resource_id\\\":\\\"\",resource_id,\"\\\",\\\"resource_scopes\\\":[\\\"\",scope,\"\\\"]}]\"])}).body.ticket\n            rpt_str := object.get(http.send({\"url\":\"http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant/protocol/openid-connect/token\",\"method\":\"post\",\"headers\":{\"Authorization\":concat(\" \",[\"Bearer \",access_token]),\"Content-Type\":\"application/x-www-form-urlencoded\"},\"raw_body\":concat(\"\",[\"grant_type=urn:ietf:params:oauth:grant-type:uma-ticket&amp;ticket=\",ticket,\"&amp;submit_request=true\"])}).body, \"access_token\", \"\")\n          }\n\n          allow {\n            permissions := object.get(io.jwt.decode(rpt)[1], \"authorization\", { \"permissions\": [] }).permissions\n            permissions[i]\n            permissions[i].rsid = resource_id\n            permissions[i].scopes[_] = scope\n          }\n        allValues: true\n  response:\n    success:\n      headers:\n        \"x-keycloak\":\n          when:\n\n          - selector: auth.identity.authorization.permissions\n            operator: eq\n            value: \"\"\n          json:\n            properties:\n              \"rpt\":\n                selector: auth.authorization.uma.rpt\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/keycloak-authorization-services/#obtain-an-access-token-with-the-keycloak-server","title":"\u277b Obtain an access token with the Keycloak server","text":"<p>The <code>AuthConfig</code> deployed in the previous step is suitable for validating access tokens requested inside the cluster. This is because Keycloak's <code>iss</code> claim added to the JWTs matches always the host used to request the token and Authorino will later try to match this host to the host that provides the OpenID Connect configuration.</p> <p>Obtain an access token from within the cluster for user Jane:</p> <pre><code>ACCESS_TOKEN=$(kubectl run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant/protocol/openid-connect/token -s -d 'grant_type=password' -d 'client_id=demo' -d 'username=jane' -d 'password=p' -d 'scope=openid' | jq -r .access_token)\n</code></pre> <p>If your Keycloak server is reachable from outside the cluster, feel free to obtain the token directly. Make sure the host name set in the OIDC issuer endpoint in the <code>AuthConfig</code> matches the one used to obtain the token and is as well reachable from within the cluster.</p>"},{"location":"authorino/docs/user-guides/keycloak-authorization-services/#consume-the-api","title":"\u277c Consume the API","text":"<p>As Jane, try to send a <code>GET</code> request to the protected resource <code>/greetings/1</code>, owned by user John.</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api.127.0.0.1.nip.io:8000/greetings/1 -i\n# HTTP/1.1 403 Forbidden\n</code></pre> <p>As John, log in to http://localhost:8080/realms/kuadrant/account in the web browser (username: <code>john</code> / password: <code>p</code>), and grant access to the resource <code>greeting-1</code> for Jane. A pending permission request by Jane shall exist in the list of John's Resources.</p> <p> </p> <p>As Jane, try to consume the protected resource <code>/greetings/1</code> again:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api.127.0.0.1.nip.io:8000/greetings/1 -i\n# HTTP/1.1 200 OK\n#\n# {\u2026\n#   \"headers\": {\u2026\n#     \"X-Keycloak\": \"{\\\"rpt\\\":\\\"&lt;RPT&gt;\", \u2026\n</code></pre> <p>Copy the RPT from the response and repeat the request now using the RPT to authenticate:</p> <pre><code>curl -H \"Authorization: Bearer &lt;RPT&gt;\" http://talker-api.127.0.0.1.nip.io:8000/greetings/1 -i\n# HTTP/1.1 200 OK\n</code></pre>"},{"location":"authorino/docs/user-guides/keycloak-authorization-services/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete authconfig/talker-api-protection\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\nkubectl delete authorino/authorino\nkubectl delete namespace keycloak\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <ol> <li> <p>In contrast to a dedicated sidecar of the protected service and other architectures. Check out Architecture &gt; Topologies for all options.\u00a0\u21a9</p> </li> <li> <p><code>namespaced</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> <li> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. If you are running your ingress gateway in Kubernetes and wants to avoid setting up and configuring your proxy manually, check out Kuadrant.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/kubernetes-subjectaccessreview/","title":"User guide: Kubernetes RBAC for service authorization (SubjectAccessReview API)","text":"<p>Manage permissions in the Kubernetes RBAC and let Authorino to check them in request-time with the authorization system of the cluster.</p> Authorino capabilities featured in this guide: <ul> <li>Authorization \u2192 Kubernetes SubjectAccessReview</li> <li>Identity verification &amp; authentication \u2192 Kubernetes TokenReview</li> </ul> <p>Authorino can delegate authorization decision to the Kubernetes authorization system, allowing permissions to be stored and managed using the Kubernetes Role-Based Access Control (RBAC) for example. The feature is based on the <code>SubjectAccessReview</code> API and can be used for <code>resourceAttributes</code> (parameters defined in the <code>AuthConfig</code>) or <code>nonResourceAttributes</code> (inferring HTTP path and verb from the original request).</p> <p>Check out as well the user guide about Authentication with Kubernetes tokens (TokenReview API).</p> <p>For further details about Authorino features in general, check the docs.</p> <p></p>"},{"location":"authorino/docs/user-guides/kubernetes-subjectaccessreview/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC) and to create <code>TokenRequest</code>s (to consume the protected service from outside the cluster)</li> <li>jq</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p></p> <p>The next steps walk you through installing Authorino, deploying and configuring a sample service called Talker API to be protected by the authorization service.</p> Using Kuadrant <p>If you are a user of Kuadrant and already have your workload cluster configured and sample service application deployed, as well as your Gateway API network resources applied to route traffic to your service, skip straight to step \u277a.</p> <p>At step \u277a, instead of creating an <code>AuthConfig</code> custom resource, create a Kuadrant <code>AuthPolicy</code> one. The schema of the AuthConfig's <code>spec</code> matches the one of the AuthPolicy's, except <code>spec.host</code>, which is not available in the Kuadrant AuthPolicy. Host names in a Kuadrant AuthPolicy are inferred automatically from the Kubernetes network object referred in <code>spec.targetRef</code> and route selectors declared in the policy.</p> <p>For more about using Kuadrant to enforce authorization, check out Kuadrant auth.</p> <p></p>"},{"location":"authorino/docs/user-guides/kubernetes-subjectaccessreview/#install-the-authorino-operator-cluster-admin-required","title":"\u2776 Install the Authorino Operator (cluster admin required)","text":"<p>The following command will install the Authorino Operator in the Kubernetes cluster. The operator manages instances of the Authorino authorization service.</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/kubernetes-subjectaccessreview/#deploy-authorino","title":"\u2777 Deploy Authorino","text":"<p>The following command will request an instance of Authorino as a separate service<sup>1</sup> that watches for <code>AuthConfig</code> resources in the <code>default</code> namespace<sup>2</sup>, with TLS disabled<sup>3</sup>.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/kubernetes-subjectaccessreview/#deploy-the-talker-api","title":"\u2778 Deploy the Talker API","text":"<p>The Talker API is a simple HTTP service that echoes back in the response whatever it gets in the request. We will use it in this guide as the sample service to be protected by Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/docs/user-guides/kubernetes-subjectaccessreview/#setup-envoy","title":"\u2779 Setup Envoy","text":"<p>The following bundle from the Authorino examples deploys the Envoy proxy and configuration to wire up the Talker API behind the reverse-proxy, with external authorization enabled with the Authorino instance.<sup>4</sup></p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The command above creates an <code>Ingress</code> with host name <code>talker-api.127.0.0.1.nip.io</code>. If you are using a local Kubernetes cluster created with Kind, forward requests from your local port 8000 to the Envoy service running inside the cluster:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre>"},{"location":"authorino/docs/user-guides/kubernetes-subjectaccessreview/#create-an-authconfig","title":"\u277a Create an <code>AuthConfig</code>","text":"<p>Create an Authorino <code>AuthConfig</code> custom resource declaring the auth rules to be enforced.</p> <p>The <code>AuthConfig</code> below sets all Kubernetes service accounts as trusted users of the API, and relies on the Kubernetes RBAC to enforce authorization using Kubernetes SubjectAccessReview API for non-resource endpoints:</p> Kuadrant users \u2013         Remember to create an <code>AuthPolicy</code> instead of an AuthConfig.         For more, see Kuadrant auth.        <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n\n  - talker-api.127.0.0.1.nip.io\n  - envoy.default.svc.cluster.local\n  authentication:\n    \"service-accounts\":\n      kubernetesTokenReview:\n        audiences: [\"https://kubernetes.default.svc.cluster.local\"]\n  authorization:\n    \"k8s-rbac\":\n      kubernetesSubjectAccessReview:\n        user:\n          selector: auth.identity.user.username\nEOF\n</code></pre> <p>Check out the spec for the Authorino Kubernetes SubjectAccessReview authorization feature, for resource attributes permission checks where SubjectAccessReviews issued by Authorino are modeled in terms of common attributes of operations on Kubernetes resources (namespace, API group, kind, name, subresource, verb).</p>"},{"location":"authorino/docs/user-guides/kubernetes-subjectaccessreview/#create-roles-associated-with-endpoints-of-the-api","title":"\u277b Create roles associated with endpoints of the API","text":"<p>Because the <code>k8s-rbac</code> policy defined in the <code>AuthConfig</code> in the previous step is for non-resource access review requests, the corresponding roles and role bindings have to be defined at cluster scope.</p> <p>Create a <code>talker-api-greeter</code> role whose users and service accounts bound to this role can consume the non-resource endpoints <code>POST /hello</code> and <code>POST /hi</code> of the API:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: talker-api-greeter\nrules:\n\n- nonResourceURLs: [\"/hello\"]\n  verbs: [\"post\"]\n- nonResourceURLs: [\"/hi\"]\n  verbs: [\"post\"]\nEOF\n</code></pre> <p>Create a <code>talker-api-speaker</code> role whose users and service accounts bound to this role can consume the non-resource endpoints <code>POST /say/*</code> of the API:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: talker-api-speaker\nrules:\n\n- nonResourceURLs: [\"/say/*\"]\n  verbs: [\"post\"]\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/kubernetes-subjectaccessreview/#create-the-serviceaccounts-and-permissions-to-consume-the-api","title":"\u277c Create the <code>ServiceAccount</code>s and permissions to consume the API","text":"<p>Create service accounts <code>api-consumer-1</code> and <code>api-consumer-2</code>:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: api-consumer-1\nEOF\n</code></pre> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: api-consumer-2\nEOF\n</code></pre> <p>Bind both service accounts to the <code>talker-api-greeter</code> role:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: talker-api-greeter-rolebinding\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: talker-api-greeter\nsubjects:\n\n- kind: ServiceAccount\n  name: api-consumer-1\n  namespace: default\n- kind: ServiceAccount\n  name: api-consumer-2\n  namespace: default\nEOF\n</code></pre> <p>Bind service account <code>api-consumer-1</code> to the <code>talker-api-speaker</code> role:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: talker-api-speaker-rolebinding\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: talker-api-speaker\nsubjects:\n\n- kind: ServiceAccount\n  name: api-consumer-1\n  namespace: default\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/kubernetes-subjectaccessreview/#consume-the-api","title":"\u277d Consume the API","text":"<p>Run a pod that consumes one of the greeting endpoints of the API from inside the cluster, as service account <code>api-consumer-1</code>, bound to the <code>talker-api-greeter</code> and <code>talker-api-speaker</code> cluster roles in the Kubernetes RBAC:</p> <pre><code>kubectl run greeter --attach --rm --restart=Never -q --image=quay.io/kuadrant/authorino-examples:api-consumer --overrides='{\n  \"apiVersion\": \"v1\",\n  \"spec\": {\n    \"containers\": [{\n      \"name\": \"api-consumer\", \"image\": \"quay.io/kuadrant/authorino-examples:api-consumer\", \"command\": [\"./run\"],\n      \"args\":[\"--endpoint=http://envoy.default.svc.cluster.local:8000/hi\",\"--method=POST\",\"--interval=0\",\"--token-path=/var/run/secrets/tokens/api-token\"],\n      \"volumeMounts\": [{\"mountPath\": \"/var/run/secrets/tokens\",\"name\": \"access-token\"}]\n    }],\n    \"serviceAccountName\": \"api-consumer-1\",\n    \"volumes\": [{\"name\": \"access-token\",\"projected\": {\"sources\": [{\"serviceAccountToken\": {\"path\": \"api-token\",\"expirationSeconds\": 7200}}]}}]\n  }\n}' -- sh\n# Sending...\n# 200\n</code></pre> <p>Run a pod that sends a <code>POST</code> request to <code>/say/blah</code> from within the cluster, as service account <code>api-consumer-1</code>:</p> <pre><code>kubectl run speaker --attach --rm --restart=Never -q --image=quay.io/kuadrant/authorino-examples:api-consumer --overrides='{\n  \"apiVersion\": \"v1\",\n  \"spec\": {\n    \"containers\": [{\n      \"name\": \"api-consumer\", \"image\": \"quay.io/kuadrant/authorino-examples:api-consumer\", \"command\": [\"./run\"],\n      \"args\":[\"--endpoint=http://envoy.default.svc.cluster.local:8000/say/blah\",\"--method=POST\",\"--interval=0\",\"--token-path=/var/run/secrets/tokens/api-token\"],\n      \"volumeMounts\": [{\"mountPath\": \"/var/run/secrets/tokens\",\"name\": \"access-token\"}]\n    }],\n    \"serviceAccountName\": \"api-consumer-1\",\n    \"volumes\": [{\"name\": \"access-token\",\"projected\": {\"sources\": [{\"serviceAccountToken\": {\"path\": \"api-token\",\"expirationSeconds\": 7200}}]}}]\n  }\n}' -- sh\n# Sending...\n# 200\n</code></pre> <p>Run a pod that sends a <code>POST</code> request to <code>/say/blah</code> from within the cluster, as service account <code>api-consumer-2</code>, bound only to the <code>talker-api-greeter</code> cluster role in the Kubernetes RBAC:</p> <pre><code>kubectl run speaker --attach --rm --restart=Never -q --image=quay.io/kuadrant/authorino-examples:api-consumer --overrides='{\n  \"apiVersion\": \"v1\",\n  \"spec\": {\n    \"containers\": [{\n      \"name\": \"api-consumer\", \"image\": \"quay.io/kuadrant/authorino-examples:api-consumer\", \"command\": [\"./run\"],\n      \"args\":[\"--endpoint=http://envoy.default.svc.cluster.local:8000/say/blah\",\"--method=POST\",\"--interval=0\",\"--token-path=/var/run/secrets/tokens/api-token\"],\n      \"volumeMounts\": [{\"mountPath\": \"/var/run/secrets/tokens\",\"name\": \"access-token\"}]\n    }],\n    \"serviceAccountName\": \"api-consumer-2\",\n    \"volumes\": [{\"name\": \"access-token\",\"projected\": {\"sources\": [{\"serviceAccountToken\": {\"path\": \"api-token\",\"expirationSeconds\": 7200}}]}}]\n  }\n}' -- sh\n# Sending...\n# 403\n</code></pre> Extra: consume the API as service account <code>api-consumer-2</code> from outside the cluster <p></p> <p>Obtain a short-lived access token for service account <code>api-consumer-2</code>, bound to the <code>talker-api-greeter</code> cluster role in the Kubernetes RBAC, using the Kubernetes TokenRequest API:</p> <pre><code>export ACCESS_TOKEN=$(echo '{ \"apiVersion\": \"authentication.k8s.io/v1\", \"kind\": \"TokenRequest\", \"spec\": { \"expirationSeconds\": 600 } }' | kubectl create --raw /api/v1/namespaces/default/serviceaccounts/api-consumer-2/token -f - | jq -r .status.token)\n</code></pre> <p>Consume the API as <code>api-consumer-2</code> from outside the cluster:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" -X POST http://talker-api.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 200 OK\n</code></pre> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" -X POST http://talker-api.127.0.0.1.nip.io:8000/say/something -i\n# HTTP/1.1 403 Forbidden\n</code></pre>"},{"location":"authorino/docs/user-guides/kubernetes-subjectaccessreview/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete serviceaccount/api-consumer-1\nkubectl delete serviceaccount/api-consumer-2\nkubectl delete clusterrolebinding/talker-api-greeter-rolebinding\nkubectl delete clusterrolebinding/talker-api-speaker-rolebinding\nkubectl delete clusterrole/talker-api-greeter\nkubectl delete clusterrole/talker-api-speaker\nkubectl delete authconfig/talker-api-protection\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\nkubectl delete authorino/authorino\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <ol> <li> <p>In contrast to a dedicated sidecar of the protected service and other architectures. Check out Architecture &gt; Topologies for all options.\u00a0\u21a9</p> </li> <li> <p><code>namespaced</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> <li> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. If you are running your ingress gateway in Kubernetes and wants to avoid setting up and configuring your proxy manually, check out Kuadrant.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/kubernetes-tokenreview/","title":"User guide: Authentication with Kubernetes tokens (TokenReview API)","text":"<p>Validate Kubernetes Service Account tokens to authenticate requests to your protected hosts.</p> Authorino capabilities featured in this guide: <ul> <li>Identity verification &amp; authentication \u2192 Kubernetes TokenReview</li> </ul> <p>Authorino can verify Kubernetes-valid access tokens (using Kubernetes TokenReview API).</p> <p>These tokens can be either <code>ServiceAccount</code> tokens or any valid user access tokens issued to users of the Kubernetes server API.</p> <p>The <code>audiences</code> claim of the token must include the requested host and port of the protected API (default), or all audiences specified in <code>spec.identity.kubernetes.audiences</code> of the <code>AuthConfig</code>.</p> <p>For further details about Authorino features in general, check the docs.</p> <p></p>"},{"location":"authorino/docs/user-guides/kubernetes-tokenreview/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC) and to create <code>TokenRequest</code>s (to consume the protected service from outside the cluster)</li> <li>jq</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p></p> <p>The next steps walk you through installing Authorino, deploying and configuring a sample service called Talker API to be protected by the authorization service.</p> Using Kuadrant <p>If you are a user of Kuadrant and already have your workload cluster configured and sample service application deployed, as well as your Gateway API network resources applied to route traffic to your service, skip straight to step \u277a.</p> <p>At step \u277a, instead of creating an <code>AuthConfig</code> custom resource, create a Kuadrant <code>AuthPolicy</code> one. The schema of the AuthConfig's <code>spec</code> matches the one of the AuthPolicy's, except <code>spec.host</code>, which is not available in the Kuadrant AuthPolicy. Host names in a Kuadrant AuthPolicy are inferred automatically from the Kubernetes network object referred in <code>spec.targetRef</code> and route selectors declared in the policy.</p> <p>For more about using Kuadrant to enforce authorization, check out Kuadrant auth.</p> <p></p>"},{"location":"authorino/docs/user-guides/kubernetes-tokenreview/#install-the-authorino-operator-cluster-admin-required","title":"\u2776 Install the Authorino Operator (cluster admin required)","text":"<p>The following command will install the Authorino Operator in the Kubernetes cluster. The operator manages instances of the Authorino authorization service.</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/kubernetes-tokenreview/#deploy-authorino","title":"\u2777 Deploy Authorino","text":"<p>The following command will request an instance of Authorino as a separate service<sup>1</sup> that watches for <code>AuthConfig</code> resources in the <code>default</code> namespace<sup>2</sup>, with TLS disabled<sup>3</sup>.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/kubernetes-tokenreview/#deploy-the-talker-api","title":"\u2778 Deploy the Talker API","text":"<p>The Talker API is a simple HTTP service that echoes back in the response whatever it gets in the request. We will use it in this guide as the sample service to be protected by Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/docs/user-guides/kubernetes-tokenreview/#setup-envoy","title":"\u2779 Setup Envoy","text":"<p>The following bundle from the Authorino examples deploys the Envoy proxy and configuration to wire up the Talker API behind the reverse-proxy, with external authorization enabled with the Authorino instance.<sup>4</sup></p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The command above creates an <code>Ingress</code> with host name <code>talker-api.127.0.0.1.nip.io</code>. If you are using a local Kubernetes cluster created with Kind, forward requests from your local port 8000 to the Envoy service running inside the cluster:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre>"},{"location":"authorino/docs/user-guides/kubernetes-tokenreview/#create-an-authconfig","title":"\u277a Create an <code>AuthConfig</code>","text":"<p>Create an Authorino <code>AuthConfig</code> custom resource declaring the auth rules to be enforced:</p> Kuadrant users \u2013         Remember to create an <code>AuthPolicy</code> instead of an AuthConfig.         For more, see Kuadrant auth.        <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n\n  - talker-api.127.0.0.1.nip.io\n  - envoy.default.svc.cluster.local\n  authentication:\n    \"authorized-service-accounts\":\n      kubernetesTokenReview:\n        audiences:\n        - talker-api\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/kubernetes-tokenreview/#consume-the-api-protected-by-authorino","title":"\u277b Consume the API protected by Authorino","text":""},{"location":"authorino/docs/user-guides/kubernetes-tokenreview/#create-a-serviceaccount","title":"Create a <code>ServiceAccount</code>","text":"<p>Create a Kubernetes <code>ServiceAccount</code> to identify the consumer application that will send requests to the protected API:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: api-consumer-1\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/kubernetes-tokenreview/#consume-the-api-from-outside-the-cluster","title":"Consume the API from outside the cluster","text":"<p>Obtain a short-lived access token for the <code>api-consumer-1</code> service account:</p> <pre><code>export ACCESS_TOKEN=$(echo '{ \"apiVersion\": \"authentication.k8s.io/v1\", \"kind\": \"TokenRequest\", \"spec\": { \"audiences\": [\"talker-api\"], \"expirationSeconds\": 600 } }' | kubectl create --raw /api/v1/namespaces/default/serviceaccounts/api-consumer-1/token -f - | jq -r .status.token)\n</code></pre> <p>Consume the API with a valid Kubernetes token:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 200 OK\n</code></pre> <p>Consume the API with the Kubernetes token expired (10 minutes):</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 401 Unauthorized\n# www-authenticate: Bearer realm=\"authorized-service-accounts\"\n# x-ext-auth-reason: Not authenticated\n</code></pre>"},{"location":"authorino/docs/user-guides/kubernetes-tokenreview/#consume-the-api-from-inside-the-cluster","title":"Consume the API from inside the cluster","text":"<p>Deploy an application that consumes an endpoint of the Talker API, in a loop, every 10 seconds. The application uses a short-lived service account token mounted inside the container using Kubernetes Service Account Token Volume Projection to authenticate.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Pod\nmetadata:\n  name: api-consumer\nspec:\n  containers:\n\n  - name: api-consumer\n    image: quay.io/kuadrant/authorino-examples:api-consumer\n    command: [\"./run\"]\n    args:\n      - --endpoint=http://envoy.default.svc.cluster.local:8000/hello\n      - --token-path=/var/run/secrets/tokens/api-token\n      - --interval=10\n    volumeMounts:\n    - mountPath: /var/run/secrets/tokens\n      name: talker-api-access-token\n  serviceAccountName: api-consumer-1\n  volumes:\n  - name: talker-api-access-token\n    projected:\n      sources:\n      - serviceAccountToken:\n          path: api-token\n          expirationSeconds: 7200\n          audience: talker-api\nEOF\n</code></pre> <p>Check the logs of <code>api-consumer</code>:</p> <pre><code>kubectl logs -f api-consumer\n# Sending...\n# 200\n# 200\n# 200\n# 200\n# ...\n</code></pre>"},{"location":"authorino/docs/user-guides/kubernetes-tokenreview/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete pod/api-consumer\nkubectl delete serviceaccount/api-consumer-1\nkubectl delete authconfig/talker-api-protection\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\nkubectl delete authorino/authorino\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <ol> <li> <p>In contrast to a dedicated sidecar of the protected service and other architectures. Check out Architecture &gt; Topologies for all options.\u00a0\u21a9</p> </li> <li> <p><code>namespaced</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> <li> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. If you are running your ingress gateway in Kubernetes and wants to avoid setting up and configuring your proxy manually, check out Kuadrant.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/mtls-authentication/","title":"User guide: Authentication with X.509 certificates and Mutual Transport Layer Security (mTLS)","text":"<p>Verify client X.509 certificates against trusted root CAs stored in Kubernetes <code>Secret</code>s to authenticate access to APIs protected with Authorino.</p> Authorino capabilities featured in this guide: <ul> <li>Identity verification &amp; authentication \u2192 X.509 client certificate authentication</li> <li>Authorization \u2192 Pattern-matching authorization</li> </ul> <p>Authorino can verify x509 certificates presented by clients for authentication on the request to the protected APIs, at application level.</p> <p>Trusted root Certificate Authorities (CA) are stored as Kubernetes <code>kubernetes.io/tls</code> Secrets labeled according to selectors specified in the AuthConfig, watched and cached by Authorino.</p> <p>For further details about Authorino features in general, check the docs.</p> <p></p>"},{"location":"authorino/docs/user-guides/mtls-authentication/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC)</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p></p> <p>The next steps walk you through installing Authorino, deploying and configuring a sample service called Talker API to be protected by the authorization service.</p> Using Kuadrant <p>If you are a user of Kuadrant and already have your workload cluster configured and sample service application deployed, as well as your Gateway API network resources applied to route traffic to your service, skip straight to step \u277b.</p> <p>At step \u277b, instead of creating an <code>AuthConfig</code> custom resource, create a Kuadrant <code>AuthPolicy</code> one. The schema of the AuthConfig's <code>spec</code> matches the one of the AuthPolicy's, except <code>spec.host</code>, which is not available in the Kuadrant AuthPolicy. Host names in a Kuadrant AuthPolicy are inferred automatically from the Kubernetes network object referred in <code>spec.targetRef</code> and route selectors declared in the policy.</p> <p>For more about using Kuadrant to enforce authorization, check out Kuadrant auth.</p> <p></p>"},{"location":"authorino/docs/user-guides/mtls-authentication/#install-the-authorino-operator-cluster-admin-required","title":"\u2776 Install the Authorino Operator (cluster admin required)","text":"<p>The following command will install the Authorino Operator in the Kubernetes cluster. The operator manages instances of the Authorino authorization service.</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/mtls-authentication/#deploy-authorino","title":"\u2777 Deploy Authorino","text":"<p>The following commands will request an instance of Authorino as a separate service<sup>1</sup> that watches for <code>AuthConfig</code> resources in the <code>default</code> namespace<sup>2</sup>, with TLS enabled<sup>3</sup>.</p> <p>Create the TLS certificates for the Authorino service:</p> <pre><code>curl -sSL https://raw.githubusercontent.com/Kuadrant/authorino/main/deploy/certs.yaml | sed \"s/\\$(AUTHORINO_INSTANCE)/authorino/g;s/\\$(NAMESPACE)/default/g\" | kubectl apply -f -\n</code></pre> <p>Request the Authorino instance:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      certSecretRef:\n        name: authorino-server-cert\n  oidcServer:\n    tls:\n      certSecretRef:\n        name: authorino-oidc-server-cert\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/mtls-authentication/#deploy-the-talker-api","title":"\u2778 Deploy the Talker API","text":"<p>The Talker API is a simple HTTP service that echoes back in the response whatever it gets in the request. We will use it in this guide as the sample service to be protected by Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/docs/user-guides/mtls-authentication/#create-a-ca","title":"\u2779 Create a CA","text":"<p>Create a CA (Certificate Authority) certificate to issue the client certificates that will be used to authenticate clients that send requests to the Talker API:</p> <pre><code>openssl req -x509 -sha512 -nodes \\\n  -days 365 \\\n  -newkey rsa:4096 \\\n  -subj \"/CN=talker-api-ca\" \\\n  -addext basicConstraints=CA:TRUE \\\n  -addext keyUsage=digitalSignature,keyCertSign \\\n  -keyout /tmp/ca.key \\\n  -out /tmp/ca.crt\n</code></pre> <p>Store the CA cert in a Kubernetes <code>Secret</code>, labeled to be discovered by Authorino and to be mounted in the file system of the Envoy container:</p> <pre><code>kubectl create secret tls talker-api-ca --cert=/tmp/ca.crt --key=/tmp/ca.key\nkubectl label secret talker-api-ca authorino.kuadrant.io/managed-by=authorino app=talker-api\n</code></pre> <p>Prepare an extension file for the client certificate signing requests:</p> <pre><code>cat &gt; /tmp/x509v3.ext &lt;&lt; EOF\nauthorityKeyIdentifier=keyid,issuer\nbasicConstraints=CA:FALSE\nkeyUsage=digitalSignature,nonRepudiation,keyEncipherment,dataEncipherment\nextendedKeyUsage=clientAuth\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/mtls-authentication/#setup-envoy","title":"\u277a Setup Envoy","text":"<p>The following command deploys the Envoy proxy and configuration to wire up the Talker API behind the reverse-proxy, with external authorization enabled with the Authorino instance.<sup>4</sup></p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  labels:\n    app: envoy\n  name: envoy\ndata:\n  envoy.yaml: |\n    static_resources:\n      listeners:\n\n      - address:\n          socket_address:\n            address: 0.0.0.0\n            port_value: 8443\n        filter_chains:\n        - transport_socket:\n            name: envoy.transport_sockets.tls\n            typed_config:\n              \"@type\": type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.DownstreamTlsContext\n              common_tls_context:\n                tls_certificates:\n                - certificate_chain: {filename: \"/etc/ssl/certs/talker-api/tls.crt\"}\n                  private_key: {filename: \"/etc/ssl/certs/talker-api/tls.key\"}\n                validation_context:\n                  trusted_ca:\n                    filename: /etc/ssl/certs/talker-api/tls.crt\n          filters:\n          - name: envoy.http_connection_manager\n            typed_config:\n              \"@type\": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager\n              stat_prefix: local\n              route_config:\n                name: local_route\n                virtual_hosts:\n                - name: local_service\n                  domains: ['*']\n                  routes:\n                  - match: { prefix: / }\n                    route: { cluster: talker-api }\n              http_filters:\n              - name: envoy.filters.http.ext_authz\n                typed_config:\n                  \"@type\": type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthz\n                  transport_api_version: V3\n                  failure_mode_allow: false\n                  include_peer_certificate: true\n                  grpc_service:\n                    envoy_grpc: { cluster_name: authorino }\n                    timeout: 1s\n              - name: envoy.filters.http.router\n                typed_config: {}\n              use_remote_address: true\n      clusters:\n      - name: authorino\n        connect_timeout: 0.25s\n        type: strict_dns\n        lb_policy: round_robin\n        http2_protocol_options: {}\n        load_assignment:\n          cluster_name: authorino\n          endpoints:\n          - lb_endpoints:\n            - endpoint:\n                address:\n                  socket_address:\n                    address: authorino-authorino-authorization\n                    port_value: 50051\n        transport_socket:\n          name: envoy.transport_sockets.tls\n          typed_config:\n            \"@type\": type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext\n            common_tls_context:\n              validation_context:\n                trusted_ca:\n                  filename: /etc/ssl/certs/authorino-ca-cert.crt\n      - name: talker-api\n        connect_timeout: 0.25s\n        type: strict_dns\n        lb_policy: round_robin\n        load_assignment:\n          cluster_name: talker-api\n          endpoints:\n          - lb_endpoints:\n            - endpoint:\n                address:\n                  socket_address:\n                    address: talker-api\n                    port_value: 3000\n    admin:\n      access_log_path: \"/tmp/admin_access.log\"\n      address:\n        socket_address:\n          address: 0.0.0.0\n          port_value: 8001\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  labels:\n    app: envoy\n  name: envoy\nspec:\n  selector:\n    matchLabels:\n      app: envoy\n  template:\n    metadata:\n      labels:\n        app: envoy\n    spec:\n      containers:\n      - args:\n        - --config-path /usr/local/etc/envoy/envoy.yaml\n        - --service-cluster front-proxy\n        - --log-level info\n        - --component-log-level filter:trace,http:debug,router:debug\n        command:\n        - /usr/local/bin/envoy\n        image: envoyproxy/envoy:v1.19-latest\n        name: envoy\n        ports:\n        - containerPort: 8443\n          name: web\n        - containerPort: 8001\n          name: admin\n        volumeMounts:\n        - mountPath: /usr/local/etc/envoy\n          name: config\n          readOnly: true\n        - mountPath: /etc/ssl/certs/authorino-ca-cert.crt\n          name: authorino-ca-cert\n          readOnly: true\n          subPath: ca.crt\n        - mountPath: /etc/ssl/certs/talker-api\n          name: talker-api-ca\n          readOnly: true\n      volumes:\n      - configMap:\n          items:\n          - key: envoy.yaml\n            path: envoy.yaml\n          name: envoy\n        name: config\n      - name: authorino-ca-cert\n        secret:\n          defaultMode: 420\n          secretName: authorino-ca-cert\n      - name: talker-api-ca\n        secret:\n          defaultMode: 420\n          secretName: talker-api-ca\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: envoy\nspec:\n  selector:\n    app: envoy\n  ports:\n  - name: web\n    port: 8443\n    protocol: TCP\n---\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: ingress-wildcard-host\nspec:\n  rules:\n  - host: talker-api.127.0.0.1.nip.io\n    http:\n      paths:\n      - backend:\n          service:\n            name: envoy\n            port: { number: 8443 }\n        path: /\n        pathType: Prefix\nEOF\n</code></pre> <p>The command above creates an <code>Ingress</code> with host name <code>talker-api.127.0.0.1.nip.io</code>. If you are using a local Kubernetes cluster created with Kind, forward requests from your local port 8443 to the Envoy service running inside the cluster:</p> <pre><code>kubectl port-forward deployment/envoy 8443:8443 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre>"},{"location":"authorino/docs/user-guides/mtls-authentication/#create-the-authconfig","title":"\u277b Create the <code>AuthConfig</code>","text":"<p>Create an Authorino <code>AuthConfig</code> custom resource declaring the auth rules to be enforced:</p> Kuadrant users \u2013         Remember to create an <code>AuthPolicy</code> instead of an AuthConfig.         For more, see Kuadrant auth.        <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n\n  - talker-api.127.0.0.1.nip.io\n  authentication:\n    \"mtls\":\n      x509:\n        selector:\n          matchLabels:\n            app: talker-api\n  authorization:\n    \"acme\":\n      patternMatching:\n        patterns:\n        - selector: auth.identity.Organization\n          operator: incl\n          value: ACME Inc.\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/mtls-authentication/#consume-the-api","title":"\u277c Consume the API","text":"<p>With a TLS certificate signed by the trusted CA:</p> <pre><code>openssl genrsa -out /tmp/aisha.key 4096\nopenssl req -new -subj \"/CN=aisha/C=PK/L=Islamabad/O=ACME Inc./OU=Engineering\" -key /tmp/aisha.key -out /tmp/aisha.csr\nopenssl x509 -req -sha512 -days 1 -CA /tmp/ca.crt -CAkey /tmp/ca.key -CAcreateserial -extfile /tmp/x509v3.ext -in /tmp/aisha.csr -out /tmp/aisha.crt\n\ncurl -k --cert /tmp/aisha.crt --key /tmp/aisha.key https://talker-api.127.0.0.1.nip.io:8443 -i\n# HTTP/1.1 200 OK\n</code></pre> <p>With a TLS certificate signed by the trusted CA, though missing an authorized Organization:</p> <pre><code>openssl genrsa -out /tmp/john.key 4096\nopenssl req -new -subj \"/CN=john/C=UK/L=London\" -key /tmp/john.key -out /tmp/john.csr\nopenssl x509 -req -sha512 -days 1 -CA /tmp/ca.crt -CAkey /tmp/ca.key -CAcreateserial -extfile /tmp/x509v3.ext -in /tmp/john.csr -out /tmp/john.crt\n\ncurl -k --cert /tmp/john.crt --key /tmp/john.key https://talker-api.127.0.0.1.nip.io:8443 -i\n# HTTP/1.1 403 Forbidden\n# x-ext-auth-reason: Unauthorized\n</code></pre>"},{"location":"authorino/docs/user-guides/mtls-authentication/#try-the-authconfig-via-raw-http-authorization-interface","title":"\u277d Try the AuthConfig via raw HTTP authorization interface","text":"<p>Expose Authorino's raw HTTP authorization to the local host:</p> <pre><code>kubectl port-forward service/authorino-authorino-authorization 5001:5001 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre> <p>With a TLS certificate signed by the trusted CA:</p> <pre><code>curl -k --cert /tmp/aisha.crt --key /tmp/aisha.key -H 'Content-Type: application/json' -d '{}' https://talker-api.127.0.0.1.nip.io:5001/check -i\n# HTTP/2 200\n</code></pre> <p>With a TLS certificate signed by an unknown authority:</p> <pre><code>openssl req -x509 -sha512 -nodes \\\n  -days 365 \\\n  -newkey rsa:4096 \\\n  -subj \"/CN=untrusted\" \\\n  -addext basicConstraints=CA:TRUE \\\n  -addext keyUsage=digitalSignature,keyCertSign \\\n  -keyout /tmp/untrusted-ca.key \\\n  -out /tmp/untrusted-ca.crt\n\nopenssl genrsa -out /tmp/niko.key 4096\nopenssl req -new -subj \"/CN=niko/C=JP/L=Osaka\" -key /tmp/niko.key -out /tmp/niko.csr\nopenssl x509 -req -sha512 -days 1 -CA /tmp/untrusted-ca.crt -CAkey /tmp/untrusted-ca.key -CAcreateserial -extfile /tmp/x509v3.ext -in /tmp/niko.csr -out /tmp/niko.crt\n\ncurl -k --cert /tmp/niko.crt --key /tmp/niko.key -H 'Content-Type: application/json' -d '{}' https://talker-api.127.0.0.1.nip.io:5001/check -i\n# HTTP/2 401\n# www-authenticate: Basic realm=\"mtls\"\n# x-ext-auth-reason: x509: certificate signed by unknown authority\n</code></pre>"},{"location":"authorino/docs/user-guides/mtls-authentication/#revoke-an-entire-chain-of-certificates","title":"\u277e Revoke an entire chain of certificates","text":"<pre><code>kubectl delete secret/talker-api-ca\n</code></pre> <p>Even if the deleted root certificate is still cached and accepted at the gateway, Authorino will revoke access at application level immediately.</p> <p>Try with a previously accepted certificate:</p> <pre><code>curl -k --cert /tmp/aisha.crt --key /tmp/aisha.key https://talker-api.127.0.0.1.nip.io:8443 -i\n# HTTP/1.1 401 Unauthorized\n# www-authenticate: Basic realm=\"mtls\"\n# x-ext-auth-reason: x509: certificate signed by unknown authority\n</code></pre>"},{"location":"authorino/docs/user-guides/mtls-authentication/#cleanup","title":"Cleanup","text":"<pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <ol> <li> <p>In contrast to a dedicated sidecar of the protected service and other architectures. Check out Architecture &gt; Topologies for all options.\u00a0\u21a9</p> </li> <li> <p><code>namespaced</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> <li> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. If you are running your ingress gateway in Kubernetes and wants to avoid setting up and configuring your proxy manually, check out Kuadrant.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/oauth2-token-introspection/","title":"User guide: OAuth 2.0 token introspection (RFC 7662)","text":"<p>Introspect OAuth 2.0 access tokens (e.g. opaque tokens) for online user data and token validation in request-time.</p> Authorino capabilities featured in this guide: <ul> <li>Identity verification &amp; authentication \u2192 OAuth 2.0 introspection</li> <li>Authorization \u2192 Pattern-matching authorization</li> </ul> <p>Authorino can perform OAuth 2.0 token introspection (RFC 7662) on the access tokens supplied in the requests to protected APIs. This is particularly useful when using opaque tokens, for remote checking the token validity and resolving the identity object.</p> <p>Important! Authorino does not implement OAuth2 grants nor OIDC authentication flows. As a common recommendation of good practice, obtaining and refreshing access tokens is for clients to negotiate directly with the auth servers and token issuers. Authorino will only validate those tokens using the parameters provided by the trusted issuer authorities.</p> <p>Check out as well the user guides about OpenID Connect Discovery and authentication with JWTs and Simple pattern-matching authorization policies.</p> <p>For further details about Authorino features in general, check the docs.</p> <p></p>"},{"location":"authorino/docs/user-guides/oauth2-token-introspection/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC)</li> <li>OAuth 2.0 server that implements the token introspection endpoint (RFC 7662) (e.g. Keycloak or a12n-server)</li> <li>jq, to extract parts of JSON responses</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p>Deploy a Keycloak server preloaded with the realm settings required for this guide:</p> <pre><code>kubectl create namespace keycloak\nkubectl -n keycloak apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/keycloak/keycloak-deploy.yaml\n</code></pre> <p>Deploy an a12n-server server preloaded with all settings required for this guide:</p> <pre><code>kubectl create namespace a12n-server\nkubectl -n a12n-server apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/a12n-server/a12n-server-deploy.yaml\n</code></pre> <p></p> <p>The next steps walk you through installing Authorino, deploying and configuring a sample service called Talker API to be protected by the authorization service.</p> Using Kuadrant <p>If you are a user of Kuadrant and already have your workload cluster configured and sample service application deployed, as well as your Gateway API network resources applied to route traffic to your service, skip straight to step \u277a.</p> <p>At step \u277a, instead of creating an <code>AuthConfig</code> custom resource, create a Kuadrant <code>AuthPolicy</code> one. The schema of the AuthConfig's <code>spec</code> matches the one of the AuthPolicy's, except <code>spec.host</code>, which is not available in the Kuadrant AuthPolicy. Host names in a Kuadrant AuthPolicy are inferred automatically from the Kubernetes network object referred in <code>spec.targetRef</code> and route selectors declared in the policy.</p> <p>For more about using Kuadrant to enforce authorization, check out Kuadrant auth.</p> <p></p>"},{"location":"authorino/docs/user-guides/oauth2-token-introspection/#install-the-authorino-operator-cluster-admin-required","title":"\u2776 Install the Authorino Operator (cluster admin required)","text":"<p>The following command will install the Authorino Operator in the Kubernetes cluster. The operator manages instances of the Authorino authorization service.</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/oauth2-token-introspection/#deploy-authorino","title":"\u2777 Deploy Authorino","text":"<p>The following command will request an instance of Authorino as a separate service<sup>1</sup> that watches for <code>AuthConfig</code> resources in the <code>default</code> namespace<sup>2</sup>, with TLS disabled<sup>3</sup>.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/oauth2-token-introspection/#deploy-the-talker-api","title":"\u2778 Deploy the Talker API","text":"<p>The Talker API is a simple HTTP service that echoes back in the response whatever it gets in the request. We will use it in this guide as the sample service to be protected by Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/docs/user-guides/oauth2-token-introspection/#setup-envoy","title":"\u2779 Setup Envoy","text":"<p>The following bundle from the Authorino examples deploys the Envoy proxy and configuration to wire up the Talker API behind the reverse-proxy, with external authorization enabled with the Authorino instance.<sup>4</sup></p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The command above creates an <code>Ingress</code> with host name <code>talker-api.127.0.0.1.nip.io</code>. If you are using a local Kubernetes cluster created with Kind, forward requests from your local port 8000 to the Envoy service running inside the cluster:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre>"},{"location":"authorino/docs/user-guides/oauth2-token-introspection/#create-an-authconfig","title":"\u277a Create an <code>AuthConfig</code>","text":"<p>Create the required secrets that will be used by Authorino to authenticate with Keycloak and a12n-server during the introspection request:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: oauth2-token-introspection-credentials-keycloak\nstringData:\n  clientID: talker-api\n  clientSecret: 523b92b6-625d-4e1e-a313-77e7a8ae4e88\ntype: Opaque\n---\napiVersion: v1\nkind: Secret\nmetadata:\n  name: oauth2-token-introspection-credentials-a12n-server\nstringData:\n  clientID: talker-api\n  clientSecret: V6g-2Eq2ALB1_WHAswzoeZofJ_e86RI4tdjClDDDb4g\ntype: Opaque\nEOF\n</code></pre> <p>Create the Authorino <code>AuthConfig</code> custom resource declaring the auth rules to be enforced:</p> Kuadrant users \u2013         Remember to create an <code>AuthPolicy</code> instead of an AuthConfig.         For more, see Kuadrant auth.        <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n\n  - talker-api.127.0.0.1.nip.io\n  authentication:\n    \"keycloak\":\n      oauth2Introspection:\n        endpoint: http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant/protocol/openid-connect/token/introspect\n        tokenTypeHint: requesting_party_token\n        credentialsRef:\n          name: oauth2-token-introspection-credentials-keycloak\n    \"a12n-server\":\n      oauth2Introspection:\n        endpoint: http://a12n-server.a12n-server.svc.cluster.local:8531/introspect\n        credentialsRef:\n          name: oauth2-token-introspection-credentials-a12n-server\n  authorization:\n    \"can-read\":\n      when:\n      - selector: auth.identity.privileges\n        operator: neq\n        value: \"\"\n      patternMatching:\n        patterns:\n        - selector: auth.identity.privileges.talker-api\n          operator: incl\n          value: read\nEOF\n</code></pre> <p>On every request, Authorino will try to verify the token remotely with the Keycloak server and the a12n-server server.</p> <p>For authorization, whenever the introspected token data includes a <code>privileges</code> property (returned by a12n-server), Authorino will enforce only consumers whose <code>privileges.talker-api</code> includes the <code>\"read\"</code> permission are granted access.</p> <p>Check out the docs for information about the common feature Conditions about skipping parts of an <code>AuthConfig</code> in the auth pipeline based on context.</p>"},{"location":"authorino/docs/user-guides/oauth2-token-introspection/#obtain-an-access-token-and-consume-the-api","title":"\u277b Obtain an access token and consume the API","text":""},{"location":"authorino/docs/user-guides/oauth2-token-introspection/#obtain-an-access-token-with-keycloak-and-consume-the-api","title":"Obtain an access token with Keycloak and consume the API","text":"<p>Obtain an access token with the Keycloak server for user Jane:</p> <p>The <code>AuthConfig</code> deployed in the previous step is suitable for validating access tokens requested inside the cluster. This is because Keycloak's <code>iss</code> claim added to the JWTs matches always the host used to request the token and Authorino will later try to match this host to the host that provides the OpenID Connect configuration.</p> <p>Obtain an access token from within the cluster for the user Jane, whose e-mail has been verified:</p> <pre><code>export $(kubectl run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant/protocol/openid-connect/token -s -d 'grant_type=password' -d 'client_id=demo' -d 'username=jane' -d 'password=p' -d 'scope=openid' | jq -r '\"ACCESS_TOKEN=\"+.access_token,\"REFRESH_TOKEN=\"+.refresh_token')\n</code></pre> <p>If your Keycloak server is reachable from outside the cluster, feel free to obtain the token directly. Make sure the host name set in the OIDC issuer endpoint in the <code>AuthConfig</code> matches the one used to obtain the token and is as well reachable from within the cluster.</p> <p>As user Jane, consume the API:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api.127.0.0.1.nip.io:8000/hello\n# HTTP/1.1 200 OK\n</code></pre> <p>Revoke the access token and try to consume the API again:</p> <pre><code>kubectl run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant/protocol/openid-connect/logout -H \"Content-Type: application/x-www-form-urlencoded\" -d \"refresh_token=$REFRESH_TOKEN\" -d 'token_type_hint=requesting_party_token' -u demo:\n</code></pre> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 401 Unauthorized\n# www-authenticate: Bearer realm=\"keycloak\"\n# www-authenticate: Bearer realm=\"a12n-server\"\n# x-ext-auth-reason: {\"a12n-server\":\"token is not active\",\"keycloak\":\"token is not active\"}\n</code></pre>"},{"location":"authorino/docs/user-guides/oauth2-token-introspection/#obtain-an-access-token-with-a12n-server-and-consume-the-api","title":"Obtain an access token with a12n-server and consume the API","text":"<p>Forward local requests to a12n-server instance running in the cluster:</p> <pre><code>kubectl -n a12n-server port-forward deployment/a12n-server 8531:8531 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre> <p>Obtain an access token with the a12n-server server for service account <code>service-account-1</code>:</p> <pre><code>ACCESS_TOKEN=$(curl -d 'grant_type=client_credentials' -u service-account-1:FO6LgoMKA8TBDDHgSXZ5-iq1wKNwqdDkyeEGIl6gp0s \"http://localhost:8531/token\" | jq -r .access_token)\n</code></pre> <p>You can as well obtain an access token from within the cluster, in case your a12n-server is not reachable from the outside:</p> <pre><code>ACCESS_TOKEN=$(kubectl run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://a12n-server.a12n-server.svc.cluster.local:8531/token -s -d 'grant_type=client_credentials' -u service-account-1:FO6LgoMKA8TBDDHgSXZ5-iq1wKNwqdDkyeEGIl6gp0s | jq -r .access_token)\n</code></pre> <p>Verify the issued token is an opaque access token in this case:</p> <pre><code>echo $ACCESS_TOKEN\n</code></pre> <p>As <code>service-account-1</code>, consumer the API with a valid access token:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api.127.0.0.1.nip.io:8000/hello\n# HTTP/1.1 200 OK\n</code></pre> <p>Revoke the access token and try to consume the API again:</p> <pre><code>curl -d \"token=$ACCESS_TOKEN\" -u service-account-1:FO6LgoMKA8TBDDHgSXZ5-iq1wKNwqdDkyeEGIl6gp0s \"http://localhost:8531/revoke\" -i\n</code></pre> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 401 Unauthorized\n# www-authenticate: Bearer realm=\"keycloak\"\n# www-authenticate: Bearer realm=\"a12n-server\"\n# x-ext-auth-reason: {\"a12n-server\":\"token is not active\",\"keycloak\":\"token is not active\"}\n</code></pre>"},{"location":"authorino/docs/user-guides/oauth2-token-introspection/#consume-the-api-with-a-missing-or-invalid-access-token","title":"Consume the API with a missing or invalid access token","text":"<pre><code>curl -H \"Authorization: Bearer invalid\" http://talker-api.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 401 Unauthorized\n# www-authenticate: Bearer realm=\"keycloak\"\n# www-authenticate: Bearer realm=\"a12n-server\"\n# x-ext-auth-reason: {\"a12n-server\":\"token is not active\",\"keycloak\":\"token is not active\"}\n</code></pre>"},{"location":"authorino/docs/user-guides/oauth2-token-introspection/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete authconfig/talker-api-protection\nkubectl delete secret/oauth2-token-introspection-credentials-keycloak\nkubectl delete secret/oauth2-token-introspection-credentials-a12n-server\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\nkubectl delete authorino/authorino\nkubectl delete namespace keycloak\nkubectl delete namespace a12n-server\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <ol> <li> <p>In contrast to a dedicated sidecar of the protected service and other architectures. Check out Architecture &gt; Topologies for all options.\u00a0\u21a9</p> </li> <li> <p><code>namespaced</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> <li> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. If you are running your ingress gateway in Kubernetes and wants to avoid setting up and configuring your proxy manually, check out Kuadrant.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/observability/","title":"Observability","text":""},{"location":"authorino/docs/user-guides/observability/#metrics","title":"Metrics","text":"<p>Authorino exports metrics at 2 endpoints:</p> /metrics Metrics of the controller-runtime about reconciliation (caching) of AuthConfigs and API key Secrets /server-metrics Metrics of the external authorization gRPC and OIDC/Festival Wristband validation built-in HTTP servers <p>The Authorino Operator creates a Kubernetes <code>Service</code> named <code>&lt;authorino-cr-name&gt;-controller-metrics</code> that exposes the endpoints on port 8080. The Authorino instance allows to modify the port number of the metrics endpoints, by setting the <code>--metrics-addr</code> command-line flag (default: <code>:8080</code>).</p> <p>Main metrics exported by endpoint<sup>1</sup>:</p> Endpoint: <code>/metrics</code> Metric name Description\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Labels Type controller_runtime_reconcile_total Total number of reconciliations per controller <code>controller=authconfig|secret</code>, <code>result=success|error|requeue</code> counter controller_runtime_reconcile_errors_total Total number of reconciliation errors per controller <code>controller=authconfig|secret</code> counter controller_runtime_reconcile_time_seconds Length of time per reconciliation per controller <code>controller=authconfig|secret</code> histogram controller_runtime_max_concurrent_reconciles Maximum number of concurrent reconciles per controller <code>controller=authconfig|secret</code> gauge workqueue_adds_total Total number of adds handled by workqueue <code>name=authconfig|secret</code> counter workqueue_depth Current depth of workqueue <code>name=authconfig|secret</code> gauge workqueue_queue_duration_seconds How long in seconds an item stays in workqueue before being requested <code>name=authconfig|secret</code> histogram workqueue_longest_running_processor_seconds How many seconds has the longest running processor for workqueue been running. <code>name=authconfig|secret</code> gauge workqueue_retries_total Total number of retries handled by workqueue <code>name=authconfig|secret</code> counter workqueue_unfinished_work_seconds How many seconds of work has been done that is in progress and hasn't been observed by work_duration. <code>name=authconfig|secret</code> gauge workqueue_work_duration_seconds How long in seconds processing an item from workqueue takes. <code>name=authconfig|secret</code> histogram rest_client_requests_total Number of HTTP requests, partitioned by status code, method, and host. <code>code=200|404</code>, <code>method=GET|PUT|POST</code> counter Endpoint: <code>/server-metrics</code> Metric name Description Labels Type auth_server_evaluator_total<sup>2</sup> Total number of evaluations of individual authconfig rule performed by the auth server. <code>namespace</code>, <code>authconfig</code>, <code>evaluator_type</code>, <code>evaluator_name</code> counter auth_server_evaluator_cancelled<sup>2</sup> Number of evaluations of individual authconfig rule cancelled by the auth server. <code>namespace</code>, <code>authconfig</code>, <code>evaluator_type</code>, <code>evaluator_name</code> counter auth_server_evaluator_ignored<sup>2</sup> Number of evaluations of individual authconfig rule ignored by the auth server. <code>namespace</code>, <code>authconfig</code>, <code>evaluator_type</code>, <code>evaluator_name</code> counter auth_server_evaluator_denied<sup>2</sup> Number of denials from individual authconfig rule evaluated by the auth server. <code>namespace</code>, <code>authconfig</code>, <code>evaluator_type</code>, <code>evaluator_name</code> counter auth_server_evaluator_duration_seconds<sup>2</sup> Response latency of individual authconfig rule evaluated by the auth server (in seconds). <code>namespace</code>, <code>authconfig</code>, <code>evaluator_type</code>, <code>evaluator_name</code> histogram auth_server_authconfig_total Total number of authconfigs enforced by the auth server, partitioned by authconfig. <code>namespace</code>, <code>authconfig</code> counter auth_server_authconfig_response_status Response status of authconfigs sent by the auth server, partitioned by authconfig. <code>namespace</code>, <code>authconfig</code>, <code>status=OK|UNAUTHENTICATED,PERMISSION_DENIED</code> counter auth_server_authconfig_duration_seconds Response latency of authconfig enforced by the auth server (in seconds). <code>namespace</code>, <code>authconfig</code> histogram auth_server_response_status Response status of authconfigs sent by the auth server. <code>status=OK|UNAUTHENTICATED,PERMISSION_DENIED|NOT_FOUND</code> counter grpc_server_handled_total Total number of RPCs completed on the server, regardless of success or failure. <code>grpc_code=OK|Aborted|Canceled|DeadlineExceeded|Internal|ResourceExhausted|Unknown</code>, <code>grpc_method=Check</code>, <code>grpc_service=envoy.service.auth.v3.Authorization</code> counter grpc_server_handling_seconds Response latency (seconds) of gRPC that had been application-level handled by the server. <code>grpc_method=Check</code>, <code>grpc_service=envoy.service.auth.v3.Authorization</code> histogram grpc_server_msg_received_total Total number of RPC stream messages received on the server. <code>grpc_method=Check</code>, <code>grpc_service=envoy.service.auth.v3.Authorization</code> counter grpc_server_msg_sent_total Total number of gRPC stream messages sent by the server. <code>grpc_method=Check</code>, <code>grpc_service=envoy.service.auth.v3.Authorization</code> counter grpc_server_started_total Total number of RPCs started on the server. <code>grpc_method=Check</code>, <code>grpc_service=envoy.service.auth.v3.Authorization</code> counter http_server_handled_total Total number of calls completed on the raw HTTP authorization server, regardless of success or failure. <code>http_code</code> counter http_server_handling_seconds Response latency (seconds) of raw HTTP authorization request that had been application-level handled by the server. histogram oidc_server_requests_total Number of get requests received on the OIDC (Festival Wristband) server. <code>namespace</code>, <code>authconfig</code>, <code>wristband</code>, <code>path=oidc-config|jwks</code> counter oidc_server_response_status Status of HTTP response sent by the OIDC (Festival Wristband) server. <code>status=200|404</code> counter <p><sup>1</sup> Both endpoints export metrics about the Go runtime, such as number of goroutines (go_goroutines) and threads (go_threads), usage of CPU, memory and GC stats.</p> <p><sup>2</sup> Opt-in metrics: <code>auth_server_evaluator_*</code> metrics require <code>authconfig.spec.(identity|metadata|authorization|response).metrics: true</code> (default: <code>false</code>). This can be enforced for the entire instance (all AuthConfigs and evaluators), by setting the <code>--deep-metrics-enabled</code> command-line flag in the Authorino deployment.</p> Example of metrics exported at the <code>/metrics</code> endpoint <pre><code># HELP controller_runtime_active_workers Number of currently used workers per controller\n# TYPE controller_runtime_active_workers gauge\ncontroller_runtime_active_workers{controller=\"authconfig\"} 0\ncontroller_runtime_active_workers{controller=\"secret\"} 0\n# HELP controller_runtime_max_concurrent_reconciles Maximum number of concurrent reconciles per controller\n# TYPE controller_runtime_max_concurrent_reconciles gauge\ncontroller_runtime_max_concurrent_reconciles{controller=\"authconfig\"} 1\ncontroller_runtime_max_concurrent_reconciles{controller=\"secret\"} 1\n# HELP controller_runtime_reconcile_errors_total Total number of reconciliation errors per controller\n# TYPE controller_runtime_reconcile_errors_total counter\ncontroller_runtime_reconcile_errors_total{controller=\"authconfig\"} 12\ncontroller_runtime_reconcile_errors_total{controller=\"secret\"} 0\n# HELP controller_runtime_reconcile_time_seconds Length of time per reconciliation per controller\n# TYPE controller_runtime_reconcile_time_seconds histogram\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"0.005\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"0.01\"} 11\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"0.025\"} 17\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"0.05\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"0.1\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"0.15\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"0.2\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"0.25\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"0.3\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"0.35\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"0.4\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"0.45\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"0.5\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"0.6\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"0.7\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"0.8\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"0.9\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"1\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"1.25\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"1.5\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"1.75\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"2\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"2.5\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"3\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"3.5\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"4\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"4.5\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"5\"} 19\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"6\"} 19\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"7\"} 19\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"8\"} 19\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"9\"} 19\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"10\"} 19\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"15\"} 19\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"20\"} 19\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"25\"} 19\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"30\"} 19\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"40\"} 19\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"50\"} 19\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"60\"} 19\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"+Inf\"} 19\ncontroller_runtime_reconcile_time_seconds_sum{controller=\"authconfig\"} 5.171108321999999\ncontroller_runtime_reconcile_time_seconds_count{controller=\"authconfig\"} 19\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"0.005\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"0.01\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"0.025\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"0.05\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"0.1\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"0.15\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"0.2\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"0.25\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"0.3\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"0.35\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"0.4\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"0.45\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"0.5\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"0.6\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"0.7\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"0.8\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"0.9\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"1\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"1.25\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"1.5\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"1.75\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"2\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"2.5\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"3\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"3.5\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"4\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"4.5\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"5\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"6\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"7\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"8\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"9\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"10\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"15\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"20\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"25\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"30\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"40\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"50\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"60\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"+Inf\"} 1\ncontroller_runtime_reconcile_time_seconds_sum{controller=\"secret\"} 0.000138025\ncontroller_runtime_reconcile_time_seconds_count{controller=\"secret\"} 1\n# HELP controller_runtime_reconcile_total Total number of reconciliations per controller\n# TYPE controller_runtime_reconcile_total counter\ncontroller_runtime_reconcile_total{controller=\"authconfig\",result=\"error\"} 12\ncontroller_runtime_reconcile_total{controller=\"authconfig\",result=\"requeue\"} 0\ncontroller_runtime_reconcile_total{controller=\"authconfig\",result=\"requeue_after\"} 0\ncontroller_runtime_reconcile_total{controller=\"authconfig\",result=\"success\"} 7\ncontroller_runtime_reconcile_total{controller=\"secret\",result=\"error\"} 0\ncontroller_runtime_reconcile_total{controller=\"secret\",result=\"requeue\"} 0\ncontroller_runtime_reconcile_total{controller=\"secret\",result=\"requeue_after\"} 0\ncontroller_runtime_reconcile_total{controller=\"secret\",result=\"success\"} 1\n# HELP go_gc_cycles_automatic_gc_cycles_total Count of completed GC cycles generated by the Go runtime.\n# TYPE go_gc_cycles_automatic_gc_cycles_total counter\ngo_gc_cycles_automatic_gc_cycles_total 13\n# HELP go_gc_cycles_forced_gc_cycles_total Count of completed GC cycles forced by the application.\n# TYPE go_gc_cycles_forced_gc_cycles_total counter\ngo_gc_cycles_forced_gc_cycles_total 0\n# HELP go_gc_cycles_total_gc_cycles_total Count of all completed GC cycles.\n# TYPE go_gc_cycles_total_gc_cycles_total counter\ngo_gc_cycles_total_gc_cycles_total 13\n# HELP go_gc_duration_seconds A summary of the pause duration of garbage collection cycles.\n# TYPE go_gc_duration_seconds summary\ngo_gc_duration_seconds{quantile=\"0\"} 4.5971e-05\ngo_gc_duration_seconds{quantile=\"0.25\"} 5.69e-05\ngo_gc_duration_seconds{quantile=\"0.5\"} 0.000140699\ngo_gc_duration_seconds{quantile=\"0.75\"} 0.000313162\ngo_gc_duration_seconds{quantile=\"1\"} 0.001692423\ngo_gc_duration_seconds_sum 0.003671076\ngo_gc_duration_seconds_count 13\n# HELP go_gc_heap_allocs_by_size_bytes_total Distribution of heap allocations by approximate size. Note that this does not include tiny objects as defined by /gc/heap/tiny/allocs:objects, only tiny blocks.\n# TYPE go_gc_heap_allocs_by_size_bytes_total histogram\ngo_gc_heap_allocs_by_size_bytes_total_bucket{le=\"8.999999999999998\"} 6357\ngo_gc_heap_allocs_by_size_bytes_total_bucket{le=\"16.999999999999996\"} 45065\n[...]\ngo_gc_heap_allocs_by_size_bytes_total_bucket{le=\"32768.99999999999\"} 128306\ngo_gc_heap_allocs_by_size_bytes_total_bucket{le=\"+Inf\"} 128327\ngo_gc_heap_allocs_by_size_bytes_total_sum 1.5021512e+07\ngo_gc_heap_allocs_by_size_bytes_total_count 128327\n# HELP go_gc_heap_allocs_bytes_total Cumulative sum of memory allocated to the heap by the application.\n# TYPE go_gc_heap_allocs_bytes_total counter\ngo_gc_heap_allocs_bytes_total 1.5021512e+07\n# HELP go_gc_heap_allocs_objects_total Cumulative count of heap allocations triggered by the application. Note that this does not include tiny objects as defined by /gc/heap/tiny/allocs:objects, only tiny blocks.\n# TYPE go_gc_heap_allocs_objects_total counter\ngo_gc_heap_allocs_objects_total 128327\n# HELP go_gc_heap_frees_by_size_bytes_total Distribution of freed heap allocations by approximate size. Note that this does not include tiny objects as defined by /gc/heap/tiny/allocs:objects, only tiny blocks.\n# TYPE go_gc_heap_frees_by_size_bytes_total histogram\ngo_gc_heap_frees_by_size_bytes_total_bucket{le=\"8.999999999999998\"} 3885\ngo_gc_heap_frees_by_size_bytes_total_bucket{le=\"16.999999999999996\"} 33418\n[...]\ngo_gc_heap_frees_by_size_bytes_total_bucket{le=\"32768.99999999999\"} 96417\ngo_gc_heap_frees_by_size_bytes_total_bucket{le=\"+Inf\"} 96425\ngo_gc_heap_frees_by_size_bytes_total_sum 9.880944e+06\ngo_gc_heap_frees_by_size_bytes_total_count 96425\n# HELP go_gc_heap_frees_bytes_total Cumulative sum of heap memory freed by the garbage collector.\n# TYPE go_gc_heap_frees_bytes_total counter\ngo_gc_heap_frees_bytes_total 9.880944e+06\n# HELP go_gc_heap_frees_objects_total Cumulative count of heap allocations whose storage was freed by the garbage collector. Note that this does not include tiny objects as defined by /gc/heap/tiny/allocs:objects, only tiny blocks.\n# TYPE go_gc_heap_frees_objects_total counter\ngo_gc_heap_frees_objects_total 96425\n# HELP go_gc_heap_goal_bytes Heap size target for the end of the GC cycle.\n# TYPE go_gc_heap_goal_bytes gauge\ngo_gc_heap_goal_bytes 9.356624e+06\n# HELP go_gc_heap_objects_objects Number of objects, live or unswept, occupying heap memory.\n# TYPE go_gc_heap_objects_objects gauge\ngo_gc_heap_objects_objects 31902\n# HELP go_gc_heap_tiny_allocs_objects_total Count of small allocations that are packed together into blocks. These allocations are counted separately from other allocations because each individual allocation is not tracked by the runtime, only their block. Each block is already accounted for in allocs-by-size and frees-by-size.\n# TYPE go_gc_heap_tiny_allocs_objects_total counter\ngo_gc_heap_tiny_allocs_objects_total 11750\n# HELP go_gc_pauses_seconds_total Distribution individual GC-related stop-the-world pause latencies.\n# TYPE go_gc_pauses_seconds_total histogram\ngo_gc_pauses_seconds_total_bucket{le=\"9.999999999999999e-10\"} 0\ngo_gc_pauses_seconds_total_bucket{le=\"1.9999999999999997e-09\"} 0\n[...]\ngo_gc_pauses_seconds_total_bucket{le=\"206708.18602188796\"} 26\ngo_gc_pauses_seconds_total_bucket{le=\"+Inf\"} 26\ngo_gc_pauses_seconds_total_sum 0.003151488\ngo_gc_pauses_seconds_total_count 26\n# HELP go_goroutines Number of goroutines that currently exist.\n# TYPE go_goroutines gauge\ngo_goroutines 80\n# HELP go_info Information about the Go environment.\n# TYPE go_info gauge\ngo_info{version=\"go1.18.7\"} 1\n# HELP go_memory_classes_heap_free_bytes Memory that is completely free and eligible to be returned to the underlying system, but has not been. This metric is the runtime's estimate of free address space that is backed by physical memory.\n# TYPE go_memory_classes_heap_free_bytes gauge\ngo_memory_classes_heap_free_bytes 589824\n# HELP go_memory_classes_heap_objects_bytes Memory occupied by live objects and dead objects that have not yet been marked free by the garbage collector.\n# TYPE go_memory_classes_heap_objects_bytes gauge\ngo_memory_classes_heap_objects_bytes 5.140568e+06\n# HELP go_memory_classes_heap_released_bytes Memory that is completely free and has been returned to the underlying system. This metric is the runtime's estimate of free address space that is still mapped into the process, but is not backed by physical memory.\n# TYPE go_memory_classes_heap_released_bytes gauge\ngo_memory_classes_heap_released_bytes 4.005888e+06\n# HELP go_memory_classes_heap_stacks_bytes Memory allocated from the heap that is reserved for stack space, whether or not it is currently in-use.\n# TYPE go_memory_classes_heap_stacks_bytes gauge\ngo_memory_classes_heap_stacks_bytes 786432\n# HELP go_memory_classes_heap_unused_bytes Memory that is reserved for heap objects but is not currently used to hold heap objects.\n# TYPE go_memory_classes_heap_unused_bytes gauge\ngo_memory_classes_heap_unused_bytes 2.0602e+06\n# HELP go_memory_classes_metadata_mcache_free_bytes Memory that is reserved for runtime mcache structures, but not in-use.\n# TYPE go_memory_classes_metadata_mcache_free_bytes gauge\ngo_memory_classes_metadata_mcache_free_bytes 13984\n# HELP go_memory_classes_metadata_mcache_inuse_bytes Memory that is occupied by runtime mcache structures that are currently being used.\n# TYPE go_memory_classes_metadata_mcache_inuse_bytes gauge\ngo_memory_classes_metadata_mcache_inuse_bytes 2400\n# HELP go_memory_classes_metadata_mspan_free_bytes Memory that is reserved for runtime mspan structures, but not in-use.\n# TYPE go_memory_classes_metadata_mspan_free_bytes gauge\ngo_memory_classes_metadata_mspan_free_bytes 17104\n# HELP go_memory_classes_metadata_mspan_inuse_bytes Memory that is occupied by runtime mspan structures that are currently being used.\n# TYPE go_memory_classes_metadata_mspan_inuse_bytes gauge\ngo_memory_classes_metadata_mspan_inuse_bytes 113968\n# HELP go_memory_classes_metadata_other_bytes Memory that is reserved for or used to hold runtime metadata.\n# TYPE go_memory_classes_metadata_other_bytes gauge\ngo_memory_classes_metadata_other_bytes 5.544408e+06\n# HELP go_memory_classes_os_stacks_bytes Stack memory allocated by the underlying operating system.\n# TYPE go_memory_classes_os_stacks_bytes gauge\ngo_memory_classes_os_stacks_bytes 0\n# HELP go_memory_classes_other_bytes Memory used by execution trace buffers, structures for debugging the runtime, finalizer and profiler specials, and more.\n# TYPE go_memory_classes_other_bytes gauge\ngo_memory_classes_other_bytes 537777\n# HELP go_memory_classes_profiling_buckets_bytes Memory that is used by the stack trace hash map used for profiling.\n# TYPE go_memory_classes_profiling_buckets_bytes gauge\ngo_memory_classes_profiling_buckets_bytes 1.455487e+06\n# HELP go_memory_classes_total_bytes All memory mapped by the Go runtime into the current process as read-write. Note that this does not include memory mapped by code called via cgo or via the syscall package. Sum of all metrics in /memory/classes.\n# TYPE go_memory_classes_total_bytes gauge\ngo_memory_classes_total_bytes 2.026804e+07\n# HELP go_memstats_alloc_bytes Number of bytes allocated and still in use.\n# TYPE go_memstats_alloc_bytes gauge\ngo_memstats_alloc_bytes 5.140568e+06\n# HELP go_memstats_alloc_bytes_total Total number of bytes allocated, even if freed.\n# TYPE go_memstats_alloc_bytes_total counter\ngo_memstats_alloc_bytes_total 1.5021512e+07\n# HELP go_memstats_buck_hash_sys_bytes Number of bytes used by the profiling bucket hash table.\n# TYPE go_memstats_buck_hash_sys_bytes gauge\ngo_memstats_buck_hash_sys_bytes 1.455487e+06\n# HELP go_memstats_frees_total Total number of frees.\n# TYPE go_memstats_frees_total counter\ngo_memstats_frees_total 108175\n# HELP go_memstats_gc_cpu_fraction The fraction of this program's available CPU time used by the GC since the program started.\n# TYPE go_memstats_gc_cpu_fraction gauge\ngo_memstats_gc_cpu_fraction 0\n# HELP go_memstats_gc_sys_bytes Number of bytes used for garbage collection system metadata.\n# TYPE go_memstats_gc_sys_bytes gauge\ngo_memstats_gc_sys_bytes 5.544408e+06\n# HELP go_memstats_heap_alloc_bytes Number of heap bytes allocated and still in use.\n# TYPE go_memstats_heap_alloc_bytes gauge\ngo_memstats_heap_alloc_bytes 5.140568e+06\n# HELP go_memstats_heap_idle_bytes Number of heap bytes waiting to be used.\n# TYPE go_memstats_heap_idle_bytes gauge\ngo_memstats_heap_idle_bytes 4.595712e+06\n# HELP go_memstats_heap_inuse_bytes Number of heap bytes that are in use.\n# TYPE go_memstats_heap_inuse_bytes gauge\ngo_memstats_heap_inuse_bytes 7.200768e+06\n# HELP go_memstats_heap_objects Number of allocated objects.\n# TYPE go_memstats_heap_objects gauge\ngo_memstats_heap_objects 31902\n# HELP go_memstats_heap_released_bytes Number of heap bytes released to OS.\n# TYPE go_memstats_heap_released_bytes gauge\ngo_memstats_heap_released_bytes 4.005888e+06\n# HELP go_memstats_heap_sys_bytes Number of heap bytes obtained from system.\n# TYPE go_memstats_heap_sys_bytes gauge\ngo_memstats_heap_sys_bytes 1.179648e+07\n# HELP go_memstats_last_gc_time_seconds Number of seconds since 1970 of last garbage collection.\n# TYPE go_memstats_last_gc_time_seconds gauge\ngo_memstats_last_gc_time_seconds 1.6461572121033354e+09\n# HELP go_memstats_lookups_total Total number of pointer lookups.\n# TYPE go_memstats_lookups_total counter\ngo_memstats_lookups_total 0\n# HELP go_memstats_mallocs_total Total number of mallocs.\n# TYPE go_memstats_mallocs_total counter\ngo_memstats_mallocs_total 140077\n# HELP go_memstats_mcache_inuse_bytes Number of bytes in use by mcache structures.\n# TYPE go_memstats_mcache_inuse_bytes gauge\ngo_memstats_mcache_inuse_bytes 2400\n# HELP go_memstats_mcache_sys_bytes Number of bytes used for mcache structures obtained from system.\n# TYPE go_memstats_mcache_sys_bytes gauge\ngo_memstats_mcache_sys_bytes 16384\n# HELP go_memstats_mspan_inuse_bytes Number of bytes in use by mspan structures.\n# TYPE go_memstats_mspan_inuse_bytes gauge\ngo_memstats_mspan_inuse_bytes 113968\n# HELP go_memstats_mspan_sys_bytes Number of bytes used for mspan structures obtained from system.\n# TYPE go_memstats_mspan_sys_bytes gauge\ngo_memstats_mspan_sys_bytes 131072\n# HELP go_memstats_next_gc_bytes Number of heap bytes when next garbage collection will take place.\n# TYPE go_memstats_next_gc_bytes gauge\ngo_memstats_next_gc_bytes 9.356624e+06\n# HELP go_memstats_other_sys_bytes Number of bytes used for other system allocations.\n# TYPE go_memstats_other_sys_bytes gauge\ngo_memstats_other_sys_bytes 537777\n# HELP go_memstats_stack_inuse_bytes Number of bytes in use by the stack allocator.\n# TYPE go_memstats_stack_inuse_bytes gauge\ngo_memstats_stack_inuse_bytes 786432\n# HELP go_memstats_stack_sys_bytes Number of bytes obtained from system for stack allocator.\n# TYPE go_memstats_stack_sys_bytes gauge\ngo_memstats_stack_sys_bytes 786432\n# HELP go_memstats_sys_bytes Number of bytes obtained from system.\n# TYPE go_memstats_sys_bytes gauge\ngo_memstats_sys_bytes 2.026804e+07\n# HELP go_sched_goroutines_goroutines Count of live goroutines.\n# TYPE go_sched_goroutines_goroutines gauge\ngo_sched_goroutines_goroutines 80\n# HELP go_sched_latencies_seconds Distribution of the time goroutines have spent in the scheduler in a runnable state before actually running.\n# TYPE go_sched_latencies_seconds histogram\ngo_sched_latencies_seconds_bucket{le=\"9.999999999999999e-10\"} 244\ngo_sched_latencies_seconds_bucket{le=\"1.9999999999999997e-09\"} 244\n[...]\ngo_sched_latencies_seconds_bucket{le=\"206708.18602188796\"} 2336\ngo_sched_latencies_seconds_bucket{le=\"+Inf\"} 2336\ngo_sched_latencies_seconds_sum 0.18509832400000004\ngo_sched_latencies_seconds_count 2336\n# HELP go_threads Number of OS threads created.\n# TYPE go_threads gauge\ngo_threads 8\n# HELP process_cpu_seconds_total Total user and system CPU time spent in seconds.\n# TYPE process_cpu_seconds_total counter\nprocess_cpu_seconds_total 1.84\n# HELP process_max_fds Maximum number of open file descriptors.\n# TYPE process_max_fds gauge\nprocess_max_fds 1.048576e+06\n# HELP process_open_fds Number of open file descriptors.\n# TYPE process_open_fds gauge\nprocess_open_fds 14\n# HELP process_resident_memory_bytes Resident memory size in bytes.\n# TYPE process_resident_memory_bytes gauge\nprocess_resident_memory_bytes 4.3728896e+07\n# HELP process_start_time_seconds Start time of the process since unix epoch in seconds.\n# TYPE process_start_time_seconds gauge\nprocess_start_time_seconds 1.64615612779e+09\n# HELP process_virtual_memory_bytes Virtual memory size in bytes.\n# TYPE process_virtual_memory_bytes gauge\nprocess_virtual_memory_bytes 7.65362176e+08\n# HELP process_virtual_memory_max_bytes Maximum amount of virtual memory available in bytes.\n# TYPE process_virtual_memory_max_bytes gauge\nprocess_virtual_memory_max_bytes 1.8446744073709552e+19\n# HELP rest_client_requests_total Number of HTTP requests, partitioned by status code, method, and host.\n# TYPE rest_client_requests_total counter\nrest_client_requests_total{code=\"200\",host=\"10.96.0.1:443\",method=\"GET\"} 114\nrest_client_requests_total{code=\"200\",host=\"10.96.0.1:443\",method=\"PUT\"} 4\n# HELP workqueue_adds_total Total number of adds handled by workqueue\n# TYPE workqueue_adds_total counter\nworkqueue_adds_total{name=\"authconfig\"} 19\nworkqueue_adds_total{name=\"secret\"} 1\n# HELP workqueue_depth Current depth of workqueue\n# TYPE workqueue_depth gauge\nworkqueue_depth{name=\"authconfig\"} 0\nworkqueue_depth{name=\"secret\"} 0\n# HELP workqueue_longest_running_processor_seconds How many seconds has the longest running processor for workqueue been running.\n# TYPE workqueue_longest_running_processor_seconds gauge\nworkqueue_longest_running_processor_seconds{name=\"authconfig\"} 0\nworkqueue_longest_running_processor_seconds{name=\"secret\"} 0\n# HELP workqueue_queue_duration_seconds How long in seconds an item stays in workqueue before being requested\n# TYPE workqueue_queue_duration_seconds histogram\nworkqueue_queue_duration_seconds_bucket{name=\"authconfig\",le=\"1e-08\"} 0\nworkqueue_queue_duration_seconds_bucket{name=\"authconfig\",le=\"1e-07\"} 0\nworkqueue_queue_duration_seconds_bucket{name=\"authconfig\",le=\"1e-06\"} 0\nworkqueue_queue_duration_seconds_bucket{name=\"authconfig\",le=\"9.999999999999999e-06\"} 8\nworkqueue_queue_duration_seconds_bucket{name=\"authconfig\",le=\"9.999999999999999e-05\"} 17\nworkqueue_queue_duration_seconds_bucket{name=\"authconfig\",le=\"0.001\"} 17\nworkqueue_queue_duration_seconds_bucket{name=\"authconfig\",le=\"0.01\"} 17\nworkqueue_queue_duration_seconds_bucket{name=\"authconfig\",le=\"0.1\"} 18\nworkqueue_queue_duration_seconds_bucket{name=\"authconfig\",le=\"1\"} 18\nworkqueue_queue_duration_seconds_bucket{name=\"authconfig\",le=\"10\"} 19\nworkqueue_queue_duration_seconds_bucket{name=\"authconfig\",le=\"+Inf\"} 19\nworkqueue_queue_duration_seconds_sum{name=\"authconfig\"} 4.969016371\nworkqueue_queue_duration_seconds_count{name=\"authconfig\"} 19\nworkqueue_queue_duration_seconds_bucket{name=\"secret\",le=\"1e-08\"} 0\nworkqueue_queue_duration_seconds_bucket{name=\"secret\",le=\"1e-07\"} 0\nworkqueue_queue_duration_seconds_bucket{name=\"secret\",le=\"1e-06\"} 0\nworkqueue_queue_duration_seconds_bucket{name=\"secret\",le=\"9.999999999999999e-06\"} 1\nworkqueue_queue_duration_seconds_bucket{name=\"secret\",le=\"9.999999999999999e-05\"} 1\nworkqueue_queue_duration_seconds_bucket{name=\"secret\",le=\"0.001\"} 1\nworkqueue_queue_duration_seconds_bucket{name=\"secret\",le=\"0.01\"} 1\nworkqueue_queue_duration_seconds_bucket{name=\"secret\",le=\"0.1\"} 1\nworkqueue_queue_duration_seconds_bucket{name=\"secret\",le=\"1\"} 1\nworkqueue_queue_duration_seconds_bucket{name=\"secret\",le=\"10\"} 1\nworkqueue_queue_duration_seconds_bucket{name=\"secret\",le=\"+Inf\"} 1\nworkqueue_queue_duration_seconds_sum{name=\"secret\"} 4.67e-06\nworkqueue_queue_duration_seconds_count{name=\"secret\"} 1\n# HELP workqueue_retries_total Total number of retries handled by workqueue\n# TYPE workqueue_retries_total counter\nworkqueue_retries_total{name=\"authconfig\"} 12\nworkqueue_retries_total{name=\"secret\"} 0\n# HELP workqueue_unfinished_work_seconds How many seconds of work has been done that is in progress and hasn't been observed by work_duration. Large values indicate stuck threads. One can deduce the number of stuck threads by observing the rate at which this increases.\n# TYPE workqueue_unfinished_work_seconds gauge\nworkqueue_unfinished_work_seconds{name=\"authconfig\"} 0\nworkqueue_unfinished_work_seconds{name=\"secret\"} 0\n# HELP workqueue_work_duration_seconds How long in seconds processing an item from workqueue takes.\n# TYPE workqueue_work_duration_seconds histogram\nworkqueue_work_duration_seconds_bucket{name=\"authconfig\",le=\"1e-08\"} 0\nworkqueue_work_duration_seconds_bucket{name=\"authconfig\",le=\"1e-07\"} 0\nworkqueue_work_duration_seconds_bucket{name=\"authconfig\",le=\"1e-06\"} 0\nworkqueue_work_duration_seconds_bucket{name=\"authconfig\",le=\"9.999999999999999e-06\"} 0\nworkqueue_work_duration_seconds_bucket{name=\"authconfig\",le=\"9.999999999999999e-05\"} 0\nworkqueue_work_duration_seconds_bucket{name=\"authconfig\",le=\"0.001\"} 0\nworkqueue_work_duration_seconds_bucket{name=\"authconfig\",le=\"0.01\"} 11\nworkqueue_work_duration_seconds_bucket{name=\"authconfig\",le=\"0.1\"} 18\nworkqueue_work_duration_seconds_bucket{name=\"authconfig\",le=\"1\"} 18\nworkqueue_work_duration_seconds_bucket{name=\"authconfig\",le=\"10\"} 19\nworkqueue_work_duration_seconds_bucket{name=\"authconfig\",le=\"+Inf\"} 19\nworkqueue_work_duration_seconds_sum{name=\"authconfig\"} 5.171738079000001\nworkqueue_work_duration_seconds_count{name=\"authconfig\"} 19\nworkqueue_work_duration_seconds_bucket{name=\"secret\",le=\"1e-08\"} 0\nworkqueue_work_duration_seconds_bucket{name=\"secret\",le=\"1e-07\"} 0\nworkqueue_work_duration_seconds_bucket{name=\"secret\",le=\"1e-06\"} 0\nworkqueue_work_duration_seconds_bucket{name=\"secret\",le=\"9.999999999999999e-06\"} 0\nworkqueue_work_duration_seconds_bucket{name=\"secret\",le=\"9.999999999999999e-05\"} 0\nworkqueue_work_duration_seconds_bucket{name=\"secret\",le=\"0.001\"} 1\nworkqueue_work_duration_seconds_bucket{name=\"secret\",le=\"0.01\"} 1\nworkqueue_work_duration_seconds_bucket{name=\"secret\",le=\"0.1\"} 1\nworkqueue_work_duration_seconds_bucket{name=\"secret\",le=\"1\"} 1\nworkqueue_work_duration_seconds_bucket{name=\"secret\",le=\"10\"} 1\nworkqueue_work_duration_seconds_bucket{name=\"secret\",le=\"+Inf\"} 1\nworkqueue_work_duration_seconds_sum{name=\"secret\"} 0.000150956\nworkqueue_work_duration_seconds_count{name=\"secret\"} 1\n</code></pre> Example of metrics exported at the <code>/server-metrics</code> endpoint <pre><code># HELP auth_server_authconfig_duration_seconds Response latency of authconfig enforced by the auth server (in seconds).\n# TYPE auth_server_authconfig_duration_seconds histogram\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.001\"} 0\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.051000000000000004\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.101\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.15100000000000002\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.201\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.251\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.301\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.351\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.40099999999999997\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.45099999999999996\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.501\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.551\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.6010000000000001\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.6510000000000001\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.7010000000000002\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.7510000000000002\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.8010000000000003\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.8510000000000003\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.9010000000000004\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.9510000000000004\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"+Inf\"} 1\nauth_server_authconfig_duration_seconds_sum{authconfig=\"edge-auth\",namespace=\"authorino\"} 0.001701795\nauth_server_authconfig_duration_seconds_count{authconfig=\"edge-auth\",namespace=\"authorino\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.001\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.051000000000000004\"} 4\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.101\"} 4\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.15100000000000002\"} 5\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.201\"} 5\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.251\"} 5\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.301\"} 5\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.351\"} 5\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.40099999999999997\"} 5\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.45099999999999996\"} 5\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.501\"} 5\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.551\"} 5\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.6010000000000001\"} 5\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.6510000000000001\"} 5\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.7010000000000002\"} 5\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.7510000000000002\"} 5\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.8010000000000003\"} 5\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.8510000000000003\"} 5\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.9010000000000004\"} 5\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.9510000000000004\"} 5\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"+Inf\"} 5\nauth_server_authconfig_duration_seconds_sum{authconfig=\"talker-api-protection\",namespace=\"authorino\"} 0.26967658299999997\nauth_server_authconfig_duration_seconds_count{authconfig=\"talker-api-protection\",namespace=\"authorino\"} 5\n# HELP auth_server_authconfig_response_status Response status of authconfigs sent by the auth server, partitioned by authconfig.\n# TYPE auth_server_authconfig_response_status counter\nauth_server_authconfig_response_status{authconfig=\"edge-auth\",namespace=\"authorino\",status=\"OK\"} 1\nauth_server_authconfig_response_status{authconfig=\"talker-api-protection\",namespace=\"authorino\",status=\"OK\"} 2\nauth_server_authconfig_response_status{authconfig=\"talker-api-protection\",namespace=\"authorino\",status=\"PERMISSION_DENIED\"} 2\nauth_server_authconfig_response_status{authconfig=\"talker-api-protection\",namespace=\"authorino\",status=\"UNAUTHENTICATED\"} 1\n# HELP auth_server_authconfig_total Total number of authconfigs enforced by the auth server, partitioned by authconfig.\n# TYPE auth_server_authconfig_total counter\nauth_server_authconfig_total{authconfig=\"edge-auth\",namespace=\"authorino\"} 1\nauth_server_authconfig_total{authconfig=\"talker-api-protection\",namespace=\"authorino\"} 5\n# HELP auth_server_evaluator_duration_seconds Response latency of individual authconfig rule evaluated by the auth server (in seconds).\n# TYPE auth_server_evaluator_duration_seconds histogram\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.001\"} 0\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.051000000000000004\"} 3\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.101\"} 3\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.15100000000000002\"} 4\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.201\"} 4\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.251\"} 4\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.301\"} 4\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.351\"} 4\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.40099999999999997\"} 4\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.45099999999999996\"} 4\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.501\"} 4\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.551\"} 4\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.6010000000000001\"} 4\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.6510000000000001\"} 4\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.7010000000000002\"} 4\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.7510000000000002\"} 4\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.8010000000000003\"} 4\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.8510000000000003\"} 4\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.9010000000000004\"} 4\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.9510000000000004\"} 4\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"+Inf\"} 4\nauth_server_evaluator_duration_seconds_sum{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\"} 0.25800055\nauth_server_evaluator_duration_seconds_count{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\"} 4\n# HELP auth_server_evaluator_total Total number of evaluations of individual authconfig rule performed by the auth server.\n# TYPE auth_server_evaluator_total counter\nauth_server_evaluator_total{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\"} 4\n# HELP auth_server_response_status Response status of authconfigs sent by the auth server.\n# TYPE auth_server_response_status counter\nauth_server_response_status{status=\"NOT_FOUND\"} 1\nauth_server_response_status{status=\"OK\"} 3\nauth_server_response_status{status=\"PERMISSION_DENIED\"} 2\nauth_server_response_status{status=\"UNAUTHENTICATED\"} 1\n# HELP go_gc_cycles_automatic_gc_cycles_total Count of completed GC cycles generated by the Go runtime.\n# TYPE go_gc_cycles_automatic_gc_cycles_total counter\ngo_gc_cycles_automatic_gc_cycles_total 11\n# HELP go_gc_cycles_forced_gc_cycles_total Count of completed GC cycles forced by the application.\n# TYPE go_gc_cycles_forced_gc_cycles_total counter\ngo_gc_cycles_forced_gc_cycles_total 0\n# HELP go_gc_cycles_total_gc_cycles_total Count of all completed GC cycles.\n# TYPE go_gc_cycles_total_gc_cycles_total counter\ngo_gc_cycles_total_gc_cycles_total 11\n# HELP go_gc_duration_seconds A summary of the pause duration of garbage collection cycles.\n# TYPE go_gc_duration_seconds summary\ngo_gc_duration_seconds{quantile=\"0\"} 4.5971e-05\ngo_gc_duration_seconds{quantile=\"0.25\"} 5.69e-05\ngo_gc_duration_seconds{quantile=\"0.5\"} 0.000158594\ngo_gc_duration_seconds{quantile=\"0.75\"} 0.000324091\ngo_gc_duration_seconds{quantile=\"1\"} 0.001692423\ngo_gc_duration_seconds_sum 0.003546711\ngo_gc_duration_seconds_count 11\n# HELP go_gc_heap_allocs_by_size_bytes_total Distribution of heap allocations by approximate size. Note that this does not include tiny objects as defined by /gc/heap/tiny/allocs:objects, only tiny blocks.\n# TYPE go_gc_heap_allocs_by_size_bytes_total histogram\ngo_gc_heap_allocs_by_size_bytes_total_bucket{le=\"8.999999999999998\"} 6261\ngo_gc_heap_allocs_by_size_bytes_total_bucket{le=\"16.999999999999996\"} 42477\n[...]\ngo_gc_heap_allocs_by_size_bytes_total_bucket{le=\"32768.99999999999\"} 122133\ngo_gc_heap_allocs_by_size_bytes_total_bucket{le=\"+Inf\"} 122154\ngo_gc_heap_allocs_by_size_bytes_total_sum 1.455944e+07\ngo_gc_heap_allocs_by_size_bytes_total_count 122154\n# HELP go_gc_heap_allocs_bytes_total Cumulative sum of memory allocated to the heap by the application.\n# TYPE go_gc_heap_allocs_bytes_total counter\ngo_gc_heap_allocs_bytes_total 1.455944e+07\n# HELP go_gc_heap_allocs_objects_total Cumulative count of heap allocations triggered by the application. Note that this does not include tiny objects as defined by /gc/heap/tiny/allocs:objects, only tiny blocks.\n# TYPE go_gc_heap_allocs_objects_total counter\ngo_gc_heap_allocs_objects_total 122154\n# HELP go_gc_heap_frees_by_size_bytes_total Distribution of freed heap allocations by approximate size. Note that this does not include tiny objects as defined by /gc/heap/tiny/allocs:objects, only tiny blocks.\n# TYPE go_gc_heap_frees_by_size_bytes_total histogram\ngo_gc_heap_frees_by_size_bytes_total_bucket{le=\"8.999999999999998\"} 3789\ngo_gc_heap_frees_by_size_bytes_total_bucket{le=\"16.999999999999996\"} 31067\n[...]\ngo_gc_heap_frees_by_size_bytes_total_bucket{le=\"32768.99999999999\"} 91013\ngo_gc_heap_frees_by_size_bytes_total_bucket{le=\"+Inf\"} 91021\ngo_gc_heap_frees_by_size_bytes_total_sum 9.399936e+06\ngo_gc_heap_frees_by_size_bytes_total_count 91021\n# HELP go_gc_heap_frees_bytes_total Cumulative sum of heap memory freed by the garbage collector.\n# TYPE go_gc_heap_frees_bytes_total counter\ngo_gc_heap_frees_bytes_total 9.399936e+06\n# HELP go_gc_heap_frees_objects_total Cumulative count of heap allocations whose storage was freed by the garbage collector. Note that this does not include tiny objects as defined by /gc/heap/tiny/allocs:objects, only tiny blocks.\n# TYPE go_gc_heap_frees_objects_total counter\ngo_gc_heap_frees_objects_total 91021\n# HELP go_gc_heap_goal_bytes Heap size target for the end of the GC cycle.\n# TYPE go_gc_heap_goal_bytes gauge\ngo_gc_heap_goal_bytes 9.601744e+06\n# HELP go_gc_heap_objects_objects Number of objects, live or unswept, occupying heap memory.\n# TYPE go_gc_heap_objects_objects gauge\ngo_gc_heap_objects_objects 31133\n# HELP go_gc_heap_tiny_allocs_objects_total Count of small allocations that are packed together into blocks. These allocations are counted separately from other allocations because each individual allocation is not tracked by the runtime, only their block. Each block is already accounted for in allocs-by-size and frees-by-size.\n# TYPE go_gc_heap_tiny_allocs_objects_total counter\ngo_gc_heap_tiny_allocs_objects_total 9866\n# HELP go_gc_pauses_seconds_total Distribution individual GC-related stop-the-world pause latencies.\n# TYPE go_gc_pauses_seconds_total histogram\ngo_gc_pauses_seconds_total_bucket{le=\"9.999999999999999e-10\"} 0\ngo_gc_pauses_seconds_total_bucket{le=\"1.9999999999999997e-09\"} 0\n[...]\ngo_gc_pauses_seconds_total_bucket{le=\"206708.18602188796\"} 22\ngo_gc_pauses_seconds_total_bucket{le=\"+Inf\"} 22\ngo_gc_pauses_seconds_total_sum 0.0030393599999999996\ngo_gc_pauses_seconds_total_count 22\n# HELP go_goroutines Number of goroutines that currently exist.\n# TYPE go_goroutines gauge\ngo_goroutines 79\n# HELP go_info Information about the Go environment.\n# TYPE go_info gauge\ngo_info{version=\"go1.18.7\"} 1\n# HELP go_memory_classes_heap_free_bytes Memory that is completely free and eligible to be returned to the underlying system, but has not been. This metric is the runtime's estimate of free address space that is backed by physical memory.\n# TYPE go_memory_classes_heap_free_bytes gauge\ngo_memory_classes_heap_free_bytes 630784\n# HELP go_memory_classes_heap_objects_bytes Memory occupied by live objects and dead objects that have not yet been marked free by the garbage collector.\n# TYPE go_memory_classes_heap_objects_bytes gauge\ngo_memory_classes_heap_objects_bytes 5.159504e+06\n# HELP go_memory_classes_heap_released_bytes Memory that is completely free and has been returned to the underlying system. This metric is the runtime's estimate of free address space that is still mapped into the process, but is not backed by physical memory.\n# TYPE go_memory_classes_heap_released_bytes gauge\ngo_memory_classes_heap_released_bytes 3.858432e+06\n# HELP go_memory_classes_heap_stacks_bytes Memory allocated from the heap that is reserved for stack space, whether or not it is currently in-use.\n# TYPE go_memory_classes_heap_stacks_bytes gauge\ngo_memory_classes_heap_stacks_bytes 786432\n# HELP go_memory_classes_heap_unused_bytes Memory that is reserved for heap objects but is not currently used to hold heap objects.\n# TYPE go_memory_classes_heap_unused_bytes gauge\ngo_memory_classes_heap_unused_bytes 2.14776e+06\n# HELP go_memory_classes_metadata_mcache_free_bytes Memory that is reserved for runtime mcache structures, but not in-use.\n# TYPE go_memory_classes_metadata_mcache_free_bytes gauge\ngo_memory_classes_metadata_mcache_free_bytes 13984\n# HELP go_memory_classes_metadata_mcache_inuse_bytes Memory that is occupied by runtime mcache structures that are currently being used.\n# TYPE go_memory_classes_metadata_mcache_inuse_bytes gauge\ngo_memory_classes_metadata_mcache_inuse_bytes 2400\n# HELP go_memory_classes_metadata_mspan_free_bytes Memory that is reserved for runtime mspan structures, but not in-use.\n# TYPE go_memory_classes_metadata_mspan_free_bytes gauge\ngo_memory_classes_metadata_mspan_free_bytes 16696\n# HELP go_memory_classes_metadata_mspan_inuse_bytes Memory that is occupied by runtime mspan structures that are currently being used.\n# TYPE go_memory_classes_metadata_mspan_inuse_bytes gauge\ngo_memory_classes_metadata_mspan_inuse_bytes 114376\n# HELP go_memory_classes_metadata_other_bytes Memory that is reserved for or used to hold runtime metadata.\n# TYPE go_memory_classes_metadata_other_bytes gauge\ngo_memory_classes_metadata_other_bytes 5.544408e+06\n# HELP go_memory_classes_os_stacks_bytes Stack memory allocated by the underlying operating system.\n# TYPE go_memory_classes_os_stacks_bytes gauge\ngo_memory_classes_os_stacks_bytes 0\n# HELP go_memory_classes_other_bytes Memory used by execution trace buffers, structures for debugging the runtime, finalizer and profiler specials, and more.\n# TYPE go_memory_classes_other_bytes gauge\ngo_memory_classes_other_bytes 537777\n# HELP go_memory_classes_profiling_buckets_bytes Memory that is used by the stack trace hash map used for profiling.\n# TYPE go_memory_classes_profiling_buckets_bytes gauge\ngo_memory_classes_profiling_buckets_bytes 1.455487e+06\n# HELP go_memory_classes_total_bytes All memory mapped by the Go runtime into the current process as read-write. Note that this does not include memory mapped by code called via cgo or via the syscall package. Sum of all metrics in /memory/classes.\n# TYPE go_memory_classes_total_bytes gauge\ngo_memory_classes_total_bytes 2.026804e+07\n# HELP go_memstats_alloc_bytes Number of bytes allocated and still in use.\n# TYPE go_memstats_alloc_bytes gauge\ngo_memstats_alloc_bytes 5.159504e+06\n# HELP go_memstats_alloc_bytes_total Total number of bytes allocated, even if freed.\n# TYPE go_memstats_alloc_bytes_total counter\ngo_memstats_alloc_bytes_total 1.455944e+07\n# HELP go_memstats_buck_hash_sys_bytes Number of bytes used by the profiling bucket hash table.\n# TYPE go_memstats_buck_hash_sys_bytes gauge\ngo_memstats_buck_hash_sys_bytes 1.455487e+06\n# HELP go_memstats_frees_total Total number of frees.\n# TYPE go_memstats_frees_total counter\ngo_memstats_frees_total 100887\n# HELP go_memstats_gc_cpu_fraction The fraction of this program's available CPU time used by the GC since the program started.\n# TYPE go_memstats_gc_cpu_fraction gauge\ngo_memstats_gc_cpu_fraction 0\n# HELP go_memstats_gc_sys_bytes Number of bytes used for garbage collection system metadata.\n# TYPE go_memstats_gc_sys_bytes gauge\ngo_memstats_gc_sys_bytes 5.544408e+06\n# HELP go_memstats_heap_alloc_bytes Number of heap bytes allocated and still in use.\n# TYPE go_memstats_heap_alloc_bytes gauge\ngo_memstats_heap_alloc_bytes 5.159504e+06\n# HELP go_memstats_heap_idle_bytes Number of heap bytes waiting to be used.\n# TYPE go_memstats_heap_idle_bytes gauge\ngo_memstats_heap_idle_bytes 4.489216e+06\n# HELP go_memstats_heap_inuse_bytes Number of heap bytes that are in use.\n# TYPE go_memstats_heap_inuse_bytes gauge\ngo_memstats_heap_inuse_bytes 7.307264e+06\n# HELP go_memstats_heap_objects Number of allocated objects.\n# TYPE go_memstats_heap_objects gauge\ngo_memstats_heap_objects 31133\n# HELP go_memstats_heap_released_bytes Number of heap bytes released to OS.\n# TYPE go_memstats_heap_released_bytes gauge\ngo_memstats_heap_released_bytes 3.858432e+06\n# HELP go_memstats_heap_sys_bytes Number of heap bytes obtained from system.\n# TYPE go_memstats_heap_sys_bytes gauge\ngo_memstats_heap_sys_bytes 1.179648e+07\n# HELP go_memstats_last_gc_time_seconds Number of seconds since 1970 of last garbage collection.\n# TYPE go_memstats_last_gc_time_seconds gauge\ngo_memstats_last_gc_time_seconds 1.6461569717723043e+09\n# HELP go_memstats_lookups_total Total number of pointer lookups.\n# TYPE go_memstats_lookups_total counter\ngo_memstats_lookups_total 0\n# HELP go_memstats_mallocs_total Total number of mallocs.\n# TYPE go_memstats_mallocs_total counter\ngo_memstats_mallocs_total 132020\n# HELP go_memstats_mcache_inuse_bytes Number of bytes in use by mcache structures.\n# TYPE go_memstats_mcache_inuse_bytes gauge\ngo_memstats_mcache_inuse_bytes 2400\n# HELP go_memstats_mcache_sys_bytes Number of bytes used for mcache structures obtained from system.\n# TYPE go_memstats_mcache_sys_bytes gauge\ngo_memstats_mcache_sys_bytes 16384\n# HELP go_memstats_mspan_inuse_bytes Number of bytes in use by mspan structures.\n# TYPE go_memstats_mspan_inuse_bytes gauge\ngo_memstats_mspan_inuse_bytes 114376\n# HELP go_memstats_mspan_sys_bytes Number of bytes used for mspan structures obtained from system.\n# TYPE go_memstats_mspan_sys_bytes gauge\ngo_memstats_mspan_sys_bytes 131072\n# HELP go_memstats_next_gc_bytes Number of heap bytes when next garbage collection will take place.\n# TYPE go_memstats_next_gc_bytes gauge\ngo_memstats_next_gc_bytes 9.601744e+06\n# HELP go_memstats_other_sys_bytes Number of bytes used for other system allocations.\n# TYPE go_memstats_other_sys_bytes gauge\ngo_memstats_other_sys_bytes 537777\n# HELP go_memstats_stack_inuse_bytes Number of bytes in use by the stack allocator.\n# TYPE go_memstats_stack_inuse_bytes gauge\ngo_memstats_stack_inuse_bytes 786432\n# HELP go_memstats_stack_sys_bytes Number of bytes obtained from system for stack allocator.\n# TYPE go_memstats_stack_sys_bytes gauge\ngo_memstats_stack_sys_bytes 786432\n# HELP go_memstats_sys_bytes Number of bytes obtained from system.\n# TYPE go_memstats_sys_bytes gauge\ngo_memstats_sys_bytes 2.026804e+07\n# HELP go_sched_goroutines_goroutines Count of live goroutines.\n# TYPE go_sched_goroutines_goroutines gauge\ngo_sched_goroutines_goroutines 79\n# HELP go_sched_latencies_seconds Distribution of the time goroutines have spent in the scheduler in a runnable state before actually running.\n# TYPE go_sched_latencies_seconds histogram\ngo_sched_latencies_seconds_bucket{le=\"9.999999999999999e-10\"} 225\ngo_sched_latencies_seconds_bucket{le=\"1.9999999999999997e-09\"} 225\n[...]\ngo_sched_latencies_seconds_bucket{le=\"206708.18602188796\"} 1916\ngo_sched_latencies_seconds_bucket{le=\"+Inf\"} 1916\ngo_sched_latencies_seconds_sum 0.18081453600000003\ngo_sched_latencies_seconds_count 1916\n# HELP go_threads Number of OS threads created.\n# TYPE go_threads gauge\ngo_threads 8\n# HELP grpc_server_handled_total Total number of RPCs completed on the server, regardless of success or failure.\n# TYPE grpc_server_handled_total counter\ngrpc_server_handled_total{grpc_code=\"Aborted\",grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"Aborted\",grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"Aborted\",grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\ngrpc_server_handled_total{grpc_code=\"AlreadyExists\",grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"AlreadyExists\",grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"AlreadyExists\",grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\ngrpc_server_handled_total{grpc_code=\"Canceled\",grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"Canceled\",grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"Canceled\",grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\ngrpc_server_handled_total{grpc_code=\"DataLoss\",grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"DataLoss\",grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"DataLoss\",grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\ngrpc_server_handled_total{grpc_code=\"DeadlineExceeded\",grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"DeadlineExceeded\",grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"DeadlineExceeded\",grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\ngrpc_server_handled_total{grpc_code=\"FailedPrecondition\",grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"FailedPrecondition\",grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"FailedPrecondition\",grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\ngrpc_server_handled_total{grpc_code=\"Internal\",grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"Internal\",grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"Internal\",grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\ngrpc_server_handled_total{grpc_code=\"InvalidArgument\",grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"InvalidArgument\",grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"InvalidArgument\",grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\ngrpc_server_handled_total{grpc_code=\"NotFound\",grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"NotFound\",grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"NotFound\",grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\ngrpc_server_handled_total{grpc_code=\"OK\",grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 7\ngrpc_server_handled_total{grpc_code=\"OK\",grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"OK\",grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\ngrpc_server_handled_total{grpc_code=\"OutOfRange\",grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"OutOfRange\",grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"OutOfRange\",grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\ngrpc_server_handled_total{grpc_code=\"PermissionDenied\",grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"PermissionDenied\",grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"PermissionDenied\",grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\ngrpc_server_handled_total{grpc_code=\"ResourceExhausted\",grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"ResourceExhausted\",grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"ResourceExhausted\",grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\ngrpc_server_handled_total{grpc_code=\"Unauthenticated\",grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"Unauthenticated\",grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"Unauthenticated\",grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\ngrpc_server_handled_total{grpc_code=\"Unavailable\",grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"Unavailable\",grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"Unavailable\",grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\ngrpc_server_handled_total{grpc_code=\"Unimplemented\",grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"Unimplemented\",grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"Unimplemented\",grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\ngrpc_server_handled_total{grpc_code=\"Unknown\",grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"Unknown\",grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"Unknown\",grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\n# HELP grpc_server_handling_seconds Histogram of response latency (seconds) of gRPC that had been application-level handled by the server.\n# TYPE grpc_server_handling_seconds histogram\ngrpc_server_handling_seconds_bucket{grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\",le=\"0.005\"} 3\ngrpc_server_handling_seconds_bucket{grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\",le=\"0.01\"} 3\ngrpc_server_handling_seconds_bucket{grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\",le=\"0.025\"} 3\ngrpc_server_handling_seconds_bucket{grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\",le=\"0.05\"} 6\ngrpc_server_handling_seconds_bucket{grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\",le=\"0.1\"} 6\ngrpc_server_handling_seconds_bucket{grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\",le=\"0.25\"} 7\ngrpc_server_handling_seconds_bucket{grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\",le=\"0.5\"} 7\ngrpc_server_handling_seconds_bucket{grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\",le=\"1\"} 7\ngrpc_server_handling_seconds_bucket{grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\",le=\"2.5\"} 7\ngrpc_server_handling_seconds_bucket{grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\",le=\"5\"} 7\ngrpc_server_handling_seconds_bucket{grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\",le=\"10\"} 7\ngrpc_server_handling_seconds_bucket{grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\",le=\"+Inf\"} 7\ngrpc_server_handling_seconds_sum{grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 0.277605516\ngrpc_server_handling_seconds_count{grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 7\n# HELP grpc_server_msg_received_total Total number of RPC stream messages received on the server.\n# TYPE grpc_server_msg_received_total counter\ngrpc_server_msg_received_total{grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 7\ngrpc_server_msg_received_total{grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_msg_received_total{grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\n# HELP grpc_server_msg_sent_total Total number of gRPC stream messages sent by the server.\n# TYPE grpc_server_msg_sent_total counter\ngrpc_server_msg_sent_total{grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 7\ngrpc_server_msg_sent_total{grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_msg_sent_total{grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\n# HELP grpc_server_started_total Total number of RPCs started on the server.\n# TYPE grpc_server_started_total counter\ngrpc_server_started_total{grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 7\ngrpc_server_started_total{grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_started_total{grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\n# HELP oidc_server_requests_total Number of get requests received on the OIDC (Festival Wristband) server.\n# TYPE oidc_server_requests_total counter\noidc_server_requests_total{authconfig=\"edge-auth\",namespace=\"authorino\",path=\"/.well-known/openid-configuration\",wristband=\"wristband\"} 1\noidc_server_requests_total{authconfig=\"edge-auth\",namespace=\"authorino\",path=\"/.well-known/openid-connect/certs\",wristband=\"wristband\"} 1\n# HELP oidc_server_response_status Status of HTTP response sent by the OIDC (Festival Wristband) server.\n# TYPE oidc_server_response_status counter\noidc_server_response_status{status=\"200\"} 2\n# HELP process_cpu_seconds_total Total user and system CPU time spent in seconds.\n# TYPE process_cpu_seconds_total counter\nprocess_cpu_seconds_total 1.42\n# HELP process_max_fds Maximum number of open file descriptors.\n# TYPE process_max_fds gauge\nprocess_max_fds 1.048576e+06\n# HELP process_open_fds Number of open file descriptors.\n# TYPE process_open_fds gauge\nprocess_open_fds 14\n# HELP process_resident_memory_bytes Resident memory size in bytes.\n# TYPE process_resident_memory_bytes gauge\nprocess_resident_memory_bytes 4.370432e+07\n# HELP process_start_time_seconds Start time of the process since unix epoch in seconds.\n# TYPE process_start_time_seconds gauge\nprocess_start_time_seconds 1.64615612779e+09\n# HELP process_virtual_memory_bytes Virtual memory size in bytes.\n# TYPE process_virtual_memory_bytes gauge\nprocess_virtual_memory_bytes 7.65362176e+08\n# HELP process_virtual_memory_max_bytes Maximum amount of virtual memory available in bytes.\n# TYPE process_virtual_memory_max_bytes gauge\nprocess_virtual_memory_max_bytes 1.8446744073709552e+19\n# HELP promhttp_metric_handler_requests_in_flight Current number of scrapes being served.\n# TYPE promhttp_metric_handler_requests_in_flight gauge\npromhttp_metric_handler_requests_in_flight 1\n# HELP promhttp_metric_handler_requests_total Total number of scrapes by HTTP status code.\n# TYPE promhttp_metric_handler_requests_total counter\npromhttp_metric_handler_requests_total{code=\"200\"} 1\npromhttp_metric_handler_requests_total{code=\"500\"} 0\npromhttp_metric_handler_requests_total{code=\"503\"} 0\n</code></pre>"},{"location":"authorino/docs/user-guides/observability/#readiness-check","title":"Readiness check","text":"<p>Authorino exposes two main endpoints for health and readiness check of the AuthConfig controller:</p> <ul> <li><code>/healthz</code>: Health probe (ping) \u2013 reports \"ok\" if the controller is healthy.</li> <li><code>/readyz</code>: Readiness probe \u2013 reports \"ok\" if the controller is ready to reconcile AuthConfig-related events.</li> </ul> <p>In general, the endpoints return either <code>200</code> (\"ok\", i.e. all checks have passed) or <code>500</code> (when one or more checks failed).</p> <p>The default binding network address is <code>:8081</code>, which can be changed by setting the command-line flag <code>--health-probe-addr</code>.</p> <p>The following additional subpath is available and its corresponding check can be aggregated into the response from the main readiness probe:</p> <ul> <li><code>/readyz/authconfigs</code>: Aggregated readiness status of the AuthConfigs \u2013 reports \"ok\" if all AuthConfigs watched by the reconciler have been marked as ready.</li> </ul> Important!The AuthConfig readiness check within the scope of the aggregated readiness probe endpoint is deactivated by default \u2013 i.e. this check is an opt-in check. Sending a request to the <code>/readyz</code> endpoint without explicitly opting-in for the AuthConfigs check, by using the <code>include</code> parameter, will result in a response message that disregards the actual status of the watched AuthConfigs, possibly an \"ok\" message. To read the aggregated status of the watched AuthConfigs, either use the specific endpoint <code>/readyz/authconfigs</code> or opt-in for the check in the aggregated endpoint by sending a request to <code>/readyz?include=authconfigs</code> <p>Apart from <code>include</code> to add the aggregated status of the AuthConfigs, the following additional query string parameters are available:</p> <ul> <li><code>verbose=true|false</code> - provides more verbose response messages;</li> <li><code>exclude=(check name)</code> \u2013 to exclude a particular readiness check (for future usage).</li> </ul>"},{"location":"authorino/docs/user-guides/observability/#logging","title":"Logging","text":"<p>Authorino provides structured log messages (\"production\") or more log messages output to stdout in a more user-friendly format (\"development\" mode) and different level of logging.</p>"},{"location":"authorino/docs/user-guides/observability/#log-levels-and-log-modes","title":"Log levels and log modes","text":"<p>Authorino outputs 3 levels of log messages: (from lowest to highest level)</p> <ol> <li><code>debug</code></li> <li><code>info</code> (default)</li> <li><code>error</code></li> </ol> <p><code>info</code> logging is restricted to high-level information of the gRPC and HTTP authorization services, limiting messages to incoming request and respective outgoing response logs, with reduced details about the corresponding objects (request payload and authorization result), and without any further detailed logs of the steps in between, except for errors.</p> <p>Only <code>debug</code> logging will include processing details of each Auth Pipeline, such as intermediary requests to validate identities with external auth servers, requests to external sources of auth metadata or authorization policies.</p> <p>To configure the desired log level, set the <code>spec.logLevel</code> field of the <code>Authorino</code> custom resource (or <code>--log-level</code> command-line flag in the Authorino deployment), to one of the supported values listed above. Default log level is <code>info</code>.</p> <p>Apart from log level, Authorino can output messages to the logs in 2 different formats:</p> <ul> <li><code>production</code> (default): each line is a parseable JSON object with properties <code>{\"level\":string, \"ts\":int, \"msg\":string, \"logger\":string, extra values...}</code></li> <li><code>development</code>: more human-readable outputs, extra stack traces and logging info, plus extra values output as JSON, in the format: <code>&lt;timestamp-iso-8601&gt;\\t&lt;log-level&gt;\\t&lt;logger&gt;\\t&lt;message&gt;\\t{extra-values-as-json}</code></li> </ul> <p>To configure the desired log mode, set the <code>spec.logMode</code> field of the <code>Authorino</code> custom resource (or <code>--log-mode</code> command-line flag in the Authorino deployment), to one of the supported values listed above. Default log level is <code>production</code>.</p> <p>Example of <code>Authorino</code> custom resource with log level <code>debug</code> and log mode <code>production</code>:</p> <pre><code>apiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  logLevel: debug\n  logMode: production\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\n</code></pre>"},{"location":"authorino/docs/user-guides/observability/#sensitive-data-output-to-the-logs","title":"Sensitive data output to the logs","text":"<p>Authorino will never output HTTP headers and query string parameters to <code>info</code> log messages, as such values usually include sensitive data (e.g. access tokens, API keys and Authorino Festival Wristbands). However, <code>debug</code> log messages may include such sensitive information and those are not redacted.</p> <p>Therefore, DO NOT USE <code>debug</code> LOG LEVEL IN PRODUCTION! Instead, use either <code>info</code> or <code>error</code>.</p>"},{"location":"authorino/docs/user-guides/observability/#log-messages-printed-by-authorino","title":"Log messages printed by Authorino","text":"<p>Some log messages printed by Authorino and corresponding extra values included:</p> logger level message extra values <code>authorino</code> <code>info</code> \"setting instance base logger\" <code>min level=info\\|debug</code>, <code>mode=production\\|development</code> <code>authorino</code> <code>info</code> \"booting up authorino\" <code>version</code> <code>authorino</code> <code>debug</code> \"setting up with options\" <code>auth-config-label-selector</code>, <code>deep-metrics-enabled</code>, <code>enable-leader-election</code>, <code>evaluator-cache-size</code>, <code>ext-auth-grpc-port</code>, <code>ext-auth-http-port</code>, <code>health-probe-addr</code>, <code>log-level</code>, <code>log-mode</code>, <code>max-http-request-body-size</code>, <code>metrics-addr</code>, <code>oidc-http-port</code>, <code>oidc-tls-cert</code>, <code>oidc-tls-cert-key</code>, <code>secret-label-selector</code>, <code>timeout</code>, <code>tls-cert</code>, <code>tls-cert-key</code>, <code>watch-namespace</code> <code>authorino</code> <code>info</code> \"attempting to acquire leader lease &lt;namespace&gt;/cb88a58a.authorino.kuadrant.io...\\n\" <code>authorino</code> <code>info</code> \"successfully acquired lease &lt;namespace&gt;/cb88a58a.authorino.kuadrant.io\\n\" <code>authorino</code> <code>info</code> \"disabling grpc auth service\" <code>authorino</code> <code>info</code> \"starting grpc auth service\" <code>port</code>, <code>tls</code> <code>authorino</code> <code>error</code> \"failed to obtain port for the grpc auth service\" <code>authorino</code> <code>error</code> \"failed to load tls cert for the grpc auth\" <code>authorino</code> <code>error</code> \"failed to start grpc auth service\" <code>authorino</code> <code>info</code> \"disabling http auth service\" <code>authorino</code> <code>info</code> \"starting http auth service\" <code>port</code>, <code>tls</code> <code>authorino</code> <code>error</code> \"failed to obtain port for the http auth service\" <code>authorino</code> <code>error</code> \"failed to start http auth service\" <code>authorino</code> <code>info</code> \"disabling http oidc service\" <code>authorino</code> <code>info</code> \"starting http oidc service\" <code>port</code>, <code>tls</code> <code>authorino</code> <code>error</code> \"failed to obtain port for the http oidc service\" <code>authorino</code> <code>error</code> \"failed to start http oidc service\" <code>authorino</code> <code>info</code> \"starting manager\" <code>authorino</code> <code>error</code> \"unable to start manager\" <code>authorino</code> <code>error</code> \"unable to create controller\" <code>controller=authconfig\\|secret\\|authconfigstatusupdate</code> <code>authorino</code> <code>error</code> \"problem running manager\" <code>authorino</code> <code>info</code> \"starting status update manager\" <code>authorino</code> <code>error</code> \"unable to start status update manager\" <code>authorino</code> <code>error</code> \"problem running status update manager\" <code>authorino.controller-runtime.metrics</code> <code>info</code> \"metrics server is starting to listen\" <code>addr</code> <code>authorino.controller-runtime.manager</code> <code>info</code> \"starting metrics server\" <code>path</code> <code>authorino.controller-runtime.manager.events</code> <code>debug</code> \"Normal\" <code>object={kind=ConfigMap, apiVersion=v1}</code>, <code>reauthorino.ason=LeaderElection</code>, <code>message=\"authorino-controller-manager-* became leader\"</code> <code>authorino.controller-runtime.manager.events</code> <code>debug</code> \"Normal\" <code>object={kind=Lease, apiVersion=coordination.k8s.io/v1}</code>, <code>reauthorino.ason=LeaderElection</code>, <code>message=\"authorino-controller-manager-* became leader\"</code> <code>authorino.controller-runtime.manager.controller.authconfig</code> <code>info</code> \"resource reconciled\" <code>authconfig</code> <code>authorino.controller-runtime.manager.controller.authconfig</code> <code>info</code> \"host already taken\" <code>authconfig</code>, <code>host</code> <code>authorino.controller-runtime.manager.controller.authconfig.statusupdater</code> <code>debug</code> \"resource status did not change\" <code>authconfig</code> <code>authorino.controller-runtime.manager.controller.authconfig.statusupdater</code> <code>debug</code> \"resource status changed\" <code>authconfig</code>, <code>authconfig/status</code> <code>authorino.controller-runtime.manager.controller.authconfig.statusupdater</code> <code>error</code> \"failed to update the resource\" <code>authconfig</code> <code>authorino.controller-runtime.manager.controller.authconfig.statusupdater</code> <code>info</code> \"resource status updated\" <code>authconfig</code> <code>authorino.controller-runtime.manager.controller.secret</code> <code>info</code> \"resource reconciled\" <code>authorino.controller-runtime.manager.controller.secret</code> <code>info</code> \"could not reconcile authconfigs using api key authorino.authentication\" <code>authorino.service.oidc</code> <code>info</code> \"request received\" <code>request id</code>, <code>url</code>, <code>realm</code>, <code>config</code>, <code>path</code> <code>authorino.service.oidc</code> <code>info</code> \"response sent\" <code>request id</code> <code>authorino.service.oidc</code> <code>error</code> \"failed to serve oidc request\" <code>authorino.service.auth</code> <code>info</code> \"incoming authorization request\" <code>request id</code>, <code>object</code> <code>authorino.service.auth</code> <code>debug</code> \"incoming authorization request\" <code>request id</code>, <code>object</code> <code>authorino.service.auth</code> <code>info</code> \"outgoing authorization response\" <code>request id</code>, <code>authorized</code>, <code>response</code>, <code>object</code> <code>authorino.service.auth</code> <code>debug</code> \"outgoing authorization response\" <code>request id</code>, <code>authorized</code>, <code>response</code>, <code>object</code> <code>authorino.service.auth</code> <code>error</code> \"failed to create dynamic metadata\" <code>request id</code>, <code>object</code> <code>authorino.service.auth.authpipeline</code> <code>debug</code> \"skipping config\" <code>request id</code>, <code>config</code>, <code>reason</code> <code>authorino.service.auth.authpipeline.identity</code> <code>debug</code> \"identity validated\" <code>request id</code>, <code>config</code>, <code>object</code> <code>authorino.service.auth.authpipeline.identity</code> <code>debug</code> \"cannot validate identity\" <code>request id</code>, <code>config</code>, <code>reason</code> <code>authorino.service.auth.authpipeline.identity</code> <code>error</code> \"failed to extend identity object\" <code>request id</code>, <code>config</code>, <code>object</code> <code>authorino.service.auth.authpipeline.identity.oidc</code> <code>error</code> \"failed to discovery openid connect configuration\" <code>endpoint</code> <code>authorino.service.auth.authpipeline.identity.oidc</code> <code>debug</code> \"auto-refresh of openid connect configuration disabled\" <code>endpoint</code>, <code>reason</code> <code>authorino.service.auth.authpipeline.identity.oidc</code> <code>debug</code> \"openid connect configuration updated\" <code>endpoint</code> <code>authorino.service.auth.authpipeline.identity.oauth2</code> <code>debug</code> \"sending token introspection request\" <code>request id</code>, <code>url</code>, <code>data</code> <code>authorino.service.auth.authpipeline.identity.kubernetesauth</code> <code>debug</code> \"calling kubernetes token review api\" <code>request id</code>, <code>tokenreview</code> <code>authorino.service.auth.authpipeline.identity.apikey</code> <code>error</code> \"Something went wrong fetching the authorized credentials\" <code>authorino.service.auth.authpipeline.metadata</code> <code>debug</code> \"fetched auth metadata\" <code>request id</code>, <code>config</code>, <code>object</code> <code>authorino.service.auth.authpipeline.metadata</code> <code>debug</code> \"cannot fetch metadata\" <code>request id</code>, <code>config</code>, <code>reason</code> <code>authorino.service.auth.authpipeline.metadata.http</code> <code>debug</code> \"sending request\" <code>request id</code>, <code>method</code>, <code>url</code>, <code>headers</code> <code>authorino.service.auth.authpipeline.metadata.userinfo</code> <code>debug</code> \"fetching user info\" <code>request id</code>, <code>endpoint</code> <code>authorino.service.auth.authpipeline.metadata.uma</code> <code>debug</code> \"requesting pat\" <code>request id</code>, <code>url</code>, <code>data</code>, <code>headers</code> <code>authorino.service.auth.authpipeline.metadata.uma</code> <code>debug</code> \"querying resources by uri\" <code>request id</code>, <code>url</code> <code>authorino.service.auth.authpipeline.metadata.uma</code> <code>debug</code> \"getting resource data\" <code>request id</code>, <code>url</code> <code>authorino.service.auth.authpipeline.authorization</code> <code>debug</code> \"evaluating for input\" <code>request id</code>, <code>input</code> <code>authorino.service.auth.authpipeline.authorization</code> <code>debug</code> \"access granted\" <code>request id</code>, <code>config</code>, <code>object</code> <code>authorino.service.auth.authpipeline.authorization</code> <code>debug</code> \"access denied\" <code>request id</code>, <code>config</code>, <code>reason</code> <code>authorino.service.auth.authpipeline.authorization.opa</code> <code>error</code> \"invalid response from policy evaluation\" <code>policy</code> <code>authorino.service.auth.authpipeline.authorization.opa</code> <code>error</code> \"failed to precompile policy\" <code>policy</code> <code>authorino.service.auth.authpipeline.authorization.opa</code> <code>error</code> \"failed to download policy from external registry\" <code>policy</code>, <code>endpoint</code> <code>authorino.service.auth.authpipeline.authorization.opa</code> <code>error</code> \"failed to refresh policy from external registry\" <code>policy</code>, <code>endpoint</code> <code>authorino.service.auth.authpipeline.authorization.opa</code> <code>debug</code> \"external policy unchanged\" <code>policy</code>, <code>endpoint</code> <code>authorino.service.auth.authpipeline.authorization.opa</code> <code>debug</code> \"auto-refresh  of external policy disabled\" <code>policy</code>, <code>endpoint</code>, <code>reason</code> <code>authorino.service.auth.authpipeline.authorization.opa</code> <code>info</code> \"policy updated from external registry\" <code>policy</code>, <code>endpoint</code> <code>authorino.service.auth.authpipeline.authorization.kubernetesauthz</code> <code>debug</code> \"calling kubernetes subject access review api\" <code>request id</code>, <code>subjectaccessreview</code> <code>authorino.service.auth.authpipeline.response</code> <code>debug</code> \"dynamic response built\" <code>request id</code>, <code>config</code>, <code>object</code> <code>authorino.service.auth.authpipeline.response</code> <code>debug</code> \"cannot build dynamic response\" <code>request id</code>, <code>config</code>, <code>reason</code> <code>authorino.service.auth.http</code> <code>debug</code> \"bad request\" <code>request id</code> <code>authorino.service.auth.http</code> <code>debug</code> \"not found\" <code>request id</code> <code>authorino.service.auth.http</code> <code>debug</code> \"request body too large\" <code>request id</code> <code>authorino.service.auth.http</code> <code>debug</code> \"service unavailable\" <code>request id</code>"},{"location":"authorino/docs/user-guides/observability/#examples","title":"Examples","text":"<p>The examples below are all with <code>--log-level=debug</code> and <code>--log-mode=production</code>.</p> Booting up the service <pre><code>{\"level\":\"info\",\"ts\":\"2024-10-07T10:31:02+01:00\",\"logger\":\"authorino\",\"msg\":\"setting instance base logger\",\"min level\":\"info\",\"mode\":\"production\"}\n{\"level\":\"info\",\"ts\":\"2024-10-07T10:31:02+01:00\",\"logger\":\"authorino\",\"msg\":\"build information\",\"version\":\"v1beta3\",\"commit\":\"ae2dc8150af2e6cdb35957ba7305c4c2a76d6149\",\"dirty\":\"false\",\"cmd\":\"server\"}\n{\"level\":\"info\",\"ts\":\"2024-10-07T10:31:02+01:00\",\"logger\":\"authorino\",\"msg\":\"starting http auth service\",\"port\":5001,\"tls\":false}\n{\"level\":\"info\",\"ts\":\"2024-10-07T10:31:02+01:00\",\"logger\":\"authorino\",\"msg\":\"starting grpc auth service\",\"port\":50051,\"tls\":false}\n{\"level\":\"info\",\"ts\":\"2024-10-07T10:31:02+01:00\",\"logger\":\"authorino\",\"msg\":\"starting http oidc service\",\"port\":8083,\"tls\":false}\n{\"level\":\"info\",\"ts\":\"2024-10-07T10:31:02+01:00\",\"logger\":\"authorino\",\"msg\":\"starting reconciliation manager\"}\n{\"level\":\"info\",\"ts\":\"2024-10-07T10:31:02+01:00\",\"logger\":\"authorino\",\"msg\":\"starting server\",\"kind\":\"health probe\",\"addr\":\"[::]:8081\"}\n{\"level\":\"info\",\"ts\":\"2024-10-07T10:31:02+01:00\",\"logger\":\"authorino.controller-runtime.metrics\",\"msg\":\"Starting metrics server\"}\n{\"level\":\"info\",\"ts\":\"2024-10-07T10:31:02+01:00\",\"logger\":\"authorino.controller-runtime.metrics\",\"msg\":\"Serving metrics server\",\"bindAddress\":\":8080\",\"secure\":false}\n{\"level\":\"info\",\"ts\":\"2024-10-07T10:31:02+01:00\",\"logger\":\"authorino\",\"msg\":\"Starting EventSource\",\"controller\":\"authconfig\",\"controllerGroup\":\"authorino.kuadrant.io\",\"controllerKind\":\"AuthConfig\",\"source\":\"kind source: *v1beta3.AuthConfig\"}\n{\"level\":\"info\",\"ts\":\"2024-10-07T10:31:02+01:00\",\"logger\":\"authorino\",\"msg\":\"Starting EventSource\",\"controller\":\"secret\",\"controllerGroup\":\"\",\"controllerKind\":\"Secret\",\"source\":\"kind source: *v1.Secret\"}\n{\"level\":\"info\",\"ts\":\"2024-10-07T10:31:02+01:00\",\"logger\":\"authorino\",\"msg\":\"Starting Controller\",\"controller\":\"secret\",\"controllerGroup\":\"\",\"controllerKind\":\"Secret\"}\n{\"level\":\"info\",\"ts\":\"2024-10-07T10:31:02+01:00\",\"logger\":\"authorino\",\"msg\":\"Starting Controller\",\"controller\":\"authconfig\",\"controllerGroup\":\"authorino.kuadrant.io\",\"controllerKind\":\"AuthConfig\"}\n{\"level\":\"info\",\"ts\":\"2024-10-07T10:31:02+01:00\",\"logger\":\"authorino\",\"msg\":\"starting status update manager\"}\n{\"level\":\"info\",\"ts\":\"2024-10-07T10:31:02+01:00\",\"logger\":\"authorino\",\"msg\":\"Starting EventSource\",\"controller\":\"authconfig\",\"controllerGroup\":\"authorino.kuadrant.io\",\"controllerKind\":\"AuthConfig\",\"source\":\"kind source: *v1beta3.AuthConfig\"}\n{\"level\":\"info\",\"ts\":\"2024-10-07T10:31:02+01:00\",\"logger\":\"authorino\",\"msg\":\"Starting Controller\",\"controller\":\"authconfig\",\"controllerGroup\":\"authorino.kuadrant.io\",\"controllerKind\":\"AuthConfig\"}\n{\"level\":\"info\",\"ts\":\"2024-10-07T10:31:02+01:00\",\"logger\":\"authorino\",\"msg\":\"Starting workers\",\"controller\":\"secret\",\"controllerGroup\":\"\",\"controllerKind\":\"Secret\",\"worker count\":1}\n{\"level\":\"info\",\"ts\":\"2024-10-07T10:31:02+01:00\",\"logger\":\"authorino\",\"msg\":\"Starting workers\",\"controller\":\"authconfig\",\"controllerGroup\":\"authorino.kuadrant.io\",\"controllerKind\":\"AuthConfig\",\"worker count\":1}\n</code></pre> Reconciling an AuthConfig and 2 related API key secrets <pre><code>{\"level\":\"debug\",\"ts\":1669221208.7473805,\"logger\":\"authorino.controller-runtime.manager.controller.authconfig.statusupdater\",\"msg\":\"resource status changed\",\"authconfig\":\"default/talker-api-protection\",\"authconfig/status\":{\"conditions\":[{\"type\":\"Available\",\"status\":\"False\",\"lastTransitionTime\":\"2022-11-23T16:33:28Z\",\"reason\":\"HostsNotLinked\",\"message\":\"No hosts linked to the resource\"},{\"type\":\"Ready\",\"status\":\"False\",\"lastTransitionTime\":\"2022-11-23T16:33:28Z\",\"reason\":\"Unknown\"}],\"summary\":{\"ready\":false,\"hostsReady\":[],\"numHostsReady\":\"0/1\",\"numIdentitySources\":1,\"numMetadataSources\":0,\"numAuthorizationPolicies\":0,\"numResponseItems\":0,\"festivalWristbandEnabled\":false}}}\n{\"level\":\"info\",\"ts\":1669221208.7496614,\"logger\":\"authorino.controller-runtime.manager.controller.authconfig\",\"msg\":\"resource reconciled\",\"authconfig\":\"default/talker-api-protection\"}\n{\"level\":\"info\",\"ts\":1669221208.7532616,\"logger\":\"authorino.controller-runtime.manager.controller.authconfig\",\"msg\":\"resource reconciled\",\"authconfig\":\"default/talker-api-protection\"}\n{\"level\":\"debug\",\"ts\":1669221208.7535005,\"logger\":\"authorino.controller.secret\",\"msg\":\"adding k8s secret to the index\",\"reconciler group\":\"\",\"reconciler kind\":\"Secret\",\"name\":\"api-key-1\",\"namespace\":\"default\",\"authconfig\":\"default/talker-api-protection\",\"config\":\"friends\"}\n{\"level\":\"debug\",\"ts\":1669221208.7535596,\"logger\":\"authorino.controller.secret.apikey\",\"msg\":\"api key added\",\"reconciler group\":\"\",\"reconciler kind\":\"Secret\",\"name\":\"api-key-1\",\"namespace\":\"default\"}\n{\"level\":\"info\",\"ts\":1669221208.7536132,\"logger\":\"authorino.controller-runtime.manager.controller.secret\",\"msg\":\"resource reconciled\",\"secret\":\"default/api-key-1\"}\n{\"level\":\"info\",\"ts\":1669221208.753772,\"logger\":\"authorino.controller-runtime.manager.controller.authconfig.statusupdater\",\"msg\":\"resource status updated\",\"authconfig\":\"default/talker-api-protection\"}\n{\"level\":\"debug\",\"ts\":1669221208.753835,\"logger\":\"authorino.controller-runtime.manager.controller.authconfig.statusupdater\",\"msg\":\"resource status changed\",\"authconfig\":\"default/talker-api-protection\",\"authconfig/status\":{\"conditions\":[{\"type\":\"Available\",\"status\":\"True\",\"lastTransitionTime\":\"2022-11-23T16:33:28Z\",\"reason\":\"HostsLinked\"},{\"type\":\"Ready\",\"status\":\"True\",\"lastTransitionTime\":\"2022-11-23T16:33:28Z\",\"reason\":\"Reconciled\"}],\"summary\":{\"ready\":true,\"hostsReady\":[\"talker-api.127.0.0.1.nip.io\"],\"numHostsReady\":\"1/1\",\"numIdentitySources\":1,\"numMetadataSources\":0,\"numAuthorizationPolicies\":0,\"numResponseItems\":0,\"festivalWristbandEnabled\":false}}}\n{\"level\":\"info\",\"ts\":1669221208.7571108,\"logger\":\"authorino.controller-runtime.manager.controller.authconfig\",\"msg\":\"resource reconciled\",\"authconfig\":\"default/talker-api-protection\"}\n{\"level\":\"info\",\"ts\":1669221208.7573664,\"logger\":\"authorino.controller-runtime.manager.controller.authconfig.statusupdater\",\"msg\":\"resource status updated\",\"authconfig\":\"default/talker-api-protection\"}\n{\"level\":\"debug\",\"ts\":1669221208.757429,\"logger\":\"authorino.controller-runtime.manager.controller.authconfig.statusupdater\",\"msg\":\"resource status did not change\",\"authconfig\":\"default/talker-api-protection\"}\n{\"level\":\"debug\",\"ts\":1669221208.7586699,\"logger\":\"authorino.controller.secret\",\"msg\":\"adding k8s secret to the index\",\"reconciler group\":\"\",\"reconciler kind\":\"Secret\",\"name\":\"api-key-2\",\"namespace\":\"default\",\"authconfig\":\"default/talker-api-protection\",\"config\":\"friends\"}\n{\"level\":\"debug\",\"ts\":1669221208.7586884,\"logger\":\"authorino.controller.secret.apikey\",\"msg\":\"api key added\",\"reconciler group\":\"\",\"reconciler kind\":\"Secret\",\"name\":\"api-key-2\",\"namespace\":\"default\"}\n{\"level\":\"info\",\"ts\":1669221208.7586913,\"logger\":\"authorino.controller-runtime.manager.controller.secret\",\"msg\":\"resource reconciled\",\"secret\":\"default/api-key-2\"}\n{\"level\":\"debug\",\"ts\":1669221208.7597604,\"logger\":\"authorino.controller-runtime.manager.controller.authconfig.statusupdater\",\"msg\":\"resource status did not change\",\"authconfig\":\"default/talker-api-protection\"}\n</code></pre> Enforcing an AuthConfig with authentication based on Kubernetes tokens: <p></p> <ul> <li>identity: k8s-auth, oidc, oauth2, apikey</li> <li>metadata: http, oidc userinfo</li> <li>authorization: opa, k8s-authz</li> <li>response: wristband</li> </ul> <pre><code>{\"level\":\"info\",\"ts\":1634830460.1486168,\"logger\":\"authorino.service.auth\",\"msg\":\"incoming authorization request\",\"request id\":\"8157480586935853928\",\"object\":{\"source\":{\"address\":{\"Address\":{\"SocketAddress\":{\"address\":\"127.0.0.1\",\"PortSpecifier\":{\"PortValue\":53144}}}}},\"destination\":{\"address\":{\"Address\":{\"SocketAddress\":{\"address\":\"127.0.0.1\",\"PortSpecifier\":{\"PortValue\":8000}}}}},\"request\":{\"http\":{\"id\":\"8157480586935853928\",\"method\":\"GET\",\"path\":\"/hello\",\"host\":\"talker-api\",\"scheme\":\"http\"}}}}\n{\"level\":\"debug\",\"ts\":1634830460.1491194,\"logger\":\"authorino.service.auth\",\"msg\":\"incoming authorization request\",\"request id\":\"8157480586935853928\",\"object\":{\"source\":{\"address\":{\"Address\":{\"SocketAddress\":{\"address\":\"127.0.0.1\",\"PortSpecifier\":{\"PortValue\":53144}}}}},\"destination\":{\"address\":{\"Address\":{\"SocketAddress\":{\"address\":\"127.0.0.1\",\"PortSpecifier\":{\"PortValue\":8000}}}}},\"request\":{\"time\":{\"seconds\":1634830460,\"nanos\":147259000},\"http\":{\"id\":\"8157480586935853928\",\"method\":\"GET\",\"headers\":{\":authority\":\"talker-api\",\":method\":\"GET\",\":path\":\"/hello\",\":scheme\":\"http\",\"accept\":\"*/*\",\"authorization\":\"Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6IkRsVWJZMENyVy1sZ0tFMVRMd19pcTFUWGtTYUl6T0hyWks0VHhKYnpEZUUifQ.eyJhdWQiOlsidGFsa2VyLWFwaSJdLCJleHAiOjE2MzQ4MzEwNTEsImlhdCI6MTYzNDgzMDQ1MSwiaXNzIjoiaHR0cHM6Ly9rdWJlcm5ldGVzLmRlZmF1bHQuc3ZjLmNsdXN0ZXIubG9jYWwiLCJrdWJlcm5ldGVzLmlvIjp7Im5hbWVzcGFjZSI6ImF1dGhvcmlubyIsInNlcnZpY2VhY2NvdW50Ijp7Im5hbWUiOiJhcGktY29uc3VtZXItMSIsInVpZCI6ImI0MGY1MzFjLWVjYWItNGYzMS1hNDk2LTJlYmM3MmFkZDEyMSJ9fSwibmJmIjoxNjM0ODMwNDUxLCJzdWIiOiJzeXN0ZW06c2VydmljZWFjY291bnQ6YXV0aG9yaW5vOmFwaS1jb25zdW1lci0xIn0.PaP0vqdl5DPfErr84KfVhPdlsGAPgsw0NkDaA9rne1zXjzcO7KPPbXhFwZC-oIjSGG1HfRMSoQeCXbQz24PSATmX8l1T52a9IFeXgP7sQmXZIDbiPfTm3X09kIIlfPKHhK_f-jQwRIpMRqNgLntlZ-xXX3P1fOBBUYR8obTPAQ6NDDaLHxw2SAmHFTQWjM_DInPDemXX0mEm7nCPKifsNxHaQH4wx4CD3LCLGbCI9FHNf2Crid8mmGJXf4wzcH1VuKkpUlsmnlUgTG2bfT2lbhSF2lBmrrhTJyYk6_aA09DwL4Bf4kvG-JtCq0Bkd_XynViIsOtOnAhgmdSPkfr-oA\",\"user-agent\":\"curl/7.65.3\",\"x-envoy-internal\":\"true\",\"x-forwarded-for\":\"10.244.0.11\",\"x-forwarded-proto\":\"http\",\"x-request-id\":\"4c5d5c97-e15b-46a3-877a-d8188e09e08f\"},\"path\":\"/hello\",\"host\":\"talker-api\",\"scheme\":\"http\",\"protocol\":\"HTTP/1.1\"}},\"context_extensions\":{\"virtual_host\":\"local_service\"},\"metadata_context\":{}}}\n{\"level\":\"debug\",\"ts\":1634830460.150506,\"logger\":\"authorino.service.auth.authpipeline.identity.kubernetesauth\",\"msg\":\"calling kubernetes token review api\",\"request id\":\"8157480586935853928\",\"tokenreview\":{\"metadata\":{\"creationTimestamp\":null},\"spec\":{\"token\":\"eyJhbGciOiJSUzI1NiIsImtpZCI6IkRsVWJZMENyVy1sZ0tFMVRMd19pcTFUWGtTYUl6T0hyWks0VHhKYnpEZUUifQ.eyJhdWQiOlsidGFsa2VyLWFwaSJdLCJleHAiOjE2MzQ4MzEwNTEsImlhdCI6MTYzNDgzMDQ1MSwiaXNzIjoiaHR0cHM6Ly9rdWJlcm5ldGVzLmRlZmF1bHQuc3ZjLmNsdXN0ZXIubG9jYWwiLCJrdWJlcm5ldGVzLmlvIjp7Im5hbWVzcGFjZSI6ImF1dGhvcmlubyIsInNlcnZpY2VhY2NvdW50Ijp7Im5hbWUiOiJhcGktY29uc3VtZXItMSIsInVpZCI6ImI0MGY1MzFjLWVjYWItNGYzMS1hNDk2LTJlYmM3MmFkZDEyMSJ9fSwibmJmIjoxNjM0ODMwNDUxLCJzdWIiOiJzeXN0ZW06c2VydmljZWFjY291bnQ6YXV0aG9yaW5vOmFwaS1jb25zdW1lci0xIn0.PaP0vqdl5DPfErr84KfVhPdlsGAPgsw0NkDaA9rne1zXjzcO7KPPbXhFwZC-oIjSGG1HfRMSoQeCXbQz24PSATmX8l1T52a9IFeXgP7sQmXZIDbiPfTm3X09kIIlfPKHhK_f-jQwRIpMRqNgLntlZ-xXX3P1fOBBUYR8obTPAQ6NDDaLHxw2SAmHFTQWjM_DInPDemXX0mEm7nCPKifsNxHaQH4wx4CD3LCLGbCI9FHNf2Crid8mmGJXf4wzcH1VuKkpUlsmnlUgTG2bfT2lbhSF2lBmrrhTJyYk6_aA09DwL4Bf4kvG-JtCq0Bkd_XynViIsOtOnAhgmdSPkfr-oA\",\"audiences\":[\"talker-api\"]},\"status\":{\"user\":{}}}}\n{\"level\":\"debug\",\"ts\":1634830460.1509938,\"logger\":\"authorino.service.auth.authpipeline.identity\",\"msg\":\"cannot validate identity\",\"request id\":\"8157480586935853928\",\"config\":{\"Name\":\"api-keys\",\"ExtendedProperties\":[{\"Name\":\"sub\",\"Value\":{\"Static\":null,\"Pattern\":\"auth.identity.metadata.annotations.userid\"}}],\"OAuth2\":null,\"OIDC\":null,\"MTLS\":null,\"HMAC\":null,\"APIKey\":{\"AuthCredentials\":{\"KeySelector\":\"APIKEY\",\"In\":\"authorization_header\"},\"Name\":\"api-keys\",\"LabelSelectors\":{\"audience\":\"talker-api\",\"authorino.kuadrant.io/managed-by\":\"authorino\"}},\"KubernetesAuth\":null},\"reason\":\"credential not found\"}\n{\"level\":\"debug\",\"ts\":1634830460.1517606,\"logger\":\"authorino.service.auth.authpipeline.identity.oauth2\",\"msg\":\"sending token introspection request\",\"request id\":\"8157480586935853928\",\"url\":\"http://talker-api:523b92b6-625d-4e1e-a313-77e7a8ae4e88@keycloak:8080/realms/kuadrant/protocol/openid-connect/token/introspect\",\"data\":\"token=eyJhbGciOiJSUzI1NiIsImtpZCI6IkRsVWJZMENyVy1sZ0tFMVRMd19pcTFUWGtTYUl6T0hyWks0VHhKYnpEZUUifQ.eyJhdWQiOlsidGFsa2VyLWFwaSJdLCJleHAiOjE2MzQ4MzEwNTEsImlhdCI6MTYzNDgzMDQ1MSwiaXNzIjoiaHR0cHM6Ly9rdWJlcm5ldGVzLmRlZmF1bHQuc3ZjLmNsdXN0ZXIubG9jYWwiLCJrdWJlcm5ldGVzLmlvIjp7Im5hbWVzcGFjZSI6ImF1dGhvcmlubyIsInNlcnZpY2VhY2NvdW50Ijp7Im5hbWUiOiJhcGktY29uc3VtZXItMSIsInVpZCI6ImI0MGY1MzFjLWVjYWItNGYzMS1hNDk2LTJlYmM3MmFkZDEyMSJ9fSwibmJmIjoxNjM0ODMwNDUxLCJzdWIiOiJzeXN0ZW06c2VydmljZWFjY291bnQ6YXV0aG9yaW5vOmFwaS1jb25zdW1lci0xIn0.PaP0vqdl5DPfErr84KfVhPdlsGAPgsw0NkDaA9rne1zXjzcO7KPPbXhFwZC-oIjSGG1HfRMSoQeCXbQz24PSATmX8l1T52a9IFeXgP7sQmXZIDbiPfTm3X09kIIlfPKHhK_f-jQwRIpMRqNgLntlZ-xXX3P1fOBBUYR8obTPAQ6NDDaLHxw2SAmHFTQWjM_DInPDemXX0mEm7nCPKifsNxHaQH4wx4CD3LCLGbCI9FHNf2Crid8mmGJXf4wzcH1VuKkpUlsmnlUgTG2bfT2lbhSF2lBmrrhTJyYk6_aA09DwL4Bf4kvG-JtCq0Bkd_XynViIsOtOnAhgmdSPkfr-oA&amp;token_type_hint=requesting_party_token\"}\n{\"level\":\"debug\",\"ts\":1634830460.1620777,\"logger\":\"authorino.service.auth.authpipeline.identity\",\"msg\":\"identity validated\",\"request id\":\"8157480586935853928\",\"config\":{\"Name\":\"k8s-service-accounts\",\"ExtendedProperties\":[],\"OAuth2\":null,\"OIDC\":null,\"MTLS\":null,\"HMAC\":null,\"APIKey\":null,\"KubernetesAuth\":{\"AuthCredentials\":{\"KeySelector\":\"Bearer\",\"In\":\"authorization_header\"}}},\"object\":{\"aud\":[\"talker-api\"],\"exp\":1634831051,\"iat\":1634830451,\"iss\":\"https://kubernetes.default.svc.cluster.local\",\"kubernetes.io\":{\"namespace\":\"authorino\",\"serviceaccount\":{\"name\":\"api-consumer-1\",\"uid\":\"b40f531c-ecab-4f31-a496-2ebc72add121\"}},\"nbf\":1634830451,\"sub\":\"system:serviceaccount:authorino:api-consumer-1\"}}\n{\"level\":\"debug\",\"ts\":1634830460.1622565,\"logger\":\"authorino.service.auth.authpipeline.metadata.uma\",\"msg\":\"requesting pat\",\"request id\":\"8157480586935853928\",\"url\":\"http://talker-api:523b92b6-625d-4e1e-a313-77e7a8ae4e88@keycloak:8080/realms/kuadrant/protocol/openid-connect/token\",\"data\":\"grant_type=client_credentials\",\"headers\":{\"Content-Type\":[\"application/x-www-form-urlencoded\"]}}\n{\"level\":\"debug\",\"ts\":1634830460.1670353,\"logger\":\"authorino.service.auth.authpipeline.metadata.http\",\"msg\":\"sending request\",\"request id\":\"8157480586935853928\",\"method\":\"GET\",\"url\":\"http://talker-api.default.svc.cluster.local:3000/metadata?encoding=text/plain&amp;original_path=/hello\",\"headers\":{\"Content-Type\":[\"text/plain\"]}}\n{\"level\":\"debug\",\"ts\":1634830460.169326,\"logger\":\"authorino.service.auth.authpipeline.metadata\",\"msg\":\"cannot fetch metadata\",\"request id\":\"8157480586935853928\",\"config\":{\"Name\":\"oidc-userinfo\",\"UserInfo\":{\"OIDC\":{\"AuthCredentials\":{\"KeySelector\":\"Bearer\",\"In\":\"authorization_header\"},\"Endpoint\":\"http://keycloak:8080/realms/kuadrant\"}},\"UMA\":null,\"GenericHTTP\":null},\"reason\":\"Missing identity for OIDC issuer http://keycloak:8080/realms/kuadrant. Skipping related UserInfo metadata.\"}\n{\"level\":\"debug\",\"ts\":1634830460.1753876,\"logger\":\"authorino.service.auth.authpipeline.metadata\",\"msg\":\"fetched auth metadata\",\"request id\":\"8157480586935853928\",\"config\":{\"Name\":\"http-metadata\",\"UserInfo\":null,\"UMA\":null,\"GenericHTTP\":{\"Endpoint\":\"http://talker-api.default.svc.cluster.local:3000/metadata?encoding=text/plain&amp;original_path={context.request.http.path}\",\"Method\":\"GET\",\"Parameters\":[],\"ContentType\":\"application/x-www-form-urlencoded\",\"SharedSecret\":\"\",\"AuthCredentials\":{\"KeySelector\":\"Bearer\",\"In\":\"authorization_header\"}}},\"object\":{\"body\":\"\",\"headers\":{\"Accept-Encoding\":\"gzip\",\"Content-Type\":\"text/plain\",\"Host\":\"talker-api.default.svc.cluster.local:3000\",\"User-Agent\":\"Go-http-client/1.1\",\"Version\":\"HTTP/1.1\"},\"method\":\"GET\",\"path\":\"/metadata\",\"query_string\":\"encoding=text/plain&amp;original_path=/hello\",\"uuid\":\"1aa6ac66-3179-4351-b1a7-7f6a761d5b61\"}}\n{\"level\":\"debug\",\"ts\":1634830460.2331996,\"logger\":\"authorino.service.auth.authpipeline.metadata.uma\",\"msg\":\"querying resources by uri\",\"request id\":\"8157480586935853928\",\"url\":\"http://keycloak:8080/realms/kuadrant/authz/protection/resource_set?uri=/hello\"}\n{\"level\":\"debug\",\"ts\":1634830460.2495668,\"logger\":\"authorino.service.auth.authpipeline.metadata.uma\",\"msg\":\"getting resource data\",\"request id\":\"8157480586935853928\",\"url\":\"http://keycloak:8080/realms/kuadrant/authz/protection/resource_set/e20d194c-274c-4845-8c02-0ca413c9bf18\"}\n{\"level\":\"debug\",\"ts\":1634830460.2927864,\"logger\":\"authorino.service.auth.authpipeline.metadata\",\"msg\":\"fetched auth metadata\",\"request id\":\"8157480586935853928\",\"config\":{\"Name\":\"uma-resource-registry\",\"UserInfo\":null,\"UMA\":{\"Endpoint\":\"http://keycloak:8080/realms/kuadrant\",\"ClientID\":\"talker-api\",\"ClientSecret\":\"523b92b6-625d-4e1e-a313-77e7a8ae4e88\"},\"GenericHTTP\":null},\"object\":[{\"_id\":\"e20d194c-274c-4845-8c02-0ca413c9bf18\",\"attributes\":{},\"displayName\":\"hello\",\"name\":\"hello\",\"owner\":{\"id\":\"57a645a5-fb67-438b-8be5-dfb971666dbc\"},\"ownerManagedAccess\":false,\"resource_scopes\":[],\"uris\":[\"/hi\",\"/hello\"]}]}\n{\"level\":\"debug\",\"ts\":1634830460.2930083,\"logger\":\"authorino.service.auth.authpipeline.authorization\",\"msg\":\"evaluating for input\",\"request id\":\"8157480586935853928\",\"input\":{\"context\":{\"source\":{\"address\":{\"Address\":{\"SocketAddress\":{\"address\":\"127.0.0.1\",\"PortSpecifier\":{\"PortValue\":53144}}}}},\"destination\":{\"address\":{\"Address\":{\"SocketAddress\":{\"address\":\"127.0.0.1\",\"PortSpecifier\":{\"PortValue\":8000}}}}},\"request\":{\"time\":{\"seconds\":1634830460,\"nanos\":147259000},\"http\":{\"id\":\"8157480586935853928\",\"method\":\"GET\",\"headers\":{\":authority\":\"talker-api\",\":method\":\"GET\",\":path\":\"/hello\",\":scheme\":\"http\",\"accept\":\"*/*\",\"authorization\":\"Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6IkRsVWJZMENyVy1sZ0tFMVRMd19pcTFUWGtTYUl6T0hyWks0VHhKYnpEZUUifQ.eyJhdWQiOlsidGFsa2VyLWFwaSJdLCJleHAiOjE2MzQ4MzEwNTEsImlhdCI6MTYzNDgzMDQ1MSwiaXNzIjoiaHR0cHM6Ly9rdWJlcm5ldGVzLmRlZmF1bHQuc3ZjLmNsdXN0ZXIubG9jYWwiLCJrdWJlcm5ldGVzLmlvIjp7Im5hbWVzcGFjZSI6ImF1dGhvcmlubyIsInNlcnZpY2VhY2NvdW50Ijp7Im5hbWUiOiJhcGktY29uc3VtZXItMSIsInVpZCI6ImI0MGY1MzFjLWVjYWItNGYzMS1hNDk2LTJlYmM3MmFkZDEyMSJ9fSwibmJmIjoxNjM0ODMwNDUxLCJzdWIiOiJzeXN0ZW06c2VydmljZWFjY291bnQ6YXV0aG9yaW5vOmFwaS1jb25zdW1lci0xIn0.PaP0vqdl5DPfErr84KfVhPdlsGAPgsw0NkDaA9rne1zXjzcO7KPPbXhFwZC-oIjSGG1HfRMSoQeCXbQz24PSATmX8l1T52a9IFeXgP7sQmXZIDbiPfTm3X09kIIlfPKHhK_f-jQwRIpMRqNgLntlZ-xXX3P1fOBBUYR8obTPAQ6NDDaLHxw2SAmHFTQWjM_DInPDemXX0mEm7nCPKifsNxHaQH4wx4CD3LCLGbCI9FHNf2Crid8mmGJXf4wzcH1VuKkpUlsmnlUgTG2bfT2lbhSF2lBmrrhTJyYk6_aA09DwL4Bf4kvG-JtCq0Bkd_XynViIsOtOnAhgmdSPkfr-oA\",\"user-agent\":\"curl/7.65.3\",\"x-envoy-internal\":\"true\",\"x-forwarded-for\":\"10.244.0.11\",\"x-forwarded-proto\":\"http\",\"x-request-id\":\"4c5d5c97-e15b-46a3-877a-d8188e09e08f\"},\"path\":\"/hello\",\"host\":\"talker-api\",\"scheme\":\"http\",\"protocol\":\"HTTP/1.1\"}},\"context_extensions\":{\"virtual_host\":\"local_service\"},\"metadata_context\":{}},\"auth\":{\"identity\":{\"aud\":[\"talker-api\"],\"exp\":1634831051,\"iat\":1634830451,\"iss\":\"https://kubernetes.default.svc.cluster.local\",\"kubernetes.io\":{\"namespace\":\"authorino\",\"serviceaccount\":{\"name\":\"api-consumer-1\",\"uid\":\"b40f531c-ecab-4f31-a496-2ebc72add121\"}},\"nbf\":1634830451,\"sub\":\"system:serviceaccount:authorino:api-consumer-1\"},\"metadata\":{\"http-metadata\":{\"body\":\"\",\"headers\":{\"Accept-Encoding\":\"gzip\",\"Content-Type\":\"text/plain\",\"Host\":\"talker-api.default.svc.cluster.local:3000\",\"User-Agent\":\"Go-http-client/1.1\",\"Version\":\"HTTP/1.1\"},\"method\":\"GET\",\"path\":\"/metadata\",\"query_string\":\"encoding=text/plain&amp;original_path=/hello\",\"uuid\":\"1aa6ac66-3179-4351-b1a7-7f6a761d5b61\"},\"uma-resource-registry\":[{\"_id\":\"e20d194c-274c-4845-8c02-0ca413c9bf18\",\"attributes\":{},\"displayName\":\"hello\",\"name\":\"hello\",\"owner\":{\"id\":\"57a645a5-fb67-438b-8be5-dfb971666dbc\"},\"ownerManagedAccess\":false,\"resource_scopes\":[],\"uris\":[\"/hi\",\"/hello\"]}]}}}}\n{\"level\":\"debug\",\"ts\":1634830460.2955465,\"logger\":\"authorino.service.auth.authpipeline.authorization.kubernetesauthz\",\"msg\":\"calling kubernetes subject access review api\",\"request id\":\"8157480586935853928\",\"subjectaccessreview\":{\"metadata\":{\"creationTimestamp\":null},\"spec\":{\"nonResourceAttributes\":{\"path\":\"/hello\",\"verb\":\"get\"},\"user\":\"system:serviceaccount:authorino:api-consumer-1\"},\"status\":{\"allowed\":false}}}\n{\"level\":\"debug\",\"ts\":1634830460.2986183,\"logger\":\"authorino.service.auth.authpipeline.authorization\",\"msg\":\"access granted\",\"request id\":\"8157480586935853928\",\"config\":{\"Name\":\"my-policy\",\"OPA\":{\"Rego\":\"fail := input.context.request.http.headers[\\\"x-ext-auth-mock\\\"] == \\\"FAIL\\\"\\nallow { not fail }\\n\",\"OPAExternalSource\":{\"Endpoint\":\"\",\"SharedSecret\":\"\",\"AuthCredentials\":{\"KeySelector\":\"Bearer\",\"In\":\"authorization_header\"}}},\"JSON\":null,\"KubernetesAuthz\":null},\"object\":true}\n{\"level\":\"debug\",\"ts\":1634830460.3044975,\"logger\":\"authorino.service.auth.authpipeline.authorization\",\"msg\":\"access granted\",\"request id\":\"8157480586935853928\",\"config\":{\"Name\":\"kubernetes-rbac\",\"OPA\":null,\"JSON\":null,\"KubernetesAuthz\":{\"Conditions\":[],\"User\":{\"Static\":\"\",\"Pattern\":\"auth.identity.user.username\"},\"Groups\":null,\"ResourceAttributes\":null}},\"object\":true}\n{\"level\":\"debug\",\"ts\":1634830460.3052874,\"logger\":\"authorino.service.auth.authpipeline.response\",\"msg\":\"dynamic response built\",\"request id\":\"8157480586935853928\",\"config\":{\"Name\":\"wristband\",\"Wrapper\":\"httpHeader\",\"WrapperKey\":\"x-ext-auth-wristband\",\"Wristband\":{\"Issuer\":\"https://authorino-oidc.default.svc:8083/default/talker-api-protection/wristband\",\"CustomClaims\":[],\"TokenDuration\":300,\"SigningKeys\":[{\"use\":\"sig\",\"kty\":\"EC\",\"kid\":\"wristband-signing-key\",\"crv\":\"P-256\",\"alg\":\"ES256\",\"x\":\"TJf5NLVKplSYp95TOfhVPqvxvEibRyjrUZwwtpDuQZw\",\"y\":\"SSg8rKBsJ3J1LxyLtt0oFvhHvZcUpmRoTuHk3UHisTA\",\"d\":\"Me-5_zWBWVYajSGZcZMCcD8dXEa4fy85zv_yN7BxW-o\"}]},\"DynamicJSON\":null},\"object\":\"eyJhbGciOiJFUzI1NiIsImtpZCI6IndyaXN0YmFuZC1zaWduaW5nLWtleSIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2MzQ4MzA3NjAsImlhdCI6MTYzNDgzMDQ2MCwiaXNzIjoiaHR0cHM6Ly9hdXRob3Jpbm8tb2lkYy5hdXRob3Jpbm8uc3ZjOjgwODMvYXV0aG9yaW5vL3RhbGtlci1hcGktcHJvdGVjdGlvbi93cmlzdGJhbmQiLCJzdWIiOiI4NDliMDk0ZDA4MzU0ZjM0MjA4ZGI3MjBmYWZmODlmNmM3NmYyOGY3MTcxOWI4NTQ3ZDk5NWNlNzAwMjU2ZGY4In0.Jn-VB5Q_0EX1ed1ji4KvhO4DlMqZeIl5H0qlukbTyYkp-Pgb4SnPGSbYWp5_uvG8xllsFAA5nuyBIXeba-dbkw\"}\n{\"level\":\"info\",\"ts\":1634830460.3054585,\"logger\":\"authorino.service.auth\",\"msg\":\"outgoing authorization response\",\"request id\":\"8157480586935853928\",\"authorized\":true,\"response\":\"OK\"}\n{\"level\":\"debug\",\"ts\":1634830460.305476,\"logger\":\"authorino.service.auth\",\"msg\":\"outgoing authorization response\",\"request id\":\"8157480586935853928\",\"authorized\":true,\"response\":\"OK\"}\n</code></pre> Enforcing an AuthConfig with authentication based on API keys <p></p> <ul> <li>identity: k8s-auth, oidc, oauth2, apikey</li> <li>metadata: http, oidc userinfo</li> <li>authorization: opa, k8s-authz</li> <li>response: wristband</li> </ul> <pre><code>{\"level\":\"info\",\"ts\":1634830413.2425854,\"logger\":\"authorino.service.auth\",\"msg\":\"incoming authorization request\",\"request id\":\"7199257136822741594\",\"object\":{\"source\":{\"address\":{\"Address\":{\"SocketAddress\":{\"address\":\"127.0.0.1\",\"PortSpecifier\":{\"PortValue\":52702}}}}},\"destination\":{\"address\":{\"Address\":{\"SocketAddress\":{\"address\":\"127.0.0.1\",\"PortSpecifier\":{\"PortValue\":8000}}}}},\"request\":{\"http\":{\"id\":\"7199257136822741594\",\"method\":\"GET\",\"path\":\"/hello\",\"host\":\"talker-api\",\"scheme\":\"http\"}}}}\n{\"level\":\"debug\",\"ts\":1634830413.2426975,\"logger\":\"authorino.service.auth\",\"msg\":\"incoming authorization request\",\"request id\":\"7199257136822741594\",\"object\":{\"source\":{\"address\":{\"Address\":{\"SocketAddress\":{\"address\":\"127.0.0.1\",\"PortSpecifier\":{\"PortValue\":52702}}}}},\"destination\":{\"address\":{\"Address\":{\"SocketAddress\":{\"address\":\"127.0.0.1\",\"PortSpecifier\":{\"PortValue\":8000}}}}},\"request\":{\"time\":{\"seconds\":1634830413,\"nanos\":240094000},\"http\":{\"id\":\"7199257136822741594\",\"method\":\"GET\",\"headers\":{\":authority\":\"talker-api\",\":method\":\"GET\",\":path\":\"/hello\",\":scheme\":\"http\",\"accept\":\"*/*\",\"authorization\":\"APIKEY ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx\",\"user-agent\":\"curl/7.65.3\",\"x-envoy-internal\":\"true\",\"x-forwarded-for\":\"10.244.0.11\",\"x-forwarded-proto\":\"http\",\"x-request-id\":\"d38f5e66-bd72-4733-95d1-3179315cdd60\"},\"path\":\"/hello\",\"host\":\"talker-api\",\"scheme\":\"http\",\"protocol\":\"HTTP/1.1\"}},\"context_extensions\":{\"virtual_host\":\"local_service\"},\"metadata_context\":{}}}\n{\"level\":\"debug\",\"ts\":1634830413.2428744,\"logger\":\"authorino.service.auth.authpipeline.identity\",\"msg\":\"cannot validate identity\",\"request id\":\"7199257136822741594\",\"config\":{\"Name\":\"k8s-service-accounts\",\"ExtendedProperties\":[],\"OAuth2\":null,\"OIDC\":null,\"MTLS\":null,\"HMAC\":null,\"APIKey\":null,\"KubernetesAuth\":{\"AuthCredentials\":{\"KeySelector\":\"Bearer\",\"In\":\"authorization_header\"}}},\"reason\":\"credential not found\"}\n{\"level\":\"debug\",\"ts\":1634830413.2434332,\"logger\":\"authorino.service.auth.authpipeline\",\"msg\":\"skipping config\",\"request id\":\"7199257136822741594\",\"config\":{\"Name\":\"keycloak-jwts\",\"ExtendedProperties\":[],\"OAuth2\":null,\"OIDC\":{\"AuthCredentials\":{\"KeySelector\":\"Bearer\",\"In\":\"authorization_header\"},\"Endpoint\":\"http://keycloak:8080/realms/kuadrant\"},\"MTLS\":null,\"HMAC\":null,\"APIKey\":null,\"KubernetesAuth\":null},\"reason\":\"context canceled\"}\n{\"level\":\"debug\",\"ts\":1634830413.2479305,\"logger\":\"authorino.service.auth.authpipeline.identity\",\"msg\":\"identity validated\",\"request id\":\"7199257136822741594\",\"config\":{\"Name\":\"api-keys\",\"ExtendedProperties\":[{\"Name\":\"sub\",\"Value\":{\"Static\":null,\"Pattern\":\"auth.identity.metadata.annotations.userid\"}}],\"OAuth2\":null,\"OIDC\":null,\"MTLS\":null,\"HMAC\":null,\"APIKey\":{\"AuthCredentials\":{\"KeySelector\":\"APIKEY\",\"In\":\"authorization_header\"},\"Name\":\"api-keys\",\"LabelSelectors\":{\"audience\":\"talker-api\",\"authorino.kuadrant.io/managed-by\":\"authorino\"}},\"KubernetesAuth\":null},\"object\":{\"apiVersion\":\"v1\",\"data\":{\"api_key\":\"bmR5QnpyZVV6RjR6cURRc3FTUE1Ia1JocmlFT3RjUng=\"},\"kind\":\"Secret\",\"metadata\":{\"annotations\":{\"kubectl.kubernetes.io/last-applied-configuration\":\"{\\\"apiVersion\\\":\\\"v1\\\",\\\"kind\\\":\\\"Secret\\\",\\\"metadata\\\":{\\\"annotations\\\":{\\\"userid\\\":\\\"john\\\"},\\\"labels\\\":{\\\"audience\\\":\\\"talker-api\\\",\\\"authorino.kuadrant.io/managed-by\\\":\\\"authorino\\\"},\\\"name\\\":\\\"api-key-1\\\",\\\"namespace\\\":\\\"authorino\\\"},\\\"stringData\\\":{\\\"api_key\\\":\\\"ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx\\\"},\\\"type\\\":\\\"Opaque\\\"}\\n\",\"userid\":\"john\"},\"creationTimestamp\":\"2021-10-21T14:45:54Z\",\"labels\":{\"audience\":\"talker-api\",\"authorino.kuadrant.io/managed-by\":\"authorino\"},\"managedFields\":[{\"apiVersion\":\"v1\",\"fieldsType\":\"FieldsV1\",\"fieldsV1\":{\"f:data\":{\".\":{},\"f:api_key\":{}},\"f:metadata\":{\"f:annotations\":{\".\":{},\"f:kubectl.kubernetes.io/last-applied-configuration\":{},\"f:userid\":{}},\"f:labels\":{\".\":{},\"f:audience\":{},\"f:authorino.kuadrant.io/managed-by\":{}}},\"f:type\":{}},\"manager\":\"kubectl-client-side-apply\",\"operation\":\"Update\",\"time\":\"2021-10-21T14:45:54Z\"}],\"name\":\"api-key-1\",\"namespace\":\"authorino\",\"resourceVersion\":\"8979\",\"uid\":\"c369852a-7e1a-43bd-94ca-e2b3f617052e\"},\"sub\":\"john\",\"type\":\"Opaque\"}}\n{\"level\":\"debug\",\"ts\":1634830413.248768,\"logger\":\"authorino.service.auth.authpipeline.metadata.http\",\"msg\":\"sending request\",\"request id\":\"7199257136822741594\",\"method\":\"GET\",\"url\":\"http://talker-api.default.svc.cluster.local:3000/metadata?encoding=text/plain&amp;original_path=/hello\",\"headers\":{\"Content-Type\":[\"text/plain\"]}}\n{\"level\":\"debug\",\"ts\":1634830413.2496722,\"logger\":\"authorino.service.auth.authpipeline.metadata\",\"msg\":\"cannot fetch metadata\",\"request id\":\"7199257136822741594\",\"config\":{\"Name\":\"oidc-userinfo\",\"UserInfo\":{\"OIDC\":{\"AuthCredentials\":{\"KeySelector\":\"Bearer\",\"In\":\"authorization_header\"},\"Endpoint\":\"http://keycloak:8080/realms/kuadrant\"}},\"UMA\":null,\"GenericHTTP\":null},\"reason\":\"Missing identity for OIDC issuer http://keycloak:8080/realms/kuadrant. Skipping related UserInfo metadata.\"}\n{\"level\":\"debug\",\"ts\":1634830413.2497928,\"logger\":\"authorino.service.auth.authpipeline.metadata.uma\",\"msg\":\"requesting pat\",\"request id\":\"7199257136822741594\",\"url\":\"http://talker-api:523b92b6-625d-4e1e-a313-77e7a8ae4e88@keycloak:8080/realms/kuadrant/protocol/openid-connect/token\",\"data\":\"grant_type=client_credentials\",\"headers\":{\"Content-Type\":[\"application/x-www-form-urlencoded\"]}}\n{\"level\":\"debug\",\"ts\":1634830413.258932,\"logger\":\"authorino.service.auth.authpipeline.metadata\",\"msg\":\"fetched auth metadata\",\"request id\":\"7199257136822741594\",\"config\":{\"Name\":\"http-metadata\",\"UserInfo\":null,\"UMA\":null,\"GenericHTTP\":{\"Endpoint\":\"http://talker-api.default.svc.cluster.local:3000/metadata?encoding=text/plain&amp;original_path={context.request.http.path}\",\"Method\":\"GET\",\"Parameters\":[],\"ContentType\":\"application/x-www-form-urlencoded\",\"SharedSecret\":\"\",\"AuthCredentials\":{\"KeySelector\":\"Bearer\",\"In\":\"authorization_header\"}}},\"object\":{\"body\":\"\",\"headers\":{\"Accept-Encoding\":\"gzip\",\"Content-Type\":\"text/plain\",\"Host\":\"talker-api.default.svc.cluster.local:3000\",\"User-Agent\":\"Go-http-client/1.1\",\"Version\":\"HTTP/1.1\"},\"method\":\"GET\",\"path\":\"/metadata\",\"query_string\":\"encoding=text/plain&amp;original_path=/hello\",\"uuid\":\"97529f8c-587b-4121-a4db-cd90c63871fd\"}}\n{\"level\":\"debug\",\"ts\":1634830413.2945344,\"logger\":\"authorino.service.auth.authpipeline.metadata.uma\",\"msg\":\"querying resources by uri\",\"request id\":\"7199257136822741594\",\"url\":\"http://keycloak:8080/realms/kuadrant/authz/protection/resource_set?uri=/hello\"}\n{\"level\":\"debug\",\"ts\":1634830413.3123596,\"logger\":\"authorino.service.auth.authpipeline.metadata.uma\",\"msg\":\"getting resource data\",\"request id\":\"7199257136822741594\",\"url\":\"http://keycloak:8080/realms/kuadrant/authz/protection/resource_set/e20d194c-274c-4845-8c02-0ca413c9bf18\"}\n{\"level\":\"debug\",\"ts\":1634830413.3340268,\"logger\":\"authorino.service.auth.authpipeline.metadata\",\"msg\":\"fetched auth metadata\",\"request id\":\"7199257136822741594\",\"config\":{\"Name\":\"uma-resource-registry\",\"UserInfo\":null,\"UMA\":{\"Endpoint\":\"http://keycloak:8080/realms/kuadrant\",\"ClientID\":\"talker-api\",\"ClientSecret\":\"523b92b6-625d-4e1e-a313-77e7a8ae4e88\"},\"GenericHTTP\":null},\"object\":[{\"_id\":\"e20d194c-274c-4845-8c02-0ca413c9bf18\",\"attributes\":{},\"displayName\":\"hello\",\"name\":\"hello\",\"owner\":{\"id\":\"57a645a5-fb67-438b-8be5-dfb971666dbc\"},\"ownerManagedAccess\":false,\"resource_scopes\":[],\"uris\":[\"/hi\",\"/hello\"]}]}\n{\"level\":\"debug\",\"ts\":1634830413.3367748,\"logger\":\"authorino.service.auth.authpipeline.authorization\",\"msg\":\"evaluating for input\",\"request id\":\"7199257136822741594\",\"input\":{\"context\":{\"source\":{\"address\":{\"Address\":{\"SocketAddress\":{\"address\":\"127.0.0.1\",\"PortSpecifier\":{\"PortValue\":52702}}}}},\"destination\":{\"address\":{\"Address\":{\"SocketAddress\":{\"address\":\"127.0.0.1\",\"PortSpecifier\":{\"PortValue\":8000}}}}},\"request\":{\"time\":{\"seconds\":1634830413,\"nanos\":240094000},\"http\":{\"id\":\"7199257136822741594\",\"method\":\"GET\",\"headers\":{\":authority\":\"talker-api\",\":method\":\"GET\",\":path\":\"/hello\",\":scheme\":\"http\",\"accept\":\"*/*\",\"authorization\":\"APIKEY ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx\",\"user-agent\":\"curl/7.65.3\",\"x-envoy-internal\":\"true\",\"x-forwarded-for\":\"10.244.0.11\",\"x-forwarded-proto\":\"http\",\"x-request-id\":\"d38f5e66-bd72-4733-95d1-3179315cdd60\"},\"path\":\"/hello\",\"host\":\"talker-api\",\"scheme\":\"http\",\"protocol\":\"HTTP/1.1\"}},\"context_extensions\":{\"virtual_host\":\"local_service\"},\"metadata_context\":{}},\"auth\":{\"identity\":{\"apiVersion\":\"v1\",\"data\":{\"api_key\":\"bmR5QnpyZVV6RjR6cURRc3FTUE1Ia1JocmlFT3RjUng=\"},\"kind\":\"Secret\",\"metadata\":{\"annotations\":{\"kubectl.kubernetes.io/last-applied-configuration\":\"{\\\"apiVersion\\\":\\\"v1\\\",\\\"kind\\\":\\\"Secret\\\",\\\"metadata\\\":{\\\"annotations\\\":{\\\"userid\\\":\\\"john\\\"},\\\"labels\\\":{\\\"audience\\\":\\\"talker-api\\\",\\\"authorino.kuadrant.io/managed-by\\\":\\\"authorino\\\"},\\\"name\\\":\\\"api-key-1\\\",\\\"namespace\\\":\\\"authorino\\\"},\\\"stringData\\\":{\\\"api_key\\\":\\\"ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx\\\"},\\\"type\\\":\\\"Opaque\\\"}\\n\",\"userid\":\"john\"},\"creationTimestamp\":\"2021-10-21T14:45:54Z\",\"labels\":{\"audience\":\"talker-api\",\"authorino.kuadrant.io/managed-by\":\"authorino\"},\"managedFields\":[{\"apiVersion\":\"v1\",\"fieldsType\":\"FieldsV1\",\"fieldsV1\":{\"f:data\":{\".\":{},\"f:api_key\":{}},\"f:metadata\":{\"f:annotations\":{\".\":{},\"f:kubectl.kubernetes.io/last-applied-configuration\":{},\"f:userid\":{}},\"f:labels\":{\".\":{},\"f:audience\":{},\"f:authorino.kuadrant.io/managed-by\":{}}},\"f:type\":{}},\"manager\":\"kubectl-client-side-apply\",\"operation\":\"Update\",\"time\":\"2021-10-21T14:45:54Z\"}],\"name\":\"api-key-1\",\"namespace\":\"authorino\",\"resourceVersion\":\"8979\",\"uid\":\"c369852a-7e1a-43bd-94ca-e2b3f617052e\"},\"sub\":\"john\",\"type\":\"Opaque\"},\"metadata\":{\"http-metadata\":{\"body\":\"\",\"headers\":{\"Accept-Encoding\":\"gzip\",\"Content-Type\":\"text/plain\",\"Host\":\"talker-api.default.svc.cluster.local:3000\",\"User-Agent\":\"Go-http-client/1.1\",\"Version\":\"HTTP/1.1\"},\"method\":\"GET\",\"path\":\"/metadata\",\"query_string\":\"encoding=text/plain&amp;original_path=/hello\",\"uuid\":\"97529f8c-587b-4121-a4db-cd90c63871fd\"},\"uma-resource-registry\":[{\"_id\":\"e20d194c-274c-4845-8c02-0ca413c9bf18\",\"attributes\":{},\"displayName\":\"hello\",\"name\":\"hello\",\"owner\":{\"id\":\"57a645a5-fb67-438b-8be5-dfb971666dbc\"},\"ownerManagedAccess\":false,\"resource_scopes\":[],\"uris\":[\"/hi\",\"/hello\"]}]}}}}\n{\"level\":\"debug\",\"ts\":1634830413.339894,\"logger\":\"authorino.service.auth.authpipeline.authorization\",\"msg\":\"access granted\",\"request id\":\"7199257136822741594\",\"config\":{\"Name\":\"my-policy\",\"OPA\":{\"Rego\":\"fail := input.context.request.http.headers[\\\"x-ext-auth-mock\\\"] == \\\"FAIL\\\"\\nallow { not fail }\\n\",\"OPAExternalSource\":{\"Endpoint\":\"\",\"SharedSecret\":\"\",\"AuthCredentials\":{\"KeySelector\":\"Bearer\",\"In\":\"authorization_header\"}}},\"JSON\":null,\"KubernetesAuthz\":null},\"object\":true}\n{\"level\":\"debug\",\"ts\":1634830413.3444238,\"logger\":\"authorino.service.auth.authpipeline.authorization.kubernetesauthz\",\"msg\":\"calling kubernetes subject access review api\",\"request id\":\"7199257136822741594\",\"subjectaccessreview\":{\"metadata\":{\"creationTimestamp\":null},\"spec\":{\"nonResourceAttributes\":{\"path\":\"/hello\",\"verb\":\"get\"},\"user\":\"john\"},\"status\":{\"allowed\":false}}}\n{\"level\":\"debug\",\"ts\":1634830413.3547812,\"logger\":\"authorino.service.auth.authpipeline.authorization\",\"msg\":\"access granted\",\"request id\":\"7199257136822741594\",\"config\":{\"Name\":\"kubernetes-rbac\",\"OPA\":null,\"JSON\":null,\"KubernetesAuthz\":{\"Conditions\":[],\"User\":{\"Static\":\"\",\"Pattern\":\"auth.identity.user.username\"},\"Groups\":null,\"ResourceAttributes\":null}},\"object\":true}\n{\"level\":\"debug\",\"ts\":1634830413.3558292,\"logger\":\"authorino.service.auth.authpipeline.response\",\"msg\":\"dynamic response built\",\"request id\":\"7199257136822741594\",\"config\":{\"Name\":\"wristband\",\"Wrapper\":\"httpHeader\",\"WrapperKey\":\"x-ext-auth-wristband\",\"Wristband\":{\"Issuer\":\"https://authorino-oidc.default.svc:8083/default/talker-api-protection/wristband\",\"CustomClaims\":[],\"TokenDuration\":300,\"SigningKeys\":[{\"use\":\"sig\",\"kty\":\"EC\",\"kid\":\"wristband-signing-key\",\"crv\":\"P-256\",\"alg\":\"ES256\",\"x\":\"TJf5NLVKplSYp95TOfhVPqvxvEibRyjrUZwwtpDuQZw\",\"y\":\"SSg8rKBsJ3J1LxyLtt0oFvhHvZcUpmRoTuHk3UHisTA\",\"d\":\"Me-5_zWBWVYajSGZcZMCcD8dXEa4fy85zv_yN7BxW-o\"}]},\"DynamicJSON\":null},\"object\":\"eyJhbGciOiJFUzI1NiIsImtpZCI6IndyaXN0YmFuZC1zaWduaW5nLWtleSIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2MzQ4MzA3MTMsImlhdCI6MTYzNDgzMDQxMywiaXNzIjoiaHR0cHM6Ly9hdXRob3Jpbm8tb2lkYy5hdXRob3Jpbm8uc3ZjOjgwODMvYXV0aG9yaW5vL3RhbGtlci1hcGktcHJvdGVjdGlvbi93cmlzdGJhbmQiLCJzdWIiOiI5NjhiZjViZjk3MDM3NWRiNjE0ZDFhMDgzZTg2NTBhYTVhMGVhMzAyOTdiYmJjMTBlNWVlMWZmYTkxYTYwZmY4In0.7G440sWgi2TIaxrGJf5KWR9UOFpNTjwVYeaJXFLzsLhVNICoMLbYzBAEo4M3ym1jipxxTVeE7anm4qDDc7cnVQ\"}\n{\"level\":\"info\",\"ts\":1634830413.3569078,\"logger\":\"authorino.service.auth\",\"msg\":\"outgoing authorization response\",\"request id\":\"7199257136822741594\",\"authorized\":true,\"response\":\"OK\"}\n{\"level\":\"debug\",\"ts\":1634830413.3569596,\"logger\":\"authorino.service.auth\",\"msg\":\"outgoing authorization response\",\"request id\":\"7199257136822741594\",\"authorized\":true,\"response\":\"OK\"}\n</code></pre> Enforcing an AuthConfig with authentication based on API keys (invalid API key) <p></p> <ul> <li>identity: k8s-auth, oidc, oauth2, apikey</li> <li>metadata: http, oidc userinfo</li> <li>authorization: opa, k8s-authz</li> <li>response: wristband</li> </ul> <pre><code>{\"level\":\"info\",\"ts\":1634830373.2066543,\"logger\":\"authorino.service.auth\",\"msg\":\"incoming authorization request\",\"request id\":\"12947265773116138711\",\"object\":{\"source\":{\"address\":{\"Address\":{\"SocketAddress\":{\"address\":\"127.0.0.1\",\"PortSpecifier\":{\"PortValue\":52288}}}}},\"destination\":{\"address\":{\"Address\":{\"SocketAddress\":{\"address\":\"127.0.0.1\",\"PortSpecifier\":{\"PortValue\":8000}}}}},\"request\":{\"http\":{\"id\":\"12947265773116138711\",\"method\":\"GET\",\"path\":\"/hello\",\"host\":\"talker-api\",\"scheme\":\"http\"}}}}\n{\"level\":\"debug\",\"ts\":1634830373.2068064,\"logger\":\"authorino.service.auth\",\"msg\":\"incoming authorization request\",\"request id\":\"12947265773116138711\",\"object\":{\"source\":{\"address\":{\"Address\":{\"SocketAddress\":{\"address\":\"127.0.0.1\",\"PortSpecifier\":{\"PortValue\":52288}}}}},\"destination\":{\"address\":{\"Address\":{\"SocketAddress\":{\"address\":\"127.0.0.1\",\"PortSpecifier\":{\"PortValue\":8000}}}}},\"request\":{\"time\":{\"seconds\":1634830373,\"nanos\":198329000},\"http\":{\"id\":\"12947265773116138711\",\"method\":\"GET\",\"headers\":{\":authority\":\"talker-api\",\":method\":\"GET\",\":path\":\"/hello\",\":scheme\":\"http\",\"accept\":\"*/*\",\"authorization\":\"APIKEY invalid\",\"user-agent\":\"curl/7.65.3\",\"x-envoy-internal\":\"true\",\"x-forwarded-for\":\"10.244.0.11\",\"x-forwarded-proto\":\"http\",\"x-request-id\":\"9e391846-afe4-489a-8716-23a2e1c1aa77\"},\"path\":\"/hello\",\"host\":\"talker-api\",\"scheme\":\"http\",\"protocol\":\"HTTP/1.1\"}},\"context_extensions\":{\"virtual_host\":\"local_service\"},\"metadata_context\":{}}}\n{\"level\":\"debug\",\"ts\":1634830373.2070816,\"logger\":\"authorino.service.auth.authpipeline.identity\",\"msg\":\"cannot validate identity\",\"request id\":\"12947265773116138711\",\"config\":{\"Name\":\"keycloak-opaque\",\"ExtendedProperties\":[],\"OAuth2\":{\"AuthCredentials\":{\"KeySelector\":\"Bearer\",\"In\":\"authorization_header\"},\"TokenIntrospectionUrl\":\"http://keycloak:8080/realms/kuadrant/protocol/openid-connect/token/introspect\",\"TokenTypeHint\":\"requesting_party_token\",\"ClientID\":\"talker-api\",\"ClientSecret\":\"523b92b6-625d-4e1e-a313-77e7a8ae4e88\"},\"OIDC\":null,\"MTLS\":null,\"HMAC\":null,\"APIKey\":null,\"KubernetesAuth\":null},\"reason\":\"credential not found\"}\n{\"level\":\"debug\",\"ts\":1634830373.207225,\"logger\":\"authorino.service.auth.authpipeline.identity\",\"msg\":\"cannot validate identity\",\"request id\":\"12947265773116138711\",\"config\":{\"Name\":\"api-keys\",\"ExtendedProperties\":[{\"Name\":\"sub\",\"Value\":{\"Static\":null,\"Pattern\":\"auth.identity.metadata.annotations.userid\"}}],\"OAuth2\":null,\"OIDC\":null,\"MTLS\":null,\"HMAC\":null,\"APIKey\":{\"AuthCredentials\":{\"KeySelector\":\"APIKEY\",\"In\":\"authorization_header\"},\"Name\":\"api-keys\",\"LabelSelectors\":{\"audience\":\"talker-api\",\"authorino.kuadrant.io/managed-by\":\"authorino\"}},\"KubernetesAuth\":null},\"reason\":\"the API Key provided is invalid\"}\n{\"level\":\"debug\",\"ts\":1634830373.2072473,\"logger\":\"authorino.service.auth.authpipeline.identity\",\"msg\":\"cannot validate identity\",\"request id\":\"12947265773116138711\",\"config\":{\"Name\":\"k8s-service-accounts\",\"ExtendedProperties\":[],\"OAuth2\":null,\"OIDC\":null,\"MTLS\":null,\"HMAC\":null,\"APIKey\":null,\"KubernetesAuth\":{\"AuthCredentials\":{\"KeySelector\":\"Bearer\",\"In\":\"authorization_header\"}}},\"reason\":\"credential not found\"}\n{\"level\":\"debug\",\"ts\":1634830373.2072592,\"logger\":\"authorino.service.auth.authpipeline.identity\",\"msg\":\"cannot validate identity\",\"request id\":\"12947265773116138711\",\"config\":{\"Name\":\"keycloak-jwts\",\"ExtendedProperties\":[],\"OAuth2\":null,\"OIDC\":{\"AuthCredentials\":{\"KeySelector\":\"Bearer\",\"In\":\"authorization_header\"},\"Endpoint\":\"http://keycloak:8080/realms/kuadrant\"},\"MTLS\":null,\"HMAC\":null,\"APIKey\":null,\"KubernetesAuth\":null},\"reason\":\"credential not found\"}\n{\"level\":\"info\",\"ts\":1634830373.2073083,\"logger\":\"authorino.service.auth\",\"msg\":\"outgoing authorization response\",\"request id\":\"12947265773116138711\",\"authorized\":false,\"response\":\"UNAUTHENTICATED\",\"object\":{\"code\":16,\"status\":302,\"message\":\"Redirecting to login\"}}\n{\"level\":\"debug\",\"ts\":1634830373.2073889,\"logger\":\"authorino.service.auth\",\"msg\":\"outgoing authorization response\",\"request id\":\"12947265773116138711\",\"authorized\":false,\"response\":\"UNAUTHENTICATED\",\"object\":{\"code\":16,\"status\":302,\"message\":\"Redirecting to login\",\"headers\":[{\"Location\":\"https://my-app.io/login\"}]}}\n</code></pre> Deleting an AuthConfig and 2 related API key secrets <pre><code>{\"level\":\"info\",\"ts\":1669221361.5032296,\"logger\":\"authorino.controller-runtime.manager.controller.secret\",\"msg\":\"resource reconciled\",\"secret\":\"default/api-key-1\"}\n{\"level\":\"info\",\"ts\":1669221361.5057878,\"logger\":\"authorino.controller-runtime.manager.controller.secret\",\"msg\":\"resource reconciled\",\"secret\":\"default/api-key-2\"}\n</code></pre> Shutting down the service <pre><code>{\"level\":\"info\",\"ts\":1669221635.0135982,\"logger\":\"authorino\",\"msg\":\"Stopping and waiting for non leader election runnables\"}\n{\"level\":\"info\",\"ts\":1669221635.0136683,\"logger\":\"authorino\",\"msg\":\"Stopping and waiting for leader election runnables\"}\n{\"level\":\"info\",\"ts\":1669221635.0135982,\"logger\":\"authorino\",\"msg\":\"Stopping and waiting for non leader election runnables\"}\n{\"level\":\"info\",\"ts\":1669221635.0136883,\"logger\":\"authorino\",\"msg\":\"Stopping and waiting for leader election runnables\"}\n{\"level\":\"info\",\"ts\":1669221635.0137057,\"logger\":\"authorino.controller.secret\",\"msg\":\"Shutdown signal received, waiting for all workers to finish\",\"reconciler group\":\"\",\"reconciler kind\":\"Secret\"}\n{\"level\":\"info\",\"ts\":1669221635.013724,\"logger\":\"authorino.controller.authconfig\",\"msg\":\"Shutdown signal received, waiting for all workers to finish\",\"reconciler group\":\"authorino.kuadrant.io\",\"reconciler kind\":\"AuthConfig\"}\n{\"level\":\"info\",\"ts\":1669221635.01375,\"logger\":\"authorino.controller.authconfig\",\"msg\":\"All workers finished\",\"reconciler group\":\"authorino.kuadrant.io\",\"reconciler kind\":\"AuthConfig\"}\n{\"level\":\"info\",\"ts\":1669221635.013752,\"logger\":\"authorino.controller.secret\",\"msg\":\"All workers finished\",\"reconciler group\":\"\",\"reconciler kind\":\"Secret\"}\n{\"level\":\"info\",\"ts\":1669221635.0137632,\"logger\":\"authorino\",\"msg\":\"Stopping and waiting for caches\"}\n{\"level\":\"info\",\"ts\":1669221635.013751,\"logger\":\"authorino.controller.authconfig\",\"msg\":\"Shutdown signal received, waiting for all workers to finish\",\"reconciler group\":\"authorino.kuadrant.io\",\"reconciler kind\":\"AuthConfig\"}\n{\"level\":\"info\",\"ts\":1669221635.0137684,\"logger\":\"authorino.controller.authconfig\",\"msg\":\"All workers finished\",\"reconciler group\":\"authorino.kuadrant.io\",\"reconciler kind\":\"AuthConfig\"}\n{\"level\":\"info\",\"ts\":1669221635.0137722,\"logger\":\"authorino\",\"msg\":\"Stopping and waiting for caches\"}\n{\"level\":\"info\",\"ts\":1669221635.0138857,\"logger\":\"authorino\",\"msg\":\"Stopping and waiting for webhooks\"}\n{\"level\":\"info\",\"ts\":1669221635.0138955,\"logger\":\"authorino\",\"msg\":\"Wait completed, proceeding to shutdown the manager\"}\n{\"level\":\"info\",\"ts\":1669221635.0138893,\"logger\":\"authorino\",\"msg\":\"Stopping and waiting for webhooks\"}\n{\"level\":\"info\",\"ts\":1669221635.0139785,\"logger\":\"authorino\",\"msg\":\"Wait completed, proceeding to shutdown the manager\"}\n</code></pre>"},{"location":"authorino/docs/user-guides/observability/#tracing","title":"Tracing","text":""},{"location":"authorino/docs/user-guides/observability/#request-id","title":"Request ID","text":"<p>Processes related to the authorization request are identified and linked together by a request ID. The request ID can be:</p> <ul> <li>generated outside Authorino and passed in the authorization request \u2013 this is essentially the case of requests via GRPC authorization interface initiated by the Envoy;</li> <li>generated by Authorino \u2013 requests via Raw HTTP Authorization interface.</li> </ul>"},{"location":"authorino/docs/user-guides/observability/#propagation","title":"Propagation","text":"<p>Authorino propagates trace identifiers compatible with the W3C Trace Context format https://www.w3.org/TR/trace-context/ and user-defined baggage data in the W3C Baggage format https://www.w3.org/TR/baggage.</p>"},{"location":"authorino/docs/user-guides/observability/#log-tracing","title":"Log tracing","text":"<p>Most log messages associated with an authorization request include the <code>request id</code> value. This value can be used to match incoming request and corresponding outgoing response log messages, including at deep level when more fine-grained log details are enabled (<code>debug</code> level level).</p>"},{"location":"authorino/docs/user-guides/observability/#opentelemetry-integration","title":"OpenTelemetry integration","text":"<p>Integration with an OpenTelemetry collector can be enabled by supplying the <code>--tracing-service-endpoint</code> command-line flag (e.g. <code>authorino server --tracing-service-endpoint=http://jaeger:14268/api/traces</code>).</p> <p>The additional <code>--tracing-service-tags</code> command-line flag allow to specify fixed agent-level key-value tags for the trace signals emitted by Authorino (e.g. <code>authorino server --tracing-service-endpoint=... --tracing-service-tag=key1=value1 --tracing-service-tag=key2=value2</code>).</p>"},{"location":"authorino/docs/user-guides/observability/#data-plane-tracing","title":"Data plane tracing","text":"<p>Traces related to authorization requests are additionally tagged with the <code>authorino.request_id</code> attribute.</p>"},{"location":"authorino/docs/user-guides/observability/#control-plane-tracing","title":"Control plane tracing","text":"<p>When OpenTelemetry integration is enabled, Authorino emits trace spans for control plane operations, specifically for the reconciliation of AuthConfig and Secret resources.</p> <p>AuthConfig reconciliation traces include:</p> <ul> <li>Span name: <code>authconfig.reconcile</code></li> <li>Span attributes:</li> <li><code>authconfig.namespace</code>: The namespace of the AuthConfig</li> <li><code>authconfig.name</code>: The name of the AuthConfig</li> <li><code>authconfig.resource_id</code>: The namespaced name (namespace/name)</li> <li><code>authconfig.hosts_count</code>: Number of hosts configured</li> <li><code>authconfig.hosts</code>: List of hosts protected by this AuthConfig</li> <li>Span events tracking reconciliation stages:</li> <li><code>authconfig.found</code>: AuthConfig resource was successfully retrieved</li> <li><code>authconfig.deleted_or_unwatched</code>: AuthConfig was deleted or no longer matches label selectors</li> <li><code>authconfig.deindexed</code>: AuthConfig removed from the index</li> <li><code>authconfig.deleting_unused_hosts</code>: Removing hosts no longer in the spec</li> <li><code>authconfig.indexed</code>: AuthConfig successfully added/updated in the index</li> </ul> <p>AuthConfig status update traces include:</p> <ul> <li>Span name: <code>authconfig.update_status</code></li> <li>Span attributes include namespace, name, and resource ID</li> <li>Span events track status update operations</li> </ul> <p>Secret reconciliation traces include:</p> <ul> <li>Span name: <code>secret.reconcile</code></li> <li>Span attributes:</li> <li><code>secret.namespace</code>: The namespace of the Secret</li> <li><code>secret.name</code>: The name of the Secret</li> <li><code>secret.affected_authconfigs</code>: Number of AuthConfigs affected by this Secret change</li> <li>Span events:</li> <li><code>secret.found</code>: Secret resource was successfully retrieved</li> <li><code>secret.deleted_or_unwatched</code>: Secret was deleted or no longer matches label selectors</li> <li><code>secret.revoked_from_authconfigs</code>: Secret-based identities revoked from affected AuthConfigs</li> <li><code>secret.refreshed_in_authconfigs</code>: Secret-based identities refreshed in affected AuthConfigs</li> </ul>"},{"location":"authorino/docs/user-guides/observability/#linking-parent-traces-for-authconfig","title":"Linking parent traces for AuthConfig","text":"<p>Authorino supports linking AuthConfig reconciliation traces to parent operations by extracting W3C Trace Context from AuthConfig resource annotations.</p> <p>When an AuthConfig is created or updated with W3C Trace Context annotations (<code>traceparent</code> and optionally <code>tracestate</code>), the reconciliation span will include a trace link to the originating operation. This creates a connection (via span link, not parent-child relationship, since reconciliation is asynchronous and event-driven) that allows you to correlate external operations with the resulting reconciliation activity in your distributed tracing system.</p> <p>To link a parent trace to AuthConfig reconciliation, add W3C Trace Context annotations to the AuthConfig resource:</p> <pre><code>apiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: my-api-protection\n  annotations:\n    traceparent: \"00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01\"\nspec:\n  # ... AuthConfig spec\n</code></pre> <p>When Authorino reconciles this resource, it will extract the trace context from the annotations and create a span link, allowing you to see the connection between your deployment operation and the subsequent reconciliation in your tracing backend (e.g., Jaeger, Tempo).</p>"},{"location":"authorino/docs/user-guides/oidc-jwt-authentication/","title":"User guide: OpenID Connect Discovery and authentication with JWTs","text":"<p>Validate JSON Web Tokens (JWT) issued and signed by an OpenID Connect server; leverage OpenID Connect Discovery to automatically fetch JSON Web Key Sets (JWKS).</p> Authorino capabilities featured in this guide: <ul> <li>Identity verification &amp; authentication \u2192 JWT verification</li> </ul> <p>Authorino validates JSON Web Tokens (JWT) issued by an OpenID Connect server that implements OpenID Connect Discovery. Authorino fetches the OpenID Connect configuration and JSON Web Key Set (JWKS) from the issuer endpoint, and verifies the JSON Web Signature (JWS) and time validity of the token.</p> <p>Important! Authorino does not implement OAuth2 grants nor OIDC authentication flows. As a common recommendation of good practice, obtaining and refreshing access tokens is for clients to negotiate directly with the auth servers and token issuers. Authorino will only validate those tokens using the parameters provided by the trusted issuer authorities.</p> <p>For further details about Authorino features in general, check the docs.</p> <p></p>"},{"location":"authorino/docs/user-guides/oidc-jwt-authentication/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC)</li> <li>Identity Provider (IdP) that implements OpenID Connect authentication and OpenID Connect Discovery (e.g. Keycloak)</li> <li>jq, to extract parts of JSON responses</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p>Deploy the identity provider and authentication server by executing the command below. For the examples in this guide, we are going to use a Keycloak server preloaded with all required realm settings.</p> <pre><code>kubectl create namespace keycloak\nkubectl -n keycloak apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/keycloak/keycloak-deploy.yaml\n</code></pre> <p></p> <p>The next steps walk you through installing Authorino, deploying and configuring a sample service called Talker API to be protected by the authorization service.</p> Using Kuadrant <p>If you are a user of Kuadrant and already have your workload cluster configured and sample service application deployed, as well as your Gateway API network resources applied to route traffic to your service, skip straight to step \u277a.</p> <p>At step \u277a, instead of creating an <code>AuthConfig</code> custom resource, create a Kuadrant <code>AuthPolicy</code> one. The schema of the AuthConfig's <code>spec</code> matches the one of the AuthPolicy's, except <code>spec.host</code>, which is not available in the Kuadrant AuthPolicy. Host names in a Kuadrant AuthPolicy are inferred automatically from the Kubernetes network object referred in <code>spec.targetRef</code> and route selectors declared in the policy.</p> <p>For more about using Kuadrant to enforce authorization, check out Kuadrant auth.</p> <p></p>"},{"location":"authorino/docs/user-guides/oidc-jwt-authentication/#install-the-authorino-operator-cluster-admin-required","title":"\u2776 Install the Authorino Operator (cluster admin required)","text":"<p>The following command will install the Authorino Operator in the Kubernetes cluster. The operator manages instances of the Authorino authorization service.</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/oidc-jwt-authentication/#deploy-authorino","title":"\u2777 Deploy Authorino","text":"<p>The following command will request an instance of Authorino as a separate service<sup>1</sup> that watches for <code>AuthConfig</code> resources in the <code>default</code> namespace<sup>2</sup>, with TLS disabled<sup>3</sup>.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/oidc-jwt-authentication/#deploy-the-talker-api","title":"\u2778 Deploy the Talker API","text":"<p>The Talker API is a simple HTTP service that echoes back in the response whatever it gets in the request. We will use it in this guide as the sample service to be protected by Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/docs/user-guides/oidc-jwt-authentication/#setup-envoy","title":"\u2779 Setup Envoy","text":"<p>The following bundle from the Authorino examples deploys the Envoy proxy and configuration to wire up the Talker API behind the reverse-proxy, with external authorization enabled with the Authorino instance.<sup>4</sup></p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The command above creates an <code>Ingress</code> with host name <code>talker-api.127.0.0.1.nip.io</code>. If you are using a local Kubernetes cluster created with Kind, forward requests from your local port 8000 to the Envoy service running inside the cluster:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre>"},{"location":"authorino/docs/user-guides/oidc-jwt-authentication/#create-an-authconfig","title":"\u277a Create an <code>AuthConfig</code>","text":"<p>Create an Authorino <code>AuthConfig</code> custom resource declaring the auth rules to be enforced:</p> Kuadrant users \u2013         Remember to create an <code>AuthPolicy</code> instead of an AuthConfig.         For more, see Kuadrant auth.        <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n\n  - talker-api.127.0.0.1.nip.io\n  authentication:\n    \"keycloak-kuadrant-realm\":\n      jwt:\n        issuerUrl: http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/oidc-jwt-authentication/#obtain-an-access-token-with-the-keycloak-server","title":"\u277b Obtain an access token with the Keycloak server","text":"<p>The <code>AuthConfig</code> deployed in the previous step is suitable for validating access tokens requested inside the cluster. This is because Keycloak's <code>iss</code> claim added to the JWTs matches always the host used to request the token and Authorino will later try to match this host to the host that provides the OpenID Connect configuration.</p> <p>Obtain an access token from within the cluster:</p> <pre><code>ACCESS_TOKEN=$(kubectl run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant/protocol/openid-connect/token -s -d 'grant_type=password' -d 'client_id=demo' -d 'username=john' -d 'password=p' -d 'scope=openid' | jq -r .access_token)\n</code></pre> <p>If your Keycloak server is reachable from outside the cluster, feel free to obtain the token directly. Make sure the host name set in the OIDC issuer endpoint in the <code>AuthConfig</code> matches the one used to obtain the token and is as well reachable from within the cluster.</p>"},{"location":"authorino/docs/user-guides/oidc-jwt-authentication/#consume-the-api","title":"\u277c Consume the API","text":"<p>With a valid access token:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api.127.0.0.1.nip.io:8000/hello\n# HTTP/1.1 200 OK\n</code></pre> <p>With missing or invalid access token:</p> <pre><code>curl http://talker-api.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 401 Unauthorized\n# www-authenticate: Bearer realm=\"keycloak-kuadrant-realm\"\n# x-ext-auth-reason: credential not found\n</code></pre>"},{"location":"authorino/docs/user-guides/oidc-jwt-authentication/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete authconfig/talker-api-protection\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\nkubectl delete authorino/authorino\nkubectl delete namespace keycloak\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <ol> <li> <p>In contrast to a dedicated sidecar of the protected service and other architectures. Check out Architecture &gt; Topologies for all options.\u00a0\u21a9</p> </li> <li> <p><code>namespaced</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> <li> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. If you are running your ingress gateway in Kubernetes and wants to avoid setting up and configuring your proxy manually, check out Kuadrant.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/oidc-rbac/","title":"User guide: OpenID Connect (OIDC) and Role-Based Access Control (RBAC) with Authorino and Keycloak","text":"<p>Combine OpenID Connect (OIDC) authentication and Role-Based Access Control (RBAC) authorization rules leveraging Keycloak and Authorino working together.</p> <p>In this user guide, you will learn via example how to implement a simple Role-Based Access Control (RBAC) system to protect endpoints of an API, with roles assigned to users of an Identity Provider (Keycloak) and carried within the access tokens as JSON Web Token (JWT) claims. Users authenticate with the IdP via OAuth2/OIDC flow and get their access tokens verified and validated by Authorino on every request. Moreover, Authorino reads the role bindings of the user and enforces the proper RBAC rules based upon the context.</p> Authorino capabilities featured in this guide: <ul> <li>Identity verification &amp; authentication \u2192 JWT verification</li> <li>Authorization \u2192 Pattern-matching authorization</li> </ul> <p>Check out as well the user guides about OpenID Connect Discovery and authentication with JWTs and Simple pattern-matching authorization policies.</p> <p>For further details about Authorino features in general, check the docs.</p> <p></p>"},{"location":"authorino/docs/user-guides/oidc-rbac/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC)</li> <li>Identity Provider (IdP) that implements OpenID Connect authentication and OpenID Connect Discovery (e.g. Keycloak)</li> <li>jq, to extract parts of JSON responses</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p>Deploy the identity provider and authentication server by executing the command below. For the examples in this guide, we are going to use a Keycloak server preloaded with all required realm settings.</p> <pre><code>kubectl create namespace keycloak\nkubectl -n keycloak apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/keycloak/keycloak-deploy.yaml\n</code></pre> <p></p> <p>The next steps walk you through installing Authorino, deploying and configuring a sample service called Talker API to be protected by the authorization service.</p> Using Kuadrant <p>If you are a user of Kuadrant and already have your workload cluster configured and sample service application deployed, as well as your Gateway API network resources applied to route traffic to your service, skip straight to step \u277a.</p> <p>At step \u277a, instead of creating an <code>AuthConfig</code> custom resource, create a Kuadrant <code>AuthPolicy</code> one. The schema of the AuthConfig's <code>spec</code> matches the one of the AuthPolicy's, except <code>spec.host</code>, which is not available in the Kuadrant AuthPolicy. Host names in a Kuadrant AuthPolicy are inferred automatically from the Kubernetes network object referred in <code>spec.targetRef</code> and route selectors declared in the policy.</p> <p>For more about using Kuadrant to enforce authorization, check out Kuadrant auth.</p> <p></p>"},{"location":"authorino/docs/user-guides/oidc-rbac/#install-the-authorino-operator-cluster-admin-required","title":"\u2776 Install the Authorino Operator (cluster admin required)","text":"<p>The following command will install the Authorino Operator in the Kubernetes cluster. The operator manages instances of the Authorino authorization service.</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/oidc-rbac/#deploy-authorino","title":"\u2777 Deploy Authorino","text":"<p>The following command will request an instance of Authorino as a separate service<sup>1</sup> that watches for <code>AuthConfig</code> resources in the <code>default</code> namespace<sup>2</sup>, with TLS disabled<sup>3</sup>.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/oidc-rbac/#deploy-the-talker-api","title":"\u2778 Deploy the Talker API","text":"<p>The Talker API is a simple HTTP service that echoes back in the response whatever it gets in the request. We will use it in this guide as the sample service to be protected by Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/docs/user-guides/oidc-rbac/#setup-envoy","title":"\u2779 Setup Envoy","text":"<p>The following bundle from the Authorino examples deploys the Envoy proxy and configuration to wire up the Talker API behind the reverse-proxy, with external authorization enabled with the Authorino instance.<sup>4</sup></p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The command above creates an <code>Ingress</code> with host name <code>talker-api.127.0.0.1.nip.io</code>. If you are using a local Kubernetes cluster created with Kind, forward requests from your local port 8000 to the Envoy service running inside the cluster:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre>"},{"location":"authorino/docs/user-guides/oidc-rbac/#create-an-authconfig","title":"\u277a Create an <code>AuthConfig</code>","text":"<p>Create an Authorino <code>AuthConfig</code> custom resource declaring the auth rules to be enforced.</p> <p>In this example, the Keycloak realm defines a few users and 2 realm roles: 'member' and 'admin'. When users authenticate to the Keycloak server by any of the supported OAuth2/OIDC flows, Keycloak adds to the access token JWT a claim <code>\"realm_access\": { \"roles\": array }</code> that holds the list of roles assigned to the user. Authorino will verify the JWT on requests to the API and read from that claim to enforce the following RBAC rules:</p> Path Method Role /resources[/*] GET / POST / PUT member /resources/{id} DELETE admin /admin[/*] * admin Kuadrant users \u2013         Remember to create an <code>AuthPolicy</code> instead of an AuthConfig.         For more, see Kuadrant auth.        <p>Apply the AuthConfig:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n\n  - talker-api.127.0.0.1.nip.io\n\n  authentication:\n    \"keycloak-kuadrant-realm\":\n      jwt:\n        issuerUrl: http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant\n\n  patterns:\n    \"member-role\":\n\n    - selector: auth.identity.realm_access.roles\n      operator: incl\n      value: member\n    \"admin-role\":\n    - selector: auth.identity.realm_access.roles\n      operator: incl\n      value: admin\n\n  authorization:\n    # RBAC rule: 'member' role required for requests to /resources[/*]\n    \"rbac-resources-api\":\n      when:\n\n      - selector: context.request.http.path\n        operator: matches\n        value: ^/resources(/.*)?$\n      patternMatching:\n        patterns:\n        - patternRef: member-role\n\n    # RBAC rule: 'admin' role required for DELETE requests to /resources/{id}\n    \"rbac-delete-resource\":\n      when:\n\n      - selector: context.request.http.path\n        operator: matches\n        value: ^/resources/\\d+$\n      - selector: context.request.http.method\n        operator: eq\n        value: DELETE\n      patternMatching:\n        patterns:\n        - patternRef: admin-role\n\n    # RBAC rule: 'admin' role required for requests to /admin[/*]\n    \"rbac-admin-api\":\n      when:\n\n      - selector: context.request.http.path\n        operator: matches\n        value: ^/admin(/.*)?$\n      patternMatching:\n        patterns:\n        - patternRef: admin-role\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/oidc-rbac/#obtain-an-access-token-and-consume-the-api","title":"\u277b Obtain an access token and consume the API","text":""},{"location":"authorino/docs/user-guides/oidc-rbac/#obtain-an-access-token-and-consume-the-api-as-john-member","title":"Obtain an access token and consume the API as John (member)","text":"<p>Obtain an access token with the Keycloak server for John:</p> <p>The <code>AuthConfig</code> deployed in the previous step is suitable for validating access tokens requested inside the cluster. This is because Keycloak's <code>iss</code> claim added to the JWTs matches always the host used to request the token and Authorino will later try to match this host to the host that provides the OpenID Connect configuration.</p> <p>Obtain an access token from within the cluster for the user John, who is assigned to the 'member' role:</p> <pre><code>ACCESS_TOKEN=$(kubectl run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant/protocol/openid-connect/token -s -d 'grant_type=password' -d 'client_id=demo' -d 'username=john' -d 'password=p' -d 'scope=openid' | jq -r .access_token)\n</code></pre> <p>If your Keycloak server is reachable from outside the cluster, feel free to obtain the token directly. Make sure the host name set in the OIDC issuer endpoint in the <code>AuthConfig</code> matches the one used to obtain the token and is as well reachable from within the cluster.</p> <p>As John, send a <code>GET</code> request to /resources:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api.127.0.0.1.nip.io:8000/resources -i\n# HTTP/1.1 200 OK\n</code></pre> <p>As John, send a <code>DELETE</code> request to /resources/123:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" -X DELETE http://talker-api.127.0.0.1.nip.io:8000/resources/123 -i\n# HTTP/1.1 403 Forbidden\n</code></pre> <p>As John, send a <code>GET</code> request to /admin/settings:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api.127.0.0.1.nip.io:8000/admin/settings -i\n# HTTP/1.1 403 Forbidden\n</code></pre>"},{"location":"authorino/docs/user-guides/oidc-rbac/#obtain-an-access-token-and-consume-the-api-as-jane-memberadmin","title":"Obtain an access token and consume the API as Jane (member/admin)","text":"<p>Obtain an access token from within the cluster for the user Jane, who is assigned to the 'member' and 'admin' roles:</p> <pre><code>ACCESS_TOKEN=$(kubectl run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant/protocol/openid-connect/token -s -d 'grant_type=password' -d 'client_id=demo' -d 'username=jane' -d 'password=p' -d 'scope=openid' | jq -r .access_token)\n</code></pre> <p>As Jane, send a <code>GET</code> request to /resources:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api.127.0.0.1.nip.io:8000/resources -i\n# HTTP/1.1 200 OK\n</code></pre> <p>As Jane, send a <code>DELETE</code> request to /resources/123:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" -X DELETE http://talker-api.127.0.0.1.nip.io:8000/resources/123 -i\n# HTTP/1.1 200 OK\n</code></pre> <p>As Jane, send a <code>GET</code> request to /admin/settings:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api.127.0.0.1.nip.io:8000/admin/settings -i\n# HTTP/1.1 200 OK\n</code></pre>"},{"location":"authorino/docs/user-guides/oidc-rbac/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete authconfig/talker-api-protection\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\nkubectl delete authorino/authorino\nkubectl delete namespace keycloak\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <ol> <li> <p>In contrast to a dedicated sidecar of the protected service and other architectures. Check out Architecture &gt; Topologies for all options.\u00a0\u21a9</p> </li> <li> <p><code>namespaced</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> <li> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. If you are running your ingress gateway in Kubernetes and wants to avoid setting up and configuring your proxy manually, check out Kuadrant.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/oidc-user-info/","title":"User guide: OpenID Connect UserInfo","text":"<p>Fetch user info for OpenID Connect ID tokens in request-time for extra metadata for your policies and online verification of token validity.</p> Authorino capabilities featured in this guide: <ul> <li>External auth metadata \u2192 OIDC UserInfo</li> <li>Identity verification &amp; authentication \u2192 JWT verification</li> <li>Authorization \u2192 Pattern-matching authorization</li> </ul> <p>Apart from possibly complementing information of the JWT, fetching OpenID Connect UserInfo in request-time can be particularly useful for remote checking the state of the session, as opposed to only verifying the JWT/JWS offline. Implementation requires an OpenID Connect issuer (<code>spec.identity.oidc</code>) configured in the same <code>AuthConfig</code>.</p> <p>Check out as well the user guide about OpenID Connect Discovery and authentication with JWTs.</p> <p>For further details about Authorino features in general, check the docs.</p> <p></p>"},{"location":"authorino/docs/user-guides/oidc-user-info/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC)</li> <li>Identity Provider (IdP) that implements OpenID Connect authentication and OpenID Connect Discovery (e.g. Keycloak)</li> <li>jq, to extract parts of JSON responses</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p>Deploy the identity provider and authentication server by executing the command below. For the examples in this guide, we are going to use a Keycloak server preloaded with all required realm settings.</p> <pre><code>kubectl create namespace keycloak\nkubectl -n keycloak apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/keycloak/keycloak-deploy.yaml\n</code></pre> <p></p> <p>The next steps walk you through installing Authorino, deploying and configuring a sample service called Talker API to be protected by the authorization service.</p> Using Kuadrant <p>If you are a user of Kuadrant and already have your workload cluster configured and sample service application deployed, as well as your Gateway API network resources applied to route traffic to your service, skip straight to step \u277a.</p> <p>At step \u277a, instead of creating an <code>AuthConfig</code> custom resource, create a Kuadrant <code>AuthPolicy</code> one. The schema of the AuthConfig's <code>spec</code> matches the one of the AuthPolicy's, except <code>spec.host</code>, which is not available in the Kuadrant AuthPolicy. Host names in a Kuadrant AuthPolicy are inferred automatically from the Kubernetes network object referred in <code>spec.targetRef</code> and route selectors declared in the policy.</p> <p>For more about using Kuadrant to enforce authorization, check out Kuadrant auth.</p> <p></p>"},{"location":"authorino/docs/user-guides/oidc-user-info/#install-the-authorino-operator-cluster-admin-required","title":"\u2776 Install the Authorino Operator (cluster admin required)","text":"<p>The following command will install the Authorino Operator in the Kubernetes cluster. The operator manages instances of the Authorino authorization service.</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/oidc-user-info/#deploy-authorino","title":"\u2777 Deploy Authorino","text":"<p>The following command will request an instance of Authorino as a separate service<sup>1</sup> that watches for <code>AuthConfig</code> resources in the <code>default</code> namespace<sup>2</sup>, with TLS disabled<sup>3</sup>.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/oidc-user-info/#deploy-the-talker-api","title":"\u2778 Deploy the Talker API","text":"<p>The Talker API is a simple HTTP service that echoes back in the response whatever it gets in the request. We will use it in this guide as the sample service to be protected by Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/docs/user-guides/oidc-user-info/#setup-envoy","title":"\u2779 Setup Envoy","text":"<p>The following bundle from the Authorino examples deploys the Envoy proxy and configuration to wire up the Talker API behind the reverse-proxy, with external authorization enabled with the Authorino instance.<sup>4</sup></p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The command above creates an <code>Ingress</code> with host name <code>talker-api.127.0.0.1.nip.io</code>. If you are using a local Kubernetes cluster created with Kind, forward requests from your local port 8000 to the Envoy service running inside the cluster:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre>"},{"location":"authorino/docs/user-guides/oidc-user-info/#create-an-authconfig","title":"\u277a Create an <code>AuthConfig</code>","text":"<p>Create an Authorino <code>AuthConfig</code> custom resource declaring the auth rules to be enforced:</p> Kuadrant users \u2013         Remember to create an <code>AuthPolicy</code> instead of an AuthConfig.         For more, see Kuadrant auth.        <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n\n  - talker-api.127.0.0.1.nip.io\n  authentication:\n    \"keycloak-kuadrant-realm\":\n      jwt:\n        issuerUrl: http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant\n  metadata:\n    \"userinfo\":\n      userInfo:\n        identitySource: keycloak-kuadrant-realm\n  authorization:\n    \"active-tokens-only\":\n      patternMatching:\n        patterns:\n        - selector: \"auth.metadata.userinfo.email\" # user email expected from the userinfo instead of the jwt\n          operator: neq\n          value: \"\"\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/oidc-user-info/#obtain-an-access-token-with-the-keycloak-server","title":"\u277b Obtain an access token with the Keycloak server","text":"<p>The <code>AuthConfig</code> deployed in the previous step is suitable for validating access tokens requested inside the cluster. This is because Keycloak's <code>iss</code> claim added to the JWTs matches always the host used to request the token and Authorino will later try to match this host to the host that provides the OpenID Connect configuration.</p> <p>Obtain an access token from within the cluster:</p> <pre><code>export $(kubectl run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant/protocol/openid-connect/token -s -d 'grant_type=password' -d 'client_id=demo' -d 'username=jane' -d 'password=p' -d 'scope=openid' | jq -r '\"ACCESS_TOKEN=\"+.access_token,\"REFRESH_TOKEN=\"+.refresh_token')\n</code></pre> <p>If your Keycloak server is reachable from outside the cluster, feel free to obtain the token directly. Make sure the host name set in the OIDC issuer endpoint in the <code>AuthConfig</code> matches the one used to obtain the token and is as well reachable from within the cluster.</p>"},{"location":"authorino/docs/user-guides/oidc-user-info/#consume-the-api","title":"\u277c Consume the API","text":"<p>With a valid access token:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api.127.0.0.1.nip.io:8000/hello\n# HTTP/1.1 200 OK\n</code></pre> <p>Revoke the access token and try to consume the API again:</p> <pre><code>kubectl run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant/protocol/openid-connect/logout -H \"Content-Type: application/x-www-form-urlencoded\" -d \"refresh_token=$REFRESH_TOKEN\" -d 'token_type_hint=requesting_party_token' -u demo:\n</code></pre> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 403 Forbidden\n</code></pre>"},{"location":"authorino/docs/user-guides/oidc-user-info/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete authconfig/talker-api-protection\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\nkubectl delete authorino/authorino\nkubectl delete namespace keycloak\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <ol> <li> <p>In contrast to a dedicated sidecar of the protected service and other architectures. Check out Architecture &gt; Topologies for all options.\u00a0\u21a9</p> </li> <li> <p><code>namespaced</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> <li> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. If you are running your ingress gateway in Kubernetes and wants to avoid setting up and configuring your proxy manually, check out Kuadrant.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/opa-authorization/","title":"User guide: Open Policy Agent (OPA) Rego policies","text":"<p>Leverage the power of Open Policy Agent (OPA) policies, evaluated against Authorino's Authorization JSON in a built-in runtime compiled together with Authorino; pre-cache policies defined in Rego language inline or fetched from an external policy registry.</p> Authorino capabilities featured in this guide: <ul> <li>Authorization \u2192 Open Policy Agent (OPA) Rego policies</li> <li>Identity verification &amp; authentication \u2192 API key</li> </ul> <p>Authorino supports Open Policy Agent policies, either inline defined in Rego language as part of the <code>AuthConfig</code> or fetched from an external endpoint, such as an OPA Policy Registry.</p> <p>Authorino's built-in OPA module precompiles the policies in reconciliation-time and cache them for fast evaluation in request-time, where they receive the Authorization JSON as input.</p> <p>Check out as well the user guide about Authentication with API keys.</p> <p>For further details about Authorino features in general, check the docs.</p> <p></p>"},{"location":"authorino/docs/user-guides/opa-authorization/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC)</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p></p> <p>The next steps walk you through installing Authorino, deploying and configuring a sample service called Talker API to be protected by the authorization service.</p> Using Kuadrant <p>If you are a user of Kuadrant and already have your workload cluster configured and sample service application deployed, as well as your Gateway API network resources applied to route traffic to your service, skip straight to step \u277a.</p> <p>At step \u277a, instead of creating an <code>AuthConfig</code> custom resource, create a Kuadrant <code>AuthPolicy</code> one. The schema of the AuthConfig's <code>spec</code> matches the one of the AuthPolicy's, except <code>spec.host</code>, which is not available in the Kuadrant AuthPolicy. Host names in a Kuadrant AuthPolicy are inferred automatically from the Kubernetes network object referred in <code>spec.targetRef</code> and route selectors declared in the policy.</p> <p>For more about using Kuadrant to enforce authorization, check out Kuadrant auth.</p> <p></p>"},{"location":"authorino/docs/user-guides/opa-authorization/#install-the-authorino-operator-cluster-admin-required","title":"\u2776 Install the Authorino Operator (cluster admin required)","text":"<p>The following command will install the Authorino Operator in the Kubernetes cluster. The operator manages instances of the Authorino authorization service.</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/opa-authorization/#deploy-authorino","title":"\u2777 Deploy Authorino","text":"<p>The following command will request an instance of Authorino as a separate service<sup>1</sup> that watches for <code>AuthConfig</code> resources in the <code>default</code> namespace<sup>2</sup>, with TLS disabled<sup>3</sup>.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/opa-authorization/#deploy-the-talker-api","title":"\u2778 Deploy the Talker API","text":"<p>The Talker API is a simple HTTP service that echoes back in the response whatever it gets in the request. We will use it in this guide as the sample service to be protected by Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/docs/user-guides/opa-authorization/#setup-envoy","title":"\u2779 Setup Envoy","text":"<p>The following bundle from the Authorino examples deploys the Envoy proxy and configuration to wire up the Talker API behind the reverse-proxy, with external authorization enabled with the Authorino instance.<sup>4</sup></p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The command above creates an <code>Ingress</code> with host name <code>talker-api.127.0.0.1.nip.io</code>. If you are using a local Kubernetes cluster created with Kind, forward requests from your local port 8000 to the Envoy service running inside the cluster:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre>"},{"location":"authorino/docs/user-guides/opa-authorization/#create-an-authconfig","title":"\u277a Create an <code>AuthConfig</code>","text":"<p>Create an Authorino <code>AuthConfig</code> custom resource declaring the auth rules to be enforced.</p> <p>In this example, we will use OPA to implement a read-only policy for requests coming from outside a trusted network (IP range 192.168.1/24).</p> <p>The implementation relies on the <code>X-Forwarded-For</code> HTTP header to read the client's IP address.<sup>5</sup></p> Kuadrant users \u2013         Remember to create an <code>AuthPolicy</code> instead of an AuthConfig.         For more, see Kuadrant auth.        <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n\n  - talker-api.127.0.0.1.nip.io\n  authentication:\n    \"friends\":\n      apiKey:\n        selector:\n          matchLabels:\n            group: friends\n      credentials:\n        authorizationHeader:\n          prefix: APIKEY\n  authorization:\n    \"read-only-outside\":\n      opa:\n        rego: |\n          ips := split(input.context.request.http.headers[\"x-forwarded-for\"], \",\")\n          trusted_network { net.cidr_contains(\"192.168.1.1/24\", ips[0]) }\n\n          allow { trusted_network }\n          allow { not trusted_network; input.context.request.http.method == \"GET\" }\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/opa-authorization/#create-the-api-key","title":"\u277b Create the API key","text":"<pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: api-key-1\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    group: friends\nstringData:\n  api_key: ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx\ntype: Opaque\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/opa-authorization/#consume-the-api","title":"\u277c Consume the API","text":"<p>Inside the trusted network:</p> <pre><code>curl -H 'Authorization: APIKEY ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx' \\\n     -H 'X-Forwarded-For: 192.168.1.10' \\\n     http://talker-api.127.0.0.1.nip.io:8000/hello\n# HTTP/1.1 200 OK\n</code></pre> <pre><code>curl -H 'Authorization: APIKEY ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx' \\\n     -H 'X-Forwarded-For: 192.168.1.10' \\\n     -X POST \\\n     http://talker-api.127.0.0.1.nip.io:8000/hello\n# HTTP/1.1 200 OK\n</code></pre> <p>Outside the trusted network:</p> <pre><code>curl -H 'Authorization: APIKEY ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx' \\\n     -H 'X-Forwarded-For: 123.45.6.78' \\\n     http://talker-api.127.0.0.1.nip.io:8000/hello\n# HTTP/1.1 200 OK\n</code></pre> <pre><code>curl -H 'Authorization: APIKEY ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx' \\\n     -H 'X-Forwarded-For: 123.45.6.78' \\\n     -X POST \\\n     http://talker-api.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 403 Forbidden\n# x-ext-auth-reason: Unauthorized\n</code></pre>"},{"location":"authorino/docs/user-guides/opa-authorization/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete secret/api-key-1\nkubectl delete authconfig/talker-api-protection\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\nkubectl delete authorino/authorino\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <ol> <li> <p>In contrast to a dedicated sidecar of the protected service and other architectures. Check out Architecture &gt; Topologies for all options.\u00a0\u21a9</p> </li> <li> <p><code>namespaced</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> <li> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. If you are running your ingress gateway in Kubernetes and wants to avoid setting up and configuring your proxy manually, check out Kuadrant.\u00a0\u21a9</p> </li> <li> <p>You can also set <code>use_remote_address: true</code> in the Envoy route configuration, so the proxy will append its IP address instead of run in transparent mode. This setting will also ensure real remote address of the client connection passed in the <code>x-envoy-external-address</code> HTTP header, which can be used to simplify the read-only policy in remote environment.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/passing-credentials/","title":"User guide: Passing credentials (<code>Authorization</code> header, cookie headers and others)","text":"<p>Customize where credentials are supplied in the request by each trusted source of identity.</p> Authorino capabilities featured in this guide: <ul> <li>Identity verification &amp; authentication \u2192 Auth credentials</li> <li>Identity verification &amp; authentication \u2192 API key</li> </ul> <p>Authentication tokens can be supplied in the <code>Authorization</code> header, in a custom header, cookie or query string parameter.</p> <p>Check out as well the user guide about Authentication with API keys.</p> <p>For further details about Authorino features in general, check the docs.</p> <p></p>"},{"location":"authorino/docs/user-guides/passing-credentials/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC)</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p></p> <p>The next steps walk you through installing Authorino, deploying and configuring a sample service called Talker API to be protected by the authorization service.</p> Using Kuadrant <p>If you are a user of Kuadrant and already have your workload cluster configured and sample service application deployed, as well as your Gateway API network resources applied to route traffic to your service, skip straight to step \u277a.</p> <p>At step \u277a, instead of creating an <code>AuthConfig</code> custom resource, create a Kuadrant <code>AuthPolicy</code> one. The schema of the AuthConfig's <code>spec</code> matches the one of the AuthPolicy's, except <code>spec.host</code>, which is not available in the Kuadrant AuthPolicy. Host names in a Kuadrant AuthPolicy are inferred automatically from the Kubernetes network object referred in <code>spec.targetRef</code> and route selectors declared in the policy.</p> <p>For more about using Kuadrant to enforce authorization, check out Kuadrant auth.</p> <p></p>"},{"location":"authorino/docs/user-guides/passing-credentials/#install-the-authorino-operator-cluster-admin-required","title":"\u2776 Install the Authorino Operator (cluster admin required)","text":"<p>The following command will install the Authorino Operator in the Kubernetes cluster. The operator manages instances of the Authorino authorization service.</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/passing-credentials/#deploy-authorino","title":"\u2777 Deploy Authorino","text":"<p>The following command will request an instance of Authorino as a separate service<sup>1</sup> that watches for <code>AuthConfig</code> resources in the <code>default</code> namespace<sup>2</sup>, with TLS disabled<sup>3</sup>.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/passing-credentials/#deploy-the-talker-api","title":"\u2778 Deploy the Talker API","text":"<p>The Talker API is a simple HTTP service that echoes back in the response whatever it gets in the request. We will use it in this guide as the sample service to be protected by Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/docs/user-guides/passing-credentials/#setup-envoy","title":"\u2779 Setup Envoy","text":"<p>The following bundle from the Authorino examples deploys the Envoy proxy and configuration to wire up the Talker API behind the reverse-proxy, with external authorization enabled with the Authorino instance.<sup>4</sup></p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The command above creates an <code>Ingress</code> with host name <code>talker-api.127.0.0.1.nip.io</code>. If you are using a local Kubernetes cluster created with Kind, forward requests from your local port 8000 to the Envoy service running inside the cluster:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre>"},{"location":"authorino/docs/user-guides/passing-credentials/#create-an-authconfig","title":"\u277a Create an <code>AuthConfig</code>","text":"<p>Create an Authorino <code>AuthConfig</code> custom resource declaring the auth rules to be enforced.</p> <p>In this example, <code>member</code> users can authenticate supplying the API key in any of 4 different ways:</p> <ul> <li>HTTP header <code>Authorization: APIKEY &lt;api-key&gt;</code></li> <li>HTTP header <code>X-API-Key: &lt;api-key&gt;</code></li> <li>Query string parameter <code>api_key=&lt;api-key&gt;</code></li> <li>Cookie <code>Cookie: APIKEY=&lt;api-key&gt;;</code></li> </ul> <p><code>admin</code> API keys are only accepted in the (default) HTTP header <code>Authorization: Bearer &lt;api-key&gt;</code>.</p> Kuadrant users \u2013         Remember to create an <code>AuthPolicy</code> instead of an AuthConfig.         For more, see Kuadrant auth.        <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n\n  - talker-api.127.0.0.1.nip.io\n  authentication:\n    \"members-authorization-header\":\n      apiKey:\n        selector:\n          matchLabels:\n            group: members\n      credentials:\n        authorizationHeader:\n          prefix: APIKEY # instead of the default prefix 'Bearer'\n    \"members-custom-header\":\n      apiKey:\n        selector:\n          matchLabels:\n            group: members\n      credentials:\n        customHeader:\n          name: X-API-Key\n    \"members-query-string-param\":\n      apiKey:\n        selector:\n          matchLabels:\n            group: members\n      credentials:\n        queryString:\n          name: api_key\n    \"members-cookie\":\n      apiKey:\n        selector:\n          matchLabels:\n            group: members\n      credentials:\n        cookie:\n          name: APIKEY\n    \"admins\":\n      apiKey:\n        selector:\n          matchLabels:\n            group: admins\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/passing-credentials/#create-the-api-keys","title":"\u277b Create the API keys","text":"<p>For a member user:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: api-key-1\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    group: members\nstringData:\n  api_key: ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx\ntype: Opaque\nEOF\n</code></pre> <p>For an admin user:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: api-key-2\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    group: admins\nstringData:\n  api_key: 7BNaTmYGItSzXiwQLNHu82+x52p1XHgY\ntype: Opaque\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/passing-credentials/#consume-the-api","title":"\u277c Consume the API","text":"<p>As member user, passing the API key in the <code>Authorization</code> header:</p> <pre><code>curl -H 'Authorization: APIKEY ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx' http://talker-api.127.0.0.1.nip.io:8000/hello\n# HTTP/1.1 200 OK\n</code></pre> <p>As member user, passing the API key in the custom <code>X-API-Key</code> header:</p> <pre><code>curl -H 'X-API-Key: ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx' http://talker-api.127.0.0.1.nip.io:8000/hello\n# HTTP/1.1 200 OK\n</code></pre> <p>As member user, passing the API key in the query string parameter <code>api_key</code>:</p> <pre><code>curl \"http://talker-api.127.0.0.1.nip.io:8000/hello?api_key=ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx\"\n# HTTP/1.1 200 OK\n</code></pre> <p>As member user, passing the API key in the <code>APIKEY</code> cookie header:</p> <pre><code>curl -H 'Cookie: APIKEY=ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx;foo=bar' http://talker-api.127.0.0.1.nip.io:8000/hello\n# HTTP/1.1 200 OK\n</code></pre> <p>As admin user:</p> <pre><code>curl -H 'Authorization: Bearer 7BNaTmYGItSzXiwQLNHu82+x52p1XHgY' http://talker-api.127.0.0.1.nip.io:8000/hello\n# HTTP/1.1 200 OK\n</code></pre> <p>Missing the API key:</p> <pre><code>curl http://talker-api.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 401 Unauthorized\n# www-authenticate: APIKEY realm=\"members-authorization-header\"\n# www-authenticate: X-API-Key realm=\"members-custom-header\"\n# www-authenticate: api_key realm=\"members-query-string-param\"\n# www-authenticate: APIKEY realm=\"members-cookie\"\n# www-authenticate: Bearer realm=\"admins\"\n# x-ext-auth-reason: {\"admins\":\"credential not found\",\"members-authorization-header\":\"credential not found\",\"members-cookie\":\"credential not found\",\"members-custom-header\":\"credential not found\",\"members-query-string-param\":\"credential not found\"}\n</code></pre>"},{"location":"authorino/docs/user-guides/passing-credentials/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete secret/api-key-1\nkubectl delete secret/api-key-2\nkubectl delete authconfig/talker-api-protection\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\nkubectl delete authorino/authorino\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <ol> <li> <p>In contrast to a dedicated sidecar of the protected service and other architectures. Check out Architecture &gt; Topologies for all options.\u00a0\u21a9</p> </li> <li> <p><code>namespaced</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> <li> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. If you are running your ingress gateway in Kubernetes and wants to avoid setting up and configuring your proxy manually, check out Kuadrant.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/resource-level-authorization-uma/","title":"User guide: Resource-level authorization with User-Managed Access (UMA) resource registry","text":"<p>Fetch resource metadata relevant for your authorization policies from Keycloak authorization clients, using User-Managed Access (UMA) protocol.</p> Authorino capabilities featured in this guide: <ul> <li>External auth metadata \u2192 User-Managed Access (UMA) resource registry</li> <li>Identity verification &amp; authentication \u2192 JWT verification</li> <li>Authorization \u2192 Open Policy Agent (OPA) Rego policies</li> </ul> <p>Check out as well the user guides about OpenID Connect Discovery and authentication with JWTs and Open Policy Agent (OPA) Rego policies.</p> <p>For further details about Authorino features in general, check the docs.</p> <p></p>"},{"location":"authorino/docs/user-guides/resource-level-authorization-uma/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC)</li> <li>Identity Provider (IdP) that implements OpenID Connect authentication and OpenID Connect Discovery (e.g. Keycloak)</li> <li>jq, to extract parts of JSON responses</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p>Deploy the identity provider and authentication server by executing the command below. For the examples in this guide, we are going to use a Keycloak server preloaded with all required realm settings.</p> <pre><code>kubectl create namespace keycloak\nkubectl -n keycloak apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/keycloak/keycloak-deploy.yaml\n</code></pre> <p></p> <p>The next steps walk you through installing Authorino, deploying and configuring a sample service called Talker API to be protected by the authorization service.</p> Using Kuadrant <p>If you are a user of Kuadrant and already have your workload cluster configured and sample service application deployed, as well as your Gateway API network resources applied to route traffic to your service, skip straight to step \u277a.</p> <p>At step \u277a, instead of creating an <code>AuthConfig</code> custom resource, create a Kuadrant <code>AuthPolicy</code> one. The schema of the AuthConfig's <code>spec</code> matches the one of the AuthPolicy's, except <code>spec.host</code>, which is not available in the Kuadrant AuthPolicy. Host names in a Kuadrant AuthPolicy are inferred automatically from the Kubernetes network object referred in <code>spec.targetRef</code> and route selectors declared in the policy.</p> <p>For more about using Kuadrant to enforce authorization, check out Kuadrant auth.</p> <p></p>"},{"location":"authorino/docs/user-guides/resource-level-authorization-uma/#install-the-authorino-operator-cluster-admin-required","title":"\u2776 Install the Authorino Operator (cluster admin required)","text":"<p>The following command will install the Authorino Operator in the Kubernetes cluster. The operator manages instances of the Authorino authorization service.</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/resource-level-authorization-uma/#deploy-authorino","title":"\u2777 Deploy Authorino","text":"<p>The following command will request an instance of Authorino as a separate service<sup>1</sup> that watches for <code>AuthConfig</code> resources in the <code>default</code> namespace<sup>2</sup>, with TLS disabled<sup>3</sup>.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/resource-level-authorization-uma/#deploy-the-talker-api","title":"\u2778 Deploy the Talker API","text":"<p>The Talker API is a simple HTTP service that echoes back in the response whatever it gets in the request. We will use it in this guide as the sample service to be protected by Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/docs/user-guides/resource-level-authorization-uma/#setup-envoy","title":"\u2779 Setup Envoy","text":"<p>The following bundle from the Authorino examples deploys the Envoy proxy and configuration to wire up the Talker API behind the reverse-proxy, with external authorization enabled with the Authorino instance.<sup>4</sup></p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The command above creates an <code>Ingress</code> with host name <code>talker-api.127.0.0.1.nip.io</code>. If you are using a local Kubernetes cluster created with Kind, forward requests from your local port 8000 to the Envoy service running inside the cluster:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre>"},{"location":"authorino/docs/user-guides/resource-level-authorization-uma/#create-an-authconfig","title":"\u277a Create an <code>AuthConfig</code>","text":"<p>Create an Authorino <code>AuthConfig</code> custom resource declaring the auth rules to be enforced:</p> <p>This example of resource-level authorization leverages part of Keycloak's User-Managed Access (UMA) support. Authorino will fetch resource attributes stored in a Keycloak resource server client.</p> <p>The Keycloak server also provides the identities. The <code>sub</code> claim of the Keycloak-issued ID tokens must match the owner of the requested resource, identified by the URI of the request.</p> Kuadrant users \u2013         Remember to create an <code>AuthPolicy</code> instead of an AuthConfig.         For more, see Kuadrant auth.        <p>Create a required secret that will be used by Authorino to initiate the authentication with the UMA registry.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: talker-api-uma-credentials\nstringData:\n  clientID: talker-api\n  clientSecret: 523b92b6-625d-4e1e-a313-77e7a8ae4e88\ntype: Opaque\nEOF\n</code></pre> <p>Create the config:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n\n  - talker-api.127.0.0.1.nip.io\n  authentication:\n    \"keycloak-kuadrant-realm\":\n      jwt:\n        issuerUrl: http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant\n  metadata:\n    \"resource-data\":\n      uma:\n        endpoint: http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant\n        credentialsRef:\n          name: talker-api-uma-credentials\n  authorization:\n    \"owned-resources\":\n      opa:\n        rego: |\n          COLLECTIONS = [\"greetings\"]\n\n          http_request = input.context.request.http\n          http_method = http_request.method\n          requested_path_sections = split(trim_left(trim_right(http_request.path, \"/\"), \"/\"), \"/\")\n\n          get { http_method == \"GET\" }\n          post { http_method == \"POST\" }\n          put { http_method == \"PUT\" }\n          delete { http_method == \"DELETE\" }\n\n          valid_collection { COLLECTIONS[_] == requested_path_sections[0] }\n\n          collection_endpoint {\n            valid_collection\n            count(requested_path_sections) == 1\n          }\n\n          resource_endpoint {\n            valid_collection\n            some resource_id\n            requested_path_sections[1] = resource_id\n          }\n\n          identity_owns_the_resource {\n            identity := input.auth.identity\n            resource_attrs := object.get(input.auth.metadata, \"resource-data\", [])[0]\n            resource_owner := object.get(object.get(resource_attrs, \"owner\", {}), \"id\", \"\")\n            resource_owner == identity.sub\n          }\n\n          allow { get;    collection_endpoint }\n          allow { post;   collection_endpoint }\n          allow { get;    resource_endpoint; identity_owns_the_resource }\n          allow { put;    resource_endpoint; identity_owns_the_resource }\n          allow { delete; resource_endpoint; identity_owns_the_resource }\nEOF\n</code></pre> <p>The OPA policy <code>owned-resource</code> above enforces that all users can send GET and POST requests to <code>/greetings</code>, while only resource owners can send GET, PUT and DELETE requests to <code>/greetings/{resource-id}</code>.</p>"},{"location":"authorino/docs/user-guides/resource-level-authorization-uma/#obtain-access-tokens-with-the-keycloak-server-and-consume-the-api","title":"\u277b Obtain access tokens with the Keycloak server and consume the API","text":""},{"location":"authorino/docs/user-guides/resource-level-authorization-uma/#obtain-an-access-token-as-john-and-consume-the-api","title":"Obtain an access token as John and consume the API","text":"<p>Obtain an access token for user John (owner of the resource <code>/greetings/1</code> in the UMA registry):</p> <p>The <code>AuthConfig</code> deployed in the previous step is suitable for validating access tokens requested inside the cluster. This is because Keycloak's <code>iss</code> claim added to the JWTs matches always the host used to request the token and Authorino will later try to match this host to the host that provides the OpenID Connect configuration.</p> <p>Obtain an access token from within the cluster:</p> <pre><code>ACCESS_TOKEN=$(kubectl run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant/protocol/openid-connect/token -s -d 'grant_type=password' -d 'client_id=demo' -d 'username=john' -d 'password=p' -d 'scope=openid' | jq -r .access_token)\n</code></pre> <p>If your Keycloak server is reachable from outside the cluster, feel free to obtain the token directly. Make sure the host name set in the OIDC issuer endpoint in the <code>AuthConfig</code> matches the one used to obtain the token and is as well reachable from within the cluster.</p> <p>As John, send requests to the API:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api.127.0.0.1.nip.io:8000/greetings\n# HTTP/1.1 200 OK\n\ncurl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api.127.0.0.1.nip.io:8000/greetings/1\n# HTTP/1.1 200 OK\n\ncurl -H \"Authorization: Bearer $ACCESS_TOKEN\" -X DELETE http://talker-api.127.0.0.1.nip.io:8000/greetings/1\n# HTTP/1.1 200 OK\n\ncurl -H \"Authorization: Bearer $ACCESS_TOKEN\" -X DELETE http://talker-api.127.0.0.1.nip.io:8000/greetings/2 -i\n# HTTP/1.1 403 Forbidden\n</code></pre>"},{"location":"authorino/docs/user-guides/resource-level-authorization-uma/#obtain-an-access-token-as-jane-and-consume-the-api","title":"Obtain an access token as Jane and consume the API","text":"<p>Obtain an access token for user Jane (owner of the resource <code>/greetings/2</code> in the UMA registry):</p> <pre><code>ACCESS_TOKEN=$(kubectl run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant/protocol/openid-connect/token -s -d 'grant_type=password' -d 'client_id=demo' -d 'username=jane' -d 'password=p' -d 'scope=openid' | jq -r .access_token)\n</code></pre> <p>As Jane, send requests to the API:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api.127.0.0.1.nip.io:8000/greetings\n# HTTP/1.1 200 OK\n\ncurl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api.127.0.0.1.nip.io:8000/greetings/1 -i\n# HTTP/1.1 403 Forbidden\n\ncurl -H \"Authorization: Bearer $ACCESS_TOKEN\" -X DELETE http://talker-api.127.0.0.1.nip.io:8000/greetings/1 -i\n# HTTP/1.1 403 Forbidden\n\ncurl -H \"Authorization: Bearer $ACCESS_TOKEN\" -X DELETE http://talker-api.127.0.0.1.nip.io:8000/greetings/2\n# HTTP/1.1 200 OK\n</code></pre>"},{"location":"authorino/docs/user-guides/resource-level-authorization-uma/#obtain-an-access-token-as-peter-and-consume-the-api","title":"Obtain an access token as Peter and consume the API","text":"<p>Obtain an access token for user Peter (does not own any resource in the UMA registry):</p> <pre><code>ACCESS_TOKEN=$(kubectl run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant/protocol/openid-connect/token -s -d 'grant_type=password' -d 'client_id=demo' -d 'username=peter' -d 'password=p' -d 'scope=openid' | jq -r .access_token)\n</code></pre> <p>As Jane, send requests to the API:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api.127.0.0.1.nip.io:8000/greetings\n# HTTP/1.1 200 OK\n\ncurl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api.127.0.0.1.nip.io:8000/greetings/1 -i\n# HTTP/1.1 403 Forbidden\n\ncurl -H \"Authorization: Bearer $ACCESS_TOKEN\" -X DELETE http://talker-api.127.0.0.1.nip.io:8000/greetings/1 -i\n# HTTP/1.1 403 Forbidden\n\ncurl -H \"Authorization: Bearer $ACCESS_TOKEN\" -X DELETE http://talker-api.127.0.0.1.nip.io:8000/greetings/2 -i\n# HTTP/1.1 403 Forbidden\n</code></pre>"},{"location":"authorino/docs/user-guides/resource-level-authorization-uma/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete authconfig/talker-api-protection\nkubectl delete secret/talker-api-uma-credentials\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\nkubectl delete authorino/authorino\nkubectl delete namespace keycloak\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <ol> <li> <p>In contrast to a dedicated sidecar of the protected service and other architectures. Check out Architecture &gt; Topologies for all options.\u00a0\u21a9</p> </li> <li> <p><code>namespaced</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> <li> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. If you are running your ingress gateway in Kubernetes and wants to avoid setting up and configuring your proxy manually, check out Kuadrant.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/sharding/","title":"User guide: Reducing the operational space","text":"<p>By default, Authorino will watch events related to all <code>AuthConfig</code> custom resources in the reconciliation space (namespace or entire cluster). Instances can be configured though to only watch a subset of the resources, thus allowing such as:</p> <ul> <li>to reduce noise and lower memory usage inside instances meant for restricted scope (e.g. Authorino deployed as a dedicated sidecar to protect only one host);</li> <li>sharding auth config data across multiple instances;</li> <li>multiple environments (e.g. staging, production) inside of a same cluster/namespace;</li> <li>providing managed instances of Authorino that all watch CRs cluster-wide, yet dedicated to organizations allowed to create and operate their own <code>AuthConfig</code>s across multiple namespaces.</li> </ul> \u26a0\ufe0f Important:         This feature may not be available to users of Authorino via Kuadrant.        Authorino capabilities featured in this guide: <ul> <li>Sharding</li> <li>Identity verification &amp; authentication \u2192 API key</li> </ul> <p>Check out as well the user guide about Authentication with API keys.</p> <p>For further details about Authorino features in general, check the docs.</p> <p></p>"},{"location":"authorino/docs/user-guides/sharding/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC)</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p></p>"},{"location":"authorino/docs/user-guides/sharding/#install-the-authorino-operator-cluster-admin-required","title":"\u2776 Install the Authorino Operator (cluster admin required)","text":"<p>The following command will install the Authorino Operator in the Kubernetes cluster. The operator manages instances of the Authorino authorization service.</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/sharding/#deploy-instances-of-authorino","title":"\u2777 Deploy instances of Authorino","text":"<p>Deploy an instance of Authorino dedicated to <code>AuthConfig</code>s and API key <code>Secrets</code> labeled with <code>authorino/environment=staging</code>:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino-staging\nspec:\n  clusterWide: true\n  authConfigLabelSelectors: authorino/environment=staging\n  secretLabelSelectors: authorino/environment=staging\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre> <p>Deploy an instance of Authorino dedicated to <code>AuthConfig</code>s and API key <code>Secrets</code> labeled with <code>authorino/environment=production</code>, ans NOT labeled <code>disabled</code>:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino-production\nspec:\n  clusterWide: true\n  authConfigLabelSelectors: authorino/environment=production,!disabled\n  secretLabelSelectors: authorino/environment=production,!disabled\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre> <p>The commands above will both request instances of Authorino that watch for <code>AuthConfig</code> resources cluster-wide<sup>1</sup>, with TLS disabled<sup>2</sup>.</p>"},{"location":"authorino/docs/user-guides/sharding/#create-a-namespace-for-user-resources","title":"\u2778 Create a namespace for user resources","text":"<pre><code>kubectl create namespace myapp\n</code></pre>"},{"location":"authorino/docs/user-guides/sharding/#create-authconfigs-and-api-key-secrets-for-both-instances","title":"\u2779 Create <code>AuthConfig</code>s and API key <code>Secret</code>s for both instances","text":""},{"location":"authorino/docs/user-guides/sharding/#create-resources-for-authorino-staging","title":"Create resources for <code>authorino-staging</code>","text":"<p>Create an <code>AuthConfig</code>:</p> <pre><code>kubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: auth-config-1\n  labels:\n    authorino/environment: staging\nspec:\n  hosts:\n\n  - my-host.staging.io\n  authentication:\n    \"api-key\":\n      apiKey:\n        selector:\n          matchLabels:\n            authorino/api-key: \"true\"\n            authorino/environment: staging\nEOF\n</code></pre> <p>Create an API key <code>Secret</code>:</p> <pre><code>kubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: api-key-1\n  labels:\n    authorino/api-key: \"true\"\n    authorino/environment: staging\nstringData:\n  api_key: ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx\ntype: Opaque\nEOF\n</code></pre> <p>Verify in the logs that only the <code>authorino-staging</code> instance adds the resources to the index:</p> <pre><code>kubectl logs $(kubectl get pods -l authorino-resource=authorino-staging -o name)\n# {\"level\":\"info\",\"ts\":1638382989.8327162,\"logger\":\"authorino.controller-runtime.manager.controller.authconfig\",\"msg\":\"resource reconciled\",\"authconfig\":\"myapp/auth-config-1\"}\n# {\"level\":\"info\",\"ts\":1638382989.837424,\"logger\":\"authorino.controller-runtime.manager.controller.authconfig.statusupdater\",\"msg\":\"resource status updated\",\"authconfig/status\":\"myapp/auth-config-1\"}\n# {\"level\":\"info\",\"ts\":1638383144.9486837,\"logger\":\"authorino.controller-runtime.manager.controller.secret\",\"msg\":\"resource reconciled\",\"secret\":\"myapp/api-key-1\"}\n</code></pre>"},{"location":"authorino/docs/user-guides/sharding/#create-resources-for-authorino-production","title":"Create resources for <code>authorino-production</code>","text":"<p>Create an <code>AuthConfig</code>:</p> <pre><code>kubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: auth-config-2\n  labels:\n    authorino/environment: production\nspec:\n  hosts:\n\n  - my-host.io\n  authentication:\n    \"api-key\":\n      apiKey:\n        selector:\n          matchLabels:\n            authorino/api-key: \"true\"\n            authorino/environment: production\nEOF\n</code></pre> <p>Create an API key <code>Secret</code>:</p> <pre><code>kubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: api-key-2\n  labels:\n    authorino/api-key: \"true\"\n    authorino/environment: production\nstringData:\n  api_key: MUWdeBte7AbSWxl6CcvYNJ+3yEIm5CaL\ntype: Opaque\nEOF\n</code></pre> <p>Verify in the logs that only the <code>authorino-production</code> instance adds the resources to the index:</p> <pre><code>kubectl logs $(kubectl get pods -l authorino-resource=authorino-production -o name)\n# {\"level\":\"info\",\"ts\":1638383423.86086,\"logger\":\"authorino.controller-runtime.manager.controller.authconfig.statusupdater\",\"msg\":\"resource status updated\",\"authconfig/status\":\"myapp/auth-config-2\"}\n# {\"level\":\"info\",\"ts\":1638383423.8608105,\"logger\":\"authorino.controller-runtime.manager.controller.authconfig\",\"msg\":\"resource reconciled\",\"authconfig\":\"myapp/auth-config-2\"}\n# {\"level\":\"info\",\"ts\":1638383460.3515081,\"logger\":\"authorino.controller-runtime.manager.controller.secret\",\"msg\":\"resource reconciled\",\"secret\":\"myapp/api-key-2\"}\n</code></pre>"},{"location":"authorino/docs/user-guides/sharding/#remove-a-resource-from-scope","title":"\u277a Remove a resource from scope","text":"<pre><code>kubectl -n myapp label authconfig/auth-config-2 disabled=true\n# authconfig.authorino.kuadrant.io/auth-config-2 labeled\n</code></pre> <p>Verify in the logs that the <code>authorino-production</code> instance removes the authconfig from the index:</p> <pre><code>kubectl logs $(kubectl get pods -l authorino-resource=authorino-production -o name)\n# {\"level\":\"info\",\"ts\":1638383515.6428752,\"logger\":\"authorino.controller-runtime.manager.controller.authconfig\",\"msg\":\"resource de-indexed\",\"authconfig\":\"myapp/auth-config-2\"}\n</code></pre>"},{"location":"authorino/docs/user-guides/sharding/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete authorino/authorino-staging\nkubectl delete authorino/authorino-production\nkubectl delete namespace myapp\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <ol> <li> <p><code>cluster-wide</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/token-normalization/","title":"User guide: Token normalization","text":"<p>Broadly, the term token normalization in authentication systems usually implies the exchange of an authentication token, as provided by the user in a given format, and/or its associated identity claims, for another freshly issued token/set of claims, of a given (normalized) structure or format.</p> <p>The most typical use-case for token normalization involves accepting tokens issued by multiple trusted sources and of often varied authentication protocols, while ensuring that the eventual different data structures adopted by each of those sources are normalized, thus allowing to simplify policies and authorization checks that depend on those values. In general, however, any modification to the identity claims can be for the purpose of normalization.</p> <p>This user guide focuses on the aspect of mutation of the identity claims resolved from an authentication token, to a certain data format and/or by extending them, so that required attributes can thereafter be trusted to be present among the claims, in a desired form. For such, Authorino allows to extend resolved identity objects with custom attributes (custom claims) of either static values or with values fetched from the Authorization JSON.</p> <p>For not only normalizing the identity claims for purpose of writing simpler authorization checks and policies, but also getting Authorino to issue a new token in a normalized format, check the Festival Wristband tokens feature.</p> Authorino capabilities featured in this guide: <ul> <li>Identity verification &amp; authentication \u2192 Identity extension</li> <li>Identity verification &amp; authentication \u2192 API key</li> <li>Identity verification &amp; authentication \u2192 JWT verification</li> <li>Authorization \u2192 Pattern-matching authorization</li> </ul> <p>Check out as well the user guides about Authentication with API keys, OpenID Connect Discovery and authentication with JWTs and Simple pattern-matching authorization policies.</p> <p>For further details about Authorino features in general, check the docs.</p> <p></p>"},{"location":"authorino/docs/user-guides/token-normalization/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC)</li> <li>Identity Provider (IdP) that implements OpenID Connect authentication and OpenID Connect Discovery (e.g. Keycloak)</li> <li>jq, to extract parts of JSON responses</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p>Deploy the identity provider and authentication server by executing the command below. For the examples in this guide, we are going to use a Keycloak server preloaded with all required realm settings.</p> <pre><code>kubectl create namespace keycloak\nkubectl -n keycloak apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/keycloak/keycloak-deploy.yaml\n</code></pre> <p></p> <p>The next steps walk you through installing Authorino, deploying and configuring a sample service called Talker API to be protected by the authorization service.</p> Using Kuadrant <p>If you are a user of Kuadrant and already have your workload cluster configured and sample service application deployed, as well as your Gateway API network resources applied to route traffic to your service, skip straight to step \u277a.</p> <p>At step \u277a, instead of creating an <code>AuthConfig</code> custom resource, create a Kuadrant <code>AuthPolicy</code> one. The schema of the AuthConfig's <code>spec</code> matches the one of the AuthPolicy's, except <code>spec.host</code>, which is not available in the Kuadrant AuthPolicy. Host names in a Kuadrant AuthPolicy are inferred automatically from the Kubernetes network object referred in <code>spec.targetRef</code> and route selectors declared in the policy.</p> <p>For more about using Kuadrant to enforce authorization, check out Kuadrant auth.</p> <p></p>"},{"location":"authorino/docs/user-guides/token-normalization/#install-the-authorino-operator-cluster-admin-required","title":"\u2776 Install the Authorino Operator (cluster admin required)","text":"<p>The following command will install the Authorino Operator in the Kubernetes cluster. The operator manages instances of the Authorino authorization service.</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/token-normalization/#deploy-authorino","title":"\u2777 Deploy Authorino","text":"<p>The following command will request an instance of Authorino as a separate service<sup>1</sup> that watches for <code>AuthConfig</code> resources in the <code>default</code> namespace<sup>2</sup>, with TLS disabled<sup>3</sup>.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/token-normalization/#deploy-the-talker-api","title":"\u2778 Deploy the Talker API","text":"<p>The Talker API is a simple HTTP service that echoes back in the response whatever it gets in the request. We will use it in this guide as the sample service to be protected by Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/docs/user-guides/token-normalization/#setup-envoy","title":"\u2779 Setup Envoy","text":"<p>The following bundle from the Authorino examples deploys the Envoy proxy and configuration to wire up the Talker API behind the reverse-proxy, with external authorization enabled with the Authorino instance.<sup>4</sup></p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The command above creates an <code>Ingress</code> with host name <code>talker-api.127.0.0.1.nip.io</code>. If you are using a local Kubernetes cluster created with Kind, forward requests from your local port 8000 to the Envoy service running inside the cluster:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre>"},{"location":"authorino/docs/user-guides/token-normalization/#create-an-authconfig","title":"\u277a Create an <code>AuthConfig</code>","text":"<p>Create an Authorino <code>AuthConfig</code> custom resource declaring the auth rules to be enforced.</p> <p>This example implements a policy that only users bound to the <code>admin</code> role can send <code>DELETE</code> requests.</p> <p>The config trusts access tokens issued by a Keycloak realm as well as API keys labeled specifically to a selected group (<code>friends</code>). The roles of the identities handled by Keycloak are managed in Keycloak, as realm roles. Particularly, users <code>john</code> and <code>peter</code> are bound to the <code>member</code> role, while user <code>jane</code> is bound to roles <code>member</code> and <code>admin</code>. As for the users authenticating with API key, they are all bound to the <code>admin</code> role.</p> <p>Without normalizing identity claims from these two different sources, the policy would have to handle the differences of data formats with additional ifs-and-elses. Instead, the config here uses the <code>identity.extendedProperties</code> option to ensure a custom <code>roles</code> (Array) claim is always present in the identity object. In the case of Keycloak ID tokens, the value is extracted from the <code>realm_access.roles</code> claim; for API key-resolved objects, the custom claim is set to the static value <code>[\"admin\"]</code>.</p> Kuadrant users \u2013         Remember to create an <code>AuthPolicy</code> instead of an AuthConfig.         For more, see Kuadrant auth.        <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n\n  - talker-api.127.0.0.1.nip.io\n  authentication:\n    \"keycloak-kuadrant-realm\":\n      jwt:\n        issuerUrl: http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant\n      overrides:\n        \"roles\":\n          selector: auth.identity.realm_access.roles\n    \"api-key-friends\":\n      apiKey:\n        selector:\n          matchLabels:\n            group: friends\n      credentials:\n        authorizationHeader:\n          prefix: APIKEY\n      defaults:\n        \"roles\":\n          value: [\"admin\"]\n  authorization:\n    \"only-admins-can-delete\":\n      when:\n      - selector: context.request.http.method\n        operator: eq\n        value: DELETE\n      patternMatching:\n        patterns:\n        - selector: auth.identity.roles\n          operator: incl\n          value: admin\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/token-normalization/#create-an-api-key","title":"\u277b Create an API key","text":"<pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: api-key-1\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    group: friends\nstringData:\n  api_key: ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx\ntype: Opaque\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/token-normalization/#consume-the-api","title":"\u277c Consume the API","text":""},{"location":"authorino/docs/user-guides/token-normalization/#obtain-an-access-token-and-consume-the-api-as-jane-admin","title":"Obtain an access token and consume the API as Jane (admin)","text":"<p>Obtain an access token with the Keycloak server for Jane:</p> <p>The <code>AuthConfig</code> deployed in the previous step is suitable for validating access tokens requested inside the cluster. This is because Keycloak's <code>iss</code> claim added to the JWTs matches always the host used to request the token and Authorino will later try to match this host to the host that provides the OpenID Connect configuration.</p> <p>Obtain an access token from within the cluster for the user Jane, whose e-mail has been verified:</p> <pre><code>ACCESS_TOKEN=$(kubectl run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant/protocol/openid-connect/token -s -d 'grant_type=password' -d 'client_id=demo' -d 'username=jane' -d 'password=p' -d 'scope=openid' | jq -r .access_token)\n</code></pre> <p>If your Keycloak server is reachable from outside the cluster, feel free to obtain the token directly. Make sure the host name set in the OIDC issuer endpoint in the <code>AuthConfig</code> matches the one used to obtain the token and is as well reachable from within the cluster.</p> <p>Consume the API as Jane:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" -X DELETE http://talker-api.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 200 OK\n</code></pre>"},{"location":"authorino/docs/user-guides/token-normalization/#obtain-an-access-token-and-consume-the-api-as-john-member","title":"Obtain an access token and consume the API as John (member)","text":"<p>Obtain an access token with the Keycloak server for John:</p> <pre><code>ACCESS_TOKEN=$(kubectl run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant/protocol/openid-connect/token -s -d 'grant_type=password' -d 'client_id=demo' -d 'username=john' -d 'password=p' -d 'scope=openid' | jq -r .access_token)\n</code></pre> <p>Consume the API as John:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" -X DELETE http://talker-api.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 403 Forbidden\n</code></pre>"},{"location":"authorino/docs/user-guides/token-normalization/#consume-the-api-using-the-api-key-to-authenticate-admin","title":"Consume the API using the API key to authenticate (admin)","text":"<pre><code>curl -H \"Authorization: APIKEY ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx\" -X DELETE http://talker-api.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 200 OK\n</code></pre>"},{"location":"authorino/docs/user-guides/token-normalization/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete secret/api-key-1\nkubectl delete authconfig/talker-api-protection\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\nkubectl delete authorino/authorino\nkubectl delete namespace keycloak\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <ol> <li> <p>In contrast to a dedicated sidecar of the protected service and other architectures. Check out Architecture &gt; Topologies for all options.\u00a0\u21a9</p> </li> <li> <p><code>namespaced</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> <li> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. If you are running your ingress gateway in Kubernetes and wants to avoid setting up and configuring your proxy manually, check out Kuadrant.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/validating-webhook/","title":"User guide: Using Authorino as ValidatingWebhook service","text":"<p>Authorino provides an interface for raw HTTP external authorization requests. This interface can be used for integrations other than the typical Envoy gRPC protocol, such as (though not limited to) using Authorino as a generic Kubernetes ValidatingWebhook service.</p> <p>The rules to validate a request to the Kubernetes API \u2013 typically a <code>POST</code>, <code>PUT</code> or <code>DELETE</code> request targeting a particular Kubernetes resource or collection \u2013, according to which either the change will be deemed accepted or not, are written in an Authorino <code>AuthConfig</code> custom resource. Authentication and authorization are performed by the Kubernetes API server as usual, with auth features of Authorino implementing the additional validation within the scope of an <code>AdmissionReview</code> request.</p> <p>This user guide provides an example of using Authorino as a Kubernetes ValidatingWebhook service that validates requests to <code>CREATE</code> and <code>UPDATE</code> Authorino <code>AuthConfig</code> resources. In other words, we will use Authorino as a validator inside the cluster that decides what is a valid AuthConfig for any application which wants to rely on Authorino to protect itself.</p> Authorino capabilities featured in this guide: <ul> <li>Identity verification &amp; authentication \u2192 Plain</li> <li>Identity verification &amp; authentication \u2192 Kubernetes TokenReview</li> <li>Identity verification &amp; authentication \u2192 API key</li> <li>External auth metadata \u2192 HTTP GET/GET-by-POST</li> <li>Authorization \u2192 Kubernetes SubjectAccessReview</li> <li>Authorization \u2192 Open Policy Agent (OPA) Rego policies</li> <li>Dynamic response \u2192 Festival Wristband tokens</li> <li>Common feature \u2192 Conditions</li> <li>Common feature \u2192 Priorities</li> </ul> <p>For further details about Authorino features in general, check the docs.</p> <p></p>"},{"location":"authorino/docs/user-guides/validating-webhook/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC)</li> <li>Identity Provider (IdP) that implements OpenID Connect authentication and OpenID Connect Discovery (e.g. Keycloak)</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p>Deploy the identity provider and authentication server. For the examples in this guide, we are going to use a Keycloak server preloaded with all required realm settings.</p> <p>The Keycloak server is only needed for trying out validating AuthConfig resources that use the authentication server.</p> <pre><code>kubectl create namespace keycloak\nkubectl -n keycloak apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/keycloak/keycloak-deploy.yaml\n</code></pre> <p></p> <p>The next steps walk you through installing Authorino, deploying and configuring a sample service called Talker API to be protected by the authorization service.</p> Using Kuadrant <p>If you are a user of Kuadrant you may already have Authorino installed and running. In this case, skip straight to step \u2778.</p> <p>At step \u277a, alternatively to creating an <code>AuthConfig</code> custom resource, you may create a Kuadrant <code>AuthPolicy</code> one. The schema of the AuthConfig's <code>spec</code> matches the one of the AuthPolicy's, except <code>spec.host</code>, which is not available in the Kuadrant AuthPolicy. Host names in a Kuadrant AuthPolicy are inferred automatically from the Kubernetes network object referred in <code>spec.targetRef</code> and route selectors declared in the policy.</p> <p>For more about using Kuadrant to enforce authorization, check out Kuadrant auth.</p> <p></p>"},{"location":"authorino/docs/user-guides/validating-webhook/#install-the-authorino-operator-cluster-admin-required","title":"\u2776 Install the Authorino Operator (cluster admin required)","text":"<p>The following command will install the Authorino Operator in the Kubernetes cluster. The operator manages instances of the Authorino authorization service.</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/validating-webhook/#deploy-authorino","title":"\u2777 Deploy Authorino","text":"<p>Create the namespace:</p> <pre><code>kubectl create namespace authorino\n</code></pre> <p>Create the TLS certificates:</p> <pre><code>curl -sSL https://raw.githubusercontent.com/Kuadrant/authorino/main/deploy/certs.yaml | sed \"s/\\$(AUTHORINO_INSTANCE)/authorino/g;s/\\$(NAMESPACE)/authorino/g\" | kubectl -n authorino apply -f -\n</code></pre> <p>Create the Authorino instance:</p> <p>The following command will request an instance of Authorino as a separate service<sup>1</sup> that watches for <code>AuthConfig</code> resources cluster-wide<sup>2</sup>, with TLS enabled<sup>3</sup>.</p> <pre><code>kubectl -n authorino apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  clusterWide: true\n  listener:\n    ports:\n      grpc: 50051\n      http: 5001 # for admissionreview requests sent by the kubernetes api server\n    tls:\n      certSecretRef:\n        name: authorino-server-cert\n  oidcServer:\n    tls:\n      certSecretRef:\n        name: authorino-oidc-server-cert\nEOF\n</code></pre> <p>For convenience, the same instance of Authorino pointed as the validating webhook will also be targeted for the sample AuthConfigs created to test the validation. For using different instances of Authorino for the validating webhook and for protecting applications behind a proxy, check out the section about sharding in the docs. There is also a user guide on the topic, with concrete examples.</p>"},{"location":"authorino/docs/user-guides/validating-webhook/#create-the-authconfig-and-related-clusterrole","title":"\u2778 Create the <code>AuthConfig</code> and related <code>ClusterRole</code>","text":"<p>Create the <code>AuthConfig</code> with the auth rules to validate other AuthConfig resources applied to the cluster.</p> <p>The AuthConfig to validate other AuthConfigs will enforce the following rules:</p> <ul> <li>Authorino features that cannot be used by any application in their security schemes:</li> <li>Anonymous Access</li> <li>Plain identity object extracted from context</li> <li>Kubernetes authentication (TokenReview)</li> <li>Kubernetes authorization (SubjectAccessReview)</li> <li>Festival Wristband tokens</li> <li>Authorino features that require a RoleBinding to a specific ClusterRole in the 'authorino' namespace, to be used in a AuthConfig:</li> <li>Authorino API key authentication</li> <li>All metadata pulled from external sources must be cached for precisely 5 minutes (300 seconds)</li> </ul> <pre><code>kubectl -n authorino apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: authconfig-validator\nspec:\n  # admissionreview requests will be sent to this host name\n  hosts:\n\n  - authorino-authorino-authorization.authorino.svc\n\n  # because we're using a single authorino instance for the validating webhook and to protect the user applications,\n  # skip operations related to this one authconfig in the 'authorino' namespace\n  when:\n\n  - selector: context.request.http.body.@fromstr|request.object.metadata.namespace\n    operator: neq\n    value: authorino\n\n  # kubernetes admissionreviews carry info about the authenticated user\n  authentication:\n    \"k8s-userinfo\":\n      plain:\n        selector: context.request.http.body.@fromstr|request.userInfo\n\n  authorization:\n    \"features\":\n      opa:\n        rego: |\n          authconfig = json.unmarshal(input.context.request.http.body).request.object\n\n          forbidden { count(object.get(authconfig.spec, \"authentication\", [])) == 0 }\n          forbidden { authconfig.spec.authentication[_].anonymous }\n          forbidden { authconfig.spec.authentication[_].kubernetesTokenReview }\n          forbidden { authconfig.spec.authentication[_].plain }\n          forbidden { authconfig.spec.authorization[_].kubernetesSubjectAccessReview }\n          forbidden { authconfig.spec.response.success.headers[_].wristband }\n\n          apiKey { authconfig.spec.authentication[_].apiKey }\n\n          allow { count(authconfig.spec.authentication) &gt; 0; not forbidden }\n        allValues: true\n\n    \"apikey-authn-requires-k8s-role-binding\":\n      priority: 1\n      when:\n\n      - selector: auth.authorization.features.apiKey\n        operator: eq\n        value: \"true\"\n      kubernetesSubjectAccessReview:\n        user:\n          selector: auth.identity.username\n        resourceAttributes:\n          namespace: { value: authorino }\n          group: { value: authorino.kuadrant.io }\n          resource: { value: authconfigs-with-apikeys }\n          verb: { value: create }\n\n    \"metadata-cache-ttl\":\n      priority: 1\n      opa:\n        rego: |\n          invalid_ttl = input.auth.authorization.features.authconfig.spec.metadata[_].cache.ttl != 300\n          allow { not invalid_ttl }\nEOF\n</code></pre> <p>Define a <code>ClusterRole</code> to control the usage of protected features of Authorino:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: authorino-apikey\nrules:\n\n- apiGroups: [\"authorino.kuadrant.io\"]\n  resources: [\"authconfigs-with-apikeys\"] # not a real k8s resource\n  verbs: [\"create\"]\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/validating-webhook/#create-the-validatingwebhookconfiguration","title":"\u2779 Create the <code>ValidatingWebhookConfiguration</code>","text":"<pre><code>kubectl -n authorino apply -f -&lt;&lt;EOF\napiVersion: admissionregistration.k8s.io/v1\nkind: ValidatingWebhookConfiguration\nmetadata:\n  name: authconfig-authz\n  annotations:\n    cert-manager.io/inject-ca-from: authorino/authorino-ca-cert\nwebhooks:\n\n- name: check-authconfig.authorino.kuadrant.io\n  clientConfig:\n    service:\n      namespace: authorino\n      name: authorino-authorino-authorization\n      port: 5001\n      path: /check\n  rules:\n  - apiGroups: [\"authorino.kuadrant.io\"]\n    apiVersions: [\"v1beta2\"]\n    resources: [\"authconfigs\"]\n    operations: [\"CREATE\", \"UPDATE\"]\n    scope: Namespaced\n  sideEffects: None\n  admissionReviewVersions: [\"v1\"]\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/validating-webhook/#try-it-out","title":"\u277a Try it out","text":"<p>Create a namespace:</p> <pre><code>kubectl create namespace myapp\n</code></pre>"},{"location":"authorino/docs/user-guides/validating-webhook/#with-a-valid-authconfig","title":"With a valid <code>AuthConfig</code>","text":"Kuadrant users \u2013         For this and other example AuthConfigs below, if you create a Kuadrant <code>AuthPolicy</code> instead, the output of the commands shall differ. The requested AuthPolicy may be initially accepted, but its state will turn ready or not ready depending on whether the corresponding AuthConfig requested by Kuadrant is accepted or rejected, according to the validating webhook rules. Check the state of the resources to confirm.         For more, see Kuadrant auth.        <pre><code>kubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: myapp-protection\nspec:\n  hosts:\n\n  - myapp.io\n  authentication:\n    \"keycloak\":\n      jwt:\n        issuerUrl: http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant\nEOF\n# authconfig.authorino.kuadrant.io/myapp-protection created\n</code></pre>"},{"location":"authorino/docs/user-guides/validating-webhook/#with-forbidden-features","title":"With forbidden features","text":"<p>Anonymous access:</p> <pre><code>kubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: myapp-protection\nspec:\n  hosts:\n\n  - myapp.io\nEOF\n# Error from server: error when applying patch:\n# {\"metadata\":{\"annotations\":{\"kubectl.kubernetes.io/last-applied-configuration\":\"{\\\"apiVersion\\\":\\\"authorino.kuadrant.io/v1beta3\\\",\\\"kind\\\":\\\"AuthConfig\\\",\\\"metadata\\\":{\\\"annotations\\\":{},\\\"name\\\":\\\"myapp-protection\\\",\\\"namespace\\\":\\\"myapp\\\"},\\\"spec\\\":{\\\"hosts\\\":[\\\"myapp.io\\\"]}}\\n\"}},\"spec\":{\"authentication\":null}}\n# to:\n# Resource: \"authorino.kuadrant.io/v1beta3, Resource=authconfigs\", GroupVersionKind: \"authorino.kuadrant.io/v1beta3, Kind=AuthConfig\"\n# Name: \"myapp-protection\", Namespace: \"myapp\"\n# for: \"STDIN\": error when patching \"STDIN\": admission webhook \"check-authconfig.authorino.kuadrant.io\" denied the request: Unauthorized\n</code></pre> <pre><code>kubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: myapp-protection\nspec:\n  hosts:\n\n  - myapp.io\n  authentication:\n    \"anonymous-access\":\n      anonymous: {}\nEOF\n# Error from server: error when applying patch:\n# {\"metadata\":{\"annotations\":{\"kubectl.kubernetes.io/last-applied-configuration\":\"{\\\"apiVersion\\\":\\\"authorino.kuadrant.io/v1beta3\\\",\\\"kind\\\":\\\"AuthConfig\\\",\\\"metadata\\\":{\\\"annotations\\\":{},\\\"name\\\":\\\"myapp-protection\\\",\\\"namespace\\\":\\\"myapp\\\"},\\\"spec\\\":{\\\"authentication\\\":{\\\"anonymous-access\\\":{\\\"anonymous\\\":{}}},\\\"hosts\\\":[\\\"myapp.io\\\"]}}\\n\"}},\"spec\":{\"authentication\":{\"anonymous-access\":{\"anonymous\":{}},\"keycloak\":null}}}\n# to:\n# Resource: \"authorino.kuadrant.io/v1beta3, Resource=authconfigs\", GroupVersionKind: \"authorino.kuadrant.io/v1beta3, Kind=AuthConfig\"\n# Name: \"myapp-protection\", Namespace: \"myapp\"\n# for: \"STDIN\": error when patching \"STDIN\": admission webhook \"check-authconfig.authorino.kuadrant.io\" denied the request: Unauthorized\n</code></pre> <p>Kubernetes TokenReview:</p> <pre><code>kubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: myapp-protection\nspec:\n  hosts:\n\n  - myapp.io\n  authentication:\n    \"k8s-tokenreview\":\n      kubernetesTokenReview:\n        audiences: [\"myapp\"]\nEOF\n# Error from server: error when applying patch:\n# {\"metadata\":{\"annotations\":{\"kubectl.kubernetes.io/last-applied-configuration\":\"{\\\"apiVersion\\\":\\\"authorino.kuadrant.io/v1beta3\\\",\\\"kind\\\":\\\"AuthConfig\\\",\\\"metadata\\\":{\\\"annotations\\\":{},\\\"name\\\":\\\"myapp-protection\\\",\\\"namespace\\\":\\\"myapp\\\"},\\\"spec\\\":{\\\"authentication\\\":{\\\"k8s-tokenreview\\\":{\\\"kubernetesTokenReview\\\":{\\\"audiences\\\":[\\\"myapp\\\"]}}},\\\"hosts\\\":[\\\"myapp.io\\\"]}}\\n\"}},\"spec\":{\"authentication\":{\"k8s-tokenreview\":{\"kubernetesTokenReview\":{\"audiences\":[\"myapp\"]}},\"keycloak\":null}}}\n# to:\n# Resource: \"authorino.kuadrant.io/v1beta3, Resource=authconfigs\", GroupVersionKind: \"authorino.kuadrant.io/v1beta3, Kind=AuthConfig\"\n# Name: \"myapp-protection\", Namespace: \"myapp\"\n# for: \"STDIN\": error when patching \"STDIN\": admission webhook \"check-authconfig.authorino.kuadrant.io\" denied the request: Unauthorized\n</code></pre> <p>Plain identity extracted from context:</p> <pre><code>kubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: myapp-protection\nspec:\n  hosts:\n\n  - myapp.io\n  authentication:\n    \"envoy-jwt-authn\":\n      plain:\n        selector: context.metadata_context.filter_metadata.envoy\\.filters\\.http\\.jwt_authn|verified_jwt\nEOF\n# Error from server: error when applying patch:\n# {\"metadata\":{\"annotations\":{\"kubectl.kubernetes.io/last-applied-configuration\":\"{\\\"apiVersion\\\":\\\"authorino.kuadrant.io/v1beta3\\\",\\\"kind\\\":\\\"AuthConfig\\\",\\\"metadata\\\":{\\\"annotations\\\":{},\\\"name\\\":\\\"myapp-protection\\\",\\\"namespace\\\":\\\"myapp\\\"},\\\"spec\\\":{\\\"authentication\\\":{\\\"envoy-jwt-authn\\\":{\\\"plain\\\":{\\\"selector\\\":\\\"context.metadata_context.filter_metadata.envoy\\\\\\\\.filters\\\\\\\\.http\\\\\\\\.jwt_authn|verified_jwt\\\"}}},\\\"hosts\\\":[\\\"myapp.io\\\"]}}\\n\"}},\"spec\":{\"authentication\":{\"envoy-jwt-authn\":{\"plain\":{\"selector\":\"context.metadata_context.filter_metadata.envoy\\\\.filters\\\\.http\\\\.jwt_authn|verified_jwt\"}},\"keycloak\":null}}}\n# to:\n# Resource: \"authorino.kuadrant.io/v1beta3, Resource=authconfigs\", GroupVersionKind: \"authorino.kuadrant.io/v1beta3, Kind=AuthConfig\"\n# Name: \"myapp-protection\", Namespace: \"myapp\"\n# for: \"STDIN\": error when patching \"STDIN\": admission webhook \"check-authconfig.authorino.kuadrant.io\" denied the request: Unauthorized\n</code></pre> <p>Kubernetes SubjectAccessReview:</p> <pre><code>kubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: myapp-protection\nspec:\n  hosts:\n\n  - myapp.io\n  authentication:\n    \"keycloak\":\n      jwt:\n        issuerUrl: http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant\n  authorization:\n    \"k8s-subjectaccessreview\":\n      kubernetesSubjectAccessReview:\n        user:\n          selector: auth.identity.sub\nEOF\n# Error from server: error when applying patch:\n# {\"metadata\":{\"annotations\":{\"kubectl.kubernetes.io/last-applied-configuration\":\"{\\\"apiVersion\\\":\\\"authorino.kuadrant.io/v1beta3\\\",\\\"kind\\\":\\\"AuthConfig\\\",\\\"metadata\\\":{\\\"annotations\\\":{},\\\"name\\\":\\\"myapp-protection\\\",\\\"namespace\\\":\\\"myapp\\\"},\\\"spec\\\":{\\\"authentication\\\":{\\\"keycloak\\\":{\\\"jwt\\\":{\\\"issuerUrl\\\":\\\"http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant\\\"}}},\\\"authorization\\\":{\\\"k8s-subjectaccessreview\\\":{\\\"kubernetesSubjectAccessReview\\\":{\\\"user\\\":{\\\"selector\\\":\\\"auth.identity.sub\\\"}}}},\\\"hosts\\\":[\\\"myapp.io\\\"]}}\\n\"}},\"spec\":{\"authorization\":{\"k8s-subjectaccessreview\":{\"kubernetesSubjectAccessReview\":{\"user\":{\"selector\":\"auth.identity.sub\"}}}}}}\n# to:\n# Resource: \"authorino.kuadrant.io/v1beta3, Resource=authconfigs\", GroupVersionKind: \"authorino.kuadrant.io/v1beta3, Kind=AuthConfig\"\n# Name: \"myapp-protection\", Namespace: \"myapp\"\n# for: \"STDIN\": error when patching \"STDIN\": admission webhook \"check-authconfig.authorino.kuadrant.io\" denied the request: Unauthorized\n</code></pre> <p>Festival Wristband tokens:</p> <pre><code>kubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: wristband-signing-key\nstringData:\n  key.pem: |\n    -----BEGIN EC PRIVATE KEY-----\n    MHcCAQEEIDHvuf81gVlWGo0hmXGTAnA/HVxGuH8vOc7/8jewcVvqoAoGCCqGSM49\n    AwEHoUQDQgAETJf5NLVKplSYp95TOfhVPqvxvEibRyjrUZwwtpDuQZxJKDysoGwn\n    cnUvHIu23SgW+Ee9lxSmZGhO4eTdQeKxMA==\n    -----END EC PRIVATE KEY-----\ntype: Opaque\n---\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: myapp-protection\nspec:\n  hosts:\n\n  - myapp.io\n  authentication:\n    \"keycloak\":\n      jwt:\n        issuerUrl: http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant\n  response:\n    success:\n      headers:\n        \"wristband\":\n          wristband:\n            issuer: http://authorino-authorino-oidc.authorino.svc.cluster.local:8083/myapp/myapp-protection/wristband\n            signingKeyRefs:\n            - algorithm: ES256\n              name: wristband-signing-key\nEOF\n# secret/wristband-signing-key created\n# Error from server: error when applying patch:\n# {\"metadata\":{\"annotations\":{\"kubectl.kubernetes.io/last-applied-configuration\":\"{\\\"apiVersion\\\":\\\"authorino.kuadrant.io/v1beta3\\\",\\\"kind\\\":\\\"AuthConfig\\\",\\\"metadata\\\":{\\\"annotations\\\":{},\\\"name\\\":\\\"myapp-protection\\\",\\\"namespace\\\":\\\"myapp\\\"},\\\"spec\\\":{\\\"authentication\\\":{\\\"keycloak\\\":{\\\"jwt\\\":{\\\"issuerUrl\\\":\\\"http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant\\\"}}},\\\"hosts\\\":[\\\"myapp.io\\\"],\\\"response\\\":{\\\"success\\\":{\\\"headers\\\":{\\\"wristband\\\":{\\\"wristband\\\":{\\\"issuer\\\":\\\"http://authorino-authorino-oidc.authorino.svc.cluster.local:8083/myapp/myapp-protection/wristband\\\",\\\"signingKeyRefs\\\":[{\\\"algorithm\\\":\\\"ES256\\\",\\\"name\\\":\\\"wristband-signing-key\\\"}]}}}}}}}\\n\"}},\"spec\":{\"response\":{\"success\":{\"headers\":{\"wristband\":{\"wristband\":{\"issuer\":\"http://authorino-authorino-oidc.authorino.svc.cluster.local:8083/myapp/myapp-protection/wristband\",\"signingKeyRefs\":[{\"algorithm\":\"ES256\",\"name\":\"wristband-signing-key\"}]}}}}}}}\n# to:\n# Resource: \"authorino.kuadrant.io/v1beta3, Resource=authconfigs\", GroupVersionKind: \"authorino.kuadrant.io/v1beta3, Kind=AuthConfig\"\n# Name: \"myapp-protection\", Namespace: \"myapp\"\n# for: \"STDIN\": error when patching \"STDIN\": admission webhook \"check-authconfig.authorino.kuadrant.io\" denied the request: Unauthorized\n</code></pre>"},{"location":"authorino/docs/user-guides/validating-webhook/#with-features-that-require-additional-permissions","title":"With features that require additional permissions","text":"<p>Before adding the required permissions:</p> <pre><code>kubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: myapp-protection\nspec:\n  hosts:\n\n  - myapp.io\n  authentication:\n    \"api-key\":\n      apiKey:\n        selector:\n          matchLabels: { app: myapp }\nEOF\n# Error from server: error when applying patch:\n# {\"metadata\":{\"annotations\":{\"kubectl.kubernetes.io/last-applied-configuration\":\"{\\\"apiVersion\\\":\\\"authorino.kuadrant.io/v1beta3\\\",\\\"kind\\\":\\\"AuthConfig\\\",\\\"metadata\\\":{\\\"annotations\\\":{},\\\"name\\\":\\\"myapp-protection\\\",\\\"namespace\\\":\\\"myapp\\\"},\\\"spec\\\":{\\\"authentication\\\":{\\\"api-key\\\":{\\\"apiKey\\\":{\\\"selector\\\":{\\\"matchLabels\\\":{\\\"app\\\":\\\"myapp\\\"}}}}},\\\"hosts\\\":[\\\"myapp.io\\\"]}}\\n\"}},\"spec\":{\"authentication\":{\"api-key\":{\"apiKey\":{\"selector\":{\"matchLabels\":{\"app\":\"myapp\"}}}},\"keycloak\":null}}}\n# to:\n# Resource: \"authorino.kuadrant.io/v1beta3, Resource=authconfigs\", GroupVersionKind: \"authorino.kuadrant.io/v1beta3, Kind=AuthConfig\"\n# Name: \"myapp-protection\", Namespace: \"myapp\"\n# for: \"STDIN\": error when patching \"STDIN\": admission webhook \"check-authconfig.authorino.kuadrant.io\" denied the request: Not authorized: unknown reason\n</code></pre> <p>Add the required permissions:</p> <pre><code>kubectl -n authorino apply -f -&lt;&lt;EOF\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: authorino-apikey\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: authorino-apikey\nsubjects:\n\n- kind: User\n  name: kubernetes-admin\nEOF\n# rolebinding.rbac.authorization.k8s.io/authorino-apikey created\n</code></pre> <p>After adding the required permissions:</p> <pre><code>kubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: myapp-protection\nspec:\n  hosts:\n\n  - myapp.io\n  authentication:\n    \"api-key\":\n      apiKey:\n        selector:\n          matchLabels: { app: myapp }\nEOF\n# authconfig.authorino.kuadrant.io/myapp-protection configured\n</code></pre>"},{"location":"authorino/docs/user-guides/validating-webhook/#with-features-that-require-specific-property-validation","title":"With features that require specific property validation","text":"<p>Invalid:</p> <pre><code>kubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: myapp-protection\nspec:\n  hosts:\n\n  - myapp.io\n  authentication:\n    \"keycloak\":\n      jwt:\n        issuerUrl: http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant\n  metadata:\n    \"external-source\":\n      http:\n        url: http://metadata.io\n      cache:\n        key: { value: global }\n        ttl: 60\nEOF\n# Error from server: error when applying patch:\n# {\"metadata\":{\"annotations\":{\"kubectl.kubernetes.io/last-applied-configuration\":\"{\\\"apiVersion\\\":\\\"authorino.kuadrant.io/v1beta3\\\",\\\"kind\\\":\\\"AuthConfig\\\",\\\"metadata\\\":{\\\"annotations\\\":{},\\\"name\\\":\\\"myapp-protection\\\",\\\"namespace\\\":\\\"myapp\\\"},\\\"spec\\\":{\\\"authentication\\\":{\\\"keycloak\\\":{\\\"jwt\\\":{\\\"issuerUrl\\\":\\\"http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant\\\"}}},\\\"hosts\\\":[\\\"myapp.io\\\"],\\\"metadata\\\":{\\\"external-source\\\":{\\\"cache\\\":{\\\"key\\\":{\\\"value\\\":\\\"global\\\"},\\\"ttl\\\":60},\\\"http\\\":{\\\"url\\\":\\\"http://metadata.io\\\"}}}}}\\n\"}},\"spec\":{\"authentication\":{\"api-key\":null,\"keycloak\":{\"jwt\":{\"issuerUrl\":\"http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant\"}}},\"metadata\":{\"external-source\":{\"cache\":{\"key\":{\"value\":\"global\"},\"ttl\":60},\"http\":{\"url\":\"http://metadata.io\"}}}}}\n# to:\n# Resource: \"authorino.kuadrant.io/v1beta3, Resource=authconfigs\", GroupVersionKind: \"authorino.kuadrant.io/v1beta3, Kind=AuthConfig\"\n# Name: \"myapp-protection\", Namespace: \"myapp\"\n# for: \"STDIN\": error when patching \"STDIN\": admission webhook \"check-authconfig.authorino.kuadrant.io\" denied the request: Unauthorized\n</code></pre> <p>Valid:</p> <pre><code>kubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: myapp-protection\nspec:\n  hosts:\n\n  - myapp.io\n  authentication:\n    \"keycloak\":\n      jwt:\n        issuerUrl: http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant\n  metadata:\n    \"external-source\":\n      http:\n        url: http://metadata.io\n      cache:\n        key: { value: global }\n        ttl: 300\nEOF\n# authconfig.authorino.kuadrant.io/myapp-protection configured\n</code></pre>"},{"location":"authorino/docs/user-guides/validating-webhook/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete namespace myapp\nkubectl delete namespace authorino\nkubectl delete clusterrole authorino-apikey\nkubectl delete namespace keycloak\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <ol> <li> <p>In contrast to a dedicated sidecar of the protected service and other architectures. Check out Architecture &gt; Topologies for all options.\u00a0\u21a9</p> </li> <li> <p><code>cluster-wide</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> </ol>"},{"location":"architecture/docs/design/architectural-overview-v1/","title":"Kuadrant Architectural Overview","text":""},{"location":"architecture/docs/design/architectural-overview-v1/#overview","title":"Overview","text":"<p>Kuadrant provides connectivity, security and service protection capabilities in both a single and multi-cluster environment. It exposes these capabilities in the form of Kubernetes CRDs that implement the Gateway API concept of policy attachment. These policy APIs can target specific Gateway API resources such as <code>Gateways</code> and <code>HTTPRoutes</code> to extend their capabilities and configuration. They enable platform engineers to secure, protect and connect their infrastructure and allow application developers to self service and refine policies to their specific needs in order to protect exposed endpoints.  </p>"},{"location":"architecture/docs/design/architectural-overview-v1/#key-architectural-areas","title":"Key Architectural Areas","text":"<ul> <li>Kuadrant architecture is defined and implemented with both control plane and data plane components.</li> <li>The control plane is where policies are exposed and expressed as Kubernetes APIs and reconciled by a policy controller. </li> <li>The data plane is where Kuadrant's \"policy enforcement\" components exist. These components are configured by the  control plane and integrate either directly with the Gateway provider or via external integrations.</li> </ul>"},{"location":"architecture/docs/design/architectural-overview-v1/#10000m-architecture","title":"10000m Architecture","text":""},{"location":"architecture/docs/design/architectural-overview-v1/#control-plane-components-and-responsibilities","title":"Control Plane Components and Responsibilities","text":"<p>The control plane is a set of controllers and operators that are responsible for installation and configuration of other components such as the data plane enforcement components and configuration of the Gateway to enable the data plane components to interact with incoming requests. The control plane also owns and reconciles the policy CRD APIs into more complex and specific configuration objects that the policy enforcement components consume in order to know the rules to apply to incoming requests or the configuration to apply to external integrations such as DNS and ACME providers. </p> <p></p>"},{"location":"architecture/docs/design/architectural-overview-v1/#kuadrant-operator","title":"Kuadrant Operator","text":"<ul> <li>Installation and configuration of other control plane components</li> <li>Installation of data plane policy enforcement components via their respective control plane operators</li> <li>Configures the Gateway via WASM plugin and other APIs to leverage the data plane components for auth and rate limiting on incoming requests.</li> <li>Exposes <code>RateLimitPolicy</code> , <code>AuthPolicy</code>, <code>DNSPolicy</code> and <code>TLSPolicy</code> and reconciles these into enforceable configuration for the data plane.</li> <li>Exposes <code>Kuadrant</code> and reconciles this to configure and trigger installation of the required data plane components and other control plane components.</li> </ul>"},{"location":"architecture/docs/design/architectural-overview-v1/#limitador-operator","title":"Limitador Operator:","text":"<ul> <li>Installs and configures the Limitador data plane component based on the Limitador CR. Limits specified in the limitador CR are mountd via configmap into the limitador component.</li> </ul>"},{"location":"architecture/docs/design/architectural-overview-v1/#authorino-operator","title":"Authorino Operator:","text":"<ul> <li>Installs and configures the Authorino data plane component based on the Authorino CR.</li> </ul>"},{"location":"architecture/docs/design/architectural-overview-v1/#cert-manager","title":"Cert-Manager:","text":"<ul> <li>Manages TLS certificates for our components and for the Gateways. Consumes Certificate resources created by Kuadrant operator in response to the TLSPolicy.</li> </ul>"},{"location":"architecture/docs/design/architectural-overview-v1/#dns-operator","title":"DNS Operator","text":"<ul> <li>DNS operator consumes DNSRecord resources that are configured via the DNSPolicy api and applies them into the targeted cloud DNS provider. AWS, Azure and Google DNS are our main targets.</li> </ul>"},{"location":"architecture/docs/design/architectural-overview-v1/#data-plane-components-and-responsibilities","title":"Data Plane Components and Responsibilities","text":"<p>The data plane components sit in the request flow and are responsible for enforcing configuration defined by policy and providing service protection capabilities based on configuration managed and created by the control plane.</p>"},{"location":"architecture/docs/design/architectural-overview-v1/#limitador","title":"Limitador","text":"<ul> <li>Complies with the with Envoy rate limiting API to provide rate limiting to the gateway. Consumes limits from a configmap created based on the RateLimitPolicy API.</li> </ul>"},{"location":"architecture/docs/design/architectural-overview-v1/#authorino","title":"Authorino","text":"<ul> <li>Complies with the Envoy external auth API to provide auth integration to the gateway. It provides both Authn and Authz. Consumes AuthConfigs created by the Kuadrant operator based on the defined <code>AuthPolicy</code> API.</li> </ul>"},{"location":"architecture/docs/design/architectural-overview-v1/#wasm-shim","title":"WASM Shim","text":"<ul> <li>Uses the Proxy WASM ABI Spec to integrate with Envoy and provide filtering and connectivity to Limitador (for request time enforcement of rate limiting) and Authorino (for request time enforcement of authentication &amp; authorization).</li> </ul>"},{"location":"architecture/docs/design/architectural-overview-v1/#single-cluster-layout","title":"Single Cluster Layout","text":"<p>In a single cluster, you have the Kuadrant control plane and data plane sitting together. It is configured to integrate with Gateways on the same cluster and configure a DNS zone via a  secret (configured alongside a DNSPolicy). Storage of rate limit counters is possible but not required as they are not being shared.</p> <p></p>"},{"location":"architecture/docs/design/architectural-overview-v1/#multi-cluster","title":"Multi-Cluster","text":"<p>In the default multi-cluster setup, each individual cluster has Kuadrant installed. Each of these clusters are unaware of the other. They are effectively operating as single clusters. The multi-cluster aspect is created by sharing access with the DNS zone, using a shared host across the clusters and leveraging shared counter storage.  Multi cluster DNS is achieved by using the eventual provider DNS service (AWS Route etc ..) as a store for ownership metadata using specially created TXT records, and as a central API service that all clusters can communicate with. The zone is operated on independently by each of DNS operator on both clusters to form a single cohesive record set. Each cluster processes its own DNSRecords, becoming aware of other DNSRecords contributing to the same set of endpoints via this centrally stored data, in turn allowing it to correctly translate the DNSRecord endpoints into an appropriate API operation. More details on this can be found in the following RFC. The rate limit counters can also be shared and used by different clusters in order to provide global rate limiting. This is achieved by connecting each instance of Limitador to a shared data store that uses the Redis protocol.</p> <p></p> <p>Shown above is a multi-cluster multi ingress gateway topology. This might be used to support a geographically distributed system for example. However, it is also possible to leverage overlay networking tools such as Skupper that integrate at the Kubernetes service level to have a single gateway cluster that then integrates with multiple backends (on different clusters or in custom infrastructure).</p>"},{"location":"architecture/docs/design/architectural-overview-v1/#observability","title":"Observability","text":"<p>The Kuadrant architecture is intended to work with some popular monitoring tools for tracing, metrics and log aggregation. Those tools are:</p> <ul> <li>Prometheus for scraping metrics - and optionally Thanos for high availability &amp; federation</li> <li>Loki for log aggregation - via log collectors like vector</li> <li>Tempo for trace collecting</li> <li>Grafana for visualing the above</li> </ul> <p>Depending on the number of clusters in your configuration, you may decide to have a monitoring system on the same cluster as workloads, or in a separate cluster completely. Below are 2 example architectures based on the single cluster and multi cluster layouts. In the single cluster architecture, the collector components (Prometheus, Vector and Tempo) are in the same cluster as the log aggregation (Loki) and visualisation component (Grafana).</p> <p></p> <p>In the multi cluster architecture, the collectors that scrape metrics or logs (Prometheus &amp; Vector) are deployed alongside the workloads in each cluster. However, as traces are sent to a collector (Tempo) from each component, it can be centralised in a separate cluster. Thanos is used in this architecutre so that each prometheus can federate metrics back to a central location. The log collector (vector) can forward logs to a central loki instance. Finally, the visualisation component (Grafana) is centralised as well, with data sources configured for each of the 3 components on the same cluster.</p> <p></p>"},{"location":"architecture/docs/design/architectural-overview-v1/#dependencies","title":"Dependencies","text":""},{"location":"architecture/docs/design/architectural-overview-v1/#istio-or-envoy-gateway","title":"Istio or Envoy Gateway:","text":"<ul> <li>Gateway API provider that Kuadrant integrates with via WASM to provide service protection capabilities. Kuadrant configures Envoy Proxy via the Istio/Envoy Gateway control plane in order to enforce the applied policies and register components such as Authorino and Limitador. </li> <li>Used by <code>RateLimitPolicy</code> and <code>AuthPolicy</code></li> </ul>"},{"location":"architecture/docs/design/architectural-overview-v1/#gateway-api-required","title":"Gateway API: Required","text":"<ul> <li>New standard for Ingress from the Kubernetes community</li> <li>Gateway API is the core API that Kuadrant integrates with.</li> </ul>"},{"location":"dns-operator/","title":"DNS Operator","text":"<p>The DNS Operator is a kubernetes based controller responsible for reconciling DNS Record custom resources. It interfaces with cloud DNS providers such as AWS, Google and Azure to bring the DNS zone into the state declared in these CRDs. One of the key use cases the DNS operator solves, is allowing complex DNS routing strategies such as Geo and Weighted to be expressed. This allows you to leverage DNS as the first layer of traffic management. These strategies increase in value as you works across multiple clusters. DNS operator can be deployed to multiple cluster and coordinate on a given zone allowing you to use a shared domain name to balance traffic based on your requirements.</p>"},{"location":"dns-operator/#getting-started","title":"Getting Started","text":""},{"location":"dns-operator/#pre-setup","title":"Pre Setup","text":""},{"location":"dns-operator/#add-dns-provider-configuration","title":"Add DNS provider configuration","text":"<p>NOTE: You can optionally skip this step but at least one DNS Provider Secret will need to be configured with valid credentials to use the DNS Operator.</p>"},{"location":"dns-operator/#aws-provider-route53","title":"AWS Provider (Route53)","text":"<p><pre><code>make local-setup-aws-clean local-setup-aws-generate AWS_ACCESS_KEY_ID=&lt;My AWS ACCESS KEY&gt; AWS_SECRET_ACCESS_KEY=&lt;My AWS Secret Access Key&gt;\n</code></pre> More details about the AWS provider can be found here</p>"},{"location":"dns-operator/#gcp-provider","title":"GCP Provider","text":"<p><pre><code>make local-setup-gcp-clean local-setup-gcp-generate GCP_GOOGLE_CREDENTIALS='&lt;My GCP Credentials.json&gt;' GCP_PROJECT_ID=&lt;My GCP PROJECT ID&gt;\n</code></pre> More details about the GCP provider can be found here</p>"},{"location":"dns-operator/#azure-provider","title":"AZURE Provider","text":"<pre><code>make local-setup-azure-clean local-setup-azure-generate KUADRANT_AZURE_CREDENTIALS='&lt;My Azure Credentials.json&gt;'\n</code></pre> <p>Info on generating service principal credentials here</p> <p>Get your resource group ID like so: <pre><code>az group show --resource-group &lt;resource group name&gt; | jq \".id\" -r\n</code></pre></p> <p>Also give traffic manager contributor role: <pre><code>az role assignment create --role \"Traffic Manager Contributor\" --assignee $EXTERNALDNS_SP_APP_ID --scope &lt;RESOURCE_GROUP_ID&gt;\n</code></pre></p> <p>Getting the zone ID can be achieved using the below command: <pre><code>az network dns zone show --name &lt;my domain name&gt; --resource-group &lt;my resource group&gt; --query \"{id:id,domain:name}\"\n</code></pre></p>"},{"location":"dns-operator/#running-controller-locally-default","title":"Running controller locally (default)","text":"<ol> <li>Create local environment(creates kind cluster) <pre><code>make local-setup\n</code></pre></li> </ol> <p>Note: When using DNS Groups functionality with CoreDNS, you can customize where the active groups TXT record is resolved from: <pre><code>make local-setup EXTERNAL_GROUPS_HOST=&lt;your-external-host&gt;\n</code></pre> Default: <code>kuadrant-active-groups.hcpapps.net</code></p> <ol> <li>Run your controller (this will run in the foreground, so switch to a new terminal if you want to leave it running):</li> </ol> <pre><code>make run\n</code></pre> <p>To run with a specific group identifier: <pre><code>make run GROUP=&lt;your-group-name&gt;\n</code></pre></p>"},{"location":"dns-operator/#running-controller-on-the-cluster","title":"Running controller on the cluster","text":"<ol> <li>Create local environment(creates kind cluster) <pre><code>make local-setup DEPLOY=true\n</code></pre></li> </ol>"},{"location":"dns-operator/#coredns-with-dns-groups","title":"CoreDNS with DNS Groups","text":"<p>After running the local-setup, some configuration is required to enable the active-groups TXT record when running locally with CoreDNS and using DNS Groups.</p> <ol> <li>Modify the corefile You will need to modify the Corefile in coredns, this is located in a configmap <code>kuadrant-coredns</code>  by default in the <code>kuadrant-coredns</code> namespace. </li> </ol> <p>Add the following config (change the parts in caps to your usecase): <pre><code>    rewrite name regex kuadrant-active-groups\\.(.*)ZONE_DOMAIN_NAME EXTERNAL_TXT_RECORD_HOST\n    forward EXTERNAL_TXT_RECORD_HOST /etc/resolv.conf\n</code></pre></p> <p>Before the <code>ready</code> statement.</p> <p>Then restart the coredns operator. <pre><code>kubectl -n kuadrant-coredns rollout restart deployment kuadrant-coredns \n</code></pre></p> <ol> <li> <p>Verify controller deployment <pre><code>kubectl logs -f deployments/dns-operator-controller-manager -n dns-operator-system\n</code></pre></p> </li> <li> <p>Create External record: In your dns provider, create the record referred to earlier in your corefile. This record requires the  following format (changing the values in caps as required): <pre><code>version=1;groups=GROUP1&amp;&amp;GROUP2\n</code></pre></p> </li> <li> <p>Verify coredns groups resolution</p> </li> </ol> <p>Once the external record has been created, find the local IP of the coredns instance: <pre><code>NS=$(kubectl get secrets -n dnstest dns-provider-credentials-coredns -o yaml | yq \".data.NAMESERVERS\" | base64 -d | cut -f1 -d\":\")\n</code></pre> Then dig the local TXT record from that IP: <pre><code>dig @$NS kuadrant-active-groups.k.example.com TXT +short\n\"version=1;groups=GROUP1&amp;&amp;GROUP2\"\n</code></pre></p>"},{"location":"dns-operator/#running-controller-on-existing-cluster","title":"Running controller on existing cluster","text":"<p>You'll need a Kubernetes cluster to run against. You can use KIND to get a local cluster for testing, or run against a remote cluster. Note: Your controller will automatically use the current context in your kubeconfig file (i.e. whatever cluster <code>kubectl cluster-info</code> shows).</p> <ol> <li> <p>Apply Operator manifests <pre><code>kustomize build config/default | kubectl apply -f -\n</code></pre></p> </li> <li> <p>Verify controller deployment <pre><code>kubectl logs -f deployments/dns-operator-controller-manager -n dns-operator-system\n</code></pre></p> </li> </ol>"},{"location":"dns-operator/#coredns-provider","title":"CoreDNS Provider","text":"<p>The DNS Operator includes a CoreDNS plugin that enables serving DNS zone data from Kubernetes DNSRecord resources. This is particularly useful for local development and testing.</p>"},{"location":"dns-operator/#coredns-plugin-configuration","title":"CoreDNS Plugin Configuration","text":"<p>For detailed CoreDNS configuration and integration documentation, see:</p> <ul> <li>CoreDNS Integration Guide</li> </ul>"},{"location":"dns-operator/#development","title":"Development","text":""},{"location":"dns-operator/#e2e-test-suite","title":"E2E Test Suite","text":"<p>The e2e test suite can be executed against any cluster running the DNS Operator with configuration added for any supported provider.</p> <pre><code>make test-e2e TEST_DNS_ZONE_DOMAIN_NAME=&lt;My domain name&gt; TEST_DNS_PROVIDER_SECRET_NAME=&lt;My provider secret name&gt; TEST_DNS_NAMESPACES=&lt;My test namespace(s)&gt;\n</code></pre> Environment Variable Description TEST_DNS_PROVIDER_SECRET_NAME Name of the provider secret to use. If using local-setup provider secrets zones, one of [dns-provider-credentials-aws; dns-provider-credentials-gcp;dns-provider-credentials-azure] TEST_DNS_ZONE_DOMAIN_NAME The Domain name to use in the test. Must be a zone accessible with the (TEST_DNS_PROVIDER_SECRET_NAME) credentials with the same domain name TEST_DNS_NAMESPACES The namespace(s) where the provider secret(s) can be found"},{"location":"dns-operator/#modifying-the-api-definitions","title":"Modifying the API definitions","text":"<p>If you are editing the API definitions, generate the manifests such as CRs or CRDs using:</p> <pre><code>make manifests\n</code></pre> <p>NOTE: Run <code>make --help</code> for more information on all potential <code>make</code> targets</p> <p>More information can be found via the Kubebuilder Documentation</p>"},{"location":"dns-operator/#controller-flags-and-environmental-variables","title":"Controller flags and environmental variables","text":"<p>The controller can be started with any of the following flags or environmental variables. Upon the start of the controller operator give precedence to envars (i.e. <code>PROVIDER</code> envar will override <code>--provider</code> flag). If neither is set the default value will be used. Envars are parsed into their types from a string where applicable. If parsing fails - envar is ignored</p> Flag Name Flag Type Envar Name Description Default metrics-bind-address string METRICS_BIND_ADDRESS The address the metric endpoint binds to. \":8080\" health-probe-bind-address string HEALTH_PROBE_BIND_ADDRESS The address the probe endpoint binds to. \":8081\" pprof-bind-address string PPROF_BIND_ADDRESS The address the pprof endpoint binds to. \":8082\" leader-elect bool LEADER_ELECT Enable leader election for controller manager. Enabling this will ensure there is only one active controller manager. \"false\" min-requeue-time time.Duration MIN_REQUEUE_TIME The minimal timeout between calls to the DNS Provider. Controls if we commit to the full reconcile loop \"5s\" max-requeue-time time.Duration MAX_REQUEUE_TIME The maximum times it takes between reconciliations of DNS Record. Controls how ofter record is reconciled. \"15m\" valid-for time.Duration VALID_FOR Duration when the record is considered to hold valid information. Controls if we commit to the full reconcile loop \"14m\" provider string PROVIDER DNS Provider(s) to enable. \"aws,google,azure,coredns,endpoint\" enable-probes bool ENABLE_PROBES Enable DNSHealthProbes controller. \"true\" insecure-health-checks bool INSECURE_HEALTH_CHECKS DNS Health Probes will ignore insecure certificates when true \"true\" cluster-secret-namespace string CLUSTER_SECRET_NAMESPACE The namespace in which cluster secrets are located \"dns-operator-system\" cluster-secret-label string CLUSTER_SECRET_LABEL The label that identifies a Secret resource as a cluster secret. \"kuadrant.io/multicluster-kubeconfig\" watch-namespaces string WATCH_NAMESPACES Comma separated list of default namespaces. \\&lt;empty string&gt; delegation-role string DELEGATION_ROLE The delegation role for this controller. Must be one of 'primary'(default), or 'secondary' \"primary\" group string GROUP The DNS failover group identifier for this controller instance. Used for active-passive failover across clusters. \\&lt;empty string&gt;"},{"location":"dns-operator/#logging","title":"Logging","text":"<p>Logs are following the general guidelines: </p> <ul> <li><code>logger.Info()</code> describe a high-level state of the resource such as creation, deletion and which reconciliation path was taken.  </li> <li><code>logger.Error()</code> describe only those errors that are not returned in the result of the reconciliation. If error is occurred there should be only one error message. </li> <li><code>logger.V(1).Info()</code> debug level logs to give information about every change or event caused by the resource as well as every update of the resource.</li> </ul> <p>There are two flags to control logging output </p> <ul> <li><code>--log-mode=[development|&lt;any-other-value&gt;]</code> will enable debug level logs for the output.      The debug mode is the most verbose.</li> <li><code>--log-level</code> controls the level of displayed logs. Defaults to the most verbose in the <code>development</code> mode.      In any other modes it can take numerical values form <code>-1</code> (Debug level) to <code>4</code> (Nothing).      It is possible to specify other values, but hey will have no effect (e.g. <code>4</code> will do the same as <code>128</code>) </li> </ul> <p>You can find more here.</p>"},{"location":"dns-operator/#common-metadata","title":"Common metadata","text":"<p>Not exhaustive list of metadata for DNSRecord controller:</p> <ul> <li><code>level</code> - logging level. Values are: <code>info</code>,<code>debug</code> or <code>error</code></li> <li><code>ts</code> - timestamp</li> <li><code>logger</code> - logger name</li> <li><code>msg</code></li> <li><code>controller</code> and <code>controllerKind</code> - controller name, and it's kind respectively to output the log</li> <li><code>DNSRecord</code> - name and namespace of the DNS Record CR that is being reconciled</li> <li><code>reconcileID</code></li> <li><code>ownerID</code> - ID the of owner of the DNS Record</li> <li><code>txtPrefix</code>/<code>txtSuffix</code> - prefix and suffix of the TXT record in provider.</li> <li><code>zoneEndpoints</code> - endpoints that exist in the provider</li> <li><code>specEndpoints</code> - endpoints defined in the spec</li> <li><code>statusEndpoints</code> - endpoints that were processed previously</li> <li><code>currentGroup</code> - the group this DNS operator instance belongs to</li> <li><code>activeGroups</code> - the currently active groups read from DNS</li> </ul> <p>Note that not all the metadata values are present at each of the logs statements. </p>"},{"location":"dns-operator/#examples","title":"Examples","text":"<p>To query logs locally you can use <code>jq</code>. For example: Retrieve logs by  <pre><code>kubectl get deployments -l app.kubernetes.io/part-of=dns-operator -A\n\nNAMESPACE             NAME                              READY \ndns-operator-system   dns-operator-controller-manager   1/1   \n</code></pre> And query them. For example: <pre><code>kubectl logs -l control-plane=dns-operator-controller-manager -n dns-operator-system --tail -1 | sed '/^{/!d' | jq 'select(.controller==\"dnsrecord\" and .level==\"info\")'\n</code></pre> or  <pre><code>kubectl logs -l control-plane=dns-operator-controller-manager -n dns-operator-system --tail -1 | sed '/^{/!d' | jq 'select(.controller==\"dnsrecord\" and .DNSRecord.name==\"test\" and .reconcileID==\"2be16b6d-b90f-430e-9996-8b5ec4855d53\")' | jq '.level, .msg, .zoneEndpoints, .specEndpoints, .statusEndpoints '\n</code></pre> You could use selector in the <code>jq</code> with <code>and</code>/<code>not</code>/<code>or</code> to restrict.</p>"},{"location":"dns-operator/#license","title":"License","text":"<p>Copyright 2024.</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at</p> <pre><code>http://www.apache.org/licenses/LICENSE-2.0\n</code></pre> <p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p> <p></p>"},{"location":"dns-operator/coredns/plugin/","title":"kuadrant","text":""},{"location":"dns-operator/coredns/plugin/#name","title":"Name","text":"<p>kuadrant - enables serving zone data from kuadrant DNSRecord resources.</p>"},{"location":"dns-operator/coredns/plugin/#description","title":"Description","text":"<p>The kuadrant plugin enables CoreDNS to serve DNS records from Kubernetes DNSRecord custom resources, providing an alternative to cloud-based DNS services by allowing you to host DNS records in your own CoreDNS instances running in Kubernetes.</p> <p>The plugin sets up watchers and listeners on DNSRecord resources in the Kubernetes cluster. As it discovers them, it processes and adds the endpoints to the appropriate DNS zone with GEO and weighted routing capabilities. The plugin uses logic from the CoreDNS file plugin to create a functioning DNS server.</p> <p>Weighted Routing: The plugin builds a list of all available records that could be provided as the answer to a given query from within the identified zone. It then applies a weighting algorithm to decide on a single response depending on the individual record weighting, using a random number between 0 and the sum of all weights. This provides probabilistic load distribution across endpoints.</p> <p>Geographic Routing: GEO data is sourced from a geographical database such as MaxMind and made available with the CoreDNS <code>geoip</code> plugin, which must execute before the Kuadrant plugin. With this enabled, the plugin uses GEO data to decide which record to return based on the client's geographic location.</p> <p>Combined Routing: When multiple endpoints exist within a single geographic region, the plugin first applies the GEO filter and then uses the weighting algorithm on the result, enabling both geographic distribution and load balancing within regions.</p> <p>For a complete overview of CoreDNS integration with DNS Operator, see the CoreDNS Integration Guide.</p>"},{"location":"dns-operator/coredns/plugin/#syntax","title":"Syntax","text":"<pre><code>kuadrant [ZONES...]\n</code></pre> <p>With only the plugin specified, the kuadrant plugin will default to the zone specified in the server's block. It will handle all queries in that zone and connect to Kubernetes in-cluster. If ZONES is used it specifies all the zones the plugin should be authoritative for.</p> <pre><code>kuadrant [ZONES...] {\n    kubeconfig KUBECONFIG [CONTEXT]\n    rname EMAIL\n}\n</code></pre> <ul> <li><code>kubeconfig</code> KUBECONFIG [CONTEXT] authenticates the connection to a remote Kubernetes cluster using a kubeconfig file.   [CONTEXT] is optional, if not set, then the current context specified in kubeconfig will be used.</li> <li><code>rname</code> EMAIL sets the email address (RNAME) in the SOA record for the zone. The email format (e.g., <code>admin@example.com</code>)   will be converted to DNS mailbox format (e.g., <code>admin.example.com.</code>). According to RFC 1035 and RFC 2142, any dots in the   local part (before @) will be escaped with backslash (e.g., <code>dns.admin@example.com</code> becomes <code>dns\\.admin.example.com.</code>).   If not specified, defaults to <code>hostmaster.{zone}</code>.</li> </ul> <p>For enabling zone transfers look at the transfer plugin.</p>"},{"location":"dns-operator/coredns/plugin/#examples","title":"Examples","text":""},{"location":"dns-operator/coredns/plugin/#example-1-basic-dns-record-serving","title":"Example 1: Basic DNS Record Serving","text":"<p>Load the <code>example.org</code> zone from DNSRecord resources on the cluster with the label <code>kuadrant.io/coredns-zone-name: example.org</code>.</p> <p>Corefile: <pre><code>example.org {\n    kuadrant\n}\n</code></pre></p> <p>DNSRecord: <pre><code>apiVersion: kuadrant.io/v1alpha1\nkind: DNSRecord\nmetadata:\n  name: example.org\n  labels:\n    kuadrant.io/coredns-zone-name: example.org\nspec:\n  rootHost: api.example.org\n  endpoints:\n\n    - dnsName: api.example.org\n      recordTTL: 60\n      recordType: A\n      targets:\n        - 1.1.1.1\n</code></pre></p>"},{"location":"dns-operator/coredns/plugin/#example-2-geographic-routing-with-geoip","title":"Example 2: Geographic Routing with GeoIP","text":"<p>Load the <code>example.org</code> zone from DNSRecord resources on the cluster with the label <code>kuadrant.io/coredns-zone-name: example.org</code> and apply geoip lookup to route clients to region-specific endpoints.</p> <p>Corefile: <pre><code>example.org {\n   geoip GeoLite2-City-demo.mmdb {\n      edns-subnet\n   }\n   metadata\n   kuadrant\n}\n</code></pre></p> <p>DNSRecord: <pre><code>apiVersion: kuadrant.io/v1alpha1\nkind: DNSRecord\nmetadata:\n  name: example.org\n  labels:\n    kuadrant.io/coredns-zone-name: example.org\nspec:\n  rootHost: api.example.org\n  endpoints:\n\n    - dnsName: api.example.org\n      recordType: A\n      providerSpecific:\n        - name: geo-code\n          value: GEO-EU\n      recordTTL: 300\n      setIdentifier: GEO-EU\n      targets:\n        - 1.1.1.1\n    - dnsName: api.example.org\n      recordType: A\n      providerSpecific:\n        - name: geo-code\n          value: GEO-US\n      recordTTL: 300\n      setIdentifier: GEO-US\n      targets:\n        - 2.2.2.2\n</code></pre></p>"},{"location":"dns-operator/coredns/plugin/#development","title":"Development","text":"<p>Quick start for testing plugin changes locally:</p> <p>Prerequisites:</p> <ul> <li>Running Kubernetes cluster with kubectl configured</li> <li>A <code>Corefile</code> in the <code>coredns/plugin/</code> directory (see below)</li> </ul> <p>When you run <code>make run</code> from the <code>coredns/plugin/</code> directory, CoreDNS will look for a <code>Corefile</code> in the current working directory. Create a <code>Corefile</code> in <code>coredns/plugin/</code> with the following content (see <code>coredns/examples/Corefile</code> for reference):</p> <pre><code>k.example.com {\n   debug\n   errors\n   log\n   geoip geoip/GeoLite2-City-demo.mmdb {\n      edns-subnet\n   }\n   metadata\n   kuadrant {\n      kubeconfig &lt;path-to-your-home&gt;/.kube/config\n   }\n}\n</code></pre> <p>Note: The <code>geoip</code> line is optional and only needed for testing geographic routing. For basic DNS record testing, you can omit it.</p> <p>Then run CoreDNS locally:</p> <pre><code># Run from coredns/plugin directory\nmake run\n\n# In another terminal, apply a test DNSRecord and label it\nkubectl apply -f ../examples/dnsrecord-api-k-example-com_geo_weight.yaml\nkubectl label dnsrecord/api-k-example-com kuadrant.io/coredns-zone-name=k.example.com\n\n# Verify DNS resolution\ndig @127.0.0.1 api.k.example.com -p 1053 +short\n</code></pre> <p>For comprehensive local development and testing instructions, see the CoreDNS Local Development Guide.</p>"},{"location":"dns-operator/coredns/plugin/#troubleshooting","title":"Troubleshooting","text":"<p>DNSRecords not appearing in DNS queries:</p> <p>Verify the DNSRecord has the required label: <pre><code>kubectl get dnsrecord -o jsonpath='{.items[*].metadata.labels}' | grep kuadrant.io/coredns-zone-name\n</code></pre></p> <p>Plugin not loading or errors during startup:</p> <p>Check the terminal output where you ran <code>make run</code> for error messages. The plugin logs errors and warnings directly to stdout/stderr.</p> <p>For more troubleshooting guidance:</p> <ul> <li>Local environment issues: Local Development Guide Troubleshooting</li> <li>General CoreDNS integration issues: Integration Guide Troubleshooting</li> </ul>"},{"location":"dns-operator/coredns/plugin/#see-also","title":"See Also","text":"<ul> <li>CoreDNS Integration Guide - Complete overview and production deployment</li> <li>CoreDNS Local Development Guide - Local testing with Kind clusters</li> <li>CoreDNS Configuration Reference - Detailed configuration options</li> <li>CoreDNS Official Documentation - General CoreDNS plugins and configuration</li> <li>CoreDNS GeoIP Plugin - Geographic routing plugin</li> </ul>"},{"location":"dns-operator/docs/cli/","title":"Overview","text":"<p>The <code>kuadrant-dns</code> (<code>kubect-kuadrant_dns</code> is the binary name) is a CLI that is shipped alongside the DNS-operator. </p> <p>It is intended to be used for advanced configuration (such as automated configuration of cluster secrets for CoreDNS), gathering of the debug information (i.e. get all records from the managed zone), and to manually adjust the managed zone (i.e. delete the owner). See <code>kubectl kuadrant-dns help</code> for a list of available functions</p> <p>If located in <code>PATH</code>, it will act as a kubectl plugin and will embed itself into <code>kuadrantctl</code>, but can be used as a standalone. </p>"},{"location":"dns-operator/docs/cli/#how-to-get","title":"How to get","text":"<p>As a note - there is a <code>make cp-cli</code> target that will move the binary from <code>dns-operator/bin</code> into <code>~/.local/bin</code>. </p>"},{"location":"dns-operator/docs/cli/#from-source","title":"From source","text":"<p>This requires <code>GO</code> configured on your machine</p> <ol> <li>Clone this repository </li> <li>Run <code>make build-cli</code></li> <li>Use the binary from the <code>dns-operator/bin</code> </li> </ol>"},{"location":"dns-operator/docs/cli/#from-repository","title":"From repository","text":"<p>You can download a binary for your architecture from the release page of the DNS-operator. A new version of the cli is built on each release after v0.14.0</p>"},{"location":"dns-operator/docs/cli/#commands","title":"Commands","text":"<p>For most cases running a command with <code>--help</code> should answer your questions. Here you will find less of a technical details but of a more reasoning and intent behind commands. </p>"},{"location":"dns-operator/docs/cli/#dns-groups","title":"DNS Groups","text":"<p>The DNS Group commands will allow the manipulation of the <code>kuadrant-active-groups.&lt;domain&gt;</code> TXT record. This record is responsible for informing controllers which DNS Groups are currently active. The DNS Group commands are intended to be run with a secret that has list permissions across all zones  and write permissions in the relevant zones.</p>"},{"location":"dns-operator/docs/cli/#global-flags","title":"Global Flags","text":"<p>--verbose / -v Set the log level for the cli. All logs are sent to standard error. </p> <ul> <li>level 0: default level, error logs will be exposed</li> <li>level 1: error, and info logs will be exposed</li> <li>level 2: error, info, and debug logs will be exposed</li> </ul>"},{"location":"dns-operator/docs/cli/#add-active-group","title":"add-active-group","text":"<p>Will fetch a list of zones that are an exact match of a domain (the <code>--domain</code> flag). You can specify <code>*.&lt;domain&gt;</code> to match all zones that end with <code>&lt;domain&gt;</code>. If more than one zone is found it will prompt asking which of the zones to select,  unless <code>-y</code> is provided in which case it will apply the change to all relevant zones.. When adding a group to the set of active groups in the selected zone the command will first ensure the group is not already present. If the group is not present, it will either update the existing <code>kuadrant-active-groups.&lt;domain&gt;</code> TXT record, or create it. </p>"},{"location":"dns-operator/docs/cli/#get-active-group","title":"get-active-group","text":"<p>Will fetch a list of active groups from the <code>kuadrant-active-groups.&lt;domain&gt;</code> TXT record and display them.  Active groups will be listed under the corresponding zone.</p>"},{"location":"dns-operator/docs/cli/#remove-active-group","title":"remove-active-group","text":"<p>Will fetch a list of zones that are an exact match of a domain (the <code>--domain</code> flag). You can specify <code>*.&lt;domain&gt;</code> to match all zones that end with <code>&lt;domain&gt;</code>. For each zone that has a group in the <code>kuadrant-active-groups.&lt;domain&gt;</code> TXT record it will display all endpoints that  are associated with the group. Then it will prompt with a confirmation of a deletion unless <code>-y</code>/<code>--assumeyes</code> flag was provided;  in that case it will proceed.</p>"},{"location":"dns-operator/docs/dns_record_delegation/","title":"DNS Record Delegation","text":"<p>Delegation in context of DNS records is to pass the reconciliation responsibility to a primary cluster. This is a multi cluster feature, with two clusters types, referred to as primary cluster and secondary cluster.</p> <p>A primary cluster is a cluster that will reconcile delegated dns records into an authoritative dns record. An authoritative dns record is a dns record that the dns-operator manages, and consists of all the delegated dns records for a root host. The primary cluster requires a default provider secret, which is labeled with <code>kuadrant.io/default-provider=true</code>. The dns-operator can have the <code>--delegation-role=primary</code> adding to the <code>args</code>, or <code>data.DELEGATION_ROLE: primary</code> to the <code>dns-operator-controller-env</code> configmap. This is not strictly necessary as the default delegation role is primary. Multi cluster communication is done via a secret with the label <code>kuadrant.io/multicluster-kubeconfig=true</code>. These secrets are created within the same namespace as the dns-operator deployment. The secret contains a kubeconfig that allow access to a cluster with multi cluster setup, and there will be one secret pre cluster. The <code>kubectl-kuadrant_dns</code> plugin provides a command to help with the secret generation. See <code>kubectl-kuadrant_dns add-cluster-secret --help</code> for more information. If there are multiply primary clusters, each cluster must have the same cluster connection secrets, and a cluster connection secrets to the other primary cluster. The primary cluster B will generate an identical authoritative dns record to primary cluster A</p> <p>A secondary cluster is a cluster that will not reconcile delegated dns records. The secondary cluster will do some validation, and status maintaining of delegated dns records, but does not interact with the dns provider. As the secondary cluster does not interact with the dns provider, there is no need for a provider secret. To configure a secondary cluster the dns-opeator deployment requires <code>--delegation-role=secondary</code> added to <code>args</code>. This can be configured within the <code>dns-operator-controller-env</code> configmap with <code>data.DELEGATION_ROLE: secondary</code>. An important note is a cluster in secondary mode can still reconcile dns records that do not have the delegation field set to true. When a dns record on a secondary cluster is configured without delegation, the dns-operator acts like a normal installation, and requires a provider secret to reconcile the dns record.</p> <p>The delegation of a dns record is achieved by setting <code>delegate=true</code> in the dns record spec. Due to limitations of multi cluster communication, the <code>delegate</code> field is immutable, Changing this field requires the removal of the dns record the cluster, and recreation with the newer values. The <code>delegate=true</code>, and <code>providerRef</code> are mutually exclusive, and can not be set together. A delegated dns record works in the same manner on a primary cluster as a secondary. This allows multiply primary clusters to operate on the dns record, but also allow the resigning of clusters roles at a later stage without having to recreate the dns records on the cluster.</p>"},{"location":"dns-operator/docs/exercising_dns_failover_via_groups/","title":"Exercising DNS Fail-over via groups","text":""},{"location":"dns-operator/docs/exercising_dns_failover_via_groups/#why","title":"Why","text":"<p>The DNS fail-over via groups allows switching traffic from one set of clusters to a second set of clusters in an outage. </p>"},{"location":"dns-operator/docs/exercising_dns_failover_via_groups/#how","title":"How","text":""},{"location":"dns-operator/docs/exercising_dns_failover_via_groups/#starting-point","title":"Starting Point","text":"<p>For this example use case the follow configuration will be assumed.</p> <ul> <li>There are two clusters configured, both with the dns-operator configured to use groups.</li> <li>Cluster_A is a member of the initial active group, and Cluster_B is a replica of Cluster_A, but in a currently inactive group.</li> <li>Cluster_A and Cluster_B have the same dnsrecords deployed for a set of hosts.</li> <li>The dnsrecords on each cluster are configured with IP addresses or CNAMEs that resolve to the service on that cluster.</li> </ul> <p>Cluster_A goes offline for some reason. Now traffic needs to be diverted from the group that Cluster_A is a member of to the group that Cluster_B is a member of, at the DNS level.</p> <p>For the example Cluster_A is configured in group_1, and Cluster_B is configured in group_2.</p>"},{"location":"dns-operator/docs/exercising_dns_failover_via_groups/#note-for-coredns-users","title":"Note for CoreDNS users","text":"<p>When using CoreDNS the active groups TXT record can proxy to any user defined TXT. Meaning <code>kuadrant-active-groups.&lt;domain&gt;</code> could point to <code>company-kuadrant-record-for-groups.&lt;company domain&gt;</code> TXT record. In the case of CoreDNS, the record can be read from the Corefile configmap</p> <p>Within this guide when the <code>kuadrant-active-groups.&lt;domain&gt;</code> TXT record is referred, it is the top level TXT record that being talk about, which may be proxied in the CoreDNS configuration.</p>"},{"location":"dns-operator/docs/exercising_dns_failover_via_groups/#confirming-the-current-group","title":"Confirming the current group","text":""},{"location":"dns-operator/docs/exercising_dns_failover_via_groups/#via-cli","title":"Via CLI","text":"<p>To get which groups are currently configured as the active groups the <code>kubectl-kuadrant_dns</code> CLI can be used. For this we will need 2 pieces of information. The domain that is covered by the <code>providerRef</code> secret, and a reference to the <code>providerRef</code> secret. The <code>providerRef</code> has the format of <code>&lt;namespace&gt;/&lt;name&gt;</code>. Using the below command the current group can be confirmed.</p> <p><pre><code>kubectl-kuadrant_dns get-active-groups --domain &lt;domain&gt; --providerRef &lt;namespace&gt;/&lt;name&gt;\n</code></pre> This will return the list of currently actives groups. It is possible to have more than one active group.</p>"},{"location":"dns-operator/docs/exercising_dns_failover_via_groups/#manually","title":"Manually","text":"<p>The currently configured active groups can be checked manually by logging into the DNS provider. There a TXT record is created listing the active groups. The record has naming format of <code>kuadrant-active-groups.&lt;domain&gt;</code>.  An example of the record is below.</p> <p><pre><code>Record name: kuadrant-active-groups.&lt;domain&gt;\nRecord type: TXT\nValue: \"version=1;groups=group_1&amp;&amp;group_2\"\n</code></pre> This record has more than one active group configured.</p> <p>As the active groups is stored in a TXT record it is also possible to get the data via a dig command.</p> <pre><code>dig kuadrant-active-groups.&lt;domain&gt; TXT +short\n</code></pre>"},{"location":"dns-operator/docs/exercising_dns_failover_via_groups/#setting-the-new-active-group","title":"Setting the new active group","text":"<p>There are two ways of updating the active groups. The easiest method is by using the <code>kubectl-kuadrant_dns</code> CLI, which is shipped as part of the kuadrantctl, and can work as a plugin to kubectl. But also the active groups can be modified by updating the TXT record in the DNS provider directly.</p>"},{"location":"dns-operator/docs/exercising_dns_failover_via_groups/#adding-a-new-active-group-via-the-cli","title":"Adding a new active group via the CLI","text":"<p>In order to configure the groups via the CLI we will need 3 pieces of information.</p> <ul> <li>GROUP_ID this is the name of the group that is to be added to the list of active groups.</li> <li><code>&lt;domain&gt;</code>, root domain of the zone to add the group to.</li> <li><code>&lt;providerRef&gt;</code>, reference to the secret with provider credentials. Format: <code>&lt;namespace&gt;/&lt;name&gt;</code>.</li> </ul> <p>Note: An active connection to the cluster with the <code>&lt;providerRef&gt;</code> is assumed.</p> <p>With this information adding the new group can be done using the following command.</p> <pre><code>kubectl-kuadrant_dns add-active-group GROUP_ID --domain &lt;domain&gt; --providerRef &lt;providerRef&gt;\n\n# Sample success message\nadded group \"group_2\" to active groups of &lt;domain&gt; zone\n</code></pre>"},{"location":"dns-operator/docs/exercising_dns_failover_via_groups/#setting-active-groups-manually","title":"Setting active groups manually","text":"<p>Access to the DNS provider is required. In the provider there will be an existing active groups TXT record. This will have a naming format of <code>kuadrant-active-groups.&lt;domain&gt;</code>. The value of the TXT record references a version, and a list of active groups. List items are separated by <code>&amp;&amp;</code>.</p> <pre><code>Record name: kuadrant-active-groups.&lt;domain&gt;\nRecord type: TXT\nValue: \"version=1;groups=group_1&amp;&amp;group_2\"\n</code></pre>"},{"location":"dns-operator/docs/exercising_dns_failover_via_groups/#removing-the-downed-cluster-group","title":"Removing the downed cluster group","text":"<p>As cluster_A is offline, it is best to disable its group until it can be confirmed to be fully back online. This can be done in the same ways as adding the group to the active-groups record.  When a group is removed from the list of active-groups, other groups in the active-groups will tidy up DNS records created by clusters in inactive groups. It is recommended to always have at least one cluster in an active group.</p>"},{"location":"dns-operator/docs/exercising_dns_failover_via_groups/#removing-old-active-group-via-cli","title":"Removing old active group via CLI","text":"<p>In order to remove groups via the CLI three pieces of information is required.</p> <ul> <li>GROUP_ID this is the name of the group that is to be removed from the list of active groups.</li> <li><code>&lt;domain&gt;</code>, root domain of the zone to add the group to.</li> <li><code>&lt;providerRef&gt;</code>, reference to the secret with provider credentials. Format: <code>&lt;namespace&gt;/&lt;name&gt;</code>.</li> </ul> <p>Note: An active connection to the cluster with the <code>&lt;providerRef&gt;</code> is assumed.</p> <p>With this information removing the new group can be done using the following command.</p> <pre><code>kubectl-kuadrant_dns remove-active-group GROUP_ID --domain &lt;domain&gt; --providerRef &lt;providerRef&gt;\n</code></pre>"},{"location":"dns-operator/docs/exercising_dns_failover_via_groups/#removing-the-old-active-group-manually","title":"Removing the old active group manually","text":"<p>Access to the DNS provider is required. In the provider the <code>kuadrant-active-groups.&lt;domain&gt;</code> TXT record will contain the current list of active groups. This can be a list of groups that are separated by <code>&amp;&amp;</code>. Remove the group which is wanted to be disabled.</p>"},{"location":"dns-operator/docs/exercising_dns_failover_via_groups/#record-reconciliation","title":"Record reconciliation","text":"<p>The dns-operator does not watch for changes in the active-groups TXT records. During the scheduled reconciles of the dns-operator, the dns-operator evaluates the active-groups TXT record, acting as required. In turn, this means fail-over will not be instant, and requires some time to complete.</p> <p>In dev preview this delay can be up to 15 minutes by default. This value can be modified by setting <code>--max-requeue-time</code> argument on the dns-operator deployment, or <code>MAX_REQUEUE_TIME</code> in the <code>dns-operator-controller-env</code> configmap.</p>"},{"location":"dns-operator/docs/exercising_dns_failover_via_groups/#confirming-fail-over-successful","title":"Confirming fail-over successful","text":"<p>To confirm the fail-over has been successful the dnsrecords on the cluster_B can be monitored for a ready status. The following will list the state of all the dnsrecords on the cluster.  Optionally the <code>--watch</code> flag can be added to the command to get updates on the resources</p> <pre><code>kubectl get dnsrecords -A -o custom-columns=\"NAMESPACE:.metadata.namespace,NAME:.metadata.name,OWNER_ID:.status.ownerID,GROUP:.status.group,ACTIVE_GROUPS:.status.activeGroups,ACTIVE:.status.active,READY:.status.conditions[?(@.type==\\\"Ready\\\")].status\"\n</code></pre>"},{"location":"dns-operator/docs/migrating_away_from_dns_groups/","title":"Migrating away from DNS Groups","text":""},{"location":"dns-operator/docs/migrating_away_from_dns_groups/#how","title":"How","text":""},{"location":"dns-operator/docs/migrating_away_from_dns_groups/#remove-the-group-value-from-the-operator","title":"Remove the group value from the operator","text":"<p>Modify the <code>dns-operator-controller-env</code> configmap in the dns-operator namespace and remove the <code>GROUP</code> entry.</p> <p>If the dns-operator is configured to use a group but the configmap does not have the group configured, the configuration was added directly to the dns-operator deployment. Edit the deployment. From <code>spec.containers[name=manager].args</code> remove the argument <code>--group=&lt;group&gt;</code>.</p>"},{"location":"dns-operator/docs/migrating_away_from_dns_groups/#restart-the-operator","title":"Restart the operator","text":"<p>After modifying the <code>dns-operator-controller-env</code> configmap the dns-operator needs to be restarted to roll out the changes.</p> <pre><code>kubectl --namespace &lt;namespace&gt; rollout restart deployment dns-operator-controller-manager\n</code></pre> <p>Check the controller logs to ensure the group has been removed. The following command can be used; the \"using group:\" output is expected to be empty.</p> <pre><code>NS=&lt;namespace&gt; kubectl logs $(kubectl get pods -l control-plane=dns-operator-controller-manager --sort-by=.metadata.creationTimestamp -o name --namespace $NS | tail -n 1) --namespace $NS | head -n 20 | grep group\n</code></pre>"},{"location":"dns-operator/docs/migrating_away_from_dns_groups/#verify-dnsrecord-statuses","title":"Verify DNSRecord statuses","text":"<p>The removal of groups will not happen when the operator restarts, but after the <code>Valid for</code> time period has passed. By default, this can be up to 15 minutes.</p> <p>The following command can be used to monitor the group assigned to a DNSRecord.</p> <pre><code>kubectl get dnsrecords -A -o custom-columns=\"NAMESPACE:.metadata.namespace,NAME:.metadata.name,OWNER_ID:.status.ownerID,GROUP:.status.group,ACTIVE_GROUPS:.status.activeGroups,ACTIVE:.status.active,READY:.status.conditions[?(@.type==\\\"Ready\\\")].status\" --watch\n</code></pre>"},{"location":"dns-operator/docs/migrating_away_from_dns_groups/#confirm-zone-is-as-expected","title":"Confirm zone is as expected","text":"<p>Once reconciliation has fully completed, the group references in the TXT records should be removed from the DNS provider.</p>"},{"location":"dns-operator/docs/migrating_away_from_dns_groups/#delete-active-groups-txt-record-optional","title":"Delete active-groups TXT record (Optional)","text":"<p>If there are no more dns-operators using groups, it is safe to remove the <code>kuadrant-active-groups.&lt;domain&gt;</code> TXT record from the DNS provider. This can be done directly within the DNS provider, or by using the <code>kubectl-kuadrant_dns</code> CLI.</p> <p>Within the DNS provider, remove the TXT record for the domain. The naming convention is <code>kuadrant-active-groups.&lt;domain&gt;</code>.</p> <p>Alternatively, use the CLI with the following command:</p> <pre><code>kubectl-kuadrant_dns remove-active-group GROUP --domain &lt;domain&gt; --providerRef &lt;providerRef&gt;\n</code></pre> <p>The <code>&lt;providerRef&gt;</code> is a reference to the secret used by the dns-operator to connect to the DNS provider, in the format <code>&lt;namespace&gt;/&lt;name&gt;</code>.</p>"},{"location":"dns-operator/docs/migrating_away_from_dns_groups/#note-for-coredns-users","title":"Note for CoreDNS users","text":"<p>When using CoreDNS the active groups TXT record can proxy to any user defined TXT. Meaning <code>kuadrant-active-groups.&lt;domain&gt;</code> could point to <code>company-kuadrant-record-for-groups.&lt;company domain&gt;</code> TXT record. In the case of CoreDNS, the record can be read from the Corefile configmap</p> <p>Within this guide when the <code>kuadrant-active-groups.&lt;domain&gt;</code> TXT record is referred, it is the top level TXT record that being talked about, which may be proxied in the CoreDNS configuration.</p>"},{"location":"dns-operator/docs/migrating_existing_clusters_to_use_groups/","title":"Migrating Existing Clusters To Use Groups","text":""},{"location":"dns-operator/docs/migrating_existing_clusters_to_use_groups/#why-use-groups","title":"Why use Groups","text":"<p>Using groups allows for planned migrations, and for fail-overs when unexpected outages occur.</p> <p>For the planned migrations, new deployment can be configured with the required infrastructure.  Once operational, the active group can be switched to the newer deployment.</p> <p>Unexpected failures do happen, and planning ahead by having a replica of the production deployment configured with DNS groups allows for a timely switch of DNS traffic from the failing deployment to the replica deployment. </p>"},{"location":"dns-operator/docs/migrating_existing_clusters_to_use_groups/#terminology","title":"Terminology","text":""},{"location":"dns-operator/docs/migrating_existing_clusters_to_use_groups/#group","title":"Group","text":"<p>A group is a method of tagging a dns-operator to reconcile on resources. The dns-operator can only be part of one group at a time. Cluster of dns-operator can be enabled, and disable by modifying TXT records with a DNS provider.</p>"},{"location":"dns-operator/docs/migrating_existing_clusters_to_use_groups/#active-groups","title":"Active groups","text":"<p>The active groups are the groups that are stated in the active-groups TXT records. Dns-operators that are configured with a group that is in the active-groups will reconcile the dnsrecords on that clusters, and any dnsrecords delegated in a multi cluster setup.</p> <p>Dns-operators in the active groups will tidy up orphaned DNS records from any dns-operator that may now be part of an inactive group.</p>"},{"location":"dns-operator/docs/migrating_existing_clusters_to_use_groups/#inactive-group","title":"Inactive group","text":"<p>Dns-operators configured with a group that is not in the active-groups are considered to be part of the inactive group. DNS records in the provider that were previously created by the dns-operator that is now in the inactive group while be removed by the dns-operators that are in the active groups.</p> <p>Inactive group dns-operators do not clean up DNS records related to the resources they manage.  Dns-operators in an inactive group may be part of an outage, and can not be trusted to be able to clean up their resources. For this reason dns-operators in inactive groups don't attempt any clean up.</p>"},{"location":"dns-operator/docs/migrating_existing_clusters_to_use_groups/#ungrouped","title":"Ungrouped.","text":"<p>When a dns-operator does not have a group assigned it is regarded as being ungrouped. A ungrouped dns-operator will reconcile all dnsrecords that the operator has access to no matter what groups are configured in the active groups.</p> <p>Ungrouped dns-operators will not process the unpublishing of in inactive groups records.  This includes DNS records created by now inactive group dns-operators which do require cleaning up.</p>"},{"location":"dns-operator/docs/migrating_existing_clusters_to_use_groups/#how-to-configure-existing-cluster","title":"How To Configure Existing Cluster","text":""},{"location":"dns-operator/docs/migrating_existing_clusters_to_use_groups/#starting-point","title":"Starting point","text":"<p>There is an existing cluster configured with dns-operator deployed without groups configured.  Along with the dns-operator deployment, dns-records have being reconciled, and are in a ready state.</p>"},{"location":"dns-operator/docs/migrating_existing_clusters_to_use_groups/#create-the-active-groups-txt-record","title":"Create the active-groups TXT record","text":"<p>The active-groups record list is a TXT record that is created in the provider. The TXT record contains a list of groups that are active.</p> <p>By creating the TXT record before updating the dns-operator the reconcile of DNS records will not cause unexpected service interruptions. </p>"},{"location":"dns-operator/docs/migrating_existing_clusters_to_use_groups/#creation-of-active-groups-txt-record-via-the-cli","title":"Creation of active-groups TXT record via the CLI.","text":"<p>Using the <code>kubectl-kuadrant_dns</code> CLI the active groups can be easily created. The CLI can be used as a plugin in the kuadrantctl, or as a plugin in the kubectl.</p> <p>To create the record three pieces of information is required.</p> <ul> <li>Group ID to be added to the active-groups TXT record</li> <li>providerRef, this is the secret used by the dns-operator to connect to the provider. Format required \\&lt;namespace&gt;/\\&lt;name&gt;.</li> <li>domain, this is the route domain for the zone.</li> </ul> <p>With this information the active-groups TXT record is created with the command below. <pre><code>kubectl-kuadrant_dns add-active-group GROUP_ID --providerRef &lt;namespace&gt;/&lt;name&gt; --domain &lt;domain&gt;\n</code></pre> This command will also add a new active group to an existing active-groups TXT record.</p> <p>Once the active-groups TXT record has being created, a new TXT record will be created in the provider. The TXT record has a naming convention of <code>kuadrant-active-groups.&lt;domain&gt;</code>. The TXT record structure is as follows. Fields are separated by <code>;</code>. A <code>version</code> field is added, current version = 1. The <code>groups</code> field contains a list of active groups. Group IDs are separated by <code>&amp;&amp;</code>.</p> <p>Sample TXT Record <pre><code>Record name: kuadrant-active-groups.&lt;domain&gt;\nRecord type: TXT\nValue: \"version=1;groups=GROUP_ID1&amp;&amp;GROUP_ID2\"\n</code></pre></p> <p>This information can be viewed by preforming a dig against the TXT record. <pre><code>dig kuadrant-active-groups.&lt;domain&gt; TXT +short\n\n# example output\n\"version=1;groups=GROUP_ID1&amp;&amp;GROUP_ID2\"\n</code></pre></p>"},{"location":"dns-operator/docs/migrating_existing_clusters_to_use_groups/#creation-of-active-groups-txt-record-manual","title":"Creation of active-groups TXT record manual.","text":"<p>As the active-groups are maintained as a TXT record, it is possible to create, and maintain the record manually.  This assumes the users has access to the DNS provider, and has permission to create TXT records in a given zone. To create the active-groups the following bits of information is required.</p> <ul> <li>Group ID to be added to the active-groups TXT record</li> <li>domain, this is the route domain for the zone.</li> </ul> <p>There are strict requirements on the active-groups TXT record. It must be named as: <code>kuadrant-active-groups.&lt;domain&gt;</code>. The record type must be TXT. Finally, the fields in the record must contain a <code>version</code> and <code>groups</code> field. Fields are separated by <code>;</code>. The <code>groups</code> field is a list of active groups, and the entries are separated by <code>&amp;&amp;</code>.</p> <p>Below is a sample TXT record.</p> <pre><code>Record name: kuadrant-active-groups.&lt;domain&gt;\nRecord type: TXT\nValue: \"version=1;groups=GROUP_ID1&amp;&amp;GROUP_ID2\"\n</code></pre>"},{"location":"dns-operator/docs/migrating_existing_clusters_to_use_groups/#checking-the-active-groups-list","title":"Checking the active groups list","text":"<p>Before moving on to configuring the dns-operator to be part of a group, it is good practice to ensure the correct groups are active. This can be easily done via the <code>kubectl-kuadrant_dns</code> CLI, or manually via the DNS provider.</p>"},{"location":"dns-operator/docs/migrating_existing_clusters_to_use_groups/#via-the-kudectl-kuadrant_dns-cli","title":"Via the kudectl-kuadrant_dns CLI","text":"<p>To do this the follow information is required.</p> <ul> <li>providerRef, this is the secret used by the dns-operator to connect to the provider. Format required \\&lt;namespace&gt;/\\&lt;name&gt;.</li> <li>domain, this is the route domain for the zone. With this information the CLI command to use is. <pre><code>kubectl-kuadrant_dns get-active-groups --providerRef &lt;namespace&gt;/&lt;name&gt; --domain &lt;domain&gt;\n</code></pre></li> </ul>"},{"location":"dns-operator/docs/migrating_existing_clusters_to_use_groups/#manually-via-the-dns-provider","title":"Manually via the DNS provider","text":"<p>In the DNS provider there will be a TXT record created that states the active groups. This TXT record has a naming schema of <code>kuadrant-active-groups.&lt;domain&gt;</code>. The active groups are in a <code>&amp;&amp;</code> separated list.</p> <p>Below is a sample TXT record.</p> <pre><code>Record name: kuadrant-active-groups.&lt;domain&gt;\nRecord type: TXT\nValue: \"version=1;groups=GROUP_ID1&amp;&amp;GROUP_ID2\"\n</code></pre> <p>The TXT record can also be accessed by doing a dig on the TXT record.</p> <pre><code>dig kuadrant-active-groups.&lt;domain&gt; TXT +short\n</code></pre>"},{"location":"dns-operator/docs/migrating_existing_clusters_to_use_groups/#configuring-the-dns-operator-to-be-part-of-a-group","title":"Configuring the dns-operator to be part of a group","text":"<p>The dns-operator can be added to a group via an env var set in the <code>dns-operator-controller-env</code> configmap. This configmap exists in the same namespace as the dns-operator.</p> <p>By using kubectl patch, the configmap can be updated with affecting other env vars that may be configured. <pre><code>kubectl patch configmap dns-operator-controller-env --namespace &lt;namespace&gt; --type merge --patch '{\"data\":{\"GROUP\":\"&lt;GROUP ID&gt;\"}}'\n</code></pre> Once the configmap has being patched, the deployment needs to be redeployed for the changes to take effect. <pre><code>kubectl rollout restart deployment dns-operator-controller-manager --namespace &lt;namespace&gt;\n</code></pre></p>"},{"location":"dns-operator/docs/migrating_existing_clusters_to_use_groups/#confirming-the-dns-operator-is-configured-correctly","title":"Confirming the dns-operator is configured correctly","text":"<p>It can take some time for the all the dnsrecords to be fully reconciled to use the new group setting. However, by checking the logs of the operator, it can be confirmed that the group was configured correctly. There are two setup log messages that confirm the group was correctly configured. These log messages can be retrieved from the cluster with the following command. <pre><code>NS=&lt;namespace&gt;; kubectl logs $(kubectl get pods -l control-plane=dns-operator-controller-manager --sort-by=.metadata.creationTimestamp -o name --namespace $NS | tail -n 1) --namespace $NS | head -n 20 | grep group\n\n# expected output\n{\"level\":\"info\",\"ts\":\"2006-1-2T15:4:5\",\"logger\":\"setup\",\"msg\":\"overriding group flag with \\\"group1\\\" value\"}\n{\"level\":\"info\",\"ts\":\"2006-1-2T15:4:5\",\"logger\":\"setup\",\"msg\":\"using group: group1\"}\n</code></pre></p> <p>When the reconcile finally completes on the dnsrecords in the status block there will be mention of the group. The current group of the dnsrecords can be checked with the following command. <pre><code>kubectl get dnsrecords -A -o custom-columns=\"NAMESPACE:.metadata.namespace,NAME:.metadata.name,OWNER_ID:.status.ownerID,STATUS.GROUP:.status.group\"\n</code></pre></p> <p>The last place that changes can be checked is the TXT record for the dnsrecords in the provider. In the provider a TXT record is created with the owner ID of the related dnsrecord. Each of these TXT records will state what group they are part of.</p> <p>Note: If using the above command will list all the owner IDs for the dnsrecords however, if cluster delegation is used not all dnsrecords will have TXT created </p> <p>The TXT records that were created will have the following fields, and structure. <pre><code>heritage=external-dns\nexternal-dns/group=&lt;GROUP ID&gt;\nexternal-dns/owner=&lt;ownerID&gt;\nexternal-dns/targets=...\nexternal-dns/version=1\n</code></pre></p>"},{"location":"dns-operator/docs/migrating_existing_clusters_to_use_groups/#beyond-the-initial-configuration","title":"Beyond the initial configuration","text":"<p>After configuring the dns-operator to be a part of a group there is some next possible steps.</p> <p>It is possible to have more than one active group at a time. This allows finer control over the networking design, and relicences of the infrastructure.</p> <p>When a dns-operator is configured with a group it is possible to change the group that dns-operator is a part of. All the dnsrecords, and TXT related to does records will be updated to use the new group. Changing the group from an active group to an inactive group at controller level is currently unsupported. See known issues for more details.</p>"},{"location":"dns-operator/docs/migrating_existing_clusters_to_use_groups/#known-issues","title":"Known Issues","text":"<ul> <li>DNS Operator - always write groupID to provider</li> </ul>"},{"location":"dns-operator/docs/provider/","title":"Configuring a DNS Provider","text":"<p>In order to be able to interact with supported DNS providers, Kuadrant needs a credential that it can use.</p> <p>Credentials are expected to reside in a secret. The secret name can be specified in the <code>DNSRecord.Spec.ProviderRef</code> or the secret can have <code>kuadrant.io/default-provider=true</code> label. The secret that got assigned to the DNSRecord will be specified in the <code>Status.ProfiverRef</code>.</p>"},{"location":"dns-operator/docs/provider/#supported-providers","title":"Supported Providers","text":"<p>Kuadrant Supports the following DNS providers currently</p> <ul> <li>AWS Route 53 (aws)</li> <li>Google Cloud DNS (gcp)</li> <li>Azure (azure)</li> <li>CoreDNS (coredns)</li> </ul>"},{"location":"dns-operator/docs/provider/#aws-route-53-provider","title":"AWS Route 53 Provider","text":"<p>Kuadrant expects a <code>Secret</code> with a credential. Below is an example for AWS Route 53. It is important to set the secret type to <code>aws</code>:</p> <pre><code>kubectl create secret generic my-aws-credentials \\\n  --namespace=kuadrant-dns-system \\\n  --type=kuadrant.io/aws \\\n  --from-literal=AWS_ACCESS_KEY_ID=XXXX \\\n  --from-literal=AWS_REGION=eu-west-1 \\\n  --from-literal=AWS_SECRET_ACCESS_KEY=XXX\n</code></pre> Key Example Value Description <code>AWS_REGION</code> <code>eu-west-1</code> AWS Region <code>AWS_ACCESS_KEY_ID</code> <code>XXXX</code> AWS Access Key ID (see note on permissions below) <code>AWS_SECRET_ACCESS_KEY</code> <code>XXXX</code> AWS Secret Access Key"},{"location":"dns-operator/docs/provider/#aws-iam-permissions-required","title":"AWS IAM Permissions Required","text":"<p>We have tested using the available policy <code>AmazonRoute53FullAccess</code> however it should also be possible to restrict the credential down to a particular zone. More info can be found in the AWS docs:</p> <p>https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/access-control-managing-permissions.html</p> <p>By default, Kuadrant will list the available zones and find the matching zone based on the listener host in the gateway listener. If it finds more than one matching zone for a given listener host, it will not update any of those zones.  When providing a credential you should limit that credential down to just have write access to the zones you want Kuadrant to manage. Below is an example of a an AWS policy for doing this type of thing:</p> <pre><code>{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Sid\": \"VisualEditor0\",\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"route53:ListTagsForResources\",\n                \"route53:GetHealthCheckLastFailureReason\",\n                \"route53:GetHealthCheckStatus\",\n                \"route53:GetChange\",\n                \"route53:GetHostedZone\",\n                \"route53:ChangeResourceRecordSets\",\n                \"route53:ListResourceRecordSets\",\n                \"route53:GetHealthCheck\",\n                \"route53:UpdateHostedZoneComment\",\n                \"route53:UpdateHealthCheck\",\n                \"route53:CreateHealthCheck\",\n                \"route53:DeleteHealthCheck\",\n                \"route53:ListTagsForResource\",\n                \"route53:ListHealthChecks\",\n                \"route53:GetGeoLocation\",\n                \"route53:ListGeoLocations\",\n                \"route53:ListHostedZonesByName\",\n                \"route53:GetHealthCheckCount\"\n            ],\n            \"Resource\": [\n                \"arn:aws:route53:::hostedzone/Z08187901Y93585DDGM6K\",\n                \"arn:aws:route53:::healthcheck/*\",\n                \"arn:aws:route53:::change/*\"\n            ]\n        },\n        {\n            \"Sid\": \"VisualEditor1\",\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"route53:ListHostedZones\"\n            ],\n            \"Resource\": \"*\"\n        }\n    ]\n}\n</code></pre>"},{"location":"dns-operator/docs/provider/#google-cloud-dns-provider","title":"Google Cloud DNS Provider","text":"<p>Kuadant expects a secret with a credential. Below is an example for Google DNS. It is important to set the secret type to <code>gcp</code>:</p> <pre><code>kubectl create secret generic my-test-gcp-credentials \\\n  --namespace=kuadrant-dns-system \\\n  --type=kuadrant.io/gcp \\\n  --from-literal=PROJECT_ID=xxx \\\n  --from-file=GOOGLE=$HOME/.config/gcloud/application_default_credentials.json\n</code></pre> Env Var Example Value Description <code>GOOGLE</code> <code>{\"client_id\": \"***\",\"client_secret\": \"***\",\"refresh_token\": \"***\",\"type\": \"authorized_user\"}</code> This is the JSON created from either the credential created by the <code>gcloud</code> CLI, or the JSON from the Service account <code>PROJECT_ID</code> <code>my_project_id</code> ID to the Google project"},{"location":"dns-operator/docs/provider/#google-cloud-dns-access-permissions-required","title":"Google Cloud DNS Access permissions required","text":"<p>We have tested with the <code>dns.admin</code> role. See for more details:</p> <p>https://cloud.google.com/dns/docs/access-control#dns.admin</p>"},{"location":"dns-operator/docs/provider/#azure-cloud-dns-provider","title":"Azure Cloud DNS Provider","text":"<p>Kuadrant expects a <code>Secret</code> with a credential. Below is an example for Azure. It is important to set the secret type to <code>azure</code>:</p> <p>We recommend creating a new service principal for managing DNS. Azure Service Principal Docs</p> <pre><code># Create the service principal\n$ DNS_NEW_SP_NAME=kuadrantDnsPrincipal\n$ DNS_SP=$(az ad sp create-for-rbac --name $DNS_NEW_SP_NAME)\n$ DNS_SP_APP_ID=$(echo $DNS_SP | jq -r '.appId')\n$ DNS_SP_PASSWORD=$(echo $DNS_SP | jq -r '.password')\n</code></pre>"},{"location":"dns-operator/docs/provider/#azure-cloud-dns-access-permissions-required","title":"Azure Cloud DNS Access permissions required","text":"<p>You will need to grant read and contributor access to the zone(s) you want managed for the service principal you are using.</p> <p>1)  fetch DNS id used to grant access to the service principal</p> <pre><code>```bash\nDNS_ID=$(az network dns zone show --name example.com \\\n --resource-group ExampleDNSResourceGroup --query \"id\" --output tsv)\n\n# get yor resource group id\n\nRESOURCE_GROUP_ID=az group show --resource-group ExampleDNSResourceGroup | jq \".id\" -r\n```\n</code></pre> <p>2) provide reader access to the resource group     <pre><code>az role assignment create --role \"Reader\" --assignee $DNS_SP_APP_ID --scope $DNS_ID\n</code></pre></p> <p>3) provide contributor access to DNS Zone itself     <pre><code>$ az role assignment create --role \"Contributor\" --assignee $DNS_SP_APP_ID --scope $DNS_ID\n</code></pre></p> <p>4) As we are setting up advanced traffic rules for GEO and Weighted responses, you will also need to grant traffic manager access:</p> <pre><code>```bash\naz role assignment create --role \"Traffic Manager Contributor\" --assignee $DNS_SP_APP_ID --scope $RESOURCE_GROUP_ID\n```\n\n```bash\ncat &lt;&lt;-EOF &gt; /local/path/to/azure.json\n{\n  \"tenantId\": \"$(az account show --query tenantId -o tsv)\",\n  \"subscriptionId\": \"$(az account show --query id -o tsv)\",\n  \"resourceGroup\": \"ExampleDNSResourceGroup\",\n  \"aadClientId\": \"$DNS_SP_APP_ID\",\n  \"aadClientSecret\": \"$DNS_SP_PASSWORD\"\n}\nEOF\n```\n</code></pre> <p>5) Finally setup the secret with the credential azure.json file</p> <pre><code>```bash\nkubectl create secret generic my-test-azure-credentials \\\n  --namespace=kuadrant-dns-system \\\n  --type=kuadrant.io/azure \\\n  --from-file=azure.json=/local/path/to/azure.json\n```\n</code></pre>"},{"location":"dns-operator/docs/provider/#coredns-provider","title":"CoreDNS Provider","text":"<p>CoreDNS provider enables self-hosted DNS using CoreDNS in Kubernetes. Unlike cloud providers, it requires configuration (zones and nameservers) rather than only supplying authentication credentials.</p> <p>Kuadrant expects a <code>Secret</code> with zone and nameserver configuration. Below is an example for CoreDNS. It is important to set the secret type to <code>coredns</code>:</p> <pre><code>kubectl create secret generic my-coredns-credentials \\\n  --namespace=kuadrant-dns-system \\\n  --type=kuadrant.io/coredns \\\n  --from-literal=ZONES=example.com \\\n  --from-literal=NAMESERVERS=ns1.example.com,ns2.example.com\n</code></pre> Key Example Value Description <code>ZONES</code> <code>example.com</code> (Required) DNS zone this provider manages <code>NAMESERVERS</code> <code>ns1.example.com,ns2.example.com</code> (Optional) Comma-separated list of authoritative nameservers for the zone. Only required for DNS Groups feature (active-passive failover). <p>Note: The CoreDNS provider does not require authentication credentials. It only needs to know which zone it manages (<code>ZONES</code> field is required). </p> <p>For setting the secret as the default provider in a namespace, add the <code>kuadrant.io/default-provider=true</code> label:</p> <pre><code>kubectl label secret my-coredns-credentials \\\n  -n kuadrant-dns-system \\\n  kuadrant.io/default-provider=true\n</code></pre>"},{"location":"dns-operator/docs/coredns/configuration/","title":"CoreDNS Configuration Reference","text":"<p>This document provides comprehensive technical information for configuring CoreDNS integration with DNS Operator. Each section follows the pattern: What (parameter/concept) \u2192 How (configuration example) \u2192 Result (expected outcome).</p>"},{"location":"dns-operator/docs/coredns/configuration/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Corefile Configuration</li> <li>Zone Configuration</li> <li>Provider Secret Configuration</li> <li>DNS Groups Configuration</li> <li>GeoIP Database Configuration</li> <li>Advanced Routing Strategies</li> <li>Monitoring and Observability</li> <li>Logging Configuration</li> </ol>"},{"location":"dns-operator/docs/coredns/configuration/#corefile-configuration","title":"Corefile Configuration","text":""},{"location":"dns-operator/docs/coredns/configuration/#what","title":"What","text":"<p>CoreDNS is configured via a Corefile that defines which zones it serves and how it processes DNS queries. The Kuadrant CoreDNS plugin extends CoreDNS to watch Kubernetes DNSRecord resources and serve them as DNS responses.</p>"},{"location":"dns-operator/docs/coredns/configuration/#how","title":"How","text":"<p>Basic Corefile Structure:</p> <pre><code>k.example.com {\n    debug\n    errors\n    log\n    health {\n        lameduck 5s\n    }\n    ready\n    geoip GeoLite2-City-demo.mmdb {\n        edns-subnet\n    }\n    metadata\n    transfer {\n        to *\n    }\n    kuadrant\n    prometheus 0.0.0.0:9153\n}\n</code></pre> <p>Key Concepts:</p> <ul> <li>Zone Coordination: Each zone in the Corefile must match a zone listed in your CoreDNS provider secret's <code>ZONES</code> field (see Provider Secret Configuration for details)</li> <li>Required Plugins: For geo-routing to work, ensure <code>geoip</code> and <code>metadata</code> plugins are included in your Corefile. Plugin execution order is determined at build time (see <code>coredns/plugin/cmd/plugin/plugin.go</code>), not by Corefile order, so you can list plugins in any order.</li> <li>Watch Mechanism: The Kuadrant plugin watches for DNSRecords labeled with <code>kuadrant.io/coredns-zone-name: &lt;zone&gt;</code></li> </ul> <p>Core Plugin:</p> <p>kuadrant - Kuadrant DNS integration (required) <pre><code>kuadrant\n</code></pre></p> <p>Plugins for Geo-Routing (required for geo/weighted routing):</p> <p>metadata - Enables metadata extraction for routing decisions <pre><code>metadata\n</code></pre></p> <p>geoip - Provides geographic IP lookup <pre><code>geoip /path/to/GeoLite2-City.mmdb {\n    edns-subnet\n}\n</code></pre></p> <p>Recommended Plugins:</p> <p>health - Kubernetes liveness probe endpoint <pre><code>health {\n    lameduck 5s\n}\n</code></pre></p> <p>ready - Kubernetes readiness probe endpoint <pre><code>ready\n</code></pre></p> <p>transfer - Zone transfer support (useful for debugging and secondary servers) <pre><code>transfer {\n    to *\n}\n</code></pre></p> <p>SOA RNAME Configuration:</p> <p>The <code>rname</code> directive customizes the email address (RNAME) in the SOA (Start of Authority) record for the zone.</p> <p>Syntax: <pre><code>kuadrant {\n    rname EMAIL\n}\n</code></pre></p> <p>Default Behavior: If not specified, defaults to <code>hostmaster.{zone}</code> (e.g., <code>hostmaster.k.example.com.</code>)</p> <p>Email Format Conversion: The email format (e.g., <code>admin@example.com</code>) is automatically converted to DNS mailbox format (e.g., <code>admin.example.com.</code>). According to RFC 1035 and RFC 2142, any dots in the local part (before @) are escaped with backslash (e.g., <code>dns.admin@example.com</code> becomes <code>dns\\.admin.example.com.</code>).</p> <p>Example: <pre><code>k.example.com {\n    kuadrant {\n        rname admin@example.com\n    }\n}\n</code></pre></p>"},{"location":"dns-operator/docs/coredns/configuration/#result","title":"Result","text":"<p>Verification: <pre><code># Query SOA record to verify RNAME\ndig @${NS} k.example.com SOA +short\n</code></pre></p> <p>Expected output: <pre><code>ns1.k.example.com. admin.example.com. 12345 7200 1800 86400 60\n</code></pre></p> <p>The second field (<code>admin.example.com.</code>) is the converted RNAME.</p>"},{"location":"dns-operator/docs/coredns/configuration/#additional-resources","title":"Additional Resources","text":"<ul> <li>Kuadrant CoreDNS Plugin Documentation - Complete plugin syntax, examples, and development guide</li> <li>CoreDNS Official Documentation - General CoreDNS configuration and plugin reference</li> </ul>"},{"location":"dns-operator/docs/coredns/configuration/#zone-configuration","title":"Zone Configuration","text":""},{"location":"dns-operator/docs/coredns/configuration/#what_1","title":"What","text":"<p>When using the Kuadrant CoreDNS plugin, you need to configure the zone's authoritative nameserver records. The plugin initializes each zone with a single hardcoded NS record (<code>ns1.&lt;zone-name&gt;</code>).</p> <p>A zone configuration typically includes:</p> <ul> <li>Multiple NS records (IANA requirement: minimum 2 nameservers)</li> <li>Corresponding A records mapping nameserver hostnames to their IP addresses</li> <li>Consistency with parent zone delegation configuration</li> <li>Parent zone delegation with NS records and glue A records</li> </ul>"},{"location":"dns-operator/docs/coredns/configuration/#how_1","title":"How","text":"<p>Use DNSRecord resources to configure zone apex NS and A records.</p>"},{"location":"dns-operator/docs/coredns/configuration/#deployment-patterns","title":"Deployment Patterns","text":""},{"location":"dns-operator/docs/coredns/configuration/#single-cluster-setup","title":"Single Cluster Setup","text":"<p>Configuration:</p> <pre><code>apiVersion: kuadrant.io/v1alpha1\nkind: DNSRecord\nmetadata:\n  name: dnsrecord-k-example-com-zone-config\n  namespace: kuadrant-coredns\nspec:\n  rootHost: k.example.com\n  providerRef:\n    name: dns-provider-credentials-coredns\n  endpoints:\n  # NS records for the zone\n  # Note: Both NS records will point to the same CoreDNS instance IP\n  # This does NOT provide true redundancy\n\n  - dnsName: k.example.com\n    recordTTL: 60\n    recordType: NS\n    targets:\n    - ns1.k.example.com\n    - ns2.k.example.com\n  # A record for ns1 (single CoreDNS instance)\n  - dnsName: ns1.k.example.com\n    recordTTL: 60\n    recordType: A\n    targets:\n    - 172.18.0.17  # IP of the single CoreDNS instance\n  # A record for ns2 (same IP as ns1 - no actual redundancy)\n  - dnsName: ns2.k.example.com\n    recordTTL: 60\n    recordType: A\n    targets:\n    - 172.18.0.17  # Same IP - this is not redundant!\n</code></pre> <p>Determining CoreDNS IP (Kind clusters): <pre><code>NS1=\"$(kubectl get service/kuadrant-coredns -n kuadrant-coredns \\\n  -o jsonpath='{.status.loadBalancer.ingress[0].ip}')\"\necho \"CoreDNS IP: ${NS1}\"\n</code></pre></p> <p>Characteristics:</p> <ul> <li>Single CoreDNS instance serves the zone</li> <li>Multiple NS records can be configured, but all point to the same IP address</li> <li>If the CoreDNS instance fails, the zone becomes unavailable</li> </ul>"},{"location":"dns-operator/docs/coredns/configuration/#multi-cluster-setup","title":"Multi-Cluster Setup","text":"<p>Deploy CoreDNS across multiple clusters with delegation enabled. Each primary cluster runs its own CoreDNS instance, and the NS record merging logic combines nameserver records from all clusters into the authoritative zone.</p> <p>Architecture:</p> <ul> <li>Multiple Primary Clusters: Each runs a CoreDNS instance with the Kuadrant plugin</li> <li>Delegation Mode: Each cluster creates delegated DNSRecord resources</li> <li>Automatic Merging: The operator merges NS records from all clusters</li> <li>True Redundancy: Each nameserver has a unique IP from a different cluster</li> </ul> <p>Configuration:</p> <p>Cluster 1 (Primary): <pre><code>apiVersion: kuadrant.io/v1alpha1\nkind: DNSRecord\nmetadata:\n  name: dnsrecord-k-example-com-zone-config\n  namespace: kuadrant-coredns\nspec:\n  rootHost: k.example.com\n  delegate: true\n  endpoints:\n  # This cluster contributes ns1.k.example.com\n\n  - dnsName: k.example.com\n    recordTTL: 60\n    recordType: NS\n    targets:\n    - ns1.k.example.com\n  # A record for ns1 pointing to Cluster 1's CoreDNS\n  - dnsName: ns1.k.example.com\n    recordTTL: 60\n    recordType: A\n    targets:\n    - 172.18.0.17  # Cluster 1 CoreDNS LoadBalancer IP\n</code></pre></p> <p>Cluster 2 (Primary): <pre><code>apiVersion: kuadrant.io/v1alpha1\nkind: DNSRecord\nmetadata:\n  name: dnsrecord-k-example-com-zone-config\n  namespace: kuadrant-coredns\nspec:\n  rootHost: k.example.com\n  delegate: true\n  endpoints:\n  # This cluster contributes ns2.k.example.com\n\n  - dnsName: k.example.com\n    recordTTL: 60\n    recordType: NS\n    targets:\n    - ns2.k.example.com\n  # A record for ns2 pointing to Cluster 2's CoreDNS\n  - dnsName: ns2.k.example.com\n    recordTTL: 60\n    recordType: A\n    targets:\n    - 172.18.0.18  # Cluster 2 CoreDNS LoadBalancer IP\n</code></pre></p> <p>Optional Cluster 3+ (Primary):</p> <p>For additional redundancy, add more clusters following the same pattern with <code>ns3.k.example.com</code>, <code>ns4.k.example.com</code>, etc.</p> <p>Determining CoreDNS IPs (Multi-cluster Kind): <pre><code># Cluster 1\nNS1=\"$(kubectl get service/kuadrant-coredns -n kuadrant-coredns \\\n  --context kind-kuadrant-dns-local-1 \\\n  -o jsonpath='{.status.loadBalancer.ingress[0].ip}')\"\necho \"Cluster 1 CoreDNS IP: ${NS1}\"\n\n# Cluster 2\nNS2=\"$(kubectl get service/kuadrant-coredns -n kuadrant-coredns \\\n  --context kind-kuadrant-dns-local-2 \\\n  -o jsonpath='{.status.loadBalancer.ingress[0].ip}')\"\necho \"Cluster 2 CoreDNS IP: ${NS2}\"\n</code></pre></p> <p>Cloud Providers: <pre><code># Most cloud providers (GCP, Azure, DigitalOcean) assign an IP\nkubectl get service/kuadrant-coredns -n kuadrant-coredns \\\n  -o jsonpath='{.status.loadBalancer.ingress[0].ip}'\n\n# AWS ELB/NLB typically provides a hostname instead of IP\nkubectl get service/kuadrant-coredns -n kuadrant-coredns \\\n  -o jsonpath='{.status.loadBalancer.ingress[0].hostname}'\n</code></pre></p> <p>Note on AWS LoadBalancers: AWS ELB/NLB services typically expose a DNS hostname (e.g., <code>abc123.elb.us-east-1.amazonaws.com</code>) rather than a static IP address. You can use the ELB hostname directly as your NS record target without needing glue A records, since the hostname is in a different DNS zone and resolvers can query it independently.</p>"},{"location":"dns-operator/docs/coredns/configuration/#result_1","title":"Result","text":"<p>Verify that CoreDNS is serving the configured NS and A records for the zone.</p>"},{"location":"dns-operator/docs/coredns/configuration/#verify-ns-and-a-records","title":"Verify NS and A Records","text":"<pre><code># Get CoreDNS IP\nNS1=\"$(kubectl get service/kuadrant-coredns -n kuadrant-coredns \\\n  -o jsonpath='{.status.loadBalancer.ingress[0].ip}')\"\n\n# Verify NS records\ndig @${NS1} k.example.com NS +short\n\n# Verify nameserver A records\ndig @${NS1} ns1.k.example.com +short\ndig @${NS1} ns2.k.example.com +short\n</code></pre> <p>Expected output: <pre><code># NS records\nns1.k.example.com.\nns2.k.example.com.\n\n# A records\n172.18.0.17\n172.18.0.18\n</code></pre></p>"},{"location":"dns-operator/docs/coredns/configuration/#optional-zone-transfer","title":"Optional: Zone Transfer","text":"<p>If you have the <code>transfer</code> plugin enabled, you can view all zone records at once:</p> <pre><code># Get CoreDNS IP\nNS1=\"$(kubectl get service/kuadrant-coredns -n kuadrant-coredns \\\n  -o jsonpath='{.status.loadBalancer.ingress[0].ip}')\"\n\n# Request full zone transfer\ndig @${NS1} -t AXFR k.example.com\n</code></pre> <p>Expected output: <pre><code>k.example.com.          60  IN  SOA  ns1.k.example.com. hostmaster.k.example.com. 12345 7200 1800 86400 60\nk.example.com.          60  IN  NS   ns1.k.example.com.\nk.example.com.          60  IN  NS   ns2.k.example.com.\nns1.k.example.com.      60  IN  A    172.18.0.17\nns2.k.example.com.      60  IN  A    172.18.0.18\nk.example.com.          60  IN  SOA  ns1.k.example.com. hostmaster.k.example.com. 12345 7200 1800 86400 60\n</code></pre></p>"},{"location":"dns-operator/docs/coredns/configuration/#parent-zone-delegation","title":"Parent Zone Delegation","text":"<p>After configuring the CoreDNS zone, you must update the parent zone to delegate authority for your subdomain. The parent zone needs NS records and corresponding glue records (A records).</p> <p>For a comprehensive step-by-step guide to parent zone delegation, including local BIND9 setup, dynamic DNS updates, and in-cluster DNS forwarding, see the Zone Delegation Guide.</p> <p>What: Glue records are required when nameserver hostnames are within the delegated zone (e.g., <code>ns1.k.example.com</code> for zone <code>k.example.com</code>). For a detailed explanation, see RFC 9471 - DNS Glue Requirements.</p> <p>How: If your CoreDNS manages <code>k.example.com</code> and the parent zone is <code>example.com</code>:</p> <p>For BIND9 (example.com zone file): <pre><code>; Delegation for k.example.com to CoreDNS instances\nk.example.com.          300  IN  NS  ns1.k.example.com.\nk.example.com.          300  IN  NS  ns2.k.example.com.\n\n; Glue records (required because nameservers are within delegated zone)\nns1.k.example.com.      300  IN  A   172.18.0.17\nns2.k.example.com.      300  IN  A   172.18.0.18\n</code></pre></p> <p>For dynamic updates (BIND9 with nsupdate): <pre><code>EDGE_NS=\"&lt;parent-nameserver&gt;\"\ncat &lt;&lt;EOF &gt;nsupdate-delegation\nserver ${EDGE_NS}\ndebug yes\nzone example.com.\nupdate add k.example.com 300 IN NS ns1.k.example.com.\nupdate add k.example.com 300 IN NS ns2.k.example.com.\nupdate add ns1.k.example.com 300 IN A 172.18.0.17\nupdate add ns2.k.example.com 300 IN A 172.18.0.18\nsend\nEOF\n\nnsupdate -k /path/to/ddns.key -v nsupdate-delegation\n</code></pre></p> <p>For cloud DNS providers (AWS Route53, Google Cloud DNS, Azure DNS):</p> <p>Use DNS Operator to manage parent zone delegation records:</p> <pre><code>apiVersion: kuadrant.io/v1alpha1\nkind: DNSRecord\nmetadata:\n  name: parent-zone-delegation-k-example-com\n  namespace: kuadrant-coredns\nspec:\n  rootHost: example.com\n  providerRef:\n    name: dns-provider-credentials  # Secret with provider credentials\n  endpoints:\n  # NS records for subdomain delegation\n\n  - dnsName: k.example.com\n    recordTTL: 300\n    recordType: NS\n    targets:\n    - ns1.k.example.com\n    - ns2.k.example.com\n  # Glue records for nameservers\n  - dnsName: ns1.k.example.com\n    recordTTL: 300\n    recordType: A\n    targets:\n    - 172.18.0.17\n  - dnsName: ns2.k.example.com\n    recordTTL: 300\n    recordType: A\n    targets:\n    - 172.18.0.18\n</code></pre> <p>TTL Best Practices:</p> <ul> <li>Within parent zone: NS and A (glue) records should use the same TTL (e.g., 300 seconds or longer)</li> <li>Within child zone: NS and A records should use the same TTL (e.g., 60 seconds)</li> <li>Between zones: Parent and child zones MAY use different TTL values (RFC 7477)</li> <li>Parent delegation NS records typically use longer TTLs (1 day is common, minimum 1 hour recommended)</li> <li>Child authoritative NS records can use shorter TTLs for faster updates</li> <li>Using consistent TTLs within each zone ensures related records expire together</li> </ul> <p>Result: Verify delegation from parent zone:</p> <pre><code># Query parent zone's nameserver for delegation\ndig @&lt;parent-nameserver&gt; k.example.com NS +short\n</code></pre> <p>Expected output: <pre><code>ns1.k.example.com.\nns2.k.example.com.\n</code></pre></p>"},{"location":"dns-operator/docs/coredns/configuration/#security-considerations","title":"Security Considerations","text":"<p>Critical: Zone configuration DNSRecords have full control over the zone's nameserver records. Anyone who can create or modify DNSRecords targeting the zone apex with NS records can effectively control the entire zone's DNS resolution.</p>"},{"location":"dns-operator/docs/coredns/configuration/#access-control-best-practices","title":"Access Control Best Practices","text":"<ol> <li>Separate namespaces: Keep zone configuration DNSRecords in a dedicated, restricted namespace</li> <li>Strict RBAC: Only grant DNSRecord creation permissions to trusted administrators</li> <li>Namespace isolation: Application teams should only have DNSRecord permissions in their own namespaces</li> <li>Audit logging: Enable Kubernetes audit logging to track all DNSRecord changes</li> <li>Version control: Store zone configuration DNSRecord YAML in Git with review processes</li> </ol> <p>Example RBAC Configuration:</p> <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: dns-zone-config-admin\n  namespace: kuadrant-coredns\nrules:\n\n- apiGroups: [\"kuadrant.io\"]\n  resources: [\"dnsrecords\"]\n  verbs: [\"create\", \"update\", \"patch\", \"delete\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: dns-zone-config-admin-binding\n  namespace: kuadrant-coredns\nsubjects:\n- kind: User\n  name: dns-admin@example.com  # Only trusted administrators\n  apiGroup: rbac.authorization.k8s.io\nroleRef:\n  kind: Role\n  name: dns-zone-config-admin\n  apiGroup: rbac.authorization.k8s.io\n</code></pre>"},{"location":"dns-operator/docs/coredns/configuration/#attack-scenarios","title":"Attack Scenarios","text":"<ul> <li>Zone Hijacking: Attacker replaces NS records with malicious nameservers, redirecting all zone queries</li> <li>Denial of Service: Invalid NS records break DNS resolution for the entire zone</li> <li>DNS Poisoning: Malicious NS records direct queries to servers returning false data</li> </ul> <p>Mitigation: Strict RBAC, namespace isolation, audit logging, admission webhooks for validation.</p>"},{"location":"dns-operator/docs/coredns/configuration/#provider-secret-configuration","title":"Provider Secret Configuration","text":""},{"location":"dns-operator/docs/coredns/configuration/#what_2","title":"What","text":"<p>CoreDNS provider secrets enable DNS Operator to match DNSRecords to zones and coordinate with CoreDNS.</p> <p>Important: At least one provider secret is always required for CoreDNS integration. Setting up the zone itself requires non-delegating DNSRecords, which need a provider secret (see \"When Provider Secrets Are Needed\" below).</p>"},{"location":"dns-operator/docs/coredns/configuration/#when-provider-secrets-are-needed","title":"When Provider Secrets Are Needed","text":"<p>Provider secrets are only required for non-delegating DNSRecords:</p> <ul> <li>Non-delegating DNSRecords (without <code>delegate: true</code>): Provider secret required (via <code>providerRef</code> or default provider label)</li> <li>DNS Operator uses the secret for zone matching and endpoint validation</li> <li>DNS Operator adds the <code>kuadrant.io/coredns-zone-name</code> label to the DNSRecord</li> <li> <p>CoreDNS plugin watches and serves the labeled DNSRecord</p> </li> <li> <p>Delegating DNSRecords (<code>delegate: true</code>): Provider secret not needed</p> </li> <li>Managed by primary clusters that handle delegation</li> <li>Primary clusters add the label and CoreDNS serves the merged authoritative record</li> <li>Note: <code>delegate: true</code> and <code>providerRef</code> are mutually exclusive fields</li> </ul>"},{"location":"dns-operator/docs/coredns/configuration/#how_2","title":"How","text":""},{"location":"dns-operator/docs/coredns/configuration/#secret-structure","title":"Secret Structure","text":"<p>Secret Type: <code>kuadrant.io/coredns</code></p> <p>Required Fields: <pre><code>data:\n  ZONES: \"k.example.com,k2.example.com\"  # Required: Comma-separated zones managed by CoreDNS\n</code></pre></p> <p>Optional Fields: <pre><code>data:\n  NAMESERVERS: \"10.22.100.23:53,10.22.100.24:53\"  # Optional: For DNS groups active-groups TXT queries\n</code></pre></p> <p>Note: The <code>NAMESERVERS</code> field is used for DNS groups failover feature to query active groups TXT records. It is not related to CoreDNS integration itself.</p>"},{"location":"dns-operator/docs/coredns/configuration/#creating-a-provider-secret","title":"Creating a Provider Secret","text":"<pre><code>kubectl create secret generic dns-provider-credentials-coredns \\\n  --namespace=&lt;target-namespace&gt; \\\n  --type=kuadrant.io/coredns \\\n  --from-literal=ZONES=\"k.example.com\"\n</code></pre>"},{"location":"dns-operator/docs/coredns/configuration/#setting-as-default-provider","title":"Setting as Default Provider","text":"<pre><code>kubectl label secret dns-provider-credentials-coredns \\\n  -n &lt;namespace&gt; \\\n  kuadrant.io/default-provider=true\n</code></pre> <p>This allows non-delegating DNSRecords to use this secret automatically without specifying <code>providerRef</code>.</p>"},{"location":"dns-operator/docs/coredns/configuration/#result_2","title":"Result","text":""},{"location":"dns-operator/docs/coredns/configuration/#how-dns-operator-uses-provider-secrets","title":"How DNS Operator Uses Provider Secrets","text":"<p>When a non-delegating DNSRecord references a CoreDNS provider secret, DNS Operator performs:</p> <ol> <li>Zone Matching: Uses the <code>ZONES</code> field to find the appropriate zone for the DNSRecord's <code>rootHost</code></li> <li>Endpoint Validation: Validates the DNSRecord endpoints conform to CoreDNS requirements</li> <li>Label Application: Adds <code>kuadrant.io/coredns-zone-name: &lt;zone&gt;</code> label so CoreDNS plugin can discover the record</li> <li>No Record Pushing: Unlike cloud providers, DNS Operator does NOT push records to CoreDNS via API - the label triggers the watch</li> </ol>"},{"location":"dns-operator/docs/coredns/configuration/#zone-coordination","title":"Zone Coordination","text":"<p>Zones must be explicitly listed in both:</p> <ul> <li>The Corefile: Tells CoreDNS which zones to serve</li> <li>The provider secret <code>ZONES</code> field: Tells DNS Operator which zones are available for matching</li> </ul> <p>Verification:</p> <pre><code># Verify provider secret exists and has correct zones\nkubectl get secret dns-provider-credentials-coredns -n kuadrant-coredns \\\n  -o jsonpath='{.data.ZONES}' | base64 --decode\n</code></pre> <p>Expected output: <pre><code>k.example.com\n</code></pre></p>"},{"location":"dns-operator/docs/coredns/configuration/#dns-groups-configuration","title":"DNS Groups Configuration","text":""},{"location":"dns-operator/docs/coredns/configuration/#what_3","title":"What","text":"<p>DNS Groups provide active-passive failover across multiple clusters. Each DNS operator instance can belong to a group, and only the active groups process and publish DNS records. This enables controlled failover scenarios where you can switch traffic between cluster groups by updating an external TXT record.</p> <p>Key Concepts:</p> <ul> <li>Group Identifier: Set via <code>--group</code> flag or <code>GROUP</code> environment variable</li> <li>Active Groups TXT Record: External DNS TXT record containing the list of active groups</li> <li>Failover Mechanism: Only DNS operators in active groups reconcile and publish records</li> </ul>"},{"location":"dns-operator/docs/coredns/configuration/#how_3","title":"How","text":""},{"location":"dns-operator/docs/coredns/configuration/#step-1-configure-dns-operator-with-group","title":"Step 1: Configure DNS Operator with Group","text":"<p>When running the DNS operator, specify the group identifier:</p> <pre><code># Using make (local development)\nmake run GROUP=primary-us-east\n\n# Using environment variable\nexport GROUP=primary-us-east\nmake run\n</code></pre> <p>For deployed controllers, set the <code>GROUP</code> environment variable in the deployment:</p> <pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: dns-operator-controller-manager\n  namespace: dns-operator-system\nspec:\n  template:\n    spec:\n      containers:\n\n      - name: manager\n        env:\n        - name: GROUP\n          value: \"primary-us-east\"\n</code></pre>"},{"location":"dns-operator/docs/coredns/configuration/#step-2-configure-coredns-to-resolve-active-groups-txt-record","title":"Step 2: Configure CoreDNS to Resolve Active Groups TXT Record","text":"<p>When using CoreDNS locally with DNS Groups, you need to configure CoreDNS to forward the active-groups TXT record query to an external resolver.</p> <p>Note: If using parent zone delegation with BIND9, see the Zone Delegation Guide - Step 6 for the BIND9-specific variant of this configuration.</p> <p>Option A: Using a CNAME DNSRecord (Recommended)</p> <p>Create a DNSRecord with a CNAME that points to the external active-groups TXT record host. This approach is more Kubernetes-native and doesn't require Corefile modifications.</p> <pre><code>apiVersion: kuadrant.io/v1alpha1\nkind: DNSRecord\nmetadata:\n  name: kuadrant-active-groups-cname\n  namespace: kuadrant-coredns\n  labels:\n    kuadrant.io/coredns-zone-name: k.example.com\nspec:\n  rootHost: kuadrant-active-groups.k.example.com\n  providerRef:\n    name: dns-provider-credentials-coredns\n  endpoints:\n\n  - dnsName: kuadrant-active-groups.k.example.com\n    recordType: CNAME\n    recordTTL: 60\n    targets:\n    - kuadrant-active-groups.hcpapps.net\n</code></pre> <p>Replace:</p> <ul> <li><code>k.example.com</code> with your actual zone domain</li> <li><code>kuadrant-active-groups.hcpapps.net</code> with your external TXT record host</li> </ul> <p>Key Points:</p> <ul> <li>The <code>kuadrant.io/coredns-zone-name</code> label ensures CoreDNS picks up this record</li> <li>The CNAME allows CoreDNS to resolve the active-groups query without Corefile changes</li> <li>No CoreDNS restart required</li> </ul> <p>Option B: Using Corefile Rewrite and Forward Directives</p> <p>Alternatively, you can modify the Corefile to rewrite and forward the active-groups query. Note: This approach requires modifying the Corefile and restarting CoreDNS.</p> <p>The Corefile is located in the <code>kuadrant-coredns</code> ConfigMap in the <code>kuadrant-coredns</code> namespace.</p> <p>Add the following configuration before the <code>ready</code> statement:</p> <pre><code>k.example.com {\n    # Forward active groups TXT record query to external resolver\n    rewrite name regex kuadrant-active-groups\\.(.*)k.example.com kuadrant-active-groups.hcpapps.net\n    forward kuadrant-active-groups.hcpapps.net /etc/resolv.conf\n\n    # ... other plugins ...\n    ready\n    kuadrant\n}\n</code></pre> <p>Replace:</p> <ul> <li><code>k.example.com</code> with your actual zone domain</li> <li><code>kuadrant-active-groups.hcpapps.net</code> with your external TXT record host</li> </ul> <p>After modifying the Corefile, restart CoreDNS: <pre><code>kubectl -n kuadrant-coredns rollout restart deployment kuadrant-coredns\n</code></pre></p> <p>Customizing External Groups Host (local setup):</p> <p>When setting up the local environment, you can customize the external groups host:</p> <pre><code>make local-setup EXTERNAL_GROUPS_HOST=&lt;your-external-host&gt;\n</code></pre> <p>Default: <code>kuadrant-active-groups.hcpapps.net</code></p>"},{"location":"dns-operator/docs/coredns/configuration/#step-3-create-external-active-groups-txt-record","title":"Step 3: Create External Active Groups TXT Record","text":"<p>Recommended: Use the DNS CLI (requires <code>make build-cli</code>):</p> <pre><code># Build the CLI (run once)\nmake build-cli\n\n# Add active group to external DNS provider\nkubectl-kuadrant_dns add-active-group primary-us-east \\\n  --providerRef &lt;namespace&gt;/&lt;secret-name&gt; \\\n  --domain &lt;external-domain&gt;\n\n# Add another group to the same domain\nkubectl-kuadrant_dns add-active-group primary-eu-west \\\n  --providerRef &lt;namespace&gt;/&lt;secret-name&gt; \\\n  --domain &lt;external-domain&gt;\n</code></pre> <p>Where:</p> <ul> <li><code>&lt;secret-name&gt;</code> is your provider secret (AWS, GCP, or Azure)</li> <li><code>&lt;external-domain&gt;</code> is the domain hosting the TXT record (e.g., <code>hcpapps.net</code>)</li> </ul> <p>The CLI automatically:</p> <ul> <li>Creates the TXT record in the correct format (<code>version=1;groups=...</code>)</li> <li>Adds groups to existing records (doesn't overwrite)</li> <li>Handles multiple zones if they exist</li> <li>Prompts for confirmation before making changes</li> </ul> <p>Verify the groups:</p> <pre><code>kubectl-kuadrant_dns get-active-groups \\\n  --providerRef &lt;namespace&gt;/&lt;secret-name&gt; \\\n  --domain &lt;external-domain&gt;\n</code></pre> Alternative: Using cloud provider CLIs directly  **TXT Record Format**: <pre><code>version=1;groups=GROUP1&amp;&amp;GROUP2\n</code></pre>  **Example for AWS Route53**:  <pre><code>aws route53 change-resource-record-sets --hosted-zone-id &lt;zone-id&gt; --change-batch '{\n  \"Changes\": [{\n    \"Action\": \"UPSERT\",\n    \"ResourceRecordSet\": {\n      \"Name\": \"kuadrant-active-groups.hcpapps.net\",\n      \"Type\": \"TXT\",\n      \"TTL\": 60,\n      \"ResourceRecords\": [{\"Value\": \"\\\"version=1;groups=primary-us-east&amp;&amp;primary-eu-west\\\"\"}]\n    }\n  }]\n}'\n</code></pre>  **Format Details**:  - `version=1` - Protocol version - `groups=` - List of active groups separated by `&amp;&amp;` - Groups listed here will actively reconcile DNS records - Groups not listed will be passive (not reconciling)"},{"location":"dns-operator/docs/coredns/configuration/#result_3","title":"Result","text":""},{"location":"dns-operator/docs/coredns/configuration/#verify-groups-resolution","title":"Verify Groups Resolution","text":"<p>Once configured, verify CoreDNS can resolve the active groups TXT record:</p> <pre><code># Get CoreDNS nameserver IP\nNS=\"$(kubectl get secrets -n dnstest dns-provider-credentials-coredns \\\n  -o jsonpath='{.data.NAMESERVERS}' | base64 -d | cut -f1 -d':')\"\n\n# Query the active groups TXT record\ndig @${NS} kuadrant-active-groups.k.example.com TXT +short\n</code></pre> <p>Expected output: <pre><code>\"version=1;groups=primary-us-east&amp;&amp;primary-eu-west\"\n</code></pre></p>"},{"location":"dns-operator/docs/coredns/configuration/#verify-controller-group-assignment","title":"Verify Controller Group Assignment","text":"<p>Check the DNS operator logs to see the current group and active groups:</p> <pre><code>kubectl logs -n dns-operator-system deployment/dns-operator-controller-manager | \\\n  grep -E \"currentGroup|activeGroups\"\n</code></pre> <p>Expected log output: <pre><code>{\n  \"currentGroup\": \"primary-us-east\",\n  \"activeGroups\": [\"primary-us-east\", \"primary-eu-west\"],\n  \"msg\": \"Processing DNSRecord\"\n}\n</code></pre></p>"},{"location":"dns-operator/docs/coredns/configuration/#additional-resources_1","title":"Additional Resources","text":"<p>For procedural guides:</p> <ul> <li>Exercising DNS Failover via Groups - Step-by-step failover exercise and use cases</li> <li>Migrating Existing Clusters to Use Groups - Migration from non-groups setup</li> </ul>"},{"location":"dns-operator/docs/coredns/configuration/#geoip-database-configuration","title":"GeoIP Database Configuration","text":""},{"location":"dns-operator/docs/coredns/configuration/#what_4","title":"What","text":"<p>GeoIP databases enable geographic routing by mapping client IP addresses to geographic locations. The Kuadrant CoreDNS plugin uses this data to return region-specific DNS responses.</p> <p>Key Concepts:</p> <ul> <li>Database Format: <code>.mmdb</code> (MaxMind database format)</li> <li>Update Frequency: Monthly updates recommended for current GeoIP data</li> <li>Demo Database: Embedded in the image with localhost/Kind cluster subnets</li> <li>MaxMind Database: Comprehensive global IP-to-location mapping</li> <li>EDNS Client Subnet: The CoreDNS Service uses <code>externalTrafficPolicy: Cluster</code> (the default), which means kube-proxy replaces the original client IP with an internal cluster IP. Without correction, CoreDNS would geo-locate based on the cluster node IP rather than the client's actual location. The <code>geoip</code> plugin's <code>edns-subnet</code> directive solves this by reading the EDNS Client Subnet (ECS) option that recursive resolvers include in DNS queries. Most major resolvers (Google Public DNS, Cloudflare, OpenDNS, ISP resolvers) send ECS, so GeoIP routing works correctly for the vast majority of traffic. Queries from resolvers that omit ECS fall back to geo-locating based on the cluster node IP.</li> </ul>"},{"location":"dns-operator/docs/coredns/configuration/#how_4","title":"How","text":""},{"location":"dns-operator/docs/coredns/configuration/#using-the-embedded-demo-database","title":"Using the Embedded Demo Database","text":"<p>The Kuadrant CoreDNS image includes a demo database (<code>GeoLite2-City-demo.mmdb</code>) with:</p> <ul> <li>Localhost and Kind cluster subnets mapped to IE and US locales</li> <li>No additional setup required</li> </ul> <p>Corefile Configuration: <pre><code>k.example.com {\n    geoip GeoLite2-City-demo.mmdb {\n        edns-subnet\n    }\n    metadata\n    kuadrant\n}\n</code></pre></p> <p>Demo Database Mappings: See the Local Development Guide GEO section for complete subnet-to-locale mappings.</p>"},{"location":"dns-operator/docs/coredns/configuration/#using-maxmind-geoip-database","title":"Using MaxMind GeoIP Database","text":"<p>For global IP-to-location mapping:</p> <ul> <li>MaxMind GeoLite2 (free tier) or commercial database</li> <li>Free tier: https://dev.maxmind.com/geoip/geolite2-free-geolocation-data</li> <li>Requires MaxMind account and license key</li> </ul> <p>Step 1: Obtain Database:</p> <ul> <li>Sign up for MaxMind account</li> <li>Download GeoLite2-City database (<code>.mmdb</code> format)</li> </ul> <p>Step 2: Create ConfigMap: <pre><code>kubectl create configmap geoip-db \\\n  --from-file=GeoLite2-City.mmdb \\\n  -n kuadrant-coredns\n</code></pre></p> <p>Step 3: Mount in CoreDNS Deployment:</p> <p>Update deployment to mount the database: <pre><code>volumeMounts:\n\n- name: geoip-db\n  mountPath: /etc/geoip\nvolumes:\n- name: geoip-db\n  configMap:\n    name: geoip-db\n</code></pre></p> <p>Step 4: Update Corefile: <pre><code>k.example.com {\n    geoip /etc/geoip/GeoLite2-City.mmdb {\n        edns-subnet\n    }\n    metadata\n    kuadrant\n}\n</code></pre></p> <p>Database Updates:</p> <p>MaxMind releases monthly database updates. Set up automated updates:</p> <pre><code># Download new database\nwget https://download.maxmind.com/app/geoip_download?...\n\n# Update ConfigMap\nkubectl create configmap geoip-db \\\n  --from-file=GeoLite2-City.mmdb \\\n  -n kuadrant-coredns \\\n  --dry-run=client -o yaml | kubectl apply -f -\n\n# Restart CoreDNS\nkubectl rollout restart deployment/kuadrant-coredns -n kuadrant-coredns\n</code></pre>"},{"location":"dns-operator/docs/coredns/configuration/#result_4","title":"Result","text":""},{"location":"dns-operator/docs/coredns/configuration/#testing-geographic-routing","title":"Testing Geographic Routing","text":"<p>When running CoreDNS locally (from terminal with <code>make run</code>):</p> <pre><code># Query from IE locale\ndig @127.0.0.1 api.k.example.com -p 1053 +subnet=127.0.100.0/24\n\n# Query from US locale\ndig @127.0.0.1 api.k.example.com -p 1053 +subnet=127.0.200.0/24\n</code></pre> <p>When running CoreDNS in Kind cluster:</p> <pre><code># Get CoreDNS IP\nNS1=\"$(kubectl get service/kuadrant-coredns -n kuadrant-coredns \\\n  -o jsonpath='{.status.loadBalancer.ingress[0].ip}')\"\n\n# Simulate query from Ireland\ndig @${NS1} api.k.example.com +subnet=127.0.100.0/24\n\n# Simulate query from United States\ndig @${NS1} api.k.example.com +subnet=127.0.200.0/24\n</code></pre> <p>Expected Behavior: Queries with different geographic contexts return different IP addresses based on the geo-code configured in DNSRecord endpoints.</p>"},{"location":"dns-operator/docs/coredns/configuration/#advanced-routing-strategies","title":"Advanced Routing Strategies","text":""},{"location":"dns-operator/docs/coredns/configuration/#what_5","title":"What","text":"<p>The Kuadrant CoreDNS plugin supports advanced routing strategies to distribute traffic across endpoints based on geographic location and weighted distribution.</p> <p>Routing Types:</p> <ul> <li>Geographic (Geo) Routing: Routes queries to geographically appropriate endpoints</li> <li>Weighted Routing: Distributes traffic across endpoints based on assigned weights</li> <li>Combined Routing: First applies GEO filter, then weighted selection within the matched region</li> </ul>"},{"location":"dns-operator/docs/coredns/configuration/#how_5","title":"How","text":""},{"location":"dns-operator/docs/coredns/configuration/#geographic-routing","title":"Geographic Routing","text":"<p>Configuration: Set <code>geo-code</code> in DNSRecord <code>providerSpecific</code> fields.</p> <p>Example DNSRecord: <pre><code>apiVersion: kuadrant.io/v1alpha1\nkind: DNSRecord\nmetadata:\n  name: geo-example\n  labels:\n    kuadrant.io/coredns-zone-name: k.example.com\nspec:\n  rootHost: api.k.example.com\n  endpoints:\n\n    - dnsName: api.k.example.com\n      recordType: A\n      providerSpecific:\n        - name: geo-code\n          value: GEO-EU\n      recordTTL: 300\n      setIdentifier: GEO-EU\n      targets:\n        - 1.1.1.1\n    - dnsName: api.k.example.com\n      recordType: A\n      providerSpecific:\n        - name: geo-code\n          value: GEO-US\n      recordTTL: 300\n      setIdentifier: GEO-US\n      targets:\n        - 2.2.2.2\n</code></pre></p> <p>Required Corefile Configuration: <pre><code>k.example.com {\n    geoip GeoLite2-City-demo.mmdb {\n        edns-subnet\n    }\n    metadata\n    kuadrant\n}\n</code></pre></p>"},{"location":"dns-operator/docs/coredns/configuration/#weighted-routing","title":"Weighted Routing","text":"<p>How It Works:</p> <ul> <li>Distributes traffic across endpoints based on assigned weights</li> <li>Uses weighted random selection algorithm</li> <li>Useful for canary deployments and gradual rollouts</li> </ul> <p>Algorithm: The plugin builds a list of available records and applies a weighting algorithm. Selection is based on a random number between 0 and the sum of all weights.</p> <p>Configuration: Set <code>weight</code> in DNSRecord <code>providerSpecific</code> fields.</p> <p>Example DNSRecord: <pre><code>apiVersion: kuadrant.io/v1alpha1\nkind: DNSRecord\nmetadata:\n  name: weighted-example\n  labels:\n    kuadrant.io/coredns-zone-name: k.example.com\nspec:\n  rootHost: api.k.example.com\n  endpoints:\n\n    - dnsName: api.k.example.com\n      recordType: A\n      recordTTL: 60\n      providerSpecific:\n        - name: weight\n          value: \"70\"\n      setIdentifier: cluster-1\n      targets:\n        - 1.1.1.1\n    - dnsName: api.k.example.com\n      recordType: A\n      recordTTL: 60\n      providerSpecific:\n        - name: weight\n          value: \"30\"\n      setIdentifier: cluster-2\n      targets:\n        - 2.2.2.2\n</code></pre></p> <p>Behavior: With the above configuration, approximately 70% of queries return <code>1.1.1.1</code> and 30% return <code>2.2.2.2</code>.</p>"},{"location":"dns-operator/docs/coredns/configuration/#combined-routing","title":"Combined Routing","text":"<p>How It Works:</p> <ol> <li>First applies GEO filter to select location-appropriate endpoints</li> <li>Then applies weighting algorithm if multiple endpoints exist in that GEO</li> </ol> <p>Use Case: Multiple clusters in the same geographic region with different capacity.</p>"},{"location":"dns-operator/docs/coredns/configuration/#result_5","title":"Result","text":""},{"location":"dns-operator/docs/coredns/configuration/#testing-geo-routing","title":"Testing Geo Routing","text":"<pre><code># Get CoreDNS IP\nNS=\"$(kubectl get service/kuadrant-coredns -n kuadrant-coredns \\\n  -o jsonpath='{.status.loadBalancer.ingress[0].ip}')\"\n\n# Simulate query from IE (using demo database)\ndig @${NS} api.k.example.com +subnet=127.0.100.0/24 +short\n\n# Simulate query from US\ndig @${NS} api.k.example.com +subnet=127.0.200.0/24 +short\n</code></pre> <p>Expected output: <pre><code># From IE subnet\n1.1.1.1\n\n# From US subnet\n2.2.2.2\n</code></pre></p> <p>Different geographic contexts return different IP addresses based on geo-code configuration.</p>"},{"location":"dns-operator/docs/coredns/configuration/#additional-resources_2","title":"Additional Resources","text":"<p>For comprehensive technical details and examples, see:</p> <ul> <li>Kuadrant CoreDNS Plugin Documentation - Complete routing algorithm details and examples</li> <li>CoreDNS Official Documentation - General CoreDNS plugin options</li> </ul>"},{"location":"dns-operator/docs/coredns/configuration/#monitoring-and-observability","title":"Monitoring and Observability","text":""},{"location":"dns-operator/docs/coredns/configuration/#what_6","title":"What","text":"<p>CoreDNS metrics enable monitoring of DNS query performance, error rates, and operational health. The Prometheus plugin exposes metrics for collection by Prometheus/Grafana.</p> <p>Key Metrics:</p> <ul> <li>Query rate (queries per second)</li> <li>Query latency (response time distribution)</li> <li>Error rate (NXDOMAIN, SERVFAIL, etc.)</li> <li>Cache hit ratio</li> <li>Plugin performance (per-plugin execution time)</li> </ul>"},{"location":"dns-operator/docs/coredns/configuration/#how_6","title":"How","text":""},{"location":"dns-operator/docs/coredns/configuration/#enable-prometheus-metrics","title":"Enable Prometheus Metrics","text":"<p>Add the <code>prometheus</code> directive to the Corefile:</p> <pre><code>k.example.com {\n    # ... other plugins ...\n    prometheus 0.0.0.0:9153\n}\n</code></pre> <p>Configuration Details:</p> <ul> <li>Exposes metrics on port 9153</li> <li>Must be added to each zone block</li> <li>Metrics available at <code>/metrics</code> endpoint</li> </ul>"},{"location":"dns-operator/docs/coredns/configuration/#servicemonitor-integration","title":"ServiceMonitor Integration","text":"<p>Default Configuration: When deploying CoreDNS using the DNS Operator's kustomize configuration (<code>config/coredns/kustomization.yaml</code>), Prometheus monitoring is already enabled by default:</p> <pre><code>prometheus:\n  service:\n    enabled: true\n  monitor:\n    enabled: true\n    namespace: kuadrant-coredns\n</code></pre> <p>This automatically creates:</p> <ul> <li>ServiceMonitor resource for Prometheus Operator scraping</li> <li>Metrics service on port 9153</li> </ul> <p>Customizing Configuration:</p> <p>If you need to modify the default settings (e.g., change namespace, add labels, or disable monitoring), edit <code>config/coredns/kustomization.yaml</code> in the <code>valuesInline</code> section.</p>"},{"location":"dns-operator/docs/coredns/configuration/#grafana-dashboards","title":"Grafana Dashboards","text":"<p>Development Setup: <pre><code>make install-observability\n</code></pre></p> <p>Access dashboards: <pre><code>kubectl -n monitoring port-forward service/grafana 3000:3000\n</code></pre></p> <p>Open http://127.0.0.1:3000</p> <p>Default Credentials: admin/admin</p>"},{"location":"dns-operator/docs/coredns/configuration/#result_6","title":"Result","text":"<p>Verify Metrics Endpoint:</p> <pre><code># Get CoreDNS pod\nCOREDNS_POD=\"$(kubectl get pods -n kuadrant-coredns \\\n  -l app.kubernetes.io/name=coredns \\\n  -o jsonpath='{.items[0].metadata.name}')\"\n\n# Port-forward to metrics endpoint\nkubectl port-forward -n kuadrant-coredns ${COREDNS_POD} 9153:9153\n\n# Query metrics\ncurl http://localhost:9153/metrics\n</code></pre> <p>Expected output (sample): <pre><code># HELP coredns_dns_request_duration_seconds Histogram of the time (in seconds) each request took.\n# TYPE coredns_dns_request_duration_seconds histogram\ncoredns_dns_request_duration_seconds_bucket{server=\"dns://:53\",zone=\"k.example.com.\",le=\"0.00025\"} 45\ncoredns_dns_request_duration_seconds_bucket{server=\"dns://:53\",zone=\"k.example.com.\",le=\"0.0005\"} 87\n...\n\n# HELP coredns_dns_requests_total Counter of DNS requests made per zone, protocol and family.\n# TYPE coredns_dns_requests_total counter\ncoredns_dns_requests_total{family=\"1\",proto=\"udp\",server=\"dns://:53\",zone=\"k.example.com.\"} 342\n</code></pre></p> <p>Grafana Dashboards will visualize:</p> <ul> <li>Query rate over time</li> <li>Latency percentiles (p50, p95, p99)</li> <li>Error rate trends</li> <li>Cache effectiveness</li> </ul>"},{"location":"dns-operator/docs/coredns/configuration/#logging-configuration","title":"Logging Configuration","text":""},{"location":"dns-operator/docs/coredns/configuration/#what_7","title":"What","text":"<p>CoreDNS logging provides visibility into DNS query processing, errors, and plugin execution. Logs are output to stdout/stderr for container log aggregation.</p> <p>Log Directives:</p> <ul> <li><code>debug</code> - Most verbose, includes all plugin execution details</li> <li><code>errors</code> - Errors and failures only</li> <li><code>log</code> - Query logging, logs each DNS query received</li> </ul>"},{"location":"dns-operator/docs/coredns/configuration/#how_7","title":"How","text":"<p>Enable logging directives in the Corefile:</p> <pre><code>k.example.com {\n    debug      # Enable debug logging\n    errors     # Log errors\n    log        # Enable query logging\n    # ... other plugins ...\n}\n</code></pre>"},{"location":"dns-operator/docs/coredns/configuration/#result_7","title":"Result","text":""},{"location":"dns-operator/docs/coredns/configuration/#viewing-logs","title":"Viewing Logs","text":"<pre><code># Stream CoreDNS logs\nkubectl logs -f deployments/kuadrant-coredns -n kuadrant-coredns\n\n# Get recent logs\nkubectl logs --tail=100 deployments/kuadrant-coredns -n kuadrant-coredns\n</code></pre> <p>Expected output (sample with query logging): <pre><code>[INFO] plugin/reload: Running configuration SHA512 = ...\n[INFO] 127.0.0.1:54321 - 12345 \"A IN api.k.example.com. udp 35 false 512\" NOERROR qr,aa,rd 98 0.001234567s\n[INFO] 127.0.0.1:54322 - 12346 \"NS IN k.example.com. udp 30 false 512\" NOERROR qr,aa,rd 156 0.000987654s\n</code></pre></p> <p>Log Integration: Logs are structured for aggregation by cluster logging solutions (FluentD, Loki, etc.).</p>"},{"location":"dns-operator/docs/coredns/configuration/#additional-configuration-topics","title":"Additional Configuration Topics","text":""},{"location":"dns-operator/docs/coredns/configuration/#parent-zone-delegation-setup","title":"Parent Zone Delegation Setup","text":"<p>For step-by-step instructions on setting up parent zone delegation with CoreDNS:</p> <ul> <li>Local Development: BIND9 setup for testing delegation scenarios</li> <li>Dynamic DNS Updates: Using nsupdate for parent zone configuration</li> <li>In-Cluster DNS Forwarding: Enabling pod-based DNS resolution</li> <li>DNS Groups with BIND9: Active-groups TXT record resolution variant</li> </ul> <p>See Zone Delegation Guide for comprehensive instructions.</p>"},{"location":"dns-operator/docs/coredns/configuration/#custom-corefile-modifications","title":"Custom Corefile Modifications","text":"<p>For general CoreDNS plugin options not specific to Kuadrant integration:</p> <ul> <li>Caching: Configure DNS response caching</li> <li>Forwarding: Forward queries to upstream DNS servers</li> <li>Rewrite Rules: Modify queries or responses</li> <li>Secondary Zones: Configure zone transfers</li> </ul> <p>See CoreDNS Official Documentation for details.</p>"},{"location":"dns-operator/docs/coredns/configuration/#multi-cluster-configuration","title":"Multi-Cluster Configuration","text":"<p>For multi-cluster deployments using delegation:</p> <ul> <li>Primary Clusters: Require default provider secret and multicluster kubeconfig secrets</li> <li>Secondary Clusters: Can optionally configure provider secrets for non-delegating DNSRecords</li> </ul> <p>See DNS Record Delegation for complete multi-cluster configuration details.</p>"},{"location":"dns-operator/docs/coredns/coredns-integration/","title":"CoreDNS Integration Guide","text":""},{"location":"dns-operator/docs/coredns/coredns-integration/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Overview</li> <li>Purpose and Use Cases</li> <li>Infrastructure Requirements</li> <li>Deploying CoreDNS</li> <li>Configuring CoreDNS</li> <li>Testing the Deployment</li> <li>Advanced Configuration: Configuring an Edge Server</li> <li>Appendix</li> </ol>"},{"location":"dns-operator/docs/coredns/coredns-integration/#overview","title":"Overview","text":"<p>CoreDNS integration enables DNS Operator to manage DNS records using a self-hosted CoreDNS instance running in Kubernetes, providing an alternative to cloud-managed DNS services (AWS Route53, Google Cloud DNS, Azure DNS).</p> <p>CoreDNS integration can be removed by deleting the CoreDNS deployment and switching DNSPolicies to use a different DNS provider. To migrate to a different provider, delete existing DNSRecords and recreate them with the new provider secret reference. No data is permanently locked into CoreDNS.</p>"},{"location":"dns-operator/docs/coredns/coredns-integration/#is-this-for-you","title":"Is This for You?","text":"<p>Consider CoreDNS integration if you:</p> <ul> <li>Need to avoid dependency on external cloud DNS services</li> <li>Operate in environments with no internet access or restricted network connectivity</li> <li>Have regulatory or compliance requirements mandating self-hosted infrastructure</li> <li>Want to delegate specific DNS zones from existing DNS servers (BIND, Unbound, or cloud DNS) to Kubernetes-managed CoreDNS</li> <li>Require consistent DNS management across hybrid or multi-cloud environments</li> <li>Need to reduce DNS operational costs by eliminating per-query charges</li> </ul> <p>Cloud DNS providers might be a simpler choice if you are running exclusively in cloud environments and none of these scenarios apply.</p> <p>Audience: Platform engineers, DevOps engineers, and system administrators deploying DNS infrastructure.</p> <p>Kuadrant-operator documentation: For Kuadrant-specific documentation including DNS delegation, DNSPolicy user guides, and deployment walkthroughs, see the kuadrant-operator user guides.</p>"},{"location":"dns-operator/docs/coredns/coredns-integration/#purpose-and-use-cases","title":"Purpose and Use Cases","text":"<p>Using CoreDNS integration, you can self-manage your DNS infrastructure in Kubernetes environments. Organizations choose CoreDNS integration to maintain full control over their DNS records, meet regulatory compliance requirements, avoid cloud provider dependencies, or integrate with existing DNS infrastructure through zone delegation.</p>"},{"location":"dns-operator/docs/coredns/coredns-integration/#how-it-works","title":"How It Works","text":"<p>Unlike cloud DNS providers where a DNS Operator \"pushes\" records through API calls, CoreDNS integration works through a Kubernetes-native label-based watch mechanism:</p> <ol> <li>DNS Operator processes DNSRecords</li> <li>DNS Operator adds a label <code>kuadrant.io/coredns-zone-name: &lt;zone&gt;</code> to processed DNSRecords</li> <li>CoreDNS plugin watches for DNSRecords with this label via Kubernetes API</li> <li>CoreDNS serves the records it discovers through the watch</li> </ol> <p>The label is what activates CoreDNS integration, not a provider secret or API call. This design allows CoreDNS to remain a passive observer of Kubernetes resources while DNS Operator handles the orchestration logic.</p>"},{"location":"dns-operator/docs/coredns/coredns-integration/#primary-use-cases","title":"Primary Use Cases","text":""},{"location":"dns-operator/docs/coredns/coredns-integration/#self-hosted-infrastructure","title":"Self-Hosted Infrastructure","text":"<p>Organizations that require full control over their DNS infrastructure without relying on external cloud services.</p> <p>Scenarios:</p> <ul> <li>On-Premise Deployments: Running Kubernetes clusters in your own data centers or colocation facilities</li> <li>Cost Optimization: Eliminating per-query or per-zone costs from cloud DNS services</li> <li>Complete Ownership: Maintaining full control over DNS data and infrastructure</li> </ul> <p>Key Benefits:</p> <ul> <li>Complete ownership and control of DNS records</li> <li>No external service dependencies</li> <li>Reduced latency for local queries</li> <li>Integration with existing data center infrastructure</li> <li>Lower operational costs for DNS services</li> </ul>"},{"location":"dns-operator/docs/coredns/coredns-integration/#restricted-and-isolated-environments","title":"Restricted and Isolated Environments","text":"<p>Deployments where external connectivity is limited, prohibited, or subject to strict compliance requirements.</p> <p>Scenarios:</p> <ul> <li>Air-Gapped Networks: Completely disconnected environments with no external internet access</li> <li>Regulatory Compliance: Government, defense, financial, or healthcare sectors with mandatory network isolation</li> <li>Data Sovereignty: Requirements to keep DNS data within specific geographic or organizational boundaries</li> <li>Security-Critical Systems: Highly sensitive environments requiring complete audit trails and access control</li> <li>Development/Test Isolation: Isolated environments that mirror production security constraints</li> </ul> <p>Key Benefits:</p> <ul> <li>Fully self-contained DNS infrastructure</li> <li>Meets security and compliance mandates</li> <li>No external network dependencies</li> <li>Complete audit trails within controlled boundaries</li> <li>Reduced attack surface by eliminating external services</li> </ul>"},{"location":"dns-operator/docs/coredns/coredns-integration/#zone-delegation-from-edge-dns-servers","title":"Zone Delegation from Edge DNS Servers","text":"<p>Integration with existing DNS infrastructure by delegating specific zones to CoreDNS while maintaining authoritative control at the edge.</p> <p>Scenario:</p> <ul> <li>Edge DNS Integration: Delegate application-specific subdomains (e.g., <code>apps.example.com</code>) from your authoritative DNS servers (BIND, Unbound, or cloud DNS providers like Route53, Cloud DNS, Azure DNS) to CoreDNS</li> </ul> <p>Key Benefits:</p> <ul> <li>Seamless integration with existing DNS infrastructure (self-hosted or cloud-based)</li> <li>Preserve existing DNS operations and processes</li> <li>Maintain edge DNS security controls and governance</li> <li>Flexible deployment without replacing entire DNS infrastructure</li> </ul>"},{"location":"dns-operator/docs/coredns/coredns-integration/#infrastructure-requirements","title":"Infrastructure Requirements","text":""},{"location":"dns-operator/docs/coredns/coredns-integration/#coredns-infrastructure","title":"CoreDNS Infrastructure","text":"<p>For CoreDNS infrastructure requirements (resource limits, storage, networking, etc.), see the CoreDNS scaling guide.</p>"},{"location":"dns-operator/docs/coredns/coredns-integration/#dns-operator-integration-requirements","title":"DNS Operator Integration Requirements","text":"<p>Minimum Kubernetes Version: 1.19.0 or higher</p> <p>Cluster Architecture:</p> <ul> <li>Single Cluster: One Kubernetes cluster running CoreDNS and DNS Operator</li> <li>Multi-Cluster: Multiple clusters with different roles:</li> <li>Primary Clusters: Run CoreDNS instance and DNS Operator in primary mode</li> <li>Secondary Clusters: Run DNS Operator only in secondary mode (no CoreDNS deployment needed)</li> </ul> <p>RBAC Permissions:</p> <p>CoreDNS pods require Kubernetes API permissions to watch DNSRecord resources:</p> <ul> <li>DNSRecord resources (<code>kuadrant.io</code> API group): <code>get</code>, <code>list</code>, <code>watch</code> permissions</li> <li>Scope: Configured with the <code>WATCH_NAMESPACES</code> environment variable (empty = all namespaces, which is the default)</li> </ul>"},{"location":"dns-operator/docs/coredns/coredns-integration/#multi-cluster-requirements","title":"Multi-Cluster Requirements","text":"<p>For multi-cluster delegation scenarios:</p> <p>Network Connectivity:</p> <p>Primary clusters must have network connectivity to secondary cluster Kubernetes APIs. Required for synchronizing DNSRecord status across clusters</p> <p>Cluster Interconnection Secrets:</p> <p>Primary clusters require kubeconfig interconnection secrets for all other clusters (primary and secondary):</p> <ul> <li>The secret must be created using the <code>kubectl-kuadrant_dns add-cluster-secret</code> command (from the <code>dns-operator</code> CLI, which must be installed separately - see CLI documentation)</li> <li>Labeled with <code>kuadrant.io/multicluster-kubeconfig=true</code></li> <li>Stored in <code>dns-operator-system</code> namespace</li> </ul> <p>DNS Operator Configuration:</p> <ul> <li>Primary clusters: <code>--delegation-role=primary</code> (default)</li> <li>Secondary clusters: <code>--delegation-role=secondary</code></li> </ul> <p>For complete details, see the DNS Record Delegation documentation in the kuadrant-operator repository</p>"},{"location":"dns-operator/docs/coredns/coredns-integration/#deploying-coredns","title":"Deploying CoreDNS","text":"<p>When DNS Operator is using CoreDNS, it can do so in both single-cluster and multi-cluster settings. However, for multi-cluster environments, the Delegation feature is required. Cloud DNS providers can operate in multi-cluster mode with or without delegation, but CoreDNS specifically requires delegation for multi-cluster coordination. See the DNS Record Delegation documentation in the kuadrant-operator repository for complete details.</p>"},{"location":"dns-operator/docs/coredns/coredns-integration/#deployment-architectures","title":"Deployment Architectures","text":"<p>Single Cluster Deployment:</p> <p>A standalone deployment where all CoreDNS components run in a single Kubernetes cluster. Suitable for development, testing, or standalone deployments. No delegation required.</p> <p>What Gets Deployed:</p> <ul> <li>CoreDNS instance (with Kuadrant plugin) - serves DNS queries</li> <li>DNS Operator - reconciles DNSRecords</li> </ul> <p>Multi-Cluster Deployment:</p> <p>Multi-cluster deployments use the delegation feature to coordinate DNS records across clusters. For complete details on how delegation works, see the DNS Record Delegation documentation in the kuadrant-operator repository.</p> <p>What Gets Deployed:</p> <ul> <li>Primary Clusters:</li> <li>CoreDNS instance - serves DNS queries</li> <li> <p>DNS Operator in primary mode (<code>--delegation-role=primary</code>)</p> </li> <li> <p>Secondary Clusters:</p> </li> <li>DNS Operator only in secondary mode (<code>--delegation-role=secondary</code>)</li> <li>No CoreDNS deployment needed</li> </ul>"},{"location":"dns-operator/docs/coredns/coredns-integration/#deployment-guides","title":"Deployment Guides","text":"<p>Follow the step-by-step deployment guides for your scenario:</p> <p>Local Environment:</p> <ul> <li>Single Cluster Setup - Deploy to a local cluster for development and testing</li> <li>Multi-Cluster Setup - Deploy to multiple local clusters with delegation</li> </ul>"},{"location":"dns-operator/docs/coredns/coredns-integration/#next-steps","title":"Next Steps","text":"<p>After deploying CoreDNS:</p> <ul> <li>For configuration details (Corefile, provider secrets, monitoring, logging, etc.), see Configuring CoreDNS</li> <li>For verification procedures, see Testing the Deployment</li> </ul>"},{"location":"dns-operator/docs/coredns/coredns-integration/#configuring-coredns","title":"Configuring CoreDNS","text":"<p>CoreDNS configuration consists of two main components:</p> <ol> <li>Corefile: Defines zones, plugins, and DNS server behavior</li> <li>Provider Secrets: Enable DNS Operator to coordinate zone matching with CoreDNS</li> </ol>"},{"location":"dns-operator/docs/coredns/coredns-integration/#core-configuration","title":"Core Configuration","text":"<p>Corefile:</p> <ul> <li>Zone definitions matching the zones CoreDNS serves with plugin directives and configuration</li> <li>Essential plugin: <code>kuadrant</code></li> </ul> <p>Provider Secrets:</p> <ul> <li>Non-delegating DNSRecords require a CoreDNS provider secret reference (with the <code>providerRef</code> or default provider label) for DNS Operator to add the zone label</li> <li>Delegating DNSRecords do not require provider secrets themselves, but they cause authoritative DNSRecords to be created on primary clusters, which do require provider secrets</li> </ul> <p>Zone Coordination: Zones must be listed in both the Corefile and provider secret <code>ZONES</code> fields to ensure that the zones CoreDNS and DNS Operator manage are specified.</p>"},{"location":"dns-operator/docs/coredns/coredns-integration/#optional-configuration","title":"Optional Configuration","text":"<ul> <li>Monitoring: Prometheus metrics, Grafana dashboards</li> <li>Logging: Debug, error, and query logging</li> </ul>"},{"location":"dns-operator/docs/coredns/coredns-integration/#configuration-reference","title":"Configuration Reference","text":"<p>For complete technical details, see CoreDNS Configuration Reference</p>"},{"location":"dns-operator/docs/coredns/coredns-integration/#additional-resources","title":"Additional Resources","text":"<ul> <li>Kuadrant CoreDNS Plugin Documentation - Plugin-specific configuration</li> <li>CoreDNS Official Documentation - General CoreDNS plugins</li> </ul>"},{"location":"dns-operator/docs/coredns/coredns-integration/#testing-the-deployment","title":"Testing the Deployment","text":"<p>After deploying and configuring CoreDNS, verify that the integration is functioning correctly by testing DNS resolution, zone transfers, and advanced routing features.</p>"},{"location":"dns-operator/docs/coredns/coredns-integration/#verification-procedures","title":"Verification Procedures","text":"<p>The deployment guides include comprehensive verification procedures for testing CoreDNS functionality:</p> <p>Local Environment:</p> <ul> <li>Single Cluster Verification - Verify single cluster deployment</li> <li>Multi-Cluster Verification - Verify multi-cluster deployment</li> <li>GEO Routing Verification - Test geographic routing</li> </ul>"},{"location":"dns-operator/docs/coredns/coredns-integration/#troubleshooting","title":"Troubleshooting","text":"<p>Records not appearing in DNS queries:</p> <ol> <li>Verify DNSRecord has the <code>kuadrant.io/coredns-zone-name</code> label - DNS Operator adds this when processing the record</li> <li>Check the zone in the label matches a zone defined in your Corefile</li> <li>Review CoreDNS logs for watch errors or plugin issues</li> <li>Confirm that CoreDNS has RBAC permissions to watch DNSRecords in the target namespace</li> </ol> <p>Geo-routing not working:</p> <ol> <li>Ensure <code>geoip</code> and <code>metadata</code> plugins are enabled in your Corefile</li> <li>Verify GeoIP database path in Corefile matches the mounted database location</li> <li>Enable debug logging in Corefile and review logs for GeoIP lookup failures</li> </ol> <p>Multi-cluster coordination issues:</p> <ol> <li>For delegation issues, see the DNS Record Delegation documentation in the kuadrant-operator repository</li> <li>Verify kubeconfig secrets exist and are correctly labeled on primary clusters</li> <li>Check DNS Operator logs on both primary and secondary clusters for reconciliation errors</li> <li>Confirm network connectivity between clusters (primary clusters must reach secondary cluster APIs)</li> </ol>"},{"location":"dns-operator/docs/coredns/coredns-integration/#advanced-configuration-configuring-an-edge-server","title":"Advanced Configuration: Configuring an Edge Server","text":"<p>This section covers zone delegation - an advanced configuration for integrating CoreDNS with existing DNS infrastructure. Zone delegation allows you to maintain your existing authoritative DNS servers while delegating specific subdomains to CoreDNS running in Kubernetes.</p> <p>Zone delegation is optional. If you're running CoreDNS as your primary DNS infrastructure without integrating with existing DNS servers, you can skip this section.</p>"},{"location":"dns-operator/docs/coredns/coredns-integration/#what-is-zone-delegation","title":"What is Zone Delegation?","text":"<p>Zone delegation is a DNS mechanism where an authoritative DNS server delegates responsibility for a subdomain to another set of nameservers. This creates a hierarchical DNS structure where:</p> <ol> <li>Parent Zone (e.g., <code>example.com</code>) is managed by an authoritative edge server (BIND9, cloud DNS, etc.)</li> <li>Delegated Zone (e.g., <code>k.example.com</code>) is delegated to CoreDNS instances running in Kubernetes</li> <li>Delegation Records (NS and glue A records) in the parent zone point to the CoreDNS nameservers</li> </ol> <p>Why Use Zone Delegation?</p> <ul> <li>Production DNS Hierarchy: Maintain your existing authoritative DNS while delegating application zones to Kubernetes</li> <li>Organizational Control: Keep root domains managed by existing DNS infrastructure and processes</li> <li>Isolation: Separate Kubernetes-managed DNS from corporate DNS infrastructure</li> <li>Flexibility: Change Kubernetes DNS infrastructure without affecting root domain configuration</li> </ul> <p>Common Scenarios:</p> <ul> <li>Delegate <code>apps.example.com</code> from Bind9-managed <code>example.com</code> to CoreDNS</li> <li>Delegate internal zones from cloud DNS (Route53, Cloud DNS) to on-premise CoreDNS</li> <li>Create test/staging zones delegated to development CoreDNS instances</li> </ul>"},{"location":"dns-operator/docs/coredns/coredns-integration/#implementation-guide","title":"Implementation Guide","text":"<p>For step-by-step instructions on configuring zone delegation with Bind9, see:</p> <ul> <li>Zone Delegation Guide - Complete guide for setting up Bind9 delegation</li> </ul> <p>What the guide covers:</p> <ul> <li>Configuring Bind9 (deployed with <code>make local-setup</code> command) to delegate zones to CoreDNS</li> <li>Creating NS and glue A records for delegation using <code>nsupdate</code></li> <li>Configuring cluster CoreDNS to forward queries to the edge server</li> <li>Setting up rewrite rules in <code>kuadrant-coredns</code> for active groups queries</li> <li>Verification procedures</li> </ul> <p>Production Adaptations:</p> <ul> <li>If using an existing Bind9 server (not in Kubernetes), adapt the <code>nsupdate</code> commands to target your server</li> <li>For cloud DNS providers (Route53, Cloud DNS, Azure DNS), create NS records via their web console or API</li> <li>Ensure proper network connectivity between your edge DNS and CoreDNS LoadBalancer IPs</li> <li>Consider DNSSEC if your root zone uses it</li> <li>Implement monitoring for delegation chain health</li> </ul>"},{"location":"dns-operator/docs/coredns/coredns-integration/#appendix","title":"Appendix","text":""},{"location":"dns-operator/docs/coredns/coredns-integration/#reference-configurations","title":"Reference Configurations","text":"<p>Corefile Examples:</p> <ul> <li>Production Corefile - Example Corefile with all plugins configured</li> </ul> <p>DNSRecord Examples:</p> <ul> <li>Plugin README Examples - DNSRecord examples with geo-routing and weighted routing</li> </ul> <p>Deployment Configurations:</p> <ul> <li>Kustomization - Kustomize configuration including Helm chart values for CoreDNS deployment</li> </ul>"},{"location":"dns-operator/docs/coredns/coredns-integration/#glossary","title":"Glossary","text":"<p>Authoritative DNSRecord: A DNSRecord created and managed by a primary cluster that merges delegating DNSRecords from all clusters in a multi-cluster setup.</p> <p>CoreDNS: An open-source, cloud-native DNS server that serves as a flexible, extensible platform for DNS services in Kubernetes.</p> <p>Corefile: The configuration file for CoreDNS that defines zones, plugins, and server behavior.</p> <p>Delegating DNSRecord: A DNSRecord with <code>delegate: true</code> that is reconciled by primary clusters and merged into authoritative DNSRecords in multi-cluster deployments.</p> <p>DNS Operator: A Kubernetes operator that manages DNS records across multiple providers (cloud and self-hosted) using DNSRecord custom resources.</p> <p>DNSRecord: A custom resource (CRD) in the DNS Operator that represents DNS record configuration to be managed by the operator.</p> <p>GeoIP Routing: DNS routing strategy that returns different responses based on the geographic location of the client making the query.</p> <p>Kuadrant Plugin: The CoreDNS plugin that watches DNSRecord resources via the Kubernetes API and serves them as DNS responses.</p> <p>Label-based Watch: The mechanism by which CoreDNS discovers DNSRecords - DNS Operator adds the <code>kuadrant.io/coredns-zone-name</code> label, and CoreDNS watches for resources with this label.</p> <p>Non-delegating DNSRecord: A DNSRecord without <code>delegate: true</code> that requires a provider secret reference for zone matching and reconciliation.</p> <p>Primary Cluster: A cluster running CoreDNS and DNS Operator in primary mode (<code>--delegation-role=primary</code>) that reconciles delegating DNSRecords into authoritative DNSRecords.</p> <p>Provider Secret: A Kubernetes Secret containing provider-specific configuration (zones, credentials) that enables DNS Operator to interact with DNS providers.</p> <p>Secondary Cluster: A cluster running only DNS Operator in secondary mode (<code>--delegation-role=secondary</code>) that creates delegating DNSRecords for primary clusters to reconcile.</p> <p>Weighted Routing: DNS routing strategy that distributes traffic across multiple endpoints based on assigned weights.</p> <p>Zone Coordination: The requirement that zones must be listed in both the Corefile (for CoreDNS) and provider secret <code>ZONES</code> field (for DNS Operator).</p> <p>Zone Delegation: DNS mechanism where an authoritative DNS server delegates responsibility for a subdomain to another set of nameservers.</p>"},{"location":"dns-operator/docs/coredns/coredns-integration/#additional-resources_1","title":"Additional Resources","text":"<p>CoreDNS Documentation:</p> <ul> <li>CoreDNS Official Documentation - General CoreDNS configuration and plugins</li> <li>Kuadrant CoreDNS Plugin - Plugin-specific documentation and examples</li> </ul> <p>DNS Operator Documentation:</p> <ul> <li>Provider Documentation - DNS provider configuration details</li> <li>DNS Operator README - Main project documentation</li> </ul> <p>Deployment Guides:</p> <ul> <li>Local Single Cluster Setup - Deploy to a local cluster</li> <li>Local Multi-Cluster Setup - Deploy to multiple local clusters with delegation</li> <li>Edge Server Configuration - Configure Bind9 zone delegation</li> </ul> <p>Configuration References:</p> <ul> <li>CoreDNS Configuration Reference - Detailed technical configuration guide</li> </ul> <p>External Resources:</p> <ul> <li>Kuadrant Architecture - CoreDNS Integration</li> <li>CoreDNS Use Cases Blog Post</li> </ul>"},{"location":"dns-operator/docs/coredns/local-development/","title":"CoreDNS Local Development Guide","text":"<p>This guide provides step-by-step instructions for setting up and testing CoreDNS integration locally using Kind clusters. This is intended for local development and testing purposes only.</p> <p>For conceptual overview and production deployment, see the CoreDNS Integration Guide.</p> <p>For quick-start examples and plugin syntax, see the CoreDNS Plugin README.</p> <p>For parent zone delegation setup (using BIND9), see the Zone Delegation Guide.</p> <p>Prerequisites:</p> <ul> <li><code>kubectl</code> - Kubernetes command-line tool</li> <li><code>kind</code> - Tool for running local Kubernetes clusters</li> <li><code>make</code> - Build automation tool</li> <li><code>yq</code> - YAML processor for querying Kubernetes resources</li> <li><code>dig</code> - DNS lookup utility for testing DNS resolution</li> </ul>"},{"location":"dns-operator/docs/coredns/local-development/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Single Cluster Setup</li> <li>Multi-Cluster Setup</li> <li>GeoIP Testing</li> <li>Troubleshooting</li> <li>Cleanup</li> </ol>"},{"location":"dns-operator/docs/coredns/local-development/#setup-single-cluster-local-environment-kind","title":"Setup single cluster local environment (kind)","text":"<p>Create a kind cluster with DNS Operator deployed: <pre><code># Run from dns-operator repository root\n# DEPLOY=true installs DNS Operator and CoreDNS into the cluster\nmake local-setup DEPLOY=true\n</code></pre></p> <p>Configure observability stack (optional): <pre><code># Run from dns-operator repository root\nmake install-observability\n</code></pre></p> <p>Forward port for Grafana (optional): <pre><code>kubectl -n monitoring port-forward service/grafana 3000:3000\n</code></pre></p> <p>Access dashboards at http://127.0.0.1:3000</p> <p>Note: Default credentials are <code>admin</code>/<code>admin</code></p>"},{"location":"dns-operator/docs/coredns/local-development/#understanding-the-setup","title":"Understanding the Setup","text":"<p>Local setup deploys a single instance of CoreDNS with the kuadrant plugin enabled, configured to watch all namespaces for DNSRecord resources and zones configured for demo/test purposes.</p> <p>View the Corefile ConfigMap data: <pre><code>kubectl get configmap/kuadrant-coredns -n kuadrant-coredns -o yaml | yq .data\n</code></pre></p> <p>View CoreDNS logs: <pre><code>kubectl logs -f deployments/kuadrant-coredns -n kuadrant-coredns\n</code></pre></p>"},{"location":"dns-operator/docs/coredns/local-development/#optional-configuration","title":"Optional Configuration","text":""},{"location":"dns-operator/docs/coredns/local-development/#enable-monitoring","title":"Enable Monitoring","text":"<p>Monitoring is not enabled by default. If you configured the observability stack above, update the CoreDNS instance to enable monitoring: <pre><code># Run from dns-operator repository root\nbin/kustomize build --enable-helm config/coredns/ | kubectl apply -f -\n</code></pre></p>"},{"location":"dns-operator/docs/coredns/local-development/#redeploy-coredns","title":"Redeploy CoreDNS","text":"<p>To apply changes to the Corefile or deployment configuration: <pre><code># Run from dns-operator repository root\n# Use config/coredns/ if monitoring is enabled, config/coredns-unmonitored/ if not\nbin/kustomize build --enable-helm config/coredns/ | kubectl apply -f -\n</code></pre></p>"},{"location":"dns-operator/docs/coredns/local-development/#verify","title":"Verify","text":"<p>Create test namespace and DNSRecord: <pre><code># Create dnstest namespace\nkubectl create ns dnstest\n\n# Run from dns-operator repository root\nkubectl apply -n dnstest -f config/local-setup/dnsrecords/basic/coredns/simple/dnsrecord-simple-coredns.yaml\n</code></pre></p> <p>Verify zone (k.example.com) has updated records in the CoreDNS instance: <pre><code>NS1=`kubectl get service/kuadrant-coredns -n kuadrant-coredns -o yaml | yq '.status.loadBalancer.ingress[0].ip'`\necho $NS1\ndig @${NS1} -t AXFR k.example.com\n</code></pre> Expected output (IP addresses, hashes, and timestamps will differ in your environment): <pre><code>; &lt;&lt;&gt;&gt; DiG 9.18.28 &lt;&lt;&gt;&gt; @172.18.0.17 -t AXFR k.example.com\n; (1 server found)\n;; global options: +cmd\nk.example.com.          60      IN      SOA     ns1.k.example.com. hostmaster.k.example.com. 12345 7200 1800 86400 60\nk.example.com.          60      IN      NS      ns1.k.example.com.\nkuadrant-2kl5wt14-a-simple.k.example.com. 0 IN TXT \"\\\"heritage=external-dns,external-dns/owner=2vl2ac4b,external-dns/version=1\\\"\"\nsimple.k.example.com.   60      IN      A       172.18.200.1\nk.example.com.          60      IN      SOA     ns1.k.example.com. hostmaster.k.example.com. 12345 7200 1800 86400 60\n;; Query time: 0 msec\n;; SERVER: 172.18.0.17#53(172.18.0.17) (TCP)\n;; WHEN: Mon Sep 29 16:02:14 IST 2025\n;; XFR size: 5 records (messages 1, bytes 441)\n</code></pre></p> <p>Verify DNS Server responds: <pre><code>NS1=`kubectl get service/kuadrant-coredns -n kuadrant-coredns -o yaml | yq '.status.loadBalancer.ingress[0].ip'`\necho $NS1\ndig @${NS1} simple.k.example.com +short\n</code></pre> Expected output (IP address might differ in your environment): <pre><code>172.18.200.1\n</code></pre></p>"},{"location":"dns-operator/docs/coredns/local-development/#setup-multi-cluster-local-environment-kind","title":"Setup multi cluster local environment (kind)","text":"<p>Create three kind clusters (2 primary and 1 secondary): <pre><code># Run from dns-operator repository root\n# PRIMARY_CLUSTER_COUNT=2 creates 2 primary clusters (with CoreDNS deployed)\n# CLUSTER_COUNT=3 creates 3 clusters total (CLUSTER_COUNT - PRIMARY_CLUSTER_COUNT = 1 secondary)\n# Primary clusters can reconcile delegated DNSRecords, secondary clusters cannot\nmake multicluster-local-setup PRIMARY_CLUSTER_COUNT=2 CLUSTER_COUNT=3\n</code></pre></p>"},{"location":"dns-operator/docs/coredns/local-development/#verify-primary-cluster-setup","title":"Verify Primary Cluster Setup","text":"<p>Check that CoreDNS, provider secrets, and cluster interconnection secrets are properly configured. </p> <p>CoreDNS is deployed and running: <pre><code>kubectl get deployments,service -A -l app.kubernetes.io/name=coredns --context kind-kuadrant-dns-local-1\nkubectl get deployments,service -A -l app.kubernetes.io/name=coredns --context kind-kuadrant-dns-local-2\n</code></pre> Expected output: <pre><code>NAMESPACE          NAME                               READY   UP-TO-DATE   AVAILABLE   AGE\nkuadrant-coredns   deployment.apps/kuadrant-coredns   1/1     1            1           10m\n\nNAMESPACE          NAME                       TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)                     AGE\nkuadrant-coredns   service/kuadrant-coredns   LoadBalancer   10.96.253.138   172.18.0.17   53:30494/UDP,53:30494/TCP   10m\n</code></pre></p> <p>Test zone transfer (AXFR) capability for k.example.com zone in both CoreDNS instances: <pre><code>NS1=`kubectl get service -n kuadrant-coredns -l app.kubernetes.io/name=coredns,app.kubernetes.io/component!=metrics --context kind-kuadrant-dns-local-1 -o yaml | yq '.items[0].status.loadBalancer.ingress[0].ip'`\nNS2=`kubectl get service -n kuadrant-coredns -l app.kubernetes.io/name=coredns,app.kubernetes.io/component!=metrics --context kind-kuadrant-dns-local-2 -o yaml | yq '.items[0].status.loadBalancer.ingress[0].ip'`\n\ndig @${NS1} -t AXFR k.example.com\ndig @${NS2} -t AXFR k.example.com\n</code></pre> Expected output (empty zone before adding DNSRecords): <pre><code>; &lt;&lt;&gt;&gt; DiG 9.18.28 &lt;&lt;&gt;&gt; @172.18.0.33 -t AXFR k.example.com\n; (1 server found)\n;; global options: +cmd\nk.example.com.          60      IN      SOA     ns1.k.example.com. hostmaster.k.example.com. 12345 7200 1800 86400 60\nk.example.com.          60      IN      NS      ns1.k.example.com.\nk.example.com.          60      IN      SOA     ns1.k.example.com. hostmaster.k.example.com. 12345 7200 1800 86400 60\n;; Query time: 1 msec\n;; SERVER: 172.18.0.33#53(172.18.0.33) (TCP)\n;; WHEN: Mon Sep 29 12:51:25 IST 2025\n;; XFR size: 3 records (messages 1, bytes 278)\n</code></pre></p> <p>CoreDNS provider secret exists in the \"dnstest\" namespace with test zone (k.example.com) configured (namespace is created automatically on primary clusters): <pre><code>kubectl get secret/dns-provider-credentials-coredns -n dnstest -o jsonpath='{.data.ZONES}' --context kind-kuadrant-dns-local-1 | base64 --decode\nkubectl get secret/dns-provider-credentials-coredns -n dnstest -o jsonpath='{.data.ZONES}' --context kind-kuadrant-dns-local-2 | base64 --decode\n</code></pre> Expected output: <pre><code>k.example.com\n</code></pre></p> <p>Cluster interconnection secrets exist on kind-kuadrant-dns-local-1(primary 1) for kind-kuadrant-dns-local-2(primary 2) and kind-kuadrant-dns-local-3(secondary): <pre><code>kubectl get secrets -A -l kuadrant.io/multicluster-kubeconfig=true --show-labels --context kind-kuadrant-dns-local-1\n</code></pre> Expected output: <pre><code>NAMESPACE             NAME                        TYPE     DATA   AGE   LABELS\ndns-operator-system   kind-kuadrant-dns-local-2   Opaque   1      19m   kuadrant.io/multicluster-kubeconfig=true\ndns-operator-system   kind-kuadrant-dns-local-3   Opaque   1      19m   kuadrant.io/multicluster-kubeconfig=true\n</code></pre></p> <p>Cluster interconnection secrets exist on kind-kuadrant-dns-local-2(primary 2) for kind-kuadrant-dns-local-1(primary 1) and kind-kuadrant-dns-local-3(secondary): <pre><code>kubectl get secrets -A -l kuadrant.io/multicluster-kubeconfig=true --show-labels --context kind-kuadrant-dns-local-2\n</code></pre> Expected output: <pre><code>NAMESPACE             NAME                        TYPE     DATA   AGE   LABELS\ndns-operator-system   kind-kuadrant-dns-local-1   Opaque   1      19m   kuadrant.io/multicluster-kubeconfig=true\ndns-operator-system   kind-kuadrant-dns-local-3   Opaque   1      19m   kuadrant.io/multicluster-kubeconfig=true\n</code></pre></p>"},{"location":"dns-operator/docs/coredns/local-development/#verify-multi-cluster-dns-records","title":"Verify Multi-Cluster DNS Records","text":"<p>Create \"dnstest\" namespace on kind-kuadrant-dns-local-3 (secondary cluster - not created automatically): <pre><code>kubectl create ns dnstest --context kind-kuadrant-dns-local-3\n</code></pre></p> <p>Set CoreDNS provider as the default in the \"dnstest\" namespace on both primary clusters: <pre><code># The kuadrant.io/default-provider=true label allows DNSRecords and DNSPolicy\n# to use this provider without explicitly specifying providerRef\nkubectl label secret/dns-provider-credentials-coredns -n dnstest kuadrant.io/default-provider=true --context kind-kuadrant-dns-local-1\nkubectl label secret/dns-provider-credentials-coredns -n dnstest kuadrant.io/default-provider=true --context kind-kuadrant-dns-local-2\n</code></pre></p> <p>Apply example DNSRecords with delegation enabled: <pre><code># Run from dns-operator repository root\nkubectl apply -n dnstest -f config/local-setup/dnsrecords/delegating/coredns/loadbalanced/dnsrecord-loadbalanced-coredns-cluster1.yaml --context kind-kuadrant-dns-local-1\nkubectl apply -n dnstest -f config/local-setup/dnsrecords/delegating/coredns/loadbalanced/dnsrecord-loadbalanced-coredns-cluster2.yaml --context kind-kuadrant-dns-local-2\nkubectl apply -n dnstest -f config/local-setup/dnsrecords/delegating/coredns/loadbalanced/dnsrecord-loadbalanced-coredns-cluster3.yaml --context kind-kuadrant-dns-local-3\n</code></pre></p> <p>Verify zone (k.example.com) has updated records in both primary cluster CoreDNS instances (after delegation reconciliation): <pre><code>NS1=`kubectl get service -n kuadrant-coredns -l app.kubernetes.io/name=coredns,app.kubernetes.io/component!=metrics --context kind-kuadrant-dns-local-1 -o yaml | yq '.items[0].status.loadBalancer.ingress[0].ip'`\nNS2=`kubectl get service -n kuadrant-coredns -l app.kubernetes.io/name=coredns,app.kubernetes.io/component!=metrics --context kind-kuadrant-dns-local-2 -o yaml | yq '.items[0].status.loadBalancer.ingress[0].ip'`\n\necho $NS1\necho $NS2\n\ndig @${NS1} -t AXFR k.example.com\ndig @${NS2} -t AXFR k.example.com\n</code></pre> Expected output (IP addresses, hashes, and timestamps will differ in your environment): <pre><code>; &lt;&lt;&gt;&gt; DiG 9.18.28 &lt;&lt;&gt;&gt; @172.18.0.33 -t AXFR k.example.com\n; (1 server found)\n;; global options: +cmd\nk.example.com.          60      IN      SOA     ns1.k.example.com. hostmaster.k.example.com. 12345 7200 1800 86400 60\nk.example.com.          60      IN      NS      ns1.k.example.com.\nkuadrant-1a20rnj9-cname-loadbalanced.k.example.com. 0 IN TXT \"\\\"heritage=external-dns,external-dns/owner=2fgmvv67,external-dns/version=1\\\"\"\nkuadrant-2o2qjax9-cname-loadbalanced.k.example.com. 0 IN TXT \"\\\"heritage=external-dns,external-dns/owner=26yn4kgw,external-dns/version=1\\\"\"\nkuadrant-31aztxux-cname-loadbalanced.k.example.com. 0 IN TXT \"\\\"heritage=external-dns,external-dns/owner=34l61c8o,external-dns/version=1\\\"\"\nloadbalanced.k.example.com. 300 IN      CNAME   klb.loadbalanced.k.example.com.\nklb.loadbalanced.k.example.com. 300 IN  CNAME   ie.klb.loadbalanced.k.example.com.\nklb.loadbalanced.k.example.com. 300 IN  CNAME   ie.klb.loadbalanced.k.example.com.\nklb.loadbalanced.k.example.com. 300 IN  CNAME   us.klb.loadbalanced.k.example.com.\ncluster1-gw1-ns1.klb.loadbalanced.k.example.com. 60 IN A 172.18.200.1\ncluster2-gw1-ns1.klb.loadbalanced.k.example.com. 60 IN A 172.18.200.2\ncluster3-gw1-ns1.klb.loadbalanced.k.example.com. 60 IN A 172.18.200.3\nie.klb.loadbalanced.k.example.com. 60 IN CNAME  cluster2-gw1-ns1.klb.loadbalanced.k.example.com.\nie.klb.loadbalanced.k.example.com. 60 IN CNAME  cluster1-gw1-ns1.klb.loadbalanced.k.example.com.\nkuadrant-1a20rnj9-a-cluster3-gw1-ns1.klb.loadbalanced.k.example.com. 0 IN TXT \"\\\"heritage=external-dns,external-dns/owner=2fgmvv67,external-dns/version=1\\\"\"\nkuadrant-1a20rnj9-cname-us.klb.loadbalanced.k.example.com. 0 IN TXT \"\\\"heritage=external-dns,external-dns/owner=2fgmvv67,external-dns/version=1\\\"\"\nkuadrant-2o2qjax9-a-cluster2-gw1-ns1.klb.loadbalanced.k.example.com. 0 IN TXT \"\\\"heritage=external-dns,external-dns/owner=26yn4kgw,external-dns/version=1\\\"\"\nkuadrant-2o2qjax9-cname-ie.klb.loadbalanced.k.example.com. 0 IN TXT \"\\\"heritage=external-dns,external-dns/owner=26yn4kgw,external-dns/version=1\\\"\"\nkuadrant-31aztxux-a-cluster1-gw1-ns1.klb.loadbalanced.k.example.com. 0 IN TXT \"\\\"heritage=external-dns,external-dns/owner=34l61c8o,external-dns/version=1\\\"\"\nkuadrant-31aztxux-cname-ie.klb.loadbalanced.k.example.com. 0 IN TXT \"\\\"heritage=external-dns,external-dns/owner=34l61c8o,external-dns/version=1\\\"\"\nus.klb.loadbalanced.k.example.com. 60 IN CNAME  cluster3-gw1-ns1.klb.loadbalanced.k.example.com.\nkuadrant-1a20rnj9-cname-klb.loadbalanced.k.example.com. 0 IN TXT \"\\\"heritage=external-dns,external-dns/owner=2fgmvv67,external-dns/version=1\\\"\"\nkuadrant-2o2qjax9-cname-klb.loadbalanced.k.example.com. 0 IN TXT \"\\\"heritage=external-dns,external-dns/owner=26yn4kgw,external-dns/version=1\\\"\"\nkuadrant-2o2qjax9-cname-klb.loadbalanced.k.example.com. 0 IN TXT \"\\\"heritage=external-dns,external-dns/owner=26yn4kgw,external-dns/version=1\\\"\"\nkuadrant-31aztxux-cname-klb.loadbalanced.k.example.com. 0 IN TXT \"\\\"heritage=external-dns,external-dns/owner=34l61c8o,external-dns/version=1\\\"\"\nkuadrant-31aztxux-cname-klb.loadbalanced.k.example.com. 0 IN TXT \"\\\"heritage=external-dns,external-dns/owner=34l61c8o,external-dns/version=1\\\"\"\nk.example.com.          60      IN      SOA     ns1.k.example.com. hostmaster.k.example.com. 12345 7200 1800 86400 60\n;; Query time: 1 msec\n;; SERVER: 172.18.0.33#53(172.18.0.33) (TCP)\n;; WHEN: Mon Sep 29 13:27:50 IST 2025\n;; XFR size: 27 records (messages 1, bytes 3060)\n</code></pre></p> <p>Verify DNS Server(s) respond: <pre><code>NS1=`kubectl get service -n kuadrant-coredns -l app.kubernetes.io/name=coredns,app.kubernetes.io/component!=metrics --context kind-kuadrant-dns-local-1 -o yaml | yq '.items[0].status.loadBalancer.ingress[0].ip'`\nNS2=`kubectl get service -n kuadrant-coredns -l app.kubernetes.io/name=coredns,app.kubernetes.io/component!=metrics --context kind-kuadrant-dns-local-2 -o yaml | yq '.items[0].status.loadBalancer.ingress[0].ip'`\n\necho $NS1\necho $NS2\n\necho \"Dig command: dig @$NS1 loadbalanced.k.example.com\"\ndig @$NS1 loadbalanced.k.example.com +short\n\necho \"Dig command: dig @$NS2 loadbalanced.k.example.com\"\n# +subnet parameter simulates client location for GEO routing (127.0.100.0/24 = Ireland in demo DB)\ndig @$NS2 loadbalanced.k.example.com +short +subnet=127.0.100.0/24\n</code></pre> Expected output (from NS2 with Ireland subnet, routing to IE geo endpoint): <pre><code>klb.loadbalanced.k.example.com.\nie.klb.loadbalanced.k.example.com.\ncluster1-gw1-ns1.klb.loadbalanced.k.example.com.\n172.18.200.1\n</code></pre></p> <p>Delete example DNSRecords: <pre><code># Run from dns-operator repository root\nkubectl delete -n dnstest -f config/local-setup/dnsrecords/delegating/coredns/loadbalanced/dnsrecord-loadbalanced-coredns-cluster1.yaml --context kind-kuadrant-dns-local-1\nkubectl delete -n dnstest -f config/local-setup/dnsrecords/delegating/coredns/loadbalanced/dnsrecord-loadbalanced-coredns-cluster2.yaml --context kind-kuadrant-dns-local-2\nkubectl delete -n dnstest -f config/local-setup/dnsrecords/delegating/coredns/loadbalanced/dnsrecord-loadbalanced-coredns-cluster3.yaml --context kind-kuadrant-dns-local-3\n</code></pre></p>"},{"location":"dns-operator/docs/coredns/local-development/#geo","title":"GEO","text":"<p>This section describes how to test CoreDNS geographic routing capabilities using the embedded demo GeoIP database.</p>"},{"location":"dns-operator/docs/coredns/local-development/#geoip-database","title":"GeoIP Database","text":"<p>The geo functionality is provided by the geoip plugin from CoreDNS. The kuadrant CoreDNS container image has a demo database embedded at its root (<code>/GeoLite2-City-demo.mmdb</code>), generated using <code>coredns/plugin/geoip/db-generator.go</code>, for testing purposes.</p> <p>Note: The database path differs between deployment contexts:</p> <ul> <li>Container deployment (Kind/Kubernetes): Use <code>/GeoLite2-City-demo.mmdb</code> (absolute path from container root)</li> <li>Local development (running from <code>coredns/plugin/</code> directory): Use <code>geoip/GeoLite2-City-demo.mmdb</code> (relative path to the plugin directory)</li> </ul> <p>Ensure your Corefile uses the correct path for your deployment context.</p> <p>The demo database contains sets of local subnets typical for Kind deployments that map to IE and US locales:</p> Subnet Continent Country 127.0.100.0/24 Europe / EU Ireland / IE 127.0.200.0/24 North America / NA United States / US 10.89.100.0/24 Europe / EU Ireland / IE 10.89.200.0/24 North America / NA United States / US"},{"location":"dns-operator/docs/coredns/local-development/#testing-geographic-routing","title":"Testing Geographic Routing","text":"<p>When running CoreDNS locally (from terminal with <code>make run</code> in <code>coredns/plugin/</code> directory): You can use the <code>+subnet</code> option with dig to specify a client subnet. For example:</p> <ul> <li><code>dig @127.0.0.1 api.k.example.com -p 1053 +subnet=127.0.100.0/24</code> will be associated with IE locale</li> <li><code>dig @127.0.0.1 api.k.example.com -p 1053 +subnet=127.0.200.0/24</code> will be associated with US locale</li> </ul> <p>When running CoreDNS in Kind cluster: The demo DB contains only localhost addresses which aren't routable in Kind. Instead, use the <code>+subnet</code> parameter with dig to simulate client location (replace <code>$NS1</code> with your CoreDNS service IP):</p> <ul> <li><code>dig @$NS1 api.k.example.com +subnet=127.0.100.0/24</code> simulates a client from Ireland</li> <li><code>dig @$NS1 api.k.example.com +subnet=127.0.200.0/24</code> simulates a client from United States</li> </ul>"},{"location":"dns-operator/docs/coredns/local-development/#customizing-the-geoip-database","title":"Customizing the GeoIP Database","text":"<p>To add more subnets, generate a new database file by editing <code>coredns/plugin/geoip/db-generator.go</code>. Add your desired CIDR range to the constants and associate it with the desired record (IE or US).</p> <p>For production deployments using a real-world database, refer to MaxMind for their free database. Once obtained, it must be mounted and referenced in the Corefile instead of the demo database.</p>"},{"location":"dns-operator/docs/coredns/local-development/#troubleshooting","title":"Troubleshooting","text":""},{"location":"dns-operator/docs/coredns/local-development/#kind-cluster-issues","title":"Kind Cluster Issues","text":"<p>LoadBalancer IP not assigned:</p> <p>Check that MetalLB is installed and running (required for LoadBalancer services in Kind): <pre><code>kubectl get pods -n metallb-system\n</code></pre></p> <p>If not present, MetalLB should be installed as part of <code>make local-setup</code>. Check the setup logs.</p> <p>CoreDNS pod not starting:</p> <p>Check pod status and logs: <pre><code>kubectl get pods -n kuadrant-coredns\nkubectl logs -n kuadrant-coredns deployment/kuadrant-coredns\n</code></pre></p> <p>Common issues:</p> <ul> <li>RBAC permissions missing (check ClusterRole and ClusterRoleBinding)</li> <li>Invalid Corefile configuration</li> <li>GeoIP database file not found</li> </ul>"},{"location":"dns-operator/docs/coredns/local-development/#dnsrecord-not-appearing-in-zone","title":"DNSRecord Not Appearing in Zone","text":"<p>Verify the DNSRecord has the zone label: <pre><code>kubectl get dnsrecords.kuadrant.io -n dnstest -o jsonpath='{.items[*].metadata.labels}' | grep kuadrant.io/coredns-zone-name\n</code></pre></p> <p>Should include <code>kuadrant.io/coredns-zone-name: k.example.com</code>.</p> <p>If the label is missing, DNS Operator hasn't processed the record yet. Check: <pre><code># Check DNS Operator is running\nkubectl get pods -n dns-operator-system\n\n# Check DNS Operator logs\nkubectl logs -n dns-operator-system deployment/dns-operator-controller-manager\n</code></pre></p> <p>Zone transfer (AXFR) shows no records:</p> <p>Ensure the <code>transfer</code> plugin is enabled in the Corefile: <pre><code>k.example.com {\n    transfer {\n        to *\n    }\n    kuadrant\n}\n</code></pre></p>"},{"location":"dns-operator/docs/coredns/local-development/#multi-cluster-issues","title":"Multi-Cluster Issues","text":"<p>Cluster interconnection secrets not working:</p> <p>Verify secrets exist and have correct labels: <pre><code>kubectl get secret -A -l kuadrant.io/multicluster-kubeconfig=true\n</code></pre></p> <p>For Kind clusters, ensure you used the correct multicluster setup command: <pre><code>make multicluster-local-setup PRIMARY_CLUSTER_COUNT=2 CLUSTER_COUNT=3\n</code></pre></p> <p>Authoritative DNSRecord not created on primary cluster:</p> <p>Check DNS Operator delegation role: <pre><code>kubectl get configmap dns-operator-controller-env -n dns-operator-system -o jsonpath='{.data.DELEGATION_ROLE}'\n</code></pre></p> <p>Should be <code>primary</code> on primary clusters and <code>secondary</code> on secondary clusters.</p> <p>For general CoreDNS integration troubleshooting, see the Integration Guide Troubleshooting Section.</p>"},{"location":"dns-operator/docs/coredns/local-development/#cleanup","title":"Cleanup","text":""},{"location":"dns-operator/docs/coredns/local-development/#single-cluster-cleanup","title":"Single Cluster Cleanup","text":"<pre><code># Delete test DNSRecord\nkubectl delete dnsrecords.kuadrant.io -n dnstest --all\n\n# Delete test namespace\nkubectl delete ns dnstest\n\n# Delete the kind cluster\nkind delete cluster --name kuadrant-dns-local\n</code></pre>"},{"location":"dns-operator/docs/coredns/local-development/#multi-cluster-cleanup","title":"Multi-Cluster Cleanup","text":"<pre><code># Delete DNSRecords from all clusters\nkubectl delete dnsrecords.kuadrant.io -n dnstest --all --context kind-kuadrant-dns-local-1\nkubectl delete dnsrecords.kuadrant.io -n dnstest --all --context kind-kuadrant-dns-local-2\nkubectl delete dnsrecords.kuadrant.io -n dnstest --all --context kind-kuadrant-dns-local-3\n\n# Delete test namespace from all clusters\nkubectl delete ns dnstest --context kind-kuadrant-dns-local-1\nkubectl delete ns dnstest --context kind-kuadrant-dns-local-2\nkubectl delete ns dnstest --context kind-kuadrant-dns-local-3\n\n# Delete all kind clusters\nkind delete cluster --name kuadrant-dns-local-1\nkind delete cluster --name kuadrant-dns-local-2\nkind delete cluster --name kuadrant-dns-local-3\n</code></pre>"},{"location":"dns-operator/docs/coredns/local-development/#related-documentation","title":"Related Documentation","text":"<ul> <li>Zone Delegation Guide - Parent zone delegation setup using BIND9 as an example authoritative DNS server</li> <li>CoreDNS Configuration Reference - Comprehensive configuration options for CoreDNS integration</li> <li>CoreDNS Plugin README - Plugin syntax and quick-start examples</li> <li>CoreDNS Integration Guide - Conceptual overview and production deployment</li> </ul>"},{"location":"dns-operator/docs/coredns/zone-delegation/","title":"Zone Delegation for CoreDNS","text":"<p>This guide explains how to set up parent zone delegation to enable CoreDNS to serve as an authoritative DNS server for a subdomain. This pattern is commonly used in development environments and scenarios where you want to delegate a subdomain (e.g., <code>k.example.com</code>) to CoreDNS while maintaining the parent zone (<code>example.com</code>) in a traditional authoritative DNS server.</p>"},{"location":"dns-operator/docs/coredns/zone-delegation/#overview","title":"Overview","text":"<p>Zone delegation is a DNS pattern where a parent zone delegates authority for a subdomain to a different set of nameservers. In this setup:</p> <ul> <li>Parent Zone (<code>example.com</code>): Managed by an authoritative DNS server (BIND9, PowerDNS, cloud provider, etc.)</li> <li>Delegated Zone (<code>k.example.com</code>): Managed by CoreDNS with the Kuadrant plugin</li> </ul> <p>This guide uses BIND9 as the example authoritative DNS server, but the same delegation pattern applies to any DNS server that supports:</p> <ul> <li>Dynamic DNS updates (nsupdate/RFC 2136)</li> <li>Zone transfers (AXFR)</li> <li>NS record delegation</li> </ul> <p>Alternative servers include: PowerDNS, Knot DNS, NSD, Unbound, or cloud provider DNS services (Route53, Cloud DNS, Azure DNS).</p>"},{"location":"dns-operator/docs/coredns/zone-delegation/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Overview</li> <li>Prerequisites</li> <li>BIND9 Deployment Overview</li> <li>Step 1: Verify BIND9 Installation</li> <li>Step 2: Identify CoreDNS Instances</li> <li>Step 3: Delegate Zone to CoreDNS</li> <li>Step 4: Test Delegation with DNSRecord</li> <li>Step 5: Configure In-Cluster DNS Forwarding (Optional)</li> <li>Step 6: Configure DNS Groups Active-Groups Resolution (Optional)</li> <li>Additional Commands</li> <li>Troubleshooting</li> <li>Related Documentation</li> </ol>"},{"location":"dns-operator/docs/coredns/zone-delegation/#prerequisites","title":"Prerequisites","text":"<p>Important: All commands in this guide should be run from the dns-operator repository root directory unless otherwise specified. File paths like <code>config/bind9/ddns.key</code> and <code>coredns/examples/</code> are relative to this root.</p> <p>Before starting, ensure you have:</p> <ol> <li>Local Kind cluster with CoreDNS and BIND9 deployed:    <pre><code>make local-setup\n</code></pre>    This installs:</li> <li>Kind cluster with MetalLB (for LoadBalancer IP assignment)</li> <li>CoreDNS with Kuadrant plugin in <code>kuadrant-coredns</code> namespace</li> <li>BIND9 authoritative DNS server in <code>kuadrant-bind9</code> namespace</li> </ol> <p>Important: MetalLB is required for Kind clusters to assign external IPs to LoadBalancer services. Without it, BIND9 and CoreDNS services would remain in \"Pending\" state and not receive IPs for DNS queries. The IP range assigned depends on your Kind cluster's Docker network configuration (typically <code>172.18.x.x</code> range).</p> <ol> <li>Required tools:</li> <li><code>kubectl</code> - Kubernetes CLI</li> <li><code>dig</code> - DNS query tool (BIND utilities)</li> <li><code>nsupdate</code> - Dynamic DNS update tool (BIND utilities)</li> <li> <p><code>jq</code> - JSON processor</p> </li> <li> <p>Understanding of:</p> </li> <li>DNS delegation concepts (NS records, glue records)</li> <li>Kubernetes Services and LoadBalancer types</li> <li>Basic DNS query tools (dig, nsupdate)</li> </ol>"},{"location":"dns-operator/docs/coredns/zone-delegation/#dns-query-flags-used-in-this-guide","title":"DNS Query Flags Used in This Guide","text":"<p>Throughout this guide, we use <code>dig</code> commands with various flags. Here's what they mean:</p> <ul> <li><code>+short</code> - Display only the answer section (minimal output)</li> <li><code>+norec</code> - Non-recursive query (query the server directly without recursion, used for authoritative answers)</li> <li><code>-t AXFR</code> - Request a zone transfer (list all records in a zone)</li> <li><code>-k &lt;keyfile&gt;</code> - Use TSIG key authentication (required for authenticated operations)</li> <li><code>@&lt;server&gt;</code> - Query a specific DNS server instead of the default resolver</li> </ul> <p>Example patterns: <pre><code># Query for minimal output\ndig @${EDGE_NS} api.k.example.com +short\n\n# Query authoritative server directly (no recursion)\ndig @${EDGE_NS} soa example.com +norec\n\n# Transfer entire zone with authentication\ndig @${EDGE_NS} -k config/bind9/ddns.key -t AXFR example.com\n</code></pre></p>"},{"location":"dns-operator/docs/coredns/zone-delegation/#bind9-deployment-overview","title":"BIND9 Deployment Overview","text":"<p>The <code>make local-setup</code> command deploys BIND9 with the following configuration:</p> <p>Service: <code>kuadrant-bind9</code> in namespace <code>kuadrant-bind9</code></p> <ul> <li>Type: LoadBalancer (provides external IP for DNS queries)</li> <li>Ports: 53 (TCP/UDP) \u2192 1053 (container port)</li> <li>Purpose: Acts as authoritative DNS server for <code>example.com</code> zone</li> </ul> <p>Initial Zone: <code>example.com</code></p> <ul> <li>Pre-configured with SOA and NS records</li> <li>Allows dynamic updates via TSIG key authentication</li> <li>Supports zone transfers (AXFR) for verification</li> </ul> <p>TSIG Key: <code>config/bind9/ddns.key</code></p> <ul> <li>Provides authenticated dynamic DNS updates</li> <li>Required for nsupdate commands</li> <li>Algorithm: HMAC-SHA256</li> </ul>"},{"location":"dns-operator/docs/coredns/zone-delegation/#step-1-verify-bind9-installation","title":"Step 1: Verify BIND9 Installation","text":"<p>Check that BIND9 is running:</p> <pre><code>kubectl get deployments -l app.kubernetes.io/name=bind9 -A\n</code></pre> <p>Expected output: <pre><code>NAMESPACE        NAME   READY   UP-TO-DATE   AVAILABLE   AGE\nkuadrant-bind9   edge   1/1     1            1           22s\n</code></pre></p> <p>Note: The label selector <code>app.kubernetes.io/name=bind9</code> works even though the deployment.yaml shows <code>app: edge</code> because Kustomize applies common labels during deployment (see <code>config/bind9/kustomization.yaml</code>). The actual deployment gets both labels applied.</p> <p>Retrieve the BIND9 LoadBalancer IP (external DNS server address):</p> <pre><code>EDGE_NS=\"$(kubectl get service/kuadrant-bind9 -n kuadrant-bind9 \\\n  -o jsonpath='{.status.loadBalancer.ingress[0].ip}')\"\necho \"BIND9 DNS Server: ${EDGE_NS}\"\n</code></pre> <p>Verify the <code>example.com</code> zone exists by querying the SOA record:</p> <pre><code>dig @${EDGE_NS} soa example.com +norec\n</code></pre> <p>Expected output: <pre><code>;; ANSWER SECTION:\nexample.com.            30      IN      SOA     example.com. root.example.com. 16 30 30 30 30\n\n;; AUTHORITY SECTION:\nexample.com.            30      IN      NS      ns.example.com.\n</code></pre></p> <p>The <code>+norec</code> flag prevents recursion, ensuring we query BIND9 directly as an authoritative server.</p>"},{"location":"dns-operator/docs/coredns/zone-delegation/#step-2-identify-coredns-instances","title":"Step 2: Identify CoreDNS Instances","text":"<p>List all CoreDNS instances running in the cluster:</p> <pre><code>kubectl get service -A \\\n  -l app.kubernetes.io/name=coredns,app.kubernetes.io/component!=metrics\n</code></pre> <p>Expected output: <pre><code>NAMESPACE          NAME               TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)                     AGE\nkuadrant-coredns   kuadrant-coredns   LoadBalancer   10.96.242.254   172.18.0.16   53:31680/UDP,53:31680/TCP   31m\n</code></pre></p> <p>Note: The <code>app.kubernetes.io/component!=metrics</code> label filter excludes metrics services, showing only DNS-serving instances.</p> <p>Verify CoreDNS is configured to serve the <code>k.example.com</code> zone by checking logs:</p> <pre><code>kubectl logs -n kuadrant-coredns deployment/kuadrant-coredns | \\\n  grep \"Starting informer\"\n</code></pre> <p>Expected log output: <pre><code>[INFO] plugin/kuadrant: Starting informer 0 for zone k.example.com.\n</code></pre></p> <p>Get the CoreDNS LoadBalancer IP (used for delegation):</p> <pre><code>CORE_NS=\"$(kubectl get service -A \\\n  -l app.kubernetes.io/name=coredns,app.kubernetes.io/component!=metrics \\\n  -o jsonpath='{.items[0].status.loadBalancer.ingress[0].ip}')\"\necho \"CoreDNS Server: ${CORE_NS}\"\n</code></pre> <p>Note: In multi-cluster scenarios, you would retrieve multiple IPs and create multiple NS records.</p>"},{"location":"dns-operator/docs/coredns/zone-delegation/#step-3-delegate-zone-to-coredns","title":"Step 3: Delegate Zone to CoreDNS","text":""},{"location":"dns-operator/docs/coredns/zone-delegation/#understanding-the-delegation","title":"Understanding the Delegation","text":"<p>To delegate <code>k.example.com</code> to CoreDNS, we need to add two records to the parent zone (<code>example.com</code>):</p> <ol> <li>NS Record: <code>k.example.com 300 IN NS ns1.k.example.com</code></li> <li> <p>Declares that <code>ns1.k.example.com</code> is authoritative for <code>k.example.com</code></p> </li> <li> <p>A Record (Glue Record): <code>ns1.k.example.com 300 IN A &lt;CORE_NS&gt;</code></p> </li> <li>Provides the IP address of the CoreDNS server</li> <li>Required because the nameserver is within the delegated zone (RFC 1034)</li> </ol> <p>Without the glue record, recursive resolvers would have a circular dependency:</p> <ul> <li>To resolve <code>k.example.com</code>, query <code>ns1.k.example.com</code></li> <li>To resolve <code>ns1.k.example.com</code>, query <code>k.example.com</code> \u2192 circular lookup</li> </ul>"},{"location":"dns-operator/docs/coredns/zone-delegation/#generate-nsupdate-file","title":"Generate nsupdate File","text":"<p>Create a dynamic DNS update file:</p> <pre><code>EDGE_NS=\"$(kubectl get service/kuadrant-bind9 -n kuadrant-bind9 \\\n  -o jsonpath='{.status.loadBalancer.ingress[0].ip}')\"\nCORE_NS=\"$(kubectl get service -A \\\n  -l app.kubernetes.io/name=coredns,app.kubernetes.io/component!=metrics \\\n  -o jsonpath='{.items[0].status.loadBalancer.ingress[0].ip}')\"\n\ncat &lt;&lt;EOF &gt;nsupdate-k-example-com\nserver ${EDGE_NS}\ndebug yes\nzone example.com.\nupdate add k.example.com 300 IN NS ns1.k.example.com\nupdate add ns1.k.example.com 300 IN A ${CORE_NS}\nsend\nEOF\n</code></pre> <p>Verify the generated file:</p> <pre><code>cat nsupdate-k-example-com\n</code></pre> <p>Example output: <pre><code>server 172.18.0.17\ndebug yes\nzone example.com.\nupdate add k.example.com 300 IN NS ns1.k.example.com\nupdate add ns1.k.example.com 300 IN A 172.18.0.16\nsend\n</code></pre></p>"},{"location":"dns-operator/docs/coredns/zone-delegation/#apply-the-update","title":"Apply the Update","text":"<p>Use <code>nsupdate</code> with TSIG key authentication to apply the changes:</p> <pre><code>nsupdate -k config/bind9/ddns.key -v nsupdate-k-example-com\n</code></pre> <p>Expected output: <pre><code>Sending update to 172.18.0.17#53\nOutgoing update query:\n;; UPDATE SECTION:\nk.example.com.          300     IN      NS      ns1.k.example.com.\nns1.k.example.com.      300     IN      A       172.18.0.16\n\nReply from update query:\n;; -&gt;&gt;HEADER&lt;&lt;- opcode: UPDATE, status: NOERROR\n</code></pre></p>"},{"location":"dns-operator/docs/coredns/zone-delegation/#verify-zone-delegation","title":"Verify Zone Delegation","text":"<p>1. Verify via zone transfer (AXFR):</p> <pre><code>dig @${EDGE_NS} -k config/bind9/ddns.key -t AXFR example.com\n</code></pre> <p>Expected output (showing the new delegation records): <pre><code>example.com.            30      IN      SOA     example.com. root.example.com. 17 30 30 30 30\nexample.com.            30      IN      NS      ns.example.com.\nk.example.com.          300     IN      NS      ns1.k.example.com.\nns1.k.example.com.      300     IN      A       172.18.0.16\nns.example.com.         30      IN      A       127.0.0.1\nexample.com.            30      IN      SOA     example.com. root.example.com. 17 30 30 30 30\n</code></pre></p> <p>The presence of the <code>k.example.com NS</code> and <code>ns1.k.example.com A</code> records confirms successful delegation.</p> <p>2. Verify SOA record of delegated zone:</p> <pre><code>dig @${EDGE_NS} soa k.example.com\n</code></pre> <p>Expected output: <pre><code>;; ANSWER SECTION:\nk.example.com.          60      IN      SOA     ns1.k.example.com. hostmaster.k.example.com. 12345 7200 1800 86400 60\n</code></pre></p> <p>The SOA record should show <code>ns1.k.example.com</code> as the primary nameserver, confirming CoreDNS is responding authoritatively.</p>"},{"location":"dns-operator/docs/coredns/zone-delegation/#step-4-test-delegation-with-dnsrecord","title":"Step 4: Test Delegation with DNSRecord","text":"<p>Create a test DNSRecord to verify end-to-end delegation:</p> <pre><code># Run from the repository root directory\nkubectl apply -f coredns/examples/dnsrecord-api-k-example-com_geo_weight.yaml\n</code></pre> <p>Create the provider secret:</p> <p>The DNSRecord includes <code>providerRef: dns-provider-credentials-coredns</code>. For DNS Operator to reconcile this DNSRecord, the provider secret must exist in the namespace.</p> <p>Why the secret is required:</p> <ul> <li>DNS Operator uses the secret's <code>ZONES</code> field for zone matching (matching <code>rootHost</code> to an available zone)</li> <li>After zone matching succeeds, DNS Operator applies the <code>kuadrant.io/coredns-zone-name</code> label</li> <li>CoreDNS plugin watches for this label and serves the DNSRecord</li> <li>Without the secret, DNS Operator reconciliation will fail even if you manually apply the label</li> </ul> <p>Create the provider secret:</p> <pre><code>kubectl create secret generic dns-provider-credentials-coredns -n dnstest \\\n  --type=kuadrant.io/coredns \\\n  --from-literal=ZONES=\"k.example.com\"\n</code></pre> <p>DNS Operator will automatically apply the zone label within a few seconds after the secret is created.</p> <p>Note: For more details on provider secrets, zone matching, and automatic vs manual labeling scenarios, see Provider Secret Configuration.</p> <p>Query the delegated DNS record via BIND9:</p> <pre><code>dig @${EDGE_NS} api.k.example.com +short\n</code></pre> <p>Expected output: <pre><code>klb.api.k.example.com.\ngeo-us.klb.api.k.example.com.\ncluster1.klb.api.k.example.com.\n127.0.0.1\n</code></pre></p> <p>This output shows:</p> <ol> <li>BIND9 received the query for <code>api.k.example.com</code></li> <li>BIND9 delegated to CoreDNS (<code>ns1.k.example.com</code>)</li> <li>CoreDNS returned the CNAME chain and IP address</li> <li>The delegation is working correctly</li> </ol>"},{"location":"dns-operator/docs/coredns/zone-delegation/#step-5-configure-in-cluster-dns-forwarding-optional","title":"Step 5: Configure In-Cluster DNS Forwarding (Optional)","text":"<p>This step enables pods running inside the cluster to resolve DNS records via the BIND9 edge server. This is useful for:</p> <ul> <li>Testing DNS Groups active-passive failover</li> <li>Simulating external DNS resolution from inside the cluster</li> <li>Resolving external TXT records (e.g., <code>kuadrant-active-groups.example.com</code>)</li> </ul>"},{"location":"dns-operator/docs/coredns/zone-delegation/#update-cluster-coredns-forwarder","title":"Update Cluster CoreDNS Forwarder","text":"<p>Get the BIND9 ClusterIP (in-cluster service address):</p> <pre><code>CLUSTER_EDGE_NS=\"$(kubectl get service/kuadrant-bind9 -n kuadrant-bind9 \\\n  -o jsonpath='{.spec.clusterIP}')\"\necho \"BIND9 ClusterIP: ${CLUSTER_EDGE_NS}\"\n</code></pre> <p>Note: We use <code>clusterIP</code> (not LoadBalancer <code>ingress</code> IP) because pods communicate with Services via internal Kubernetes networking.</p> <p>Retrieve the current kube-system CoreDNS Corefile:</p> <pre><code>kubectl get configmap/coredns -n kube-system \\\n  -o jsonpath='{.data.Corefile}' &gt; kube.Corefile\n</code></pre> <p>Prepend <code>example.com</code> zone forwarding to the Corefile:</p> <pre><code>ZONE=example.com\ncat &lt;&lt;EOF | cat - kube.Corefile &gt; /tmp/kube.Corefile.new &amp;&amp; mv /tmp/kube.Corefile.new kube.Corefile\n${ZONE}:53 {\n    forward . ${CLUSTER_EDGE_NS}\n}\nEOF\n</code></pre> <p>Review the updated Corefile:</p> <pre><code>cat kube.Corefile\n</code></pre> <p>Expected output (showing the new zone block at the top): <pre><code>example.com:53 {\n    forward . 10.96.123.45\n}\n\n.:53 {\n    errors\n    health\n    ...\n}\n</code></pre></p> <p>Apply the updated Corefile:</p> <pre><code>kubectl create configmap coredns -n kube-system \\\n  --from-file=Corefile=kube.Corefile --dry-run=client -o yaml | kubectl apply -f -\n</code></pre>"},{"location":"dns-operator/docs/coredns/zone-delegation/#verify-in-cluster-dns-resolution","title":"Verify In-Cluster DNS Resolution","text":"<p>Test that pods can resolve records via the edge server:</p> <pre><code>kubectl run -n default dig --attach --rm --restart=Never \\\n  --image=docker.io/curlimages/curl:latest \\\n  -- sh -c \"apk add --no-cache bind-tools &amp;&amp; dig k.example.com NS +short\"\n</code></pre> <p>Expected output: <pre><code>ns1.k.example.com.\n</code></pre></p> <p>Alternative verification using a long-running pod:</p> <pre><code>kubectl run -n default test-dns --image=docker.io/curlimages/curl:latest \\\n  --command -- sleep 3600\nkubectl exec -n default test-dns -- sh -c \\\n  \"apk add --no-cache bind-tools &amp;&amp; dig k.example.com NS +short\"\nkubectl delete pod -n default test-dns\n</code></pre> <p>Note: We replaced the <code>toolbelt/dig</code> image with <code>curlimages/curl</code> (a well-maintained, official image) and install <code>bind-tools</code> for DNS utilities.</p>"},{"location":"dns-operator/docs/coredns/zone-delegation/#step-6-configure-dns-groups-active-groups-resolution-optional","title":"Step 6: Configure DNS Groups Active-Groups Resolution (Optional)","text":"<p>For complete DNS Groups documentation, see the DNS Groups Configuration section, which covers: - What DNS Groups are and how active-passive failover works - Configuring DNS Operator with group identifiers - Creating and managing active groups TXT records</p> <p>For failover procedures, see Exercising DNS Failover via Groups</p> <p>Prerequisites for this step:</p> <ul> <li>Understanding of DNS Groups concept (see link above)</li> <li>DNS Operator configured with <code>GROUP</code> environment variable or <code>--group</code> flag</li> <li>Step 5 completed (in-cluster DNS forwarding configured)</li> </ul> <p>What's different for BIND9 delegation: With parent zone delegation, the active-groups TXT record lives in the parent zone (<code>example.com</code>) rather than an external DNS provider. DNS Operator queries <code>kuadrant-active-groups.k.example.com</code>, so we need kuadrant-coredns to rewrite this to <code>k.kuadrant-active-groups.example.com</code> and forward to BIND9.</p>"},{"location":"dns-operator/docs/coredns/zone-delegation/#add-active-groups-txt-record","title":"Add Active-Groups TXT Record","text":"<p>For BIND9 (local development), use nsupdate:</p> <pre><code>EDGE_NS=\"$(kubectl get service/kuadrant-bind9 -n kuadrant-bind9 \\\n  -o jsonpath='{.status.loadBalancer.ingress[0].ip}')\"\n\ncat &lt;&lt;EOF &gt;nsupdate-active-groups\nserver ${EDGE_NS}\nzone example.com.\nupdate add k.kuadrant-active-groups.example.com 300 TXT \"version=1;groups=primary-us-east\"\nsend\nEOF\n\nnsupdate -k config/bind9/ddns.key -v nsupdate-active-groups\n</code></pre> <p>For production (cloud DNS providers), use the DNS CLI instead:</p> <pre><code># Build the CLI (run once)\nmake build-cli\n\n# Add active group using DNS CLI\nkubectl-kuadrant_dns add-active-group primary-us-east \\\n  --providerRef &lt;namespace&gt;/&lt;secret-name&gt; \\\n  --domain &lt;your-domain&gt;\n</code></pre> <p>Where <code>&lt;secret-name&gt;</code> is your AWS/GCP/Azure provider secret. The CLI automatically creates the TXT record in the correct format and handles multiple zones.</p>"},{"location":"dns-operator/docs/coredns/zone-delegation/#add-rewrite-rule-to-kuadrant-coredns","title":"Add Rewrite Rule to Kuadrant CoreDNS","text":"<p>Add a rewrite rule to the kuadrant-coredns Corefile using the same pattern from Step 5:</p> <pre><code>CLUSTER_EDGE_NS=\"$(kubectl get service/kuadrant-bind9 -n kuadrant-bind9 \\\n  -o jsonpath='{.spec.clusterIP}')\"\n\nkubectl get configmap/kuadrant-coredns -n kuadrant-coredns \\\n  -o jsonpath='{.data.Corefile}' &gt; kuadrant.Corefile\n\ncat &lt;&lt;EOF | cat - kuadrant.Corefile &gt; /tmp/kuadrant.Corefile.new &amp;&amp; mv /tmp/kuadrant.Corefile.new kuadrant.Corefile\nkuadrant-active-groups.k.example.com {\n    rewrite name exact kuadrant-active-groups.k.example.com k.kuadrant-active-groups.example.com\n    forward . ${CLUSTER_EDGE_NS}\n}\nEOF\n\nkubectl create configmap kuadrant-coredns -n kuadrant-coredns \\\n  --from-file=Corefile=kuadrant.Corefile --dry-run=client -o yaml | kubectl apply -f -\n\nkubectl rollout restart -n kuadrant-coredns deployment/kuadrant-coredns\n</code></pre>"},{"location":"dns-operator/docs/coredns/zone-delegation/#verify","title":"Verify","text":"<p>Test that DNS Groups active-groups resolution works:</p> <pre><code>kubectl run -n default dig-test --attach --rm --restart=Never \\\n  --image=docker.io/curlimages/curl:latest \\\n  -- sh -c \"apk add --no-cache bind-tools &amp;&amp; dig kuadrant-active-groups.k.example.com TXT +short\"\n</code></pre> <p>Expected: <code>\"version=1;groups=primary-us-east\"</code></p>"},{"location":"dns-operator/docs/coredns/zone-delegation/#additional-commands","title":"Additional Commands","text":""},{"location":"dns-operator/docs/coredns/zone-delegation/#generate-new-ddns-key","title":"Generate New DDNS Key","text":"<p>If you need to regenerate the TSIG key:</p> <pre><code>ddns-confgen -k example.com-key -z example.com.\n</code></pre> <p>This outputs configuration for both BIND9 named.conf and the key file.</p>"},{"location":"dns-operator/docs/coredns/zone-delegation/#monitor-all-dns-logs","title":"Monitor All DNS Logs","text":"<p>Tail logs from both CoreDNS and BIND9:</p> <pre><code>kubectl stern -l 'app.kubernetes.io/name in (coredns, bind9)' -A\n</code></pre> <p>Note: Requires stern to be installed.</p>"},{"location":"dns-operator/docs/coredns/zone-delegation/#verify-bind9-configuration-files","title":"Verify BIND9 Configuration Files","text":"<p>The BIND9 deployment includes:</p> <p>Zone Configuration (<code>config/bind9/zone.yaml</code>):</p> <ul> <li>Defines <code>example.com</code> zone</li> <li>Configures TSIG key for authentication</li> <li>Allows dynamic updates and zone transfers</li> </ul> <p>DDNS Key (<code>config/bind9/ddns.key</code>):</p> <ul> <li>TSIG key for authenticated updates</li> <li>Algorithm: HMAC-SHA256</li> <li>Used with <code>-k</code> flag in nsupdate and dig commands</li> </ul> <p>Deployment (<code>config/bind9/deployment.yaml</code>):</p> <ul> <li>Runs BIND9 in namespace <code>kuadrant-bind9</code></li> <li>Listens on container port 1053</li> <li>Mounts zone configuration and DDNS key</li> </ul> <p>Service (<code>config/bind9/service.yaml</code>):</p> <ul> <li>Type: LoadBalancer</li> <li>Exposes port 53 (DNS standard) \u2192 1053 (container)</li> <li>Provides external IP for DNS queries</li> </ul>"},{"location":"dns-operator/docs/coredns/zone-delegation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"dns-operator/docs/coredns/zone-delegation/#nsupdate-fails-with-update-failed-notauth","title":"nsupdate Fails with \"update failed: NOTAUTH\"","text":"<p>Cause: TSIG key authentication failed.</p> <p>Solution:</p> <ul> <li>Verify key file path: <code>config/bind9/ddns.key</code></li> <li>Ensure key name in file matches zone configuration: <code>example.com-key</code></li> <li>Check that you're running from repository root</li> </ul>"},{"location":"dns-operator/docs/coredns/zone-delegation/#dig-shows-servfail-for-delegated-zone","title":"dig Shows SERVFAIL for Delegated Zone","text":"<p>Cause: Delegation records not properly configured.</p> <p>Solution:</p> <ol> <li> <p>Verify NS record exists:    <pre><code>dig @${EDGE_NS} k.example.com NS +short\n</code></pre>    Should return: <code>ns1.k.example.com.</code></p> </li> <li> <p>Verify glue record exists:    <pre><code>dig @${EDGE_NS} ns1.k.example.com A +short\n</code></pre>    Should return CoreDNS LoadBalancer IP</p> </li> <li> <p>Check zone transfer to see all records:    <pre><code>dig @${EDGE_NS} -k config/bind9/ddns.key -t AXFR example.com\n</code></pre></p> </li> </ol>"},{"location":"dns-operator/docs/coredns/zone-delegation/#coredns-not-serving-dnsrecord","title":"CoreDNS Not Serving DNSRecord","text":"<p>Cause: Missing zone label on DNSRecord.</p> <p>Solution: Add the label to tell CoreDNS to serve this record: <pre><code>kubectl label dnsrecords.kuadrant.io/&lt;name&gt; -n &lt;namespace&gt; \\\n  kuadrant.io/coredns-zone-name=k.example.com\n</code></pre></p>"},{"location":"dns-operator/docs/coredns/zone-delegation/#pods-cant-resolve-examplecom-records","title":"Pods Can't Resolve example.com Records","text":"<p>Cause: kube-system CoreDNS not configured to forward to BIND9.</p> <p>Solution: Verify forwarding configuration exists in kube-system CoreDNS: <pre><code>kubectl get configmap/coredns -n kube-system -o yaml\n</code></pre></p> <p>Should contain: <pre><code>example.com:53 {\n    forward . &lt;CLUSTER_EDGE_NS&gt;\n}\n</code></pre></p>"},{"location":"dns-operator/docs/coredns/zone-delegation/#active-groups-txt-record-returns-nxdomain","title":"Active-Groups TXT Record Returns NXDOMAIN","text":"<p>Cause: Rewrite rule not applied or incorrect.</p> <p>Solution:</p> <ol> <li> <p>Check kuadrant-coredns Corefile:    <pre><code>kubectl get configmap/kuadrant-coredns -n kuadrant-coredns \\\n  -o jsonpath='{.data.Corefile}'\n</code></pre></p> </li> <li> <p>Verify rewrite syntax:    <pre><code>rewrite name exact kuadrant-active-groups.k.example.com k.kuadrant-active-groups.example.com\n</code></pre></p> </li> <li> <p>Restart CoreDNS after configuration changes:    <pre><code>kubectl rollout restart -n kuadrant-coredns deployment/kuadrant-coredns\n</code></pre></p> </li> </ol>"},{"location":"dns-operator/docs/coredns/zone-delegation/#related-documentation","title":"Related Documentation","text":"<ul> <li>CoreDNS Local Development Guide - Getting started with CoreDNS integration</li> <li>CoreDNS Configuration Reference - Comprehensive configuration options</li> <li>DNS Groups Configuration - Active-passive failover setup</li> <li>Provider Secret Configuration - CoreDNS provider secrets</li> </ul>"},{"location":"developer-portal-controller/docs/references/apikey/","title":"The APIKey Custom Resource Definition (CRD)","text":""},{"location":"developer-portal-controller/docs/references/apikey/#overview","title":"Overview","text":"<p>The APIKey CRD is part of the Developer Portal extension for Kuadrant. It represents a request for API access credentials by a developer for a specific APIProduct and plan tier. When approved, the APIKey creates a Kubernetes Secret containing the actual API key that can be used to authenticate requests. The APIKey resource manages the entire lifecycle of API access requests, from initial submission through approval/rejection to credential generation.</p>"},{"location":"developer-portal-controller/docs/references/apikey/#apikey","title":"APIKey","text":"Field Type Required Description <code>spec</code> APIKeySpec Yes The specification for APIKey custom resource <code>status</code> APIKeyStatus No The status for the custom resource"},{"location":"developer-portal-controller/docs/references/apikey/#apikeyspec","title":"APIKeySpec","text":"Field Type Required Description <code>apiProductRef</code> APIProductReference Yes Reference to the APIProduct this API key provides access to <code>planTier</code> String Yes Tier of the plan (e.g., \"premium\", \"basic\", \"enterprise\") <code>requestedBy</code> RequestedBy Yes Information about who requested the API key <code>useCase</code> String Yes Description of how the API key will be used"},{"location":"developer-portal-controller/docs/references/apikey/#apiproductreference","title":"APIProductReference","text":"Field Type Required Description <code>name</code> String Yes Name of the APIProduct in the same namespace"},{"location":"developer-portal-controller/docs/references/apikey/#requestedby","title":"RequestedBy","text":"Field Type Required Description <code>userId</code> String Yes Identifier of the user requesting the API key <code>email</code> String Yes Email address of the user (must be valid email format)"},{"location":"developer-portal-controller/docs/references/apikey/#apikeystatus","title":"APIKeyStatus","text":"Field Type Description <code>phase</code> String Current phase of the APIKey. Valid values: <code>Pending</code>, <code>Approved</code>, <code>Rejected</code> <code>conditions</code> []ConditionSpec Represents the observations of the APIKey's current state <code>secretRef</code> SecretReference Reference to the created Secret containing the API key (only when Approved) <code>limits</code> Limits Rate limits for the plan <code>apiHostname</code> String Hostname from the HTTPRoute that the APIProduct references <code>reviewedBy</code> String Who approved or rejected the request <code>reviewedAt</code> Timestamp When the request was reviewed <code>canReadSecret</code> Boolean Permission to read the APIKey's secret. Default: <code>true</code>"},{"location":"developer-portal-controller/docs/references/apikey/#conditionspec","title":"ConditionSpec","text":"<p>Standard Kubernetes condition type with the following fields:</p> Field Type Description <code>type</code> String Condition type (e.g., <code>Ready</code>) <code>status</code> String Status of the condition: <code>True</code>, <code>False</code>, or <code>Unknown</code> <code>reason</code> String Unique, one-word, CamelCase reason for the condition's last transition <code>message</code> String Human-readable message indicating details about the transition <code>lastTransitionTime</code> Timestamp Last time the condition transitioned from one status to another <code>observedGeneration</code> Integer The .metadata.generation that the condition was set based upon"},{"location":"developer-portal-controller/docs/references/apikey/#secretreference","title":"SecretReference","text":"Field Type Required Description <code>name</code> String Yes Name of the secret in the Authorino's namespace <code>key</code> String Yes The key of the secret to select from"},{"location":"developer-portal-controller/docs/references/apikey/#limits","title":"Limits","text":"Field Type Required Description <code>daily</code> Integer No Daily limit of requests for this plan <code>weekly</code> Integer No Weekly limit of requests for this plan <code>monthly</code> Integer No Monthly limit of requests for this plan <code>yearly</code> Integer No Yearly limit of requests for this plan <code>custom</code> []Rate No Additional limits defined in terms of a RateLimitPolicy Rate"},{"location":"developer-portal-controller/docs/references/apikey/#rate","title":"Rate","text":"Field Type Required Description <code>limit</code> Integer Yes Maximum value allowed for a given period of time <code>window</code> String Yes Time period for which the limit applies (pattern: <code>^([0-9]{1,5}(h\\|m\\|s\\|ms)){1,4}$</code>)"},{"location":"developer-portal-controller/docs/references/apikey/#high-level-example","title":"High level example","text":"<pre><code>apiVersion: devportal.kuadrant.io/v1alpha1\nkind: APIKey\nmetadata:\n  name: developer-john-premium\n  namespace: payment-services\nspec:\n  apiProductRef:\n    name: payment-api\n  planTier: premium\n  requestedBy:\n    userId: john-doe-123\n    email: john.doe@example.com\n  useCase: Building a mobile payment application for retail customers\n</code></pre>"},{"location":"developer-portal-controller/docs/references/apikey/#relationship-to-apiproduct-and-authpolicy","title":"Relationship to APIProduct and AuthPolicy","text":""},{"location":"developer-portal-controller/docs/references/apikey/#apiproduct","title":"APIProduct","text":"<p>APIKey must reference an existing APIProduct via <code>apiProductRef</code>. The APIProduct defines the API being accessed.</p>"},{"location":"developer-portal-controller/docs/references/apikey/#authpolicy","title":"AuthPolicy","text":"<p>AuthPolicy is applied to the HTTPRoute that the APIProduct references. When an APIKey is approved, a Kubernetes Secret is created with an annotation <code>secret.kuadrant.io/plan-id</code> value. The AuthPolicy validates incoming API requests by checking the API key against secrets that match specific label selectors.</p>"},{"location":"developer-portal-controller/docs/references/apikey/#planpolicy","title":"PlanPolicy","text":"<p>PlanPolicy defines the available tiers and their corresponding rate limits. When an APIKey specifies a <code>planTier</code>, the controller validates that this tier exists in the PlanPolicy attached to the HTTPRoute. If the tier is valid and the APIKey is approved, the Secret is annotated with <code>secret.kuadrant.io/plan-id: &lt;planTier&gt;</code>, allowing PlanPolicy's CEL predicates to match the request to the appropriate rate limits.</p>"},{"location":"developer-portal-controller/docs/references/apiproduct/","title":"The APIProduct Custom Resource Definition (CRD)","text":""},{"location":"developer-portal-controller/docs/references/apiproduct/#overview","title":"Overview","text":"<p>The APIProduct CRD is part of the Developer Portal extension for Kuadrant. It references an HTTPRoute and adds product catalog information, enabling APIs to be published to a developer portal (Backstage) where they can be discovered and consumed. While HTTPRoute defines the technical routing configuration, APIProduct adds the business and organizational context needed for API consumption: human-readable names, descriptions, documentation links, contact information, versioning, and approval workflows. </p>"},{"location":"developer-portal-controller/docs/references/apiproduct/#apiproduct","title":"APIProduct","text":"Field Type Required Description <code>spec</code> APIProductSpec Yes The specification for APIProduct custom resource <code>status</code> APIProductStatus No The status for the custom resource"},{"location":"developer-portal-controller/docs/references/apiproduct/#apiproductspec","title":"APIProductSpec","text":"Field Type Required Description <code>targetRef</code> Gateway API LocalPolicyTargetReference Yes Reference to the HTTPRoute that the API product represents <code>displayName</code> String Yes Human-readable name for the API product shown in the developer portal <code>approvalMode</code> String Yes Whether access requests are auto-approved or require manual review. Valid values: <code>automatic</code>, <code>manual</code>. Default: <code>manual</code> <code>publishStatus</code> String Yes Controls whether the API product appears in the Backstage catalog. Valid values: <code>Draft</code>, <code>Published</code>. Default: <code>Draft</code> <code>description</code> String No Detailed description of the API product <code>version</code> String No API version (e.g., v1, v2) <code>tags</code> []String No Tags for categorization and search in the developer portal <code>contact</code> ContactInfo No Contact information for API owners <code>documentation</code> Documentation No API documentation links"},{"location":"developer-portal-controller/docs/references/apiproduct/#localpolicytargetreference","title":"LocalPolicyTargetReference","text":"Field Type Required Description <code>group</code> String Yes Group of the target resource. Must be <code>gateway.networking.k8s.io</code> <code>kind</code> String Yes Kind of the target resource. Must be <code>HTTPRoute</code> <code>name</code> String Yes Name of the target HTTPRoute resource"},{"location":"developer-portal-controller/docs/references/apiproduct/#contactinfo","title":"ContactInfo","text":"Field Type Required Description <code>team</code> String No Team name <code>email</code> String No Contact email <code>slack</code> String No Slack channel (e.g., #api-support) <code>url</code> String No URL to team page or support portal"},{"location":"developer-portal-controller/docs/references/apiproduct/#documentation","title":"Documentation","text":"Field Type Required Description <code>docsURL</code> String No URL to general documentation <code>openAPISpecURL</code> String No URL to OpenAPI specification (JSON/YAML) <code>swaggerUI</code> String No URL to Swagger UI or similar interactive documentation <code>gitRepository</code> String No URL to git repository (shown as \"View Source\" in Backstage) <code>techdocsRef</code> String No Techdocs reference (e.g., <code>url:https://github.com/org/repo</code> or <code>dir:.</code> for local docs)"},{"location":"developer-portal-controller/docs/references/apiproduct/#apiproductstatus","title":"APIProductStatus","text":"Field Type Description <code>observedGeneration</code> Integer ObservedGeneration reflects the generation of the most recently observed spec <code>conditions</code> []ConditionSpec Represents the observations of the APIProduct's current state <code>discoveredPlans</code> []PlanSpec List of PlanPolicies discovered from the HTTPRoute <code>discoveredAuthScheme</code> AuthSchemeSpec Authentication scheme discovered from the HTTPRoute's AuthPolicy <code>openapi</code> OpenAPIStatus OpenAPI specification fetched from the API and its sync status"},{"location":"developer-portal-controller/docs/references/apiproduct/#conditionspec","title":"ConditionSpec","text":"<p>Standard Kubernetes condition type with the following fields:</p> Field Type Description <code>type</code> String Condition type (e.g., <code>Ready</code>) <code>status</code> String Status of the condition: <code>True</code>, <code>False</code>, or <code>Unknown</code> <code>reason</code> String Unique, one-word, CamelCase reason for the condition's last transition <code>message</code> String Human-readable message indicating details about the transition <code>lastTransitionTime</code> Timestamp Last time the condition transitioned from one status to another <code>observedGeneration</code> Integer The .metadata.generation that the condition was set based upon"},{"location":"developer-portal-controller/docs/references/apiproduct/#planspec","title":"PlanSpec","text":"Field Type Required Description <code>tier</code> String Yes Tier this plan represents <code>limits</code> Limits No Rate limits that the plan enforces"},{"location":"developer-portal-controller/docs/references/apiproduct/#limits","title":"Limits","text":"Field Type Required Description <code>daily</code> Integer No Daily limit of requests for this plan <code>weekly</code> Integer No Weekly limit of requests for this plan <code>monthly</code> Integer No Monthly limit of requests for this plan <code>yearly</code> Integer No Yearly limit of requests for this plan <code>custom</code> []Rate No Additional limits defined in terms of a RateLimitPolicy Rate"},{"location":"developer-portal-controller/docs/references/apiproduct/#rate","title":"Rate","text":"Field Type Required Description <code>limit</code> Integer Yes Maximum value allowed for a given period of time <code>window</code> String Yes Time period for which the limit applies (pattern: <code>^([0-9]{1,5}(h\\|m\\|s\\|ms)){1,4}$</code>)"},{"location":"developer-portal-controller/docs/references/apiproduct/#openapistatus","title":"OpenAPIStatus","text":"Field Type Required Description <code>raw</code> String Yes Raw OpenAPI specification content <code>lastSyncTime</code> Timestamp Yes Last time the raw content was updated"},{"location":"developer-portal-controller/docs/references/apiproduct/#high-level-example","title":"High level example","text":"<pre><code>apiVersion: devportal.kuadrant.io/v1alpha1\nkind: APIProduct\nmetadata:\n  name: payment-api\n  namespace: payment-services\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: payment-route\n  displayName: Payment Processing API\n  description: |\n    Secure API for processing payments, managing transactions,\n    and handling refunds. Supports multiple payment methods\n    including credit cards, digital wallets, and bank transfers.\n  version: v2\n  approvalMode: automatic\n  publishStatus: Published\n  tags:\n\n    - payments\n    - fintech\n    - transactions\n  contact:\n    team: Payment Platform Team\n    email: payment-api@example.com\n    slack: \"#payment-support\"\n    url: https://wiki.example.com/teams/payment-platform\n  documentation:\n    docsURL: https://docs.example.com/apis/payment\n    openAPISpecURL: https://api.example.com/specs/payment-v2.yaml\n    swaggerUI: https://api.example.com/docs/payment\n    gitRepository: https://github.com/example/payment-api\n    techdocsRef: url:https://github.com/example/payment-api/tree/main/docs\n</code></pre>"},{"location":"developer-portal-controller/docs/references/apiproduct/#relationship-to-httproute-authpolicy-planpolicy","title":"Relationship to HTTPRoute, AuthPolicy, PlanPolicy","text":""},{"location":"developer-portal-controller/docs/references/apiproduct/#httproute","title":"HTTPRoute","text":"<p>APIProduct must reference an existing HTTPRoute via <code>targetRef</code>. The HTTPRoute defines the actual traffic routing and path matching, while APIProduct adds product catalog metadata, documentation, and plan discovery.</p>"},{"location":"developer-portal-controller/docs/references/apiproduct/#authpolicy","title":"AuthPolicy","text":"<p>AuthPolicy is applied to the same HTTPRoute that the APIProduct references. This enforces authentication (such as API key validation) for requests to the API. When a developer requests access to an APIProduct, an APIKey resource is created, which generates a Kubernetes Secret. The AuthPolicy validates incoming requests against these secrets.</p>"},{"location":"developer-portal-controller/docs/references/apiproduct/#planpolicy","title":"PlanPolicy","text":"<p>PlanPolicy is an extension that can target the same HTTPRoute as the APIProduct. It defines tiered access plans with different rate limits. The APIProduct controller automatically discovers PlanPolicies attached to the same HTTPRoute and surfaces the plan information in the <code>status.discoveredPlans</code> field. This allows the developer portal to display available plans to users requesting API access.</p>"},{"location":"kuadrant-backstage-plugin/","title":"Kuadrant Backstage Plugins","text":"<p>Backstage plugins for API access management using Kuadrant Gateway API primitives.</p> <p>Looking to install the plugins? See the Installation Guide.</p> <p>This repository is for plugin development. It's based on Red Hat Developer Hub (RHDH).</p>"},{"location":"kuadrant-backstage-plugin/#features","title":"Features","text":"<p>For API consumers:</p> <ul> <li>Request API access with tiered access (bronze, silver, gold)</li> <li>View and manage API keys</li> <li>Track request status (pending, approved, rejected)</li> </ul> <p>For platform engineers:</p> <ul> <li>Approve/reject API access requests</li> <li>Manage API products and tiers</li> <li>Configure rate limits via PlanPolicy</li> </ul> <p>For API owners:</p> <ul> <li>Create API products with multiple tiers</li> <li>Define rate limits and quotas</li> <li>Sync API products from Kubernetes to Backstage catalog</li> </ul>"},{"location":"kuadrant-backstage-plugin/#quick-start","title":"Quick Start","text":"<pre><code># Install dependencies\nyarn install\n\n# Create kind cluster with Kuadrant\ncd kuadrant-dev-setup\nmake kind-create\ncd ..\n\n# Start development server with hot reload\nyarn dev\n</code></pre> <p>Visit:</p> <ul> <li>http://localhost:3000/kuadrant - Main plugin page</li> <li>http://localhost:3000/catalog - Catalog with APIProduct entities</li> <li>http://localhost:3000/catalog/default/api/toystore-api - API with Kuadrant tabs</li> </ul>"},{"location":"kuadrant-backstage-plugin/#architecture","title":"Architecture","text":""},{"location":"kuadrant-backstage-plugin/#plugins","title":"Plugins","text":"<p>Frontend (<code>plugins/kuadrant</code>):</p> <ul> <li>Main Kuadrant page with approval queue</li> <li>API key management tab for API entities</li> <li>API product info tab for APIProduct entities</li> <li>API access request card</li> </ul> <p>Backend (<code>plugins/kuadrant-backend</code>):</p> <ul> <li>Kubernetes integration (@kubernetes/client-node)</li> <li>APIProduct entity provider for catalog sync</li> <li>HTTP API endpoints for API keys and requests</li> <li>Support for explicit cluster config and in-cluster auth</li> </ul>"},{"location":"kuadrant-backstage-plugin/#kubernetes-resources","title":"Kubernetes Resources","text":"<p>Custom CRDs:</p> <ul> <li><code>APIProduct</code> - Defines API products with tiers</li> <li><code>APIKey</code> - Tracks API access requests</li> </ul> <p>Kuadrant components:</p> <ul> <li>Kuadrant operator v1.3.0</li> <li>Gateway API with Istio</li> <li>AuthPolicy for authentication</li> <li>RateLimitPolicy for rate limiting</li> <li>PlanPolicy for tiered access</li> </ul>"},{"location":"kuadrant-backstage-plugin/#development","title":"Development","text":""},{"location":"kuadrant-backstage-plugin/#daily-workflow","title":"Daily Workflow","text":"<pre><code>yarn dev                          # Start with hot reload\n# Make changes to plugin code\n# Browser automatically reloads\n</code></pre>"},{"location":"kuadrant-backstage-plugin/#kubernetes-access","title":"Kubernetes Access","text":"<p>Uses local <code>~/.kube/config</code> for development:</p> <pre><code>kubectl config current-context    # Verify cluster\nkubectl get apiproducts -A        # Check resources\nkubectl get apikeys -A\n</code></pre>"},{"location":"kuadrant-backstage-plugin/#cluster-management","title":"Cluster Management","text":"<pre><code>cd kuadrant-dev-setup\nmake kind-delete                  # Delete cluster\nmake kind-create                  # Recreate with fresh setup\n</code></pre>"},{"location":"kuadrant-backstage-plugin/#building","title":"Building","text":"<pre><code>yarn build                        # Build all packages\nyarn tsc                          # TypeScript compilation\nyarn lint:check                   # Check linting\nyarn test                         # Run tests\n</code></pre>"},{"location":"kuadrant-backstage-plugin/#testing","title":"Testing","text":"<p>Unit Tests: <pre><code>yarn test                       # run all tests\nyarn test --filter=backend      # run tests for specific package\n</code></pre></p> <p>E2E Tests:</p> <p>End-to-end tests use Playwright to test the Kuadrant plugin UI and workflows.</p> <p>Prerequisites:</p> <ol> <li>Kind cluster running with Kuadrant (<code>cd kuadrant-dev-setup &amp;&amp; make kind-create</code>)</li> <li>App running (<code>yarn dev</code> in separate terminal)</li> </ol> <p>Run tests: <pre><code>cd e2e-tests\nyarn test                       # run kuadrant e2e tests\nyarn test:smoke                 # run smoke tests only\n</code></pre></p> <p>Tests available:</p> <ul> <li><code>kuadrant-plugin.spec.ts</code> - basic navigation and rendering tests</li> <li><code>kuadrant-rbac.spec.ts</code> - comprehensive RBAC permission tests covering all personas</li> </ul> <p>The E2E tests verify:</p> <ul> <li>UI navigation and page rendering</li> <li>RBAC permissions for all 4 personas (Platform Engineer, API Admin, API Owner, API Consumer)</li> <li>Create/read/update/delete operations</li> <li>Approval workflows</li> <li>Ownership enforcement</li> </ul>"},{"location":"kuadrant-backstage-plugin/#linting-and-formatting","title":"Linting and Formatting","text":"<pre><code>yarn lint:check                 # check for linting errors\nyarn lint:fix                   # fix linting errors\nyarn prettier:check             # check formatting\nyarn prettier:fix               # fix formatting\n</code></pre>"},{"location":"kuadrant-backstage-plugin/#testing-permissions","title":"Testing Permissions","text":"<p>The application uses RBAC with a four-persona model:</p> <pre><code>API Consumer \u2192 API Owner \u2192 API Admin \u2192 Platform Engineer\n</code></pre> <p>See docs/rbac-permissions.md for complete details.</p> <p>Test users are configured in <code>catalog-entities/kuadrant-users.yaml</code>:</p> <ul> <li><code>consumer1</code>, <code>consumer2</code> - members of <code>api-consumers</code> group</li> <li><code>owner1</code>, <code>owner2</code> - members of <code>api-owners</code> group</li> <li><code>admin</code> - member of <code>api-admins</code> group</li> <li><code>guest</code> - member of <code>api-owners</code> group (for development)</li> </ul> <p>API Consumer (browse and request):</p> <ul> <li>Can view all API Products (for browsing)</li> <li>Can request API keys</li> <li>Can manage own API keys only</li> <li>No \"Create API Product\" button</li> <li>No \"Plan Policies\" or \"Approval Queue\" cards</li> </ul> <p>API Owner (own products):</p> <ul> <li>Can create/delete own API Products</li> <li>Can approve/reject requests for own APIs only</li> <li>Can view Plan Policies (read-only)</li> <li>Cannot see other owners' API Products</li> </ul> <p>API Admin (all products):</p> <ul> <li>Can view/edit/delete all API Products</li> <li>Can approve/reject any API key request</li> <li>Can manage RBAC policies</li> <li>Full visibility across all API Products</li> </ul> <p>Ownership Model:</p> <ul> <li>API Products track ownership via annotations (<code>backstage.io/owner</code>)</li> <li>Backend enforces ownership checks for API Owners</li> <li>API Admins bypass ownership checks (can manage everything)</li> </ul> <p>Note: PlanPolicies are managed on the cluster by platform engineers. This plugin only provides read access to view existing policies.</p>"},{"location":"kuadrant-backstage-plugin/#project-structure","title":"Project Structure","text":"<pre><code>plugins/\n\u251c\u2500\u2500 kuadrant/                     # Frontend plugin\n\u2514\u2500\u2500 kuadrant-backend/             # Backend plugin\n\nkuadrant-dev-setup/               # Development environment\n\u251c\u2500\u2500 crds/                         # APIProduct, APIKey CRDs\n\u251c\u2500\u2500 demo/                         # Toystore demo resources\n\u251c\u2500\u2500 rbac/                         # RHDH service account permissions\n\u251c\u2500\u2500 kuadrant-instance.yaml        # Kuadrant CR\n\u2514\u2500\u2500 Makefile                      # Cluster setup automation\n\npackages/\n\u251c\u2500\u2500 app/                          # RHDH frontend (customised)\n\u2514\u2500\u2500 backend/                      # RHDH backend (customised)\n</code></pre>"},{"location":"kuadrant-backstage-plugin/#customisations","title":"Customisations","text":"<p>This repo is a fork of RHDH with Kuadrant-specific customisations. See KUADRANT.md for:</p> <ul> <li>Branching strategy (main vs rhdh-upstream)</li> <li>List of modified files</li> <li>Merge conflict resolution guide</li> <li>How to pull RHDH updates</li> </ul>"},{"location":"kuadrant-backstage-plugin/#key-integration-points","title":"Key Integration Points","text":"<p>Routes: <code>packages/app/src/components/AppBase/AppBase.tsx</code> Entity tabs: <code>packages/app/src/components/catalog/EntityPage/defaultTabs.tsx</code> Menu: <code>packages/app/src/consts.ts</code> Backend plugins: <code>packages/backend/src/index.ts</code></p>"},{"location":"kuadrant-backstage-plugin/#documentation","title":"Documentation","text":"<ul> <li>docs/getting-started.md - End-to-end tutorial</li> <li>docs/installation.md - Plugin installation guide (for RHDH users)</li> <li>docs/rbac-permissions.md - RBAC and permissions guide</li> <li>docs/api-reference.md - Backend API reference</li> <li>kuadrant-dev-setup/README.md - Development cluster setup</li> <li>KUADRANT.md - Branching strategy and customisations</li> </ul>"},{"location":"kuadrant-backstage-plugin/#technical-details","title":"Technical Details","text":"<p>Node.js: 22.20.0 (see <code>.nvmrc</code>) Package manager: Yarn 3 Build system: Turborepo Hot reload: Webpack dev server on port 3000 Backend: Express on port 7007</p>"},{"location":"kuadrant-backstage-plugin/#contributing","title":"Contributing","text":"<p>We welcome contributions! This is a development fork focused on Kuadrant plugins.</p> <p>For RHDH-specific improvements, see KUADRANT.md for how to contribute upstream.</p>"},{"location":"kuadrant-backstage-plugin/#license","title":"License","text":"<p>See LICENSE</p>"},{"location":"kuadrant-backstage-plugin/#related","title":"Related","text":"<ul> <li>Kuadrant - API management for Kubernetes</li> <li>Backstage - Open platform for building developer portals</li> <li>RHDH - Enterprise Backstage distribution</li> </ul>"},{"location":"kuadrant-backstage-plugin/KUADRANT/","title":"Kuadrant Plugin Development","text":"<p>This repository is a customised fork of Red Hat Developer Hub (RHDH) for developing Kuadrant Backstage plugins.</p>"},{"location":"kuadrant-backstage-plugin/KUADRANT/#branching-strategy","title":"Branching Strategy","text":"<ul> <li><code>main</code> - Our development branch with Kuadrant plugins and customisations</li> <li><code>rhdh-upstream-main</code> - Tracking branch for upstream RHDH main (reference only, do not commit here)</li> <li><code>pre-migration-backup</code> - Snapshot of old plugin structure before migration (backup only)</li> </ul>"},{"location":"kuadrant-backstage-plugin/KUADRANT/#repository-remotes","title":"Repository Remotes","text":"<p>This repository tracks three remotes:</p> <ul> <li><code>origin</code> - Your fork (e.g., jasonmadigan/kuadrant-backstage-plugin)</li> <li><code>upstream</code> - Kuadrant organisation repo (Kuadrant/kuadrant-backstage-plugin)</li> <li><code>rhdh-upstream</code> - Red Hat Developer Hub upstream (redhat-developer/rhdh)</li> </ul>"},{"location":"kuadrant-backstage-plugin/KUADRANT/#pulling-rhdh-updates","title":"Pulling RHDH Updates","text":"<p>To pull the latest changes from upstream RHDH and rebase our Kuadrant customisations:</p> <pre><code># fetch latest from rhdh upstream\ngit fetch rhdh-upstream\n\n# update the tracking branch (optional, for reference)\ngit checkout rhdh-upstream-main\ngit reset --hard rhdh-upstream/main\ngit push upstream rhdh-upstream-main\n\n# rebase our main branch on top of latest rhdh\ngit checkout main\ngit rebase rhdh-upstream/main\n\n# resolve any conflicts (see below)\n\n# force push to update upstream after rebase\ngit push --force-with-lease upstream main\ngit push --force-with-lease origin main\n</code></pre>"},{"location":"kuadrant-backstage-plugin/KUADRANT/#expected-merge-conflicts","title":"Expected Merge Conflicts","text":"<p>When rebasing, you'll likely see conflicts in these files:</p> <p>packages/app/src/components/AppBase/AppBase.tsx</p> <ul> <li>Conflict: Kuadrant route and Navigate import</li> <li>Resolution: Keep both upstream changes and our Kuadrant route</li> </ul> <p>packages/app/src/components/catalog/EntityPage/defaultTabs.tsx</p> <ul> <li>Conflict: Kuadrant tab definitions</li> <li>Resolution: Keep our Kuadrant imports and tab configurations</li> </ul> <p>packages/app/src/components/catalog/EntityPage/OverviewTabContent.tsx</p> <ul> <li>Conflict: EntityKuadrantApiAccessCard in API entity section</li> <li>Resolution: Keep our Kuadrant card addition</li> </ul> <p>packages/app/src/consts.ts</p> <ul> <li>Conflict: Kuadrant menu item</li> <li>Resolution: Keep our menu item addition</li> </ul> <p>packages/app/package.json</p> <ul> <li>Conflict: Kuadrant plugin dependency</li> <li>Resolution: Keep our @internal/plugin-kuadrant dependency</li> </ul> <p>packages/backend/src/index.ts</p> <ul> <li>Conflict: Kuadrant backend plugin registration</li> <li>Resolution: Keep our backend.add() calls for Kuadrant plugins</li> </ul> <p>app-config.local.yaml</p> <ul> <li>Conflict: Usually none (gitignored)</li> <li>Resolution: N/A</li> </ul>"},{"location":"kuadrant-backstage-plugin/KUADRANT/#customisations-summary","title":"Customisations Summary","text":""},{"location":"kuadrant-backstage-plugin/KUADRANT/#added-filesdirectories","title":"Added Files/Directories","text":"<pre><code>plugins/kuadrant/                      # Frontend plugin\nplugins/kuadrant-backend/              # Backend plugin\nkuadrant-dev-setup/                    # Kind cluster setup\n  \u251c\u2500\u2500 crds/                            # APIProduct, APIKey\n  \u251c\u2500\u2500 demo/                            # Toystore demo\n  \u251c\u2500\u2500 rbac/                            # RHDH service account\n  \u251c\u2500\u2500 scripts/                         # Kind cluster config\n  \u251c\u2500\u2500 kuadrant-instance.yaml           # Kuadrant CR\n  \u251c\u2500\u2500 Makefile                         # Cluster setup\n  \u2514\u2500\u2500 README.md\nKUADRANT.md                            # This file\n</code></pre>"},{"location":"kuadrant-backstage-plugin/KUADRANT/#modified-rhdh-files","title":"Modified RHDH Files","text":"<p>Frontend routing:</p> <ul> <li><code>packages/app/src/components/AppBase/AppBase.tsx</code></li> <li>Added: <code>import { Navigate, Route } from 'react-router-dom'</code></li> <li>Added: <code>&lt;Route path=\"/\" element={&lt;Navigate to=\"catalog\" /&gt;} /&gt;</code></li> <li>Added: <code>&lt;Route path=\"/kuadrant\" element={&lt;KuadrantPage /&gt;} /&gt;</code></li> </ul> <p>Entity page integration:</p> <ul> <li><code>packages/app/src/components/catalog/EntityPage/defaultTabs.tsx</code></li> <li>Added: Kuadrant imports</li> <li>Added: <code>/api-keys</code> and <code>/api-product-info</code> tabs</li> <li> <p>Added: Grid wrapping for full-width layout</p> </li> <li> <p><code>packages/app/src/components/catalog/EntityPage/OverviewTabContent.tsx</code></p> </li> <li>Added: <code>EntityKuadrantApiAccessCard</code> for API entities</li> </ul> <p>Navigation:</p> <ul> <li><code>packages/app/src/consts.ts</code></li> <li>Added: Kuadrant menu item</li> </ul> <p>Dependencies:</p> <ul> <li><code>packages/app/package.json</code></li> <li>Added: <code>\"@internal/plugin-kuadrant\": \"0.1.0\"</code></li> </ul> <p>Backend:</p> <ul> <li><code>packages/backend/src/index.ts</code></li> <li>Added: <code>backend.add(import('@internal/plugin-kuadrant-backend'))</code></li> <li>Added: <code>backend.add(import('@internal/plugin-kuadrant-backend/alpha'))</code></li> </ul> <p>Documentation:</p> <ul> <li><code>CLAUDE.md</code> - Added Kuadrant development guidance</li> </ul>"},{"location":"kuadrant-backstage-plugin/KUADRANT/#configuration","title":"Configuration","text":"<p>app-config.local.yaml (checked in for dev convenience): <pre><code>app:\n  baseUrl: http://localhost:3000\n\nbackend:\n  baseUrl: http://localhost:7007\n  cors:\n    origin: http://localhost:3000\n    credentials: true\n\nauth:\n  environment: development\n  providers:\n    guest:\n      dangerouslyAllowOutsideDevelopment: true\n\ncatalog:\n  rules:\n\n    - allow: [Component, System, Group, Resource, Location, Template, API, APIProduct]\n</code></pre></p>"},{"location":"kuadrant-backstage-plugin/KUADRANT/#development-workflow","title":"Development Workflow","text":""},{"location":"kuadrant-backstage-plugin/KUADRANT/#first-time-setup","title":"First Time Setup","text":"<pre><code># Install dependencies\nyarn install\n\n# Create kind cluster with Kuadrant\ncd kuadrant-dev-setup\nmake kind-create\ncd ..\n</code></pre>"},{"location":"kuadrant-backstage-plugin/KUADRANT/#daily-development","title":"Daily Development","text":"<pre><code># Start RHDH with hot reload\nyarn dev\n\n# Visit http://localhost:3000\n# - /kuadrant - Main plugin page\n# - /catalog - Catalog with APIProduct entities\n# - /catalog/default/api/toystore-api - API with Kuadrant tabs\n</code></pre>"},{"location":"kuadrant-backstage-plugin/KUADRANT/#kubernetes-access","title":"Kubernetes Access","text":"<p>The backend uses your local <code>~/.kube/config</code> for development. Verify access:</p> <pre><code>kubectl config current-context\nkubectl get apiproducts -A\n</code></pre>"},{"location":"kuadrant-backstage-plugin/KUADRANT/#rebuilding-cluster","title":"Rebuilding Cluster","text":"<pre><code>cd kuadrant-dev-setup\nmake kind-delete\nmake kind-create\n</code></pre>"},{"location":"kuadrant-backstage-plugin/KUADRANT/#rbac-and-permissions","title":"RBAC and Permissions","text":"<p>The Kuadrant plugins ship with a comprehensive permission system for access control.</p>"},{"location":"kuadrant-backstage-plugin/KUADRANT/#three-tier-role-hierarchy","title":"Three-Tier Role Hierarchy","text":"<p>These are example role configurations - permissions are composable, so you can create custom roles mixing these permissions however you want.</p> <pre><code>API Consumer (browse all, manage own keys)\n    \u2193\nAPI Owner (owns specific products, approves requests for own products)\n    \u2193\nAPI Admin (owns all products, approves any request)\n</code></pre> <p>API Admin (platform engineer)</p> <ul> <li>Can do: View/edit ALL API Products, approve/reject any API key requests, manage RBAC policies, read PlanPolicy</li> <li>Cannot do: Create/update/delete PlanPolicy (managed on cluster by platform engineers via kubectl)</li> <li>Use case: Platform engineers who manage all API products and access control</li> </ul> <p>API Owner</p> <ul> <li>Can do: Create/update OWN API Products, approve/reject requests for OWN APIs, read PlanPolicy (to reference), request API access</li> <li>Cannot do: View/edit other owners' APIs, create/update/delete PlanPolicy (managed on cluster)</li> <li>Use case: Publishes APIs they own, manages access to their own APIs</li> </ul> <p>API Consumer</p> <ul> <li>Can do: Read ALL APIProducts (for catalog browsing), create APIKeys, manage own API keys</li> <li>Cannot do: Approve requests, create APIs, modify rate limits</li> <li>Use case: Browses APIs, requests access, uses APIs within quotas</li> </ul>"},{"location":"kuadrant-backstage-plugin/KUADRANT/#kuadrant-permissions","title":"Kuadrant Permissions","text":"<p>The backend exports these permissions (defined in <code>plugins/kuadrant-backend/src/permissions.ts</code>). These appear in the RBAC plugin UI and can be composed into custom roles.</p> <p>PlanPolicy (rate limit tiers):</p> <ul> <li><code>kuadrant.planpolicy.create</code> - create PlanPolicy resources</li> <li><code>kuadrant.planpolicy.read</code> - read PlanPolicy resources</li> <li><code>kuadrant.planpolicy.update</code> - update PlanPolicy resources</li> <li><code>kuadrant.planpolicy.delete</code> - delete PlanPolicy resources</li> <li><code>kuadrant.planpolicy.list</code> - list PlanPolicy resources</li> </ul> <p>APIProduct (catalog entries with ownership):</p> <ul> <li><code>kuadrant.apiproduct.create</code> - create APIProduct resources</li> <li><code>kuadrant.apiproduct.read.own</code> - read own APIProduct resources</li> <li><code>kuadrant.apiproduct.read.all</code> - read all APIProduct resources</li> <li><code>kuadrant.apiproduct.update.own</code> - update own APIProduct resources</li> <li><code>kuadrant.apiproduct.update.all</code> - update any APIProduct resource</li> <li><code>kuadrant.apiproduct.delete.own</code> - delete own APIProduct resources</li> <li><code>kuadrant.apiproduct.delete.all</code> - delete any APIProduct resource</li> <li><code>kuadrant.apiproduct.list</code> - list APIProduct resources (backend filters by ownership)</li> </ul> <p>APIKey (access requests with ownership):</p> <ul> <li><code>kuadrant.apikey.create</code> - create APIKey resources (resource permission scoped to APIProduct)</li> <li><code>kuadrant.apikey.read.own</code> - read own APIKey resources</li> <li><code>kuadrant.apikey.read.all</code> - read all APIKey resources</li> <li><code>kuadrant.apikey.update.own</code> - update own APIKey resources</li> <li><code>kuadrant.apikey.update.all</code> - update any APIKey (approve/reject)</li> <li><code>kuadrant.apikey.delete.own</code> - delete own APIKey resources</li> <li><code>kuadrant.apikey.delete.all</code> - delete any APIKey resource</li> </ul> <p>Ownership Model:</p> <p>APIProducts track ownership via Kubernetes annotations:</p> <ul> <li><code>backstage.io/created-by-user-id</code> - user ID for permission checks</li> <li><code>backstage.io/created-by-user-ref</code> - user entity ref for catalog owner field</li> <li><code>backstage.io/created-at</code> - creation timestamp</li> </ul> <p>Backend enforces ownership checks for <code>.own</code> permissions:</p> <ul> <li>API Owners can only view/edit/delete their own APIProducts</li> <li>API Admins can view/edit/delete all APIProducts</li> <li>APIKey approval requires ownership of the associated APIProduct</li> </ul>"},{"location":"kuadrant-backstage-plugin/KUADRANT/#testing-with-different-users","title":"Testing with Different Users","text":"<p>Test users are defined in <code>catalog-entities/kuadrant-users.yaml</code>:</p> <p>API Consumers:</p> <ul> <li><code>consumer1</code> (consumer1@kuadrant.local)</li> <li><code>consumer2</code> (consumer2@kuadrant.local)</li> </ul> <p>API Owners:</p> <ul> <li><code>owner1</code> (owner1@kuadrant.local) - API Owner 1</li> <li><code>owner2</code> (owner2@kuadrant.local) - API Owner 2</li> </ul> <p>API Admins:</p> <ul> <li><code>admin</code> (admin@kuadrant.local) - Administrator</li> </ul> <p>Development:</p> <ul> <li><code>guest</code> (guest@kuadrant.local) - Guest User (member of api-owners for development convenience)</li> </ul> <p>To test different permission levels, sign in as different users through your authentication provider (Dex, Keycloak, etc.)</p>"},{"location":"kuadrant-backstage-plugin/KUADRANT/#rbac-policy","title":"RBAC Policy","text":"<p>The RBAC policy is defined in <code>rbac-policy.csv</code> using Casbin format. This maps:</p> <ul> <li>Roles to permissions (what each role can do)</li> <li>Groups to roles (which groups have which roles)</li> <li>Users to roles (which users have which roles)</li> </ul> <p>Example policy entry: <pre><code>p, role:default/platform-engineer, kuadrant.policy.write, update, allow\ng, group:default/platform-engineers, role:default/platform-engineer\ng, user:default/platform-engineer, role:default/platform-engineer\n</code></pre></p>"},{"location":"kuadrant-backstage-plugin/KUADRANT/#configuration_1","title":"Configuration","text":"<p>RBAC is configured in <code>app-config.local.yaml</code>:</p> <pre><code>auth:\n  environment: development\n  providers:\n    guest:\n      dangerouslyAllowOutsideDevelopment: true\n\npermission:\n  enabled: true\n  rbac:\n    policies-csv-file: ../../rbac-policy.csv\n</code></pre> <p>The RBAC policy file maps groups to roles, and users inherit permissions from their group memberships defined in the catalog.</p>"},{"location":"kuadrant-backstage-plugin/KUADRANT/#kubernetes-rbac","title":"Kubernetes RBAC","text":"<p>For production deployments, the RHDH service account needs these permissions:</p> <ul> <li>Read/write access to <code>apiproducts.devportal.kuadrant.io</code></li> <li>Read/write access to <code>apikeys.devportal.kuadrant.io</code></li> <li>Read/write access to <code>secrets</code> (for API key storage)</li> <li>Read access to Kuadrant policies (optional, for policy viewing)</li> </ul> <p>See <code>kuadrant-dev-setup/rbac/rhdh-rbac.yaml</code> for the development cluster setup.</p>"},{"location":"kuadrant-backstage-plugin/KUADRANT/#philosophy","title":"Philosophy","text":"<ul> <li>main is ours - This is our development repo for Kuadrant plugins</li> <li>Track upstream RHDH - Periodically rebase from rhdh-upstream to stay current with RHDH releases</li> <li>Customisations are minimal - Keep changes focused on Kuadrant integration</li> <li>Clean history - Use rebase workflow to maintain clean commit history</li> </ul>"},{"location":"kuadrant-backstage-plugin/docs/api-reference/","title":"Backend API Reference","text":"<p>The backend plugin exposes REST API endpoints at <code>/api/kuadrant/*</code>. All endpoints require authentication and enforce RBAC permissions.</p>"},{"location":"kuadrant-backstage-plugin/docs/api-reference/#apiproduct-endpoints","title":"APIProduct Endpoints","text":"Method Endpoint Description Permission GET <code>/api/kuadrant/apiproducts</code> List all API Products (filtered by ownership for non-admins) <code>kuadrant.apiproduct.list</code> GET <code>/api/kuadrant/apiproducts/:namespace/:name</code> Get specific API Product <code>kuadrant.apiproduct.read.own</code> or <code>.read.all</code> POST <code>/api/kuadrant/apiproducts</code> Create new API Product <code>kuadrant.apiproduct.create</code> PATCH <code>/api/kuadrant/apiproducts/:namespace/:name</code> Update API Product <code>kuadrant.apiproduct.update.own</code> or <code>.update.all</code> DELETE <code>/api/kuadrant/apiproducts/:namespace/:name</code> Delete API Product (cascades to APIKeys) <code>kuadrant.apiproduct.delete.own</code> or <code>.delete.all</code>"},{"location":"kuadrant-backstage-plugin/docs/api-reference/#httproute-endpoints","title":"HTTPRoute Endpoints","text":"Method Endpoint Description Permission GET <code>/api/kuadrant/httproutes</code> List all HTTPRoutes <code>kuadrant.apiproduct.list</code>"},{"location":"kuadrant-backstage-plugin/docs/api-reference/#planpolicy-endpoints","title":"PlanPolicy Endpoints","text":"Method Endpoint Description Permission GET <code>/api/kuadrant/planpolicies</code> List all Plan Policies <code>kuadrant.planpolicy.list</code> GET <code>/api/kuadrant/planpolicies/:namespace/:name</code> Get specific Plan Policy <code>kuadrant.planpolicy.read</code>"},{"location":"kuadrant-backstage-plugin/docs/api-reference/#authpolicy-endpoints","title":"AuthPolicy Endpoints","text":"Method Endpoint Description Permission GET <code>/api/kuadrant/authpolicies</code> List all AuthPolicies <code>kuadrant.authpolicy.list</code>"},{"location":"kuadrant-backstage-plugin/docs/api-reference/#ratelimitpolicy-endpoints","title":"RateLimitPolicy Endpoints","text":"Method Endpoint Description Permission GET <code>/api/kuadrant/ratelimitpolicies</code> List all RateLimitPolicies <code>kuadrant.ratelimitpolicy.list</code>"},{"location":"kuadrant-backstage-plugin/docs/api-reference/#apikey-endpoints","title":"APIKey Endpoints","text":"Method Endpoint Description Permission GET <code>/api/kuadrant/requests</code> List API Keys (filtered by ownership) <code>kuadrant.apikey.read.own</code> or <code>.read.all</code> GET <code>/api/kuadrant/requests/my</code> List current user's API Keys <code>kuadrant.apikey.read.own</code> POST <code>/api/kuadrant/requests</code> Create API Key request <code>kuadrant.apikey.create</code> PATCH <code>/api/kuadrant/requests/:namespace/:name</code> Edit pending request <code>kuadrant.apikey.update.own</code> or <code>.update.all</code> DELETE <code>/api/kuadrant/requests/:namespace/:name</code> Delete/cancel request <code>kuadrant.apikey.delete.own</code> or <code>.delete.all</code> POST <code>/api/kuadrant/requests/:namespace/:name/approve</code> Approve request <code>kuadrant.apikey.approve</code> POST <code>/api/kuadrant/requests/:namespace/:name/reject</code> Reject request <code>kuadrant.apikey.approve</code> POST <code>/api/kuadrant/requests/bulk-approve</code> Bulk approve requests <code>kuadrant.apikey.approve</code> POST <code>/api/kuadrant/requests/bulk-reject</code> Bulk reject requests <code>kuadrant.apikey.approve</code>"},{"location":"kuadrant-backstage-plugin/docs/api-reference/#api-key-secret-endpoints","title":"API Key Secret Endpoints","text":"Method Endpoint Description Permission GET <code>/api/kuadrant/apikeys/:namespace/:name/secret</code> Get API key secret (one-time read) <code>kuadrant.apikey.read.own</code> or <code>.read.all</code>"},{"location":"kuadrant-backstage-plugin/docs/api-reference/#query-parameters","title":"Query Parameters","text":"<p><code>GET /api/kuadrant/requests</code>:</p> <ul> <li><code>status</code> - Filter by status: <code>Pending</code>, <code>Approved</code>, <code>Rejected</code></li> <li><code>namespace</code> - Filter by Kubernetes namespace</li> </ul> <p><code>GET /api/kuadrant/requests/my</code>:</p> <ul> <li><code>namespace</code> - Filter by Kubernetes namespace</li> </ul>"},{"location":"kuadrant-backstage-plugin/docs/getting-started/","title":"Getting Started Tutorial","text":"<p>This tutorial walks you through publishing an API and managing consumer access using the Kuadrant developer portal.</p> <p>By the end, you will have:</p> <ul> <li>Deployed an API with authentication and tiered rate limiting</li> <li>Published it as an API Product via Backstage</li> <li>Requested and approved API access</li> <li>Used the generated API key</li> </ul>"},{"location":"kuadrant-backstage-plugin/docs/getting-started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Kubernetes cluster with Kuadrant operator installed</li> <li>Gateway API CRDs and a gateway provider (Istio or Envoy Gateway)</li> <li>RHDH/Backstage with Kuadrant plugins installed (see Installation Guide)</li> </ul>"},{"location":"kuadrant-backstage-plugin/docs/getting-started/#part-1-platform-engineer-setup","title":"Part 1: Platform Engineer Setup","text":"<p>These steps are performed by a platform engineer or API owner with cluster access. They prepare the infrastructure and policies that enable API access management.</p>"},{"location":"kuadrant-backstage-plugin/docs/getting-started/#step-1-deploy-the-api","title":"Step 1: Deploy the API","text":"<p>Create the namespace and deploy the toystore application:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: v1\nkind: Namespace\nmetadata:\n  name: getting-started-tutorial\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: toystore\n  namespace: getting-started-tutorial\n  labels:\n    app: toystore\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: toystore\n  template:\n    metadata:\n      labels:\n        app: toystore\n    spec:\n      containers:\n\n        - name: toystore\n          image: quay.io/kuadrant/authorino-examples:talker-api\n          ports:\n            - containerPort: 3000\n          env:\n            - name: PORT\n              value: \"3000\"\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: toystore\n  namespace: getting-started-tutorial\nspec:\n  selector:\n    app: toystore\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 3000\nEOF\n</code></pre> <p>Wait for the deployment to be available:</p> <pre><code>kubectl -n getting-started-tutorial wait --timeout=120s --for=condition=Available deployment/toystore\n</code></pre>"},{"location":"kuadrant-backstage-plugin/docs/getting-started/#step-2-create-the-gateway-and-httproute","title":"Step 2: Create the Gateway and HTTPRoute","text":"<p>Create a Gateway and expose the API via an HTTPRoute.</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1\nkind: Gateway\nmetadata:\n  name: getting-started-gateway\n  namespace: getting-started-tutorial\nspec:\n  gatewayClassName: istio\n  listeners:\n\n    - name: http\n      protocol: HTTP\n      port: 80\n      allowedRoutes:\n        namespaces:\n          from: All\n---\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: getting-started-toystore\n  namespace: getting-started-tutorial\nspec:\n  parentRefs:\n    - name: getting-started-gateway\n      namespace: getting-started-tutorial\n  hostnames:\n    - getting-started.toystore.com\n  rules:\n    - matches:\n        - path:\n            type: PathPrefix\n            value: /\n          method: GET\n      backendRefs:\n        - name: toystore\n          port: 80\nEOF\n</code></pre> <p>Verify:</p> <pre><code>kubectl get httproute,gateway -n getting-started-tutorial\n</code></pre>"},{"location":"kuadrant-backstage-plugin/docs/getting-started/#step-3-configure-api-key-authentication","title":"Step 3: Configure API Key Authentication","text":"<p>Create an AuthPolicy requiring API key authentication. Keys are stored as Kubernetes Secrets with the label <code>app: getting-started-toystore-api</code> (matching the APIProduct name we'll create in Step 5).</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1\nkind: AuthPolicy\nmetadata:\n  name: getting-started-auth\n  namespace: getting-started-tutorial\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: getting-started-toystore\n  rules:\n    authentication:\n      \"api-key-users\":\n        apiKey:\n          selector:\n            matchLabels:\n              app: getting-started-toystore-api\n          allNamespaces: true\n        credentials:\n          authorizationHeader:\n            prefix: APIKEY\nEOF\n</code></pre> <p>Verify the policy is enforced:</p> <pre><code>kubectl get authpolicy -n getting-started-tutorial\n</code></pre>"},{"location":"kuadrant-backstage-plugin/docs/getting-started/#step-4-create-plan-tiers","title":"Step 4: Create Plan Tiers","text":"<p>Create a PlanPolicy defining access tiers with different rate limits.</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: extensions.kuadrant.io/v1alpha1\nkind: PlanPolicy\nmetadata:\n  name: getting-started-plans\n  namespace: getting-started-tutorial\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: getting-started-toystore\n  plans:\n\n    - tier: gold\n      predicate: |\n        has(auth.identity) &amp;&amp; auth.identity.metadata.annotations[\"secret.kuadrant.io/plan-id\"] == \"gold\"\n      limits:\n        daily: 100\n    - tier: silver\n      predicate: |\n        has(auth.identity) &amp;&amp; auth.identity.metadata.annotations[\"secret.kuadrant.io/plan-id\"] == \"silver\"\n      limits:\n        daily: 50\n    - tier: bronze\n      predicate: |\n        has(auth.identity) &amp;&amp; auth.identity.metadata.annotations[\"secret.kuadrant.io/plan-id\"] == \"bronze\"\n      limits:\n        daily: 10\nEOF\n</code></pre> <p>Verify:</p> <pre><code>kubectl get planpolicy -n getting-started-tutorial\n</code></pre> <p>The platform engineer setup is complete. The HTTPRoute is now available for API owners to publish via the developer portal.</p>"},{"location":"kuadrant-backstage-plugin/docs/getting-started/#part-2-api-owner-workflow","title":"Part 2: API Owner Workflow","text":"<p>These steps are performed by an API owner using the Backstage UI.</p>"},{"location":"kuadrant-backstage-plugin/docs/getting-started/#step-5-publish-as-an-api-product","title":"Step 5: Publish as an API Product","text":"<ol> <li>Navigate to your Backstage instance</li> <li>Go to the Kuadrant/API Products page from the sidebar</li> <li>Click Create API Product</li> <li>Select the getting-started-toystore HTTPRoute from the dropdown</li> <li>Fill in the details:</li> <li>Name: <code>getting-started-toystore-api</code></li> <li>Display Name: <code>Getting Started Toystore API</code></li> <li>Description: <code>Toystore API for the getting started tutorial</code></li> <li>Approval Mode: Manual</li> <li>Publish Status: Published</li> <li>Click Create</li> </ol> <p>The plugin creates an APIProduct resource in Kubernetes. The PlanPolicy tiers (gold, silver, bronze) are automatically discovered and shown on the API Product page.</p> <p>Verify via kubectl:</p> <pre><code>kubectl get apiproduct -n getting-started-tutorial\n</code></pre>"},{"location":"kuadrant-backstage-plugin/docs/getting-started/#part-3-api-consumer-workflow","title":"Part 3: API Consumer Workflow","text":"<p>These steps are performed by an API consumer using the Backstage UI.</p>"},{"location":"kuadrant-backstage-plugin/docs/getting-started/#step-6-discover-the-api","title":"Step 6: Discover the API","text":"<ol> <li>Navigate to the API in the Backstage catalog</li> <li>Find Getting Started Toystore API in the list</li> <li>Click to view the API details</li> </ol> <p>The API page shows:</p> <ul> <li>Overview tab with description and metadata</li> <li>API Keys tab for requesting access</li> <li>API Product Info tab with plan tiers and rate limits</li> </ul>"},{"location":"kuadrant-backstage-plugin/docs/getting-started/#step-7-request-api-access","title":"Step 7: Request API Access","text":"<ol> <li>Click the API Keys tab</li> <li>Click Request API Access</li> <li>Select a tier (e.g. silver - 50 requests/day)</li> <li>Provide a use case description (e.g. \"Testing API integration\")</li> <li>Click Submit</li> </ol> <p>The request creates an APIKey resource with status <code>Pending</code>.</p>"},{"location":"kuadrant-backstage-plugin/docs/getting-started/#part-4-api-owner-approval","title":"Part 4: API Owner Approval","text":"<p>Back to the API owner workflow.</p>"},{"location":"kuadrant-backstage-plugin/docs/getting-started/#step-8-approve-the-request","title":"Step 8: Approve the Request","text":"<ol> <li>Navigate to the Kuadrant page</li> <li>View the Pending Requests section</li> <li>Find the request and review the details:</li> <li>Requester</li> <li>Requested tier</li> <li>Use case</li> <li>Click Approve</li> </ol> <p>The developer-portal-controller creates a Secret containing the API key and updates the APIKey status to <code>Approved</code>.</p>"},{"location":"kuadrant-backstage-plugin/docs/getting-started/#part-5-using-the-api","title":"Part 5: Using the API","text":"<p>Back to the API consumer.</p>"},{"location":"kuadrant-backstage-plugin/docs/getting-started/#step-9-retrieve-and-use-the-api-key","title":"Step 9: Retrieve and Use the API Key","text":"<ol> <li>Navigate to the Getting Started Toystore API in the catalog</li> <li>Click the API Keys tab</li> <li>Find your approved key</li> <li>Click the eye icon to reveal the secret</li> <li>Copy the API key value</li> </ol> <p>Test the API:</p> <pre><code>export GATEWAY_IP=$(kubectl get gateway getting-started-gateway -n getting-started-tutorial -o jsonpath='{.status.addresses[0].value}')\nexport API_KEY=\"your-api-key-here\"\n\ncurl -H \"Host: getting-started.toystore.com\" -H \"Authorization: APIKEY $API_KEY\" http://$GATEWAY_IP/\n</code></pre> <p>You should receive a response from the toystore API.</p>"},{"location":"kuadrant-backstage-plugin/docs/getting-started/#cleanup","title":"Cleanup","text":"<p>Remove all resources by deleting the namespace:</p> <pre><code>kubectl delete namespace getting-started-tutorial\n</code></pre>"},{"location":"kuadrant-backstage-plugin/docs/getting-started/#summary","title":"Summary","text":"Persona Actions Platform Engineer Deploy API, create Gateway/HTTPRoute, configure AuthPolicy and PlanPolicy API Owner Publish API Product via Backstage, approve access requests API Consumer Discover APIs, request access, use API keys"},{"location":"kuadrant-backstage-plugin/docs/getting-started/#variant-oidc-authentication","title":"Variant: OIDC Authentication","text":"<p>This section shows how to configure the tutorial API with OIDC/JWT authentication instead of API key authentication. This approach delegates authentication to an external identity provider.</p>"},{"location":"kuadrant-backstage-plugin/docs/getting-started/#prerequisites_1","title":"Prerequisites","text":"<ul> <li>An OIDC-compliant identity provider (e.g., Keycloak, Auth0, Azure AD)</li> <li>The issuer URL from your identity provider (e.g., <code>https://keycloak.example.com/realms/myrealm</code>)</li> <li>Client credentials for testing (client ID and secret)</li> </ul>"},{"location":"kuadrant-backstage-plugin/docs/getting-started/#modified-step-3-configure-oidc-authentication","title":"Modified Step 3: Configure OIDC Authentication","text":"<p>Replace the API key AuthPolicy from Step 3 with this OIDC-based AuthPolicy:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1\nkind: AuthPolicy\nmetadata:\n  name: getting-started-auth\n  namespace: getting-started-tutorial\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: getting-started-toystore\n  rules:\n    authentication:\n      \"oidc-users\":\n        jwt:\n          issuerUrl: https://your-oidc-provider.example.com/realms/your-realm\n        credentials:\n          authorizationHeader:\n            prefix: Bearer\nEOF\n</code></pre> <p>Replace <code>https://your-oidc-provider.example.com/realms/your-realm</code> with your actual OIDC issuer URL.</p>"},{"location":"kuadrant-backstage-plugin/docs/getting-started/#modified-consumer-workflow","title":"Modified Consumer Workflow","text":"<p>When using OIDC authentication, API consumers follow a different workflow:</p> <ol> <li>Go to the Kuadrant/API Products page from the sidebar</li> <li>Find Getting Started Toystore API in the list</li> <li>Click to view the API details</li> <li>View the OIDC tab showing:</li> <li>Identity Provider URL</li> <li>Token Endpoint</li> <li>Example curl command for obtaining a token</li> <li>Obtain a token from the identity provider (Example using Client Credentials Flow):</li> </ol> <pre><code>export TOKEN_ENDPOINT=\"https://your-oidc-provider.example.com/realms/your-realm/protocol/openid-connect/token\"\nexport CLIENT_ID=\"your-client-id\"\nexport CLIENT_SECRET=\"your-client-secret\"\n\n# Get access token\nTOKEN=$(curl -X POST \\\n  -d \"grant_type=client_credentials\" \\\n  -d \"client_id=$CLIENT_ID\" \\\n  -d \"client_secret=$CLIENT_SECRET\" \\\n  $TOKEN_ENDPOINT | jq -r '.access_token')\n</code></pre> <ol> <li>Use the token to call the API:</li> </ol> <pre><code>export GATEWAY_IP=$(kubectl get gateway getting-started-gateway -n getting-started-tutorial -o jsonpath='{.status.addresses[0].value}')\n\ncurl -H \"Host: getting-started.toystore.com\" -H \"Authorization: Bearer $TOKEN\" http://$GATEWAY_IP/\n</code></pre>"},{"location":"kuadrant-backstage-plugin/docs/getting-started/#key-differences","title":"Key Differences","text":"Aspect API Key Authentication OIDC Authentication Credential Source Generated by Developer Portal controller External identity provider Approval Workflow Yes (manual or automatic) No (managed by identity provider) APIKey Resources Required Not needed Consumer Workflow Request \u2192 Approve \u2192 Retrieve key View provider \u2192 Obtain token Use Cases Internal APIs, dev environments Enterprise SSO, external APIs, stronger auth requirements"},{"location":"kuadrant-backstage-plugin/docs/getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>RBAC Permissions - Configure role-based access control</li> <li>API Reference - Backend API endpoints</li> <li>Kuadrant Documentation - Full Kuadrant operator documentation</li> </ul>"},{"location":"kuadrant-backstage-plugin/docs/installation/","title":"Kuadrant Plugin Installation Guide","text":"<p>This guide covers installing the Kuadrant plugins into an existing Red Hat Developer Hub (RHDH) or Backstage instance.</p> <p>For plugin development, see the main README.</p>"},{"location":"kuadrant-backstage-plugin/docs/installation/#packages","title":"Packages","text":"Plugin Package Type Frontend @kuadrant/kuadrant-backstage-plugin-frontend Frontend Backend @kuadrant/kuadrant-backstage-plugin-backend-dynamic Backend"},{"location":"kuadrant-backstage-plugin/docs/installation/#why-two-packages","title":"Why Two Packages?","text":"<p>We publish only two packages that work for both dynamic (RHDH) and static (Backstage) deployments:</p> <ul> <li> <p>Frontend plugin: Published directly from <code>plugins/kuadrant</code>. Frontend plugins are bundled by the app's webpack at build time, so the dynamic plugin system simply needs the source to be available. The <code>dist-scalprum/</code> assets for dynamic loading are included alongside the standard build output in the same package.</p> </li> <li> <p>Backend plugin: Published from <code>plugins/kuadrant-backend/dist-dynamic</code> (not the root). Backend plugins run in Node.js and are loaded at runtime, not bundled by webpack. For dynamic loading to work, the backend code must be pre-bundled as a self-contained module with all dependencies embedded. The <code>@janus-idp/cli export-dynamic</code> command generates this in <code>dist-dynamic/</code> with its own <code>package.json</code>. This is a separate package because the dependency structure differs from the source plugin.</p> </li> </ul> <p>In short: frontend plugins are bundled by the consuming app (so source is fine), while backend plugins must be pre-bundled for runtime loading (so we publish the generated <code>dist-dynamic</code> output).</p>"},{"location":"kuadrant-backstage-plugin/docs/installation/#prerequisites","title":"Prerequisites","text":""},{"location":"kuadrant-backstage-plugin/docs/installation/#kubernetes-cluster-with-kuadrant","title":"Kubernetes Cluster with Kuadrant","text":"<p>The plugins require a Kubernetes cluster with Kuadrant installed. You can either:</p> <ol> <li>Use an existing cluster with:</li> <li> <p>Kuadrant operator 1.4+ installed</p> </li> <li> <p>Use the development setup (recommended for testing):    <pre><code>cd kuadrant-dev-setup\nmake kind-create\n</code></pre>    This creates a kind cluster with:</p> </li> <li>Kuadrant operator</li> <li>Gateway API CRDs v1.2.0</li> <li>Istio service mesh</li> <li>APIProduct and APIKey CRDs</li> <li>Demo resources (toystore)</li> <li>RHDH service account with proper RBAC</li> </ol>"},{"location":"kuadrant-backstage-plugin/docs/installation/#installation-on-red-hat-developer-hub-rhdh","title":"Installation on Red Hat Developer Hub (RHDH)","text":"<p>This section covers installing the Kuadrant plugins on a Red Hat Developer Hub deployment in a Kubernetes/OpenShift cluster.</p>"},{"location":"kuadrant-backstage-plugin/docs/installation/#prerequisites_1","title":"Prerequisites","text":"<ul> <li>Red Hat Developer Hub</li> </ul> <p>The Kuadrant plugins are tested and supported on Red Hat Developer Hub 1.6 (based on Backstage 1.45.3).</p> <p>Installation guide:</p> <ul> <li>Installing Red Hat Developer Hub</li> </ul> <p>Choose your preferred deployment method:</p> <ul> <li>Operator-based deployment (recommended for production)</li> <li>Helm-based deployment</li> </ul>"},{"location":"kuadrant-backstage-plugin/docs/installation/#configure-red-hat-developer-hub","title":"Configure Red Hat Developer Hub","text":"<p>Set the following environment variables used for convenience in this tutorial:</p> <pre><code># Your backstage instance namespace. Choose your own.\nexport RHDH_NS=rhdh\nexport KUADRANT_PLUGIN_VERSION=v0.1.0\nexport KUADRANT_BACKSTAGE_PLUGIN_BACKEND_DYNAMIC_SHA256=$(npm view @kuadrant/kuadrant-backstage-plugin-backend-dynamic@$KUADRANT_PLUGIN_VERSION dist.integrity)\nexport KUADRANT_BACKSTAGE_PLUGIN_FRONTEND_SHA256=$(npm view @kuadrant/kuadrant-backstage-plugin-frontend@$KUADRANT_PLUGIN_VERSION dist.integrity)\n# base hostname of the cluster.\n# In openshift, this can be easily read with the following command\n#  oc get ingress.config.openshift.io cluster -o jsonpath='{.spec.domain}'\nexport CLUSTER_HOSTNAME=apps.example.com\n</code></pre>"},{"location":"kuadrant-backstage-plugin/docs/installation/#backstage-namespace","title":"Backstage Namespace","text":"<p>Create namespace for the backstage instance</p> <pre><code>kubectl create namespace $RHDH_NS\n</code></pre>"},{"location":"kuadrant-backstage-plugin/docs/installation/#dynamic-plugin-configmap","title":"Dynamic Plugin ConfigMap","text":"<p>Create a config map with the dynamic plugin configuration required to load kuadrant backstage plugins as dynamic plugins.</p> <p>Copy Kuadrant backstage dynamic plugins metadata into a file named, for example, <code>dynamic-plugins-rhdh.yaml</code>. Replace the environment variables with their actual values. Then, create <code>dynamic-plugins-rhdh</code> configmap from that file.</p> <pre><code>kubectl create configmap dynamic-plugins-rhdh --from-file=dynamic-plugins-rhdh.yaml --namespace=$RHDH_NS\n</code></pre>"},{"location":"kuadrant-backstage-plugin/docs/installation/#backstage-app-configyaml","title":"Backstage app-config.yaml","text":"<p>This is the main backstage application level configuration.</p> <p>1. Enable authentication and the permission framework</p> <p>The Kuadrant backstage plugin requires that the permissions framework is set up and configured properly.</p> <p>Set <code>permissions.enabled</code> to true in <code>app-config.yaml</code>:</p> <pre><code>permission:\n  enabled: true\n</code></pre> <p>Additionally, set up some authentication in backstage.</p> <pre><code>auth:\n  providers: {}\n</code></pre> <p>2. Set up RBAC for the kuadrant plugin functionality</p> <p>This configuration will define kuadrant plugin user roles and permissions on those roles. Basically, who can do what within the plugin. The kuadrant backstage plugin permission model is detailed in RBAC and Permissions doc.</p> <p>Create <code>rbac-policy.csv</code> file with the kuadrant plugin's permission definition. You can start with this RBAC policy content sample that includes three roles <code>[api-consumer, api-owner, api-admin]</code>. Then, create <code>rbac-policies</code> configmap from that file.</p> <pre><code>kubectl create configmap rbac-policies --from-file=rbac-policy.csv --namespace=$RHDH_NS\n</code></pre> <p>Add reference to <code>rbac-policy.csv</code> file in the <code>permissions.rbac.policies-csv-file</code> section of the <code>app-config.yaml</code>:</p> <pre><code>permission:\n  rbac:\n    policies-csv-file: /opt/app-root/etc/rbac-policy.csv\n    policyFileReload: true\n</code></pre> <p>Note: The mounting path <code>/opt/app-root/etc</code> is configured later in the Backstage CR. Ensure they match.</p> <p>3. Configure Kubernetes access</p> <p>Kubernetes access is configured in <code>app-config.yaml</code>.</p> <p>The recommended approach is so-called <code>in-cluster</code> mode. In this mode, the backstage application running inside a Kubernetes pod authenticates to the Kubernetes API server using the service account automatically provided by Kubernetes.</p> <p>The <code>in-cluster</code> mode can be configured by either:</p> <ul> <li> <p>Omitting the <code>kubernetes</code> section entirely (setting it to null):   <pre><code>kubernetes: null\n</code></pre></p> </li> <li> <p>Omitting the <code>serviceAccountToken</code> when configuring clusters:   <pre><code>kubernetes:\n  serviceLocatorMethod:\n    type: multiTenant\n  clusterLocatorMethods:\n    - type: config\n      clusters:\n        - name: local-cluster\n          url: ignored\n          authProvider: serviceAccount\n</code></pre></p> </li> </ul> <p>Alternatively, the kuadrant backstage plugin also supports the cluster locator method config. With this method, the kuadrant plugin will read cluster information, typically cluster URL and cluster access token (which usually expires), from the <code>app-config.yaml</code> file.</p> <pre><code>kubernetes:\n  serviceLocatorMethod:\n    type: multiTenant\n  clusterLocatorMethods:\n\n    - type: config\n      clusters:\n        - name: remote-cluster\n          url: https://example.com\n          authProvider: serviceAccount\n          serviceAccountToken: ${K8S_ACCESS_TOKEN}\n</code></pre> <p>4. Configure Catalog Rules</p> <p>Add <code>APIProduct</code> to <code>catalog.rules</code> in <code>app-config.yaml</code>:</p> <pre><code>catalog:\n  rules:\n\n    - allow: [Component, System, API, APIProduct, Resource, Location]\n</code></pre> <p>Follow the steps in Provisioning your custom Red Hat Developer Hub configuration for the full procedure.</p> A full example for \"app-config.yaml\" <pre><code>app:\n  title: Red Hat Developer Hub\n  baseUrl: https://frontend.$CLUSTER_HOSTNAME\n\n# Testing only: enables guest access for rhdh-local.\n# In production, configure your own identity provider and map roles/permissions to your users or groups.\nauth:\n  environment: development\n  providers:\n    guest:\n      dangerouslyAllowOutsideDevelopment: true\n      userEntityRef: user:default/guest\n\nkubernetes: null\n\ncatalog:\n  rules:\n\n    - allow: [Component, API, APIProduct, Location, Template, Domain, User, Group, System, Resource, Plugin, Package]\n\npermission:\n  enabled: true\n  rbac:\n    policies-csv-file: /opt/app-root/etc/rbac-policy.csv\n    policyFileReload: true\n</code></pre> <p>Finally, create a config map from the <code>app-config.yaml</code> file.</p> <pre><code>kubectl create configmap rhdh-app-config --from-file=app-config.yaml --namespace=$RHDH_NS\n</code></pre>"},{"location":"kuadrant-backstage-plugin/docs/installation/#rbac-for-kuadrant-crds","title":"RBAC for Kuadrant CRDs","text":"<p>This step grants permissions to the backstage application to manage kuadrant CRD's existing in the cluster. It consist on two steps: creating the clusterRole and then the ClusterRoleBinding.</p> <p>First, create the ClusterRole which defines permissions on the kuadrant CRD's.</p> <p>By default, backstage application will run with the <code>default</code> service account of the namespace. Thus, secondly, we need to bind that cluster role to this service account with cluster wide scope. Therefore, create CluterRoleBinding as follows:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: rhdh-kuadrant\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: rhdh-kuadrant\nsubjects:\n\n  - kind: ServiceAccount\n    name: default\n    namespace: $RHDH_NS\nEOF\n</code></pre> <p>You can verify permissions with the following command:</p> <pre><code>kubectl auth can-i update apikeys.devportal.kuadrant.io --as=system:serviceaccount:$RHDH_NS:default\n</code></pre>"},{"location":"kuadrant-backstage-plugin/docs/installation/#backstage-instance","title":"Backstage instance","text":"<p>The Backstage CR represents one backstage instance. It is where all preparation comes into one place and takes effect.</p> <ul> <li>Link the dynamic plugin configmap</li> </ul> <pre><code>spec:\n  application:\n    dynamicPluginsConfigMapName: dynamic-plugins-rhdh\n</code></pre> <ul> <li>Link the main <code>rhdh-app-config</code> configmap</li> </ul> <pre><code>spec:\n  application:\n    appConfig:\n      mountPath: /opt/app-root/src\n      configMaps:\n\n         - name: rhdh-app-config\n</code></pre> <ul> <li>Link the RBAC policies from the <code>rbac-policies</code> configmap</li> </ul> <pre><code>spec:\n  application:\n    extraFiles:\n      mountPath: /opt/app-root/etc\n      configMaps:\n\n         - name: rbac-policies\n</code></pre> <p>The mounting path is referenced from <code>app-config.yaml</code>, RBAC for the kuadrant functionality section. Ensure they match.</p> <ul> <li>[Optional] Enable serviceaccount token automount</li> </ul> <p>Only required for kubernetes access in-cluster mode.</p> <pre><code>spec:\n  deployment:\n    patch:\n      spec:\n        template:\n          spec:\n            automountServiceAccountToken: true\n</code></pre> A full example for \"rhdh\" Backstage instance <pre><code># https://github.com/redhat-developer/rhdh-operator/blob/main/api/v1alpha3/backstage_types.go\napiVersion: rhdh.redhat.com/v1alpha3\nkind: Backstage\nmetadata:\n  name: rhdh\n  namespace: $RHDH_NS\nspec:\n  application:\n    appConfig:\n      mountPath: /opt/app-root/src\n      configMaps:\n\n         - name: rhdh-app-config\n    extraFiles:\n      mountPath: /opt/app-root/etc\n      configMaps:\n         - name: rbac-policies\n    route:\n      enabled: true\n      subdomain: frontend\n    dynamicPluginsConfigMapName: dynamic-plugins-rhdh\n  database:\n    enableLocalDb: true\n  deployment:\n    patch:\n      spec:\n        template:\n          spec:\n            automountServiceAccountToken: true\n</code></pre> <p>Go to backstage_types.go for v1alpha3 for full reference on the Backstage CRD.</p>"},{"location":"kuadrant-backstage-plugin/docs/installation/#installation-on-red-hat-developer-hub-rhdh-local","title":"Installation on Red Hat Developer Hub (RHDH) Local","text":"<p>This section covers installing the plugins using rhdh-local for local development with Docker Compose.</p>"},{"location":"kuadrant-backstage-plugin/docs/installation/#1-configure-dynamic-plugins","title":"1. Configure Dynamic Plugins","text":"<p>Copy Kuadrant backstage dynamic plugins metadata into a file named <code>configs/dynamic-plugins/dynamic-plugins.override.yaml</code>:</p> <p>To get the integrity hash: <pre><code>npm view @kuadrant/kuadrant-backstage-plugin-frontend dist.integrity\nnpm view @kuadrant/kuadrant-backstage-plugin-backend-dynamic dist.integrity\n</code></pre></p>"},{"location":"kuadrant-backstage-plugin/docs/installation/#2-configure-kubernetes-access","title":"2. Configure Kubernetes Access","text":"<p>Add to <code>configs/app-config/app-config.yaml</code>:</p> <pre><code>kubernetes:\n  serviceLocatorMethod:\n    type: multiTenant\n  clusterLocatorMethods:\n\n    - type: config\n      clusters:\n        - name: production\n          url: https://host.docker.internal:&lt;port&gt;\n          authProvider: serviceAccount\n          serviceAccountToken: &lt;your-token&gt;\n          skipTLSVerify: true\n</code></pre> <p>Note: Use <code>host.docker.internal</code> to access the host machine's kind cluster from Docker. Get the port with <code>kubectl cluster-info</code>.</p>"},{"location":"kuadrant-backstage-plugin/docs/installation/#3-configure-rbac","title":"3. Configure RBAC","text":"<p>Add to <code>configs/app-config/app-config.yaml</code>:</p> <pre><code>permission:\n  enabled: true\n  rbac:\n    policies-csv-file: /opt/app-root/src/configs/rbac-policy.csv\n    policyFileReload: true\n</code></pre> <p>Create <code>configs/rbac-policy.csv</code> with the RBAC policy content.</p>"},{"location":"kuadrant-backstage-plugin/docs/installation/#4-service-account-setup","title":"4. Service Account Setup","text":"<p>Create a service account with permissions to manage Kuadrant resources</p>"},{"location":"kuadrant-backstage-plugin/docs/installation/#clusterrole","title":"ClusterRole","text":"<p>Create the ClusterRole which defines permissions on the kuadrant CRD's.</p>"},{"location":"kuadrant-backstage-plugin/docs/installation/#namespace","title":"Namespace","text":"<pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: v1\nkind: Namespace\nmetadata:\n  name: rhdh\nEOF\n</code></pre>"},{"location":"kuadrant-backstage-plugin/docs/installation/#serviceaccount","title":"ServiceAccount","text":"<pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: rhdh-kuadrant\n  namespace: rhdh\nEOF\n</code></pre>"},{"location":"kuadrant-backstage-plugin/docs/installation/#clusterrolebinding","title":"ClusterRoleBinding","text":"<pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: rhdh-kuadrant\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: rhdh-kuadrant\nsubjects:\n\n  - kind: ServiceAccount\n    name: rhdh-kuadrant\n    namespace: rhdh\nEOF\n</code></pre>"},{"location":"kuadrant-backstage-plugin/docs/installation/#5-start-rhdh","title":"5. Start RHDH","text":"<pre><code>docker compose up\n</code></pre> <p>Visit http://localhost:7007/kuadrant</p>"},{"location":"kuadrant-backstage-plugin/docs/installation/#installation-on-backstage","title":"Installation on Backstage","text":"<p>This section covers installing the plugins on a standard Backstage instance.</p>"},{"location":"kuadrant-backstage-plugin/docs/installation/#important-rbac-plugin-requirement","title":"Important: RBAC Plugin Requirement","text":"<p>The Kuadrant backend plugin includes an RBAC module that integrates with the Backstage permission framework. Standard Backstage does not include the RBAC plugin that RHDH provides.</p> <p>To use the RBAC module on Backstage, you need to install the community RBAC plugin:</p> <pre><code>yarn --cwd packages/backend add @backstage-community/plugin-rbac-backend @backstage-community/plugin-rbac-node\n</code></pre> <p>If you don't need RBAC, you can skip the RBAC module - the core plugin functionality works without it.</p>"},{"location":"kuadrant-backstage-plugin/docs/installation/#1-install-dependencies","title":"1. Install Dependencies","text":"<p>Frontend (<code>packages/app</code>):</p> <pre><code>yarn --cwd packages/app add @kuadrant/kuadrant-backstage-plugin-frontend\n</code></pre> <p>Backend (<code>packages/backend</code>):</p> <pre><code>yarn --cwd packages/backend add @kuadrant/kuadrant-backstage-plugin-backend-dynamic\n</code></pre>"},{"location":"kuadrant-backstage-plugin/docs/installation/#2-register-backend-plugin","title":"2. Register Backend Plugin","text":"<p>Edit <code>packages/backend/src/index.ts</code>:</p> <pre><code>import { createBackend } from '@backstage/backend-defaults';\nimport {\n  kuadrantPlugin,\n  catalogModuleApiProductEntityProvider,\n} from '@kuadrant/kuadrant-backstage-plugin-backend-dynamic';\n\nconst backend = createBackend();\n\n// ... other plugins ...\n\n// Kuadrant plugin\nbackend.add(kuadrantPlugin);\nbackend.add(catalogModuleApiProductEntityProvider);\n\nbackend.start();\n</code></pre>"},{"location":"kuadrant-backstage-plugin/docs/installation/#3-register-frontend-routes","title":"3. Register Frontend Routes","text":"<p>Edit <code>packages/app/src/App.tsx</code>:</p> <pre><code>import {\n  KuadrantPage,\n  ApiProductsPage,\n  ApiProductDetailPage,\n  ApiKeysPage,\n  ApiKeyDetailPage,\n} from '@kuadrant/kuadrant-backstage-plugin-frontend';\n\n// In your routes:\nconst routes = (\n  &lt;FlatRoutes&gt;\n    {/* ... other routes ... */}\n    &lt;Route path=\"/kuadrant\" element={&lt;KuadrantPage /&gt;} /&gt;\n    &lt;Route path=\"/kuadrant/api-products\" element={&lt;ApiProductsPage /&gt;} /&gt;\n    &lt;Route path=\"/kuadrant/api-products/:namespace/:name\" element={&lt;ApiProductDetailPage /&gt;} /&gt;\n    &lt;Route path=\"/kuadrant/api-keys\" element={&lt;ApiKeysPage /&gt;} /&gt;\n    &lt;Route path=\"/kuadrant/api-keys/:namespace/:name\" element={&lt;ApiKeyDetailPage /&gt;} /&gt;\n  &lt;/FlatRoutes&gt;\n);\n</code></pre>"},{"location":"kuadrant-backstage-plugin/docs/installation/#4-add-sidebar-navigation-optional","title":"4. Add Sidebar Navigation (Optional)","text":"<p>Edit <code>packages/app/src/components/Root/Root.tsx</code>:</p> <pre><code>import ExtensionIcon from '@material-ui/icons/Extension';\n\n// In your sidebar:\n&lt;SidebarItem icon={ExtensionIcon} to=\"kuadrant\" text=\"Kuadrant\" /&gt;\n</code></pre>"},{"location":"kuadrant-backstage-plugin/docs/installation/#5-configure-auth","title":"5. Configure Auth","text":"<p>Add to <code>app-config.yaml</code>. The <code>userEntityRef</code> ensures the guest user identity matches the RBAC policy:</p> <pre><code># Testing only: enables guest access for local development.\n# In production, configure your own identity provider and map roles/permissions to your users or groups.\nauth:\n  environment: development\n  providers:\n    guest:\n      dangerouslyAllowOutsideDevelopment: true\n      userEntityRef: user:default/guest\n</code></pre>"},{"location":"kuadrant-backstage-plugin/docs/installation/#6-configure-kubernetes-access","title":"6. Configure Kubernetes Access","text":"<p>Add to <code>app-config.yaml</code>:</p> <pre><code>kubernetes:\n  serviceLocatorMethod:\n    type: multiTenant\n  clusterLocatorMethods:\n\n    - type: config\n      clusters:\n        - name: production\n          url: https://127.0.0.1:&lt;port&gt;\n          authProvider: serviceAccount\n          serviceAccountToken: &lt;your-token&gt;\n          skipTLSVerify: true\n</code></pre>"},{"location":"kuadrant-backstage-plugin/docs/installation/#7-configure-catalog-rules","title":"7. Configure Catalog Rules","text":"<p>Add to <code>app-config.yaml</code>:</p> <pre><code>catalog:\n  rules:\n\n    - allow: [Component, System, API, APIProduct, Resource, Location]\n</code></pre>"},{"location":"kuadrant-backstage-plugin/docs/installation/#8-configure-permissions-and-rbac","title":"8. Configure Permissions and RBAC","text":"<p>Add to <code>app-config.yaml</code>:</p> <pre><code>permission:\n  enabled: true\n  rbac:\n    policies-csv-file: ./configs/rbac-policy.csv\n    policyFileReload: true\n</code></pre> <p>Then create the RBAC policy file at <code>configs/rbac-policy.csv</code> in your project root. See the RBAC Policy section for the full file contents.</p> <p>For example, to grant the guest user admin access:</p> <pre><code>mkdir -p configs\n</code></pre> <p>Create <code>configs/rbac-policy.csv</code> with the policies from the RBAC Policy section.</p>"},{"location":"kuadrant-backstage-plugin/docs/installation/#9-register-rbac-backend-plugin","title":"9. Register RBAC Backend Plugin","text":"<p>The default Backstage permission backend uses an allow-all policy. To use the RBAC CSV policies, replace it with the community RBAC plugin.</p> <p>In <code>packages/backend/src/index.ts</code>, replace:</p> <pre><code>backend.add(\n  import('@backstage/plugin-permission-backend-module-allow-all-policy'),\n);\n</code></pre> <p>with:</p> <pre><code>// RBAC permission policy\nbackend.add(import('@backstage-community/plugin-rbac-backend'));\n</code></pre>"},{"location":"kuadrant-backstage-plugin/docs/installation/#10-service-account-setup","title":"10. Service Account Setup","text":"<p>Create a service account with permissions to manage Kuadrant resources</p>"},{"location":"kuadrant-backstage-plugin/docs/installation/#clusterrole_1","title":"ClusterRole","text":"<p>Create the ClusterRole which defines permissions on the kuadrant CRD's.</p>"},{"location":"kuadrant-backstage-plugin/docs/installation/#namespace_1","title":"Namespace","text":"<pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: v1\nkind: Namespace\nmetadata:\n  name: rhdh\nEOF\n</code></pre>"},{"location":"kuadrant-backstage-plugin/docs/installation/#serviceaccount_1","title":"ServiceAccount","text":"<pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: rhdh-kuadrant\n  namespace: rhdh\nEOF\n</code></pre>"},{"location":"kuadrant-backstage-plugin/docs/installation/#clusterrolebinding_1","title":"ClusterRoleBinding","text":"<pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: rhdh-kuadrant\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: rhdh-kuadrant\nsubjects:\n\n  - kind: ServiceAccount\n    name: rhdh-kuadrant\n    namespace: rhdh\nEOF\n</code></pre>"},{"location":"kuadrant-backstage-plugin/docs/installation/#11-start-backstage","title":"11. Start Backstage","text":"<pre><code>yarn start\n</code></pre> <p>Visit http://localhost:3000/kuadrant</p>"},{"location":"kuadrant-backstage-plugin/docs/installation/#assets","title":"Assets","text":""},{"location":"kuadrant-backstage-plugin/docs/installation/#dynamic-plugins","title":"Dynamic Plugins","text":"<pre><code>includes:\n\n  - dynamic-plugins.default.yaml\n\nplugins:\n  # Kuadrant Backend\n\n  - package: \"@kuadrant/kuadrant-backstage-plugin-backend-dynamic@$KUADRANT_PLUGIN_VERSION\"\n    disabled: false\n    integrity: $KUADRANT_BACKSTAGE_PLUGIN_BACKEND_DYNAMIC_SHA256\n\n  # Kuadrant Frontend\n\n  - package: \"@kuadrant/kuadrant-backstage-plugin-frontend@$KUADRANT_PLUGIN_VERSION\"\n    integrity: $KUADRANT_BACKSTAGE_PLUGIN_FRONTEND_SHA256\n    disabled: false\n    pluginConfig:\n      dynamicPlugins:\n        frontend:\n          internal.plugin-kuadrant:\n            appIcons:\n              - name: kuadrantIcon\n                importName: KuadrantIcon\n            dynamicRoutes:\n              - path: /kuadrant\n                importName: KuadrantPage\n                menuItem:\n                  icon: kuadrantIcon\n                  text: Kuadrant\n              - path: /kuadrant/api-products/:namespace/:name\n                importName: ApiProductDetailPage\n              - path: /kuadrant/api-keys/:namespace/:name\n                importName: ApiKeyDetailPage\n            mountPoints:\n              - mountPoint: entity.page.api/cards\n                importName: EntityKuadrantApiKeyManagementTab\n                config:\n                  layout:\n                    gridColumn: \"1 / -1\"\n                  if:\n                    allOf:\n                      - isKind: api\n              - mountPoint: entity.page.api/cards\n                importName: EntityKuadrantApiProductInfoContent\n                config:\n                  layout:\n                    gridColumn: \"1 / -1\"\n                  if:\n                    allOf:\n                      - isKind: api\n</code></pre>"},{"location":"kuadrant-backstage-plugin/docs/installation/#rbac-policy","title":"RBAC Policy","text":"<p>Example <code>rbac-policy.csv</code> for Kuadrant permissions:</p> <pre><code># api consumer: browses apis, requests access\np, role:default/api-consumer, kuadrant.apiproduct.read.all, read, allow\np, role:default/api-consumer, kuadrant.apiproduct.list, read, allow\np, role:default/api-consumer, kuadrant.apikey.create, create, allow, apiproduct:*/*\np, role:default/api-consumer, kuadrant.apikey.read.own, read, allow\np, role:default/api-consumer, kuadrant.apikey.update.own, update, allow\np, role:default/api-consumer, kuadrant.apikey.delete.own, delete, allow\np, role:default/api-consumer, catalog.entity.read, read, allow\n\n# api owner: publishes apis they own, approves requests for their apis\np, role:default/api-owner, kuadrant.planpolicy.read, read, allow\np, role:default/api-owner, kuadrant.planpolicy.list, read, allow\np, role:default/api-owner, kuadrant.apiproduct.create, create, allow\np, role:default/api-owner, kuadrant.apiproduct.read.all, read, allow\np, role:default/api-owner, kuadrant.apiproduct.update.own, update, allow\np, role:default/api-owner, kuadrant.apiproduct.delete.own, delete, allow\np, role:default/api-owner, kuadrant.apiproduct.list, read, allow\np, role:default/api-owner, kuadrant.apikey.create, create, allow, apiproduct:*/*\np, role:default/api-owner, kuadrant.apikey.read.own, read, allow\np, role:default/api-owner, kuadrant.apikey.update.own, update, allow\np, role:default/api-owner, kuadrant.apikey.delete.own, delete, allow\np, role:default/api-owner, kuadrant.apikey.approve, update, allow\np, role:default/api-owner, catalog.entity.read, read, allow\n\n# api admin: platform engineers who manage all api products\np, role:default/api-admin, kuadrant.planpolicy.read, read, allow\np, role:default/api-admin, kuadrant.planpolicy.list, read, allow\np, role:default/api-admin, kuadrant.apiproduct.create, create, allow\np, role:default/api-admin, kuadrant.apiproduct.read.all, read, allow\np, role:default/api-admin, kuadrant.apiproduct.update.all, update, allow\np, role:default/api-admin, kuadrant.apiproduct.delete.all, delete, allow\np, role:default/api-admin, kuadrant.apiproduct.list, read, allow\np, role:default/api-admin, kuadrant.apikey.create, create, allow, apiproduct:*/*\np, role:default/api-admin, kuadrant.apikey.read.all, read, allow\np, role:default/api-admin, kuadrant.apikey.update.all, update, allow\np, role:default/api-admin, kuadrant.apikey.delete.all, delete, allow\np, role:default/api-admin, kuadrant.apikey.approve, update, allow\np, role:default/api-admin, catalog.entity.read, read, allow\n\n# assign groups to roles\ng, group:default/api-consumers, role:default/api-consumer\ng, group:default/api-owners, role:default/api-owner\ng, group:default/api-admins, role:default/api-admin\n\n# Development/testing only: assign guest user to admin role.\n# For production, remove this line and assign roles to your actual users or groups.\ng, user:default/guest, role:default/api-admin\n</code></pre>"},{"location":"kuadrant-backstage-plugin/docs/installation/#clusterrole_2","title":"ClusterRole","text":"<p>Permissions to manage resources from kuadrant CRDs.</p> <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: rhdh-kuadrant\nrules:\n\n  - apiGroups: [\"kuadrant.io\"]\n    resources:\n      - authpolicies\n      - ratelimitpolicies\n      - dnspolicies\n      - tlspolicies\n    verbs: [\"get\", \"list\", \"watch\"]\n  - apiGroups: [\"extensions.kuadrant.io\"]\n    resources:\n      - planpolicies\n    verbs: [\"get\", \"list\", \"watch\"]\n  - apiGroups: [\"devportal.kuadrant.io\"]\n    resources:\n      - apiproducts\n      - apikeys\n    verbs: [\"get\", \"list\", \"watch\", \"create\", \"delete\", \"patch\", \"update\"]\n  - apiGroups: [\"devportal.kuadrant.io\"]\n    resources:\n      - apikeys/status\n    verbs: [\"get\", \"patch\", \"update\"]\n  - apiGroups: [\"gateway.networking.k8s.io\"]\n    resources:\n      - gateways\n      - httproutes\n    verbs: [\"get\", \"list\", \"watch\"]\n  - apiGroups: [\"\"]\n    resources:\n      - namespaces\n    verbs: [\"get\", \"list\", \"watch\"]\n  - apiGroups: [\"\"]\n    resources:\n      - secrets\n    verbs: [\"get\", \"list\", \"watch\", \"create\", \"delete\"]\n</code></pre>"},{"location":"kuadrant-backstage-plugin/docs/installation/#exposed-modules","title":"Exposed Modules","text":""},{"location":"kuadrant-backstage-plugin/docs/installation/#frontend","title":"Frontend","text":"Import Name Description <code>KuadrantPage</code> Main page with API products and approval queue <code>ApiProductsPage</code> API products list page <code>ApiProductDetailPage</code> Single API product detail page <code>ApiKeysPage</code> API keys list page <code>ApiKeyDetailPage</code> Single API key detail page <code>EntityKuadrantApiAccessCard</code> API key request card for entity overview <code>EntityKuadrantApiKeyManagementTab</code> Full API keys management tab <code>EntityKuadrantApiKeysContent</code> API keys content component <code>EntityKuadrantApiProductInfoContent</code> APIProduct details tab <code>KuadrantIcon</code> Kuadrant logo icon for navigation"},{"location":"kuadrant-backstage-plugin/docs/installation/#backend","title":"Backend","text":"Export Description <code>kuadrantPlugin</code> Main backend plugin with HTTP router <code>catalogModuleApiProductEntityProvider</code> Catalog entity provider for APIProduct sync <code>rbacModule</code> RBAC module for permission integration (requires RBAC plugin)"},{"location":"kuadrant-backstage-plugin/docs/installation/#verification","title":"Verification","text":"<p>After installation:</p> <ol> <li>Navigate to <code>/kuadrant</code> - you should see the main Kuadrant page</li> <li>Check the catalog for APIProduct entities synced from Kubernetes</li> <li>Navigate to an API entity and verify Kuadrant components appear</li> </ol>"},{"location":"kuadrant-backstage-plugin/docs/installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"kuadrant-backstage-plugin/docs/installation/#apiproduct-entities-not-appearing","title":"APIProduct entities not appearing","text":"<ol> <li>Check backend logs for entity provider sync messages</li> <li>Verify Kubernetes connectivity</li> <li>Ensure APIProduct CRDs exist in your cluster</li> <li>Check catalog rules allow APIProduct kind</li> </ol>"},{"location":"kuadrant-backstage-plugin/docs/installation/#api-key-requests-failing","title":"API key requests failing","text":"<ol> <li>Verify Kubernetes write permissions for the service account</li> <li>Check backend logs for detailed error messages</li> <li>Ensure the target namespace exists and is accessible</li> </ol>"},{"location":"kuadrant-backstage-plugin/docs/installation/#related-documentation","title":"Related Documentation","text":"<ul> <li>RBAC Permissions - Detailed permissions guide</li> <li>Kuadrant Docs - Kuadrant documentation</li> <li>RHDH Local - RHDH local development</li> </ul>"},{"location":"kuadrant-backstage-plugin/docs/overview/","title":"Developer Portal Overview","text":"<p>The Developer Portal brings self-service API access management to Kubernetes-native organizations. It bridges the gap between API providers who want to share their services and developers who need to consume them, providing a structured workflow for API discovery, access requests, and credential management.</p>"},{"location":"kuadrant-backstage-plugin/docs/overview/#the-problem-api-access-at-scale","title":"The Problem: API Access at Scale","text":"<p>Organizations running microservices on Kubernetes face a common challenge: how do you let developers both internal and external discover and consume your APIs safely and efficiently?</p> <p>Without a structured approach, teams resort to ad-hoc solutions:</p> <ul> <li>Sharing API keys through Slack messages or wikis</li> <li>Manual onboarding processes that don't scale</li> <li>No visibility into who is using which APIs</li> <li>Inconsistent rate limiting and access controls</li> <li>APIs that exist but remain undiscoverable</li> </ul> <p>The Developer Portal addresses this by providing a Kubernetes-native system where APIs are cataloged, access is requested through a formal workflow, and credentials are managed automatically.</p>"},{"location":"kuadrant-backstage-plugin/docs/overview/#how-it-works","title":"How It Works","text":"<p>The Developer Portal introduces two Custom Resource Definitions (CRDs) that model API products and access requests:</p> <p>APIProduct represents an API offering. It wraps an existing HTTPRoute with the business context needed for consumption: a human-readable name, documentation links, contact information, and access policies. When an API owner creates an APIProduct and sets its <code>publishStatus</code> to <code>Published</code>, it becomes discoverable in the Backstage developer portal.</p> <p>APIKey represents a developer's request for API access. It captures the requester's identity, their intended use case, and their desired service tier. Depending on the APIProduct's approval mode, the request is either automatically approved or queued for manual review. Upon approval, the controller generates secure credentials stored as Kubernetes Secrets.</p> <p>This model means that API access follows the same patterns as other Kubernetes resources: declarative, auditable, and managed through standard tooling.</p>"},{"location":"kuadrant-backstage-plugin/docs/overview/#authentication-methods","title":"Authentication Methods","text":"<p>The Developer Portal supports two authentication methods for protecting APIs. The method is configured at the platform level via AuthPolicy and automatically discovered by the controller.</p>"},{"location":"kuadrant-backstage-plugin/docs/overview/#api-key-authentication","title":"API Key Authentication","text":"<p>API key authentication uses Kubernetes Secrets to store credentials. This method involves a request and approval workflow:</p> <ol> <li>API consumer creates an APIKey resource requesting access</li> <li>Depending on the APIProduct's <code>approvalMode</code>:</li> <li>Manual: Request enters <code>Pending</code> state, awaiting API owner approval</li> <li>Automatic: Request is immediately approved by the controller</li> <li>Upon approval, the controller generates a Secret containing the API key</li> <li>Consumer retrieves the key from Backstage and uses it in API requests</li> <li>AuthPolicy validates incoming requests against the generated Secrets</li> </ol> <p>This method is ideal for internal APIs, development environments, or scenarios where you want fine-grained control over who can access your API.</p>"},{"location":"kuadrant-backstage-plugin/docs/overview/#oidcjwt-authentication","title":"OIDC/JWT Authentication","text":"<p>OIDC (OpenID Connect) authentication delegates credential management to an external identity provider. There is no request/approval workflow in the Developer Portal:</p> <ol> <li>Platform engineer configures AuthPolicy with JWT validation pointing to an OIDC issuer</li> <li>The controller discovers the JWT authentication scheme and performs OIDC discovery to find the token endpoint</li> <li>Discovered authentication details are surfaced in the APIProduct status</li> <li>API consumer views the identity provider URL and token endpoint in Backstage</li> <li>Consumer obtains a JWT token directly from the identity provider (e.g., using client credentials flow or any other available flow)</li> <li>Consumer uses the JWT token in API requests</li> <li>AuthPolicy validates the token's signature and claims against the OIDC issuer</li> </ol> <p>This method is ideal for APIs that integrate with existing identity providers (Keycloak, Auth0, Azure AD, etc.), need stronger authentication, or require integration with enterprise SSO systems. No APIKey resources are created\u2014access control happens at the identity provider level.</p>"},{"location":"kuadrant-backstage-plugin/docs/overview/#developer-portal-personas","title":"Developer Portal Personas","text":"<p>The Developer Portal serves four distinct personas, each with different concerns and workflows.</p>"},{"location":"kuadrant-backstage-plugin/docs/overview/#1-the-api-consumer","title":"1. The API Consumer","text":"<p>API consumers are developers who need to integrate with services provided by other teams. They experience the portal primarily through Backstage, where they can:</p> <ul> <li>Browse a catalog of available APIs with descriptions, documentation links, and OpenAPI specifications</li> <li>See what service tiers are available and their associated rate limits</li> <li>View authentication requirements and obtain credentials</li> </ul> <p>The authentication experience depends on how the API is protected:</p> <p>For API Key Authentication:</p> <ul> <li>Request access by creating an APIKey resource (either directly or through the Backstage UI)</li> <li>Receive an API key once their request is approved (credentials are shown once and must be saved immediately)</li> <li>Use the API key in the <code>Authorization</code> header when making requests</li> </ul> <p>For OIDC/JWT Authentication:</p> <ul> <li>View the OIDC provider details and token endpoint</li> <li>Obtain an access token from the identity provider using their client credentials</li> <li>Use the JWT token in the <code>Authorization</code> header when making requests</li> <li>No APIKey resource is needed, authentication is handled by the external identity provider</li> </ul> <p>From the consumer's perspective, the value is discoverability and self-service. Rather than searching through wikis or asking colleagues, they find what they need in a single catalog. The portal surfaces the authentication method and provides clear guidance on how to obtain credentials, whether through the API key request workflow or by interacting with an OIDC provider.</p>"},{"location":"kuadrant-backstage-plugin/docs/overview/#2-the-api-owner","title":"2. The API Owner","text":"<p>API owners are the teams responsible for specific services. They control how their APIs are presented and accessed:</p> <ul> <li>Define how the API appears in the catalog through APIProduct metadata</li> <li>For API key authentication:</li> <li>Choose between automatic and manual approval for access requests</li> <li>Review pending access requests and approve or reject them</li> <li>Set documentation links so consumers can self-serve</li> </ul> <p>The authentication and approval workflow depends on the authentication requirements set by the platform engineering team. For API key authentication, owners can choose between automatic approval (useful for development environments or internal tooling) and manual approval (for production APIs requiring human review). The <code>approvalMode</code> field on APIProduct lets owners make this choice per-API.</p> <p>For OIDC/JWT authentication, there is no config required. Access control is managed entirely by the external identity provider.</p>"},{"location":"kuadrant-backstage-plugin/docs/overview/#3-the-api-admin","title":"3. The API Admin","text":"<p>API Admins provide cross-team oversight and governance without being infrastructure-focused platform engineers. They bridge the gap between individual API owners and the platform team:</p> <ul> <li>View and manage all API Products across the organization, regardless of ownership</li> <li>Approve or reject any API key request, enabling centralized governance</li> <li>Troubleshoot issues on behalf of API Owners</li> <li>Ensure consistency across API Products (naming, documentation standards, etc.)</li> </ul> <p>This role is particularly valuable in larger organizations where individual API owners may be unavailable, or where a central team needs visibility into all API access for compliance or security reasons. Unlike platform engineers, API Admins work within the Developer Portal rather than managing the underlying infrastructure.</p>"},{"location":"kuadrant-backstage-plugin/docs/overview/#4-the-platform-engineer","title":"4. The Platform Engineer","text":"<p>Platform engineers install and configure the Developer Portal infrastructure. Their responsibilities include:</p> <ul> <li>Deploying the Developer Portal Controller and Backstage plugin</li> <li>Creating HTTPRoutes and annotating them for exposure to API owners</li> <li>Configuring AuthPolicy resources for authentication:</li> <li>API key validation using Kubernetes Secrets</li> <li>OIDC/JWT validation with external identity providers</li> <li>Defining PlanPolicy resources that specify rate limit tiers</li> <li>Setting up RBAC so appropriate users can create, approve, and manage resources</li> </ul> <p>The platform team doesn't need to be involved in individual API publications or access requests \u2014 those are handled by API owners and consumers. Instead, they establish the guardrails and infrastructure that make self-service possible. When configuring OIDC authentication, platform engineers work with identity provider administrators to obtain issuer URLs and configure the AuthPolicy accordingly.</p>"},{"location":"kuadrant-backstage-plugin/docs/overview/#architecture","title":"Architecture","text":"<p>The Developer Portal consists of several components working together:</p> <pre><code>flowchart TB\n    subgraph Backstage[\"Backstage UI\"]\n        Catalog[\"API Catalog\"]\n        Requests[\"Access Requests\"]\n        Docs[\"API Docs\"]\n    end\n\n    subgraph K8s[\"Kubernetes Cluster\"]\n        subgraph Controller[\"Developer Portal Controller\"]\n            Reconcile[\"Reconciles APIProduct and APIKey\"]\n            Discover[\"Discovers PlanPolicy and AuthPolicy\"]\n            Generate[\"Generates Secrets for approved APIKeys\"]\n            Fetch[\"Fetches OpenAPI and OIDC discovery\"]\n        end\n\n        APIProduct[\"APIProduct&lt;br/&gt;displayName, targetRef&lt;br/&gt;approvalMode, status\"]\n        APIKey[\"APIKey&lt;br/&gt;apiProductRef, planTier&lt;br/&gt;requestedBy, status\"]\n        Secret[\"Secret&lt;br/&gt;api_key\"]\n        HTTPRoute[\"HTTPRoute&lt;br/&gt;Gateway\"]\n        PlanPolicy[\"PlanPolicy&lt;br/&gt;tiers, rate limits\"]\n        AuthPolicy[\"AuthPolicy&lt;br/&gt;API key validation\"]\n    end\n\n    Backstage --&gt;|\"Reads/Creates CRDs\"| K8s\n    APIKey --&gt;|\"references\"| APIProduct\n    APIKey --&gt;|\"creates\"| Secret\n    APIProduct --&gt;|\"references\"| HTTPRoute\n    PlanPolicy --&gt;|\"targets\"| HTTPRoute\n    AuthPolicy --&gt;|\"targets\"| HTTPRoute</code></pre> <p>The flow works as follows:</p> <ol> <li>Platform engineers create HTTPRoutes (standard Gateway API routing) and attach PlanPolicy (rate limits) and AuthPolicy (authentication)</li> <li>API owners select an available HTTPRoute and create an APIProduct that adds catalog metadata</li> <li>The controller discovers these policies and updates the APIProduct status with available plans</li> <li>Backstage reads APIProduct resources and displays them in the catalog</li> <li>Consumers browse the catalog and create APIKey resources to request access</li> <li>The controller processes APIKey requests, auto-approving or waiting for manual approval based on the APIProduct's configuration</li> <li>Upon approval, the controller generates a Secret containing the API key</li> <li>The consumer retrieves their key and uses it to authenticate API requests</li> <li>AuthPolicy validates incoming requests against the generated Secrets</li> <li>PlanPolicy enforces rate limits based on the consumer's selected tier</li> </ol>"},{"location":"kuadrant-backstage-plugin/docs/overview/#integration-with-kuadrant","title":"Integration with Kuadrant","text":"<p>The Developer Portal is designed as part of the Kuadrant ecosystem. It builds on:</p> <ul> <li>Gateway API: The standard Kubernetes API for traffic routing. APIProduct references HTTPRoute.</li> <li>Kuadrant AuthPolicy: Enforces authentication at the gateway level. The controller discovers AuthPolicy configurations and surfaces authentication details to consumers:</li> <li>For API key authentication: The controller creates Secrets with labels that AuthPolicy (via Authorino) uses for validation</li> <li>For OIDC/JWT authentication: The controller discovers the JWT issuer URL from the AuthPolicy, performs OIDC discovery to find the token endpoint, and surfaces both to consumers in the Backstage UI</li> <li>PlanPolicy: A Kuadrant extension for tiered rate limiting. The controller discovers plan definitions and surfaces them to consumers.</li> </ul> <p>This integration means the Developer Portal doesn't duplicate functionality, it adds the product catalog and credential discovery workflow on top of existing traffic management and policy enforcement. Whether using API keys or OIDC, authentication is always enforced by Kuadrant's AuthPolicy\u2014the Developer Portal simply makes the authentication requirements discoverable and, for API keys, manages the credential lifecycle.</p>"},{"location":"kuadrant-backstage-plugin/docs/overview/#next-steps","title":"Next Steps","text":"<ul> <li>Getting Started Tutorial: Set up a complete example with an API product and access request</li> <li>Installation Guide: Deploy the Developer Portal Controller to your cluster</li> </ul>"},{"location":"kuadrant-backstage-plugin/docs/rbac-permissions/","title":"RBAC and Permissions","text":"<p>This document describes the complete permission model for the Kuadrant Backstage plugin.</p>"},{"location":"kuadrant-backstage-plugin/docs/rbac-permissions/#overview","title":"Overview","text":"<p>The Kuadrant plugin uses Backstage's RBAC system for access control across API Products, API Keys, and Plan Policies. Permissions follow a consistent <code>.own</code> / <code>.all</code> pattern for resource-level access control.</p>"},{"location":"kuadrant-backstage-plugin/docs/rbac-permissions/#design-principles","title":"Design Principles","text":"<p>When adding or modifying permissions, follow these principles:</p>"},{"location":"kuadrant-backstage-plugin/docs/rbac-permissions/#1-pure-rbac-only","title":"1. Pure RBAC Only","text":"<p>All authorisation decisions must use Backstage RBAC permissions. Never bypass RBAC with:</p> <ul> <li>Group membership checks (e.g., <code>if (user.groups.includes('api-owners'))</code>)</li> <li>Data-based ownership checks for UI visibility (e.g., <code>if (user owns any API products)</code>)</li> <li>Role flags derived from user identity</li> </ul> <p>If you need to control access to a feature, create a permission for it.</p>"},{"location":"kuadrant-backstage-plugin/docs/rbac-permissions/#2-one-permission-per-distinct-capability","title":"2. One Permission Per Distinct Capability","text":"<p>Each permission should represent a single, well-defined capability. Don't overload permissions with multiple meanings.</p> <p>Example: <code>kuadrant.apikey.update.own</code> was overloaded:</p> <ul> <li>Consumers used it to edit their pending requests</li> <li>API Owners used it to imply approval queue access</li> </ul> <p>Solution: Added <code>kuadrant.apikey.approve</code> as a separate permission for approval queue access.</p>"},{"location":"kuadrant-backstage-plugin/docs/rbac-permissions/#3-ui-visibility-permission-check","title":"3. UI Visibility = Permission Check","text":"<p>If a UI element should be hidden from certain users, gate it with a permission check. Don't use data queries to determine visibility.</p> <pre><code>// correct - pure RBAC\nconst { allowed } = useKuadrantPermission(kuadrantApiKeyApprovePermission);\nif (allowed) {\n  return &lt;ApprovalQueueCard /&gt;;\n}\n\n// incorrect - data-based check\nconst userOwnsProducts = apiProducts.some(p =&gt; p.owner === userId);\nif (userOwnsProducts) {\n  return &lt;ApprovalQueueCard /&gt;;\n}\n</code></pre>"},{"location":"kuadrant-backstage-plugin/docs/rbac-permissions/#4-backend-enforces-frontend-hints","title":"4. Backend Enforces, Frontend Hints","text":"<p>Permissions in the frontend are for UX (hiding buttons, showing appropriate UI). The backend must always enforce permissions independently - never trust the frontend.</p>"},{"location":"kuadrant-backstage-plugin/docs/rbac-permissions/#5-scope-permissions-appropriately","title":"5. Scope Permissions Appropriately","text":"<ul> <li><code>.own</code> - user can act on resources they created/own</li> <li><code>.all</code> - user can act on any resource regardless of ownership</li> <li>No scope - permission applies globally (e.g., <code>list</code>, <code>create</code>)</li> </ul> <p>For actions that don't fit the ownership model (like viewing an approval queue), use an unscoped permission.</p>"},{"location":"kuadrant-backstage-plugin/docs/rbac-permissions/#permission-structure","title":"Permission Structure","text":""},{"location":"kuadrant-backstage-plugin/docs/rbac-permissions/#naming-convention","title":"Naming Convention","text":"<p>Permissions follow the pattern: <code>kuadrant.&lt;resource&gt;.&lt;action&gt;[.scope]</code></p> <ul> <li>resource: <code>planpolicy</code>, <code>apiproduct</code>, <code>apikey</code></li> <li>action: <code>create</code>, <code>read</code>, <code>update</code>, <code>delete</code>, <code>list</code></li> <li>scope: <code>own</code> (user's resources) or <code>all</code> (any resource) - omitted for non-scoped permissions</li> </ul>"},{"location":"kuadrant-backstage-plugin/docs/rbac-permissions/#permission-types","title":"Permission Types","text":"<p>Basic Permissions: No ownership scope, apply globally</p> <ul> <li><code>kuadrant.planpolicy.create</code></li> <li><code>kuadrant.planpolicy.read</code></li> <li><code>kuadrant.planpolicy.list</code></li> </ul> <p>Scoped Permissions: Ownership-aware access control</p> <ul> <li><code>kuadrant.apiproduct.read.own</code> - read your own API Products</li> <li><code>kuadrant.apiproduct.read.all</code> - read any API Product</li> </ul> <p>Resource Permissions: Include resource references for fine-grained control</p> <ul> <li><code>kuadrant.apikey.create</code> with resource ref <code>apiproduct:namespace/name</code></li> </ul>"},{"location":"kuadrant-backstage-plugin/docs/rbac-permissions/#complete-permission-list","title":"Complete Permission List","text":""},{"location":"kuadrant-backstage-plugin/docs/rbac-permissions/#planpolicy-permissions","title":"PlanPolicy Permissions","text":"Permission Description Notes <code>kuadrant.planpolicy.create</code> Create plan policies Not exposed via plugin - managed on cluster <code>kuadrant.planpolicy.read</code> Read plan policy details <code>kuadrant.planpolicy.update</code> Update plan policies Not exposed via plugin <code>kuadrant.planpolicy.delete</code> Delete plan policies Not exposed via plugin <code>kuadrant.planpolicy.list</code> List plan policies"},{"location":"kuadrant-backstage-plugin/docs/rbac-permissions/#apiproduct-permissions","title":"APIProduct Permissions","text":"Permission Description Scope <code>kuadrant.apiproduct.create</code> Create API Products - <code>kuadrant.apiproduct.read.own</code> Read your own API Products Own <code>kuadrant.apiproduct.read.all</code> Read any API Product All <code>kuadrant.apiproduct.update.own</code> Update your own API Products Own <code>kuadrant.apiproduct.update.all</code> Update any API Product All <code>kuadrant.apiproduct.delete.own</code> Delete your own API Products Own <code>kuadrant.apiproduct.delete.all</code> Delete any API Product All <code>kuadrant.apiproduct.list</code> List API Products (filtered by read permissions) -"},{"location":"kuadrant-backstage-plugin/docs/rbac-permissions/#apikey-permissions","title":"APIKey Permissions","text":"Permission Description Scope <code>kuadrant.apikey.create</code> Request API access Resource (APIProduct) <code>kuadrant.apikey.read.own</code> Read requests you created Own <code>kuadrant.apikey.read.all</code> Read any request All <code>kuadrant.apikey.update.own</code> Edit your own pending requests Own <code>kuadrant.apikey.update.all</code> Update any request All <code>kuadrant.apikey.delete.own</code> Delete your own requests Own <code>kuadrant.apikey.delete.all</code> Delete any request All <code>kuadrant.apikey.approve</code> Access approval queue, approve/reject requests - <code>kuadrant.apikey.list</code> List requests (filtered by read permissions) -"},{"location":"kuadrant-backstage-plugin/docs/rbac-permissions/#authpolicy-permissions","title":"AuthPolicy Permissions","text":"Permission Description Notes <code>kuadrant.authpolicy.list</code> List authpolicies Read-only access for API Admins and Owners"},{"location":"kuadrant-backstage-plugin/docs/rbac-permissions/#ratelimitpolicy-permissions","title":"RateLimitPolicy Permissions","text":"Permission Description Notes <code>kuadrant.ratelimitpolicy.list</code> List ratelimitpolicies Read-only access for API Admins and Owners"},{"location":"kuadrant-backstage-plugin/docs/rbac-permissions/#role-definitions","title":"Role Definitions","text":"<p>The Kuadrant plugin defines four personas with distinct responsibilities and permissions:</p>"},{"location":"kuadrant-backstage-plugin/docs/rbac-permissions/#api-consumer","title":"API Consumer","text":"<p>Purpose: End users who consume APIs</p> <p>Permissions:</p> <ul> <li><code>kuadrant.apiproduct.read.all</code> - browse API catalog</li> <li><code>kuadrant.apiproduct.list</code></li> <li><code>kuadrant.apikey.create</code> - request API access</li> <li><code>kuadrant.apikey.read.own</code> - view own requests</li> <li><code>kuadrant.apikey.update.own</code> - edit own pending requests</li> <li><code>kuadrant.apikey.delete.own</code> - cancel own requests</li> <li><code>kuadrant.apikey.read.own</code> - view own API keys</li> <li><code>kuadrant.apikey.delete.own</code> - revoke own API keys</li> </ul> <p>Cannot:</p> <ul> <li>Create or manage API Products</li> <li>Approve/reject requests</li> <li>View other users' API keys</li> </ul>"},{"location":"kuadrant-backstage-plugin/docs/rbac-permissions/#api-owner","title":"API Owner","text":"<p>Purpose: Users who publish and manage their own APIs</p> <p>Permissions:</p> <ul> <li>All API Consumer permissions, plus:</li> <li><code>kuadrant.planpolicy.read</code> - view plan policies (for reference)</li> <li><code>kuadrant.planpolicy.list</code></li> <li><code>kuadrant.apiproduct.create</code> - create API Products</li> <li><code>kuadrant.apiproduct.read.own</code> - view own API Products</li> <li><code>kuadrant.apiproduct.update.own</code> - update own API Products</li> <li><code>kuadrant.apiproduct.delete.own</code> - delete own API Products</li> <li><code>kuadrant.apikey.approve</code> - access approval queue, approve/reject requests for own APIs</li> <li><code>kuadrant.apikey.read.own</code> - view API keys for own APIs</li> <li><code>kuadrant.apikey.delete.own</code> - delete API keys for own APIs</li> </ul> <p>Cannot:</p> <ul> <li>View or modify other owners' API Products</li> <li>Create/update/delete PlanPolicies (managed on cluster)</li> <li>Approve requests for other owners' APIs</li> </ul>"},{"location":"kuadrant-backstage-plugin/docs/rbac-permissions/#api-admin","title":"API Admin","text":"<p>Purpose: Platform engineers who manage all API Products</p> <p>Responsibilities:</p> <ul> <li>Manages all API Products across the platform</li> <li>Approves/rejects any API key request (cross-team)</li> <li>Troubleshoots issues on behalf of API Owners</li> <li>Provides second-level support for API management</li> </ul> <p>Permissions:</p> <ul> <li>All <code>.all</code> scoped permissions</li> <li><code>kuadrant.apiproduct.create</code> - create any API Product</li> <li><code>kuadrant.apiproduct.read.all</code> - view all API Products</li> <li><code>kuadrant.apiproduct.update.all</code> - update any API Product</li> <li><code>kuadrant.apiproduct.delete.all</code> - delete any API Product</li> <li><code>kuadrant.apikey.read.all</code> - view all requests</li> <li><code>kuadrant.apikey.update.all</code> - update any request</li> <li><code>kuadrant.apikey.approve</code> - access approval queue, approve/reject any request</li> <li><code>kuadrant.apikey.delete.all</code> - delete any request/API key</li> <li>RBAC policy management permissions</li> </ul> <p>Cannot:</p> <ul> <li>Create/update/delete PlanPolicies (managed on cluster)</li> <li>Create/update/delete AuthPolicies (managed on cluster)</li> <li>Create/update/delete RateLimitPolicies (managed on cluster)</li> <li>Modify platform infrastructure (HTTPRoutes, Gateways)</li> </ul>"},{"location":"kuadrant-backstage-plugin/docs/rbac-permissions/#platform-engineer","title":"Platform Engineer","text":"<p>Purpose: Infrastructure engineers who manage Kuadrant platform</p> <p>Responsibilities:</p> <ul> <li>Manages cluster infrastructure (Gateways, HTTPRoutes, PlanPolicies)</li> <li>Creates PlanPolicy resources with rate limit tiers</li> <li>Coordinates with API Admins and API Owners when changing rate limits</li> <li>Does not typically manage individual API Products (delegated to API Admins/Owners)</li> </ul> <p>Permissions:</p> <ul> <li>Full cluster admin access (Kubernetes RBAC)</li> <li>Create/read/update/delete PlanPolicy resources</li> <li>Create/read/update/delete HTTPRoute resources</li> <li>Create/read/update/delete Gateway resources</li> <li>Manage RBAC policies</li> </ul> <p>Cannot:</p> <ul> <li>Typically does not manage day-to-day API Products (delegates to API Admin)</li> </ul>"},{"location":"kuadrant-backstage-plugin/docs/rbac-permissions/#rbac-permissions-matrix","title":"RBAC Permissions Matrix","text":"<p>Comprehensive view of what each persona can and cannot do:</p> Persona Can Do Cannot Do Platform Engineer \u2022 Manage Kuadrant infrastructure (Gateways, HTTPRoutes)\u2022 Create/update/delete PlanPolicy resources\u2022 Manage RBAC policies and permissions\u2022 Configure platform-wide settings\u2022 Full cluster admin access for platform management \u2022 Typically does not manage day-to-day API Products (delegates to API Admin/Owner)\u2022 Should coordinate with API Admins and API Owners before changing rate limits API Admin \u2022 Read all APIProducts\u2022 Create/update/delete any APIProduct\u2022 Approve/reject any API key requests\u2022 Manage all API keys (read/delete)\u2022 View all APIKeys\u2022 Troubleshoot on behalf of API Owners\u2022 All <code>.all</code> scoped permissions \u2022 Cannot create/update/delete PlanPolicy\u2022 Cannot modify platform infrastructure (HTTPRoutes, Gateways) API Owner \u2022 Read/list HTTPRoutes (to publish APIs)\u2022 Create/update/delete own APIProducts\u2022 Read all APIProducts\u2022 Approve/reject API key requests for own APIs\u2022 Delete API key requests for own APIs\u2022 Manage own API documentation\u2022 View/manage API keys for own APIs \u2022 Cannot create/update PlanPolicy\u2022 Cannot modify platform infrastructure\u2022 Cannot approve requests for other owners' APIs\u2022 Cannot update/delete other owners' APIProducts API Consumer \u2022 Read/list APIProduct\u2022 Create APIKey\u2022 Read/update/delete own APIKeys\u2022 View own request status\u2022 Manage own API keys\u2022 Use APIs within rate limit quotas \u2022 Cannot approve requests\u2022 Cannot view others' requests\u2022 Cannot create or publish APIs\u2022 Cannot modify rate limits"},{"location":"kuadrant-backstage-plugin/docs/rbac-permissions/#permission-breakdown-by-resource","title":"Permission Breakdown by Resource","text":"<p>PlanPolicy (rate limit tiers):</p> <ul> <li>Platform Engineer: create, read, update, delete</li> <li>API Admin: read, list (for reference)</li> <li>API Owner: read, list (for reference)</li> <li>API Consumer: none</li> </ul> <p>HTTPRoute:</p> <ul> <li>Platform Engineer: create, read, update, delete, annotate</li> <li>API Admin: read, list (for reference)</li> <li>API Owner: read, list (to select for publishing)</li> <li>API Consumer: none (indirect read through APIProduct)</li> </ul> <p>APIProduct (catalog entries):</p> <ul> <li>Platform Engineer: typically none (delegated to API Admin/Owner)</li> <li>API Admin: create, read, update, delete (all)</li> <li>API Owner: create, read (all), update (own), delete (own)</li> <li>API Consumer: read, list</li> </ul> <p>APIKey (access requests):</p> <ul> <li>Platform Engineer: typically none (delegated to API Admin)</li> <li>API Admin: create, read (all), update (all), delete (all), approve</li> <li>API Owner: create, read (own), update (own), delete (own), approve (for own APIs)</li> <li>API Consumer: create, read (own), update (own - edit pending), delete (own)</li> </ul> <p>AuthPolicy (authentication rules):</p> <ul> <li>Platform Engineer: create, read, update, delete</li> <li>API Admin: list (for reference)</li> <li>API Owner: list (for reference)</li> <li>API Consumer: none</li> </ul> <p>RateLimitPolicy (rate limiting rules):</p> <ul> <li>Platform Engineer: create, read, update, delete</li> <li>API Admin: list (for reference)</li> <li>API Owner: list (for reference)</li> <li>API Consumer: none</li> </ul>"},{"location":"kuadrant-backstage-plugin/docs/rbac-permissions/#role-hierarchy","title":"Role Hierarchy","text":"<p>The four personas form a clear hierarchy:</p> <ol> <li>Platform Engineer - infrastructure layer (cluster, gateways, rate limits)</li> <li>API Admin - management layer (all API Products, all requests)</li> <li>API Owner - ownership layer (own API Products, own API requests)</li> <li>API Consumer - consumption layer (browse, request, use)</li> </ol> <p>Each layer builds on the capabilities below it, with clear boundaries of responsibility.</p>"},{"location":"kuadrant-backstage-plugin/docs/rbac-permissions/#ownership-model","title":"Ownership Model","text":""},{"location":"kuadrant-backstage-plugin/docs/rbac-permissions/#ownership-tracking","title":"Ownership Tracking","text":"<p>APIProducts track ownership via the standard Backstage annotation:</p> <pre><code>metadata:\n  annotations:\n    backstage.io/owner: \"user:default/jmadigan\"\n</code></pre> <p>The owner reference uses Backstage's entity reference format: <code>kind:namespace/name</code></p> <p>Immutability: The ownership annotation is set on creation and cannot be modified. This prevents ownership hijacking and maintains clear accountability.</p> <p>Timestamp: Kubernetes automatically sets <code>metadata.creationTimestamp</code> for audit purposes.</p>"},{"location":"kuadrant-backstage-plugin/docs/rbac-permissions/#backend-enforcement-pattern","title":"Backend Enforcement Pattern","text":"<p>All sensitive endpoints use tiered permission checks:</p> <pre><code>// 1. try .all permission first (admin access)\nconst allDecision = await permissions.authorize(\n  [{ permission: kuadrantApiProductUpdateAllPermission }],\n  { credentials }\n);\n\nif (allDecision[0].result !== AuthorizeResult.ALLOW) {\n  // 2. fallback to .own permission\n  const ownDecision = await permissions.authorize(\n    [{ permission: kuadrantApiProductUpdateOwnPermission }],\n    { credentials }\n  );\n\n  if (ownDecision[0].result !== AuthorizeResult.ALLOW) {\n    throw new NotAllowedError('unauthorised');\n  }\n\n  // 3. verify ownership\n  const apiProduct = await k8sClient.getCustomResource(...);\n  const owner = apiProduct.metadata?.annotations?.['backstage.io/owner'];\n  const ownerUserId = extractUserIdFromOwner(owner); // extracts \"jmadigan\" from \"user:default/jmadigan\"\n\n  if (ownerUserId !== userId) {\n    throw new NotAllowedError('you can only update your own api products');\n  }\n}\n\n// proceed with operation\n</code></pre>"},{"location":"kuadrant-backstage-plugin/docs/rbac-permissions/#list-endpoint-filtering","title":"List Endpoint Filtering","text":"<p>List endpoints return different results based on permissions:</p> <pre><code>// GET /apiproducts\nif (hasReadAllPermission) {\n  return allApiProducts;\n} else if (hasReadOwnPermission) {\n  return allApiProducts.filter(p =&gt; {\n    const owner = p.metadata?.annotations?.['backstage.io/owner'];\n    const ownerUserId = extractUserIdFromOwner(owner);\n    return ownerUserId === userId;\n  });\n} else {\n  throw new NotAllowedError('unauthorised');\n}\n</code></pre>"},{"location":"kuadrant-backstage-plugin/docs/rbac-permissions/#approval-workflow","title":"Approval Workflow","text":""},{"location":"kuadrant-backstage-plugin/docs/rbac-permissions/#approval-queue-visibility","title":"Approval Queue Visibility","text":"<p>The approval queue card is gated by <code>kuadrant.apikey.approve</code>:</p> <pre><code>const { allowed } = useKuadrantPermission(kuadrantApiKeyApprovePermission);\nif (allowed) {\n  return &lt;ApprovalQueueCard /&gt;;\n}\n</code></pre> <ul> <li>API Consumers: No approval queue (no <code>approve</code> permission)</li> <li>API Owners: See approval queue, can approve requests for their own APIs</li> <li>API Admins: See approval queue, can approve any request</li> </ul>"},{"location":"kuadrant-backstage-plugin/docs/rbac-permissions/#backend-approval-enforcement","title":"Backend Approval Enforcement","text":"<p>The backend uses tiered permission checks for the actual approve/reject action:</p> <ol> <li>Check <code>kuadrant.apikey.update.all</code> (admin access)</li> <li>Fallback to ownership verification (API owner must own the APIProduct)</li> </ol> <pre><code>// approval endpoint logic\nconst updateAllDecision = await permissions.authorize(\n  [{ permission: kuadrantAPIKeyUpdateAllPermission }],\n  { credentials }\n);\n\nif (updateAllDecision[0].result !== AuthorizeResult.ALLOW) {\n  // not an admin - verify ownership of the APIProduct\n  const apiProduct = await k8sClient.getCustomResource(...);\n  const owner = apiProduct.metadata?.annotations?.['backstage.io/owner'];\n  const ownerUserId = extractUserIdFromOwner(owner);\n\n  if (ownerUserId !== userId) {\n    throw new NotAllowedError('you can only approve requests for your own api products');\n  }\n}\n</code></pre> <p>Note: <code>kuadrant.apikey.approve</code> controls UI visibility of the approval queue. The backend enforces ownership separately to ensure API Owners can only approve requests for their own APIs.</p>"},{"location":"kuadrant-backstage-plugin/docs/rbac-permissions/#per-apiproduct-access-control","title":"Per-APIProduct Access Control","text":"<p>The <code>kuadrant.apikey.create</code> permission supports resource references for fine-grained control:</p> <pre><code># allow all consumers to request any API\np, role:default/api-consumer, kuadrant.apikey.create, create, allow, apiproduct:*/*\n\n# restrict specific APIs to specific roles\np, role:default/partner, kuadrant.apikey.create, create, allow, apiproduct:toystore/toystore-api\np, role:default/internal, kuadrant.apikey.create, create, allow, apiproduct:internal/*\n</code></pre> <p>Backend checks include the resource reference:</p> <pre><code>const resourceRef = `apiproduct:${apiNamespace}/${apiName}`;\nconst decision = await permissions.authorize([{\n  permission: kuadrantAPIKeyCreatePermission,\n  resourceRef,\n}], { credentials });\n</code></pre>"},{"location":"kuadrant-backstage-plugin/docs/rbac-permissions/#catalog-integration","title":"Catalog Integration","text":"<p>The APIProduct entity provider only syncs products with ownership annotations to the Backstage catalog:</p> <pre><code>const owner = product.metadata.annotations?.['backstage.io/owner'];\nif (!owner) {\n  console.warn(`skipping apiproduct ${namespace}/${name} - no ownership annotation`);\n  return null;\n}\n\nconst entity: ApiEntity = {\n  spec: {\n    owner,  // \"user:default/jmadigan\"\n    // ...\n  }\n};\n</code></pre> <p>This ensures clean separation between Backstage-managed and kubectl-managed resources.</p>"},{"location":"kuadrant-backstage-plugin/docs/rbac-permissions/#rbac-configuration","title":"RBAC Configuration","text":""},{"location":"kuadrant-backstage-plugin/docs/rbac-permissions/#policy-file-location","title":"Policy File Location","text":"<p><code>rbac-policy.csv</code> at repository root</p>"},{"location":"kuadrant-backstage-plugin/docs/rbac-permissions/#configuration-reference","title":"Configuration Reference","text":"<p>See <code>app-config.local.yaml</code>:</p> <pre><code>permission:\n  enabled: true\n  rbac:\n    policies-csv-file: ./rbac-policy.csv\n    policyFileReload: true\n</code></pre>"},{"location":"kuadrant-backstage-plugin/docs/rbac-permissions/#testing-different-roles","title":"Testing Different Roles","text":"<p>Use the included helper scripts:</p> <pre><code>yarn user:consumer  # switch to API Consumer role\nyarn user:owner     # switch to API Owner role\nyarn user:default   # restore default permissions\n</code></pre> <p>After switching roles, restart with <code>yarn dev</code>.</p>"},{"location":"kuadrant-backstage-plugin/docs/rbac-permissions/#security-considerations","title":"Security Considerations","text":""},{"location":"kuadrant-backstage-plugin/docs/rbac-permissions/#input-validation","title":"Input Validation","text":"<p>All mutating endpoints use Zod schemas to validate request bodies with explicit whitelists:</p> <pre><code>const patchSchema = z.object({\n  spec: z.object({\n    displayName: z.string().optional(),\n    description: z.string().optional(),\n    // only allowed fields - targetRef, namespace, etc. excluded\n  }).partial(),\n});\n</code></pre>"},{"location":"kuadrant-backstage-plugin/docs/rbac-permissions/#ownership-immutability","title":"Ownership Immutability","text":"<p>PATCH endpoints explicitly prevent modification of ownership annotation:</p> <pre><code>// prevent ownership hijacking\nif (req.body.metadata?.annotations) {\n  delete req.body.metadata.annotations['backstage.io/owner'];\n}\n</code></pre>"},{"location":"kuadrant-backstage-plugin/docs/rbac-permissions/#authentication-required","title":"Authentication Required","text":"<p>All endpoints require valid authentication with no guest fallbacks:</p> <pre><code>const credentials = await httpAuth.credentials(req);\n\nif (!credentials || !credentials.principal) {\n  throw new NotAllowedError('authentication required');\n}\n</code></pre>"},{"location":"kuadrant-backstage-plugin/docs/rbac-permissions/#frontend-permission-checks","title":"Frontend Permission Checks","text":"<p>Use the custom <code>useKuadrantPermission</code> hook for permission-aware UI:</p> <pre><code>import { useKuadrantPermission } from '../../utils/permissions';\n\nconst { allowed, loading, error } = useKuadrantPermission(\n  kuadrantApiProductCreatePermission\n);\n\nif (loading) return &lt;Progress /&gt;;\nif (!allowed) return null; // hide button\n</code></pre> <p>For ownership-aware actions:</p> <pre><code>import { canDeleteResource } from '../../utils/permissions';\n\nconst canDelete = canDeleteResource(\n  resource.spec.requestedBy.userId,  // owner\n  currentUserId,                      // current user\n  canDeleteOwnPermission,             // permission to delete own\n  canDeleteAllPermission              // permission to delete all\n);\n</code></pre>"},{"location":"kuadrant-backstage-plugin/docs/rbac-permissions/#two-layer-rbac-model","title":"Two-Layer RBAC Model","text":"<p>The Kuadrant plugin uses separate RBAC layers with clear separation:</p> <p>Layer 1: Backstage RBAC (Portal Access Control)</p> <ul> <li>Catalog visibility: who can see API entities</li> <li>Request creation: who can request API keys</li> <li>Approval: who can approve/reject requests</li> <li>Management: who can create/delete APIProducts</li> </ul> <p>Layer 2: Kuadrant/Gateway RBAC (Runtime Access Control)</p> <ul> <li>API key validation: is this key valid? (AuthPolicy)</li> <li>Rate limiting: what limits apply? (PlanPolicy predicate checks)</li> <li>Authentication: does request have valid auth? (AuthPolicy)</li> </ul> <p>No overlap: Backstage controls who gets API keys, Kuadrant/Gateway enforces runtime limits.</p>"},{"location":"kuadrant-backstage-plugin/kuadrant-dev-setup/","title":"kuadrant development setup","text":"<p>development environment for kuadrant plugins in rhdh.</p>"},{"location":"kuadrant-backstage-plugin/kuadrant-dev-setup/#quick-start","title":"quick start","text":"<pre><code># create kind cluster with kuadrant\nmake kind-create\n\n# start rhdh with hot reload\ncd ..\nyarn dev\n</code></pre> <p>visit http://localhost:3000/kuadrant</p>"},{"location":"kuadrant-backstage-plugin/kuadrant-dev-setup/#what-gets-installed","title":"what gets installed","text":"<p>kubernetes cluster (kind):</p> <ul> <li>kind cluster named <code>local-cluster</code></li> <li>kuadrant operator (from <code>main</code>)</li> <li>gateway api crds v1.2.0</li> <li>istio service mesh (base + istiod)</li> </ul> <p>kuadrant components:</p> <ul> <li>custom crds: APIProduct, APIKey</li> <li>kuadrant instance in <code>kuadrant-system</code> namespace</li> </ul> <p>demo resources (toystore):</p> <ul> <li>toystore namespace</li> <li>gateway with httproute</li> <li>authpolicy for api key authentication</li> <li>planpolicy for rate limiting</li> <li>sample api products</li> <li>example secrets</li> </ul> <p>rbac:</p> <ul> <li>rhdh service account with cluster access</li> <li>permissions for kuadrant crds and secrets</li> </ul>"},{"location":"kuadrant-backstage-plugin/kuadrant-dev-setup/#directory-structure","title":"directory structure","text":"<pre><code>kuadrant-dev-setup/\n\u251c\u2500\u2500 Makefile                  # cluster and kuadrant setup\n\u251c\u2500\u2500 README.md                 # this file\n\u251c\u2500\u2500 crds/                     # custom resource definitions\n\u2502   \u251c\u2500\u2500 devportal.kuadrant.io_apiproduct.yaml\n\u2502   \u2514\u2500\u2500 devportal.kuadrant.io_apikey.yaml\n\u251c\u2500\u2500 demo/                     # demo resources\n\u2502   \u2514\u2500\u2500 toystore-demo.yaml    # toystore api with policies\n\u251c\u2500\u2500 rbac/                     # rbac configs\n\u2502   \u2514\u2500\u2500 rhdh-rbac.yaml        # rhdh service account permissions\n\u2514\u2500\u2500 scripts/                  # helper scripts\n    \u2514\u2500\u2500 kind-cluster.yaml     # kind cluster configuration\n</code></pre>"},{"location":"kuadrant-backstage-plugin/kuadrant-dev-setup/#commands","title":"commands","text":""},{"location":"kuadrant-backstage-plugin/kuadrant-dev-setup/#cluster-management","title":"cluster management","text":"<pre><code>make kind-create    # create cluster + install kuadrant + demo\nmake kind-delete    # delete cluster\nmake clean          # delete cluster + cleanup bin/\n</code></pre>"},{"location":"kuadrant-backstage-plugin/kuadrant-dev-setup/#kuadrant","title":"kuadrant","text":"<pre><code>make kuadrant-install [KUADRANT_VERSION=v1.3.0] # install kuadrant. Version defaults to main branch\nmake demo-install       # install toystore demo\nmake demo-uninstall     # remove toystore demo\n</code></pre>"},{"location":"kuadrant-backstage-plugin/kuadrant-dev-setup/#verify-installation","title":"verify installation","text":"<pre><code># check kuadrant pods\nkubectl get pods -n kuadrant-system\n\n# check demo resources\nkubectl get pods -n toystore\nkubectl get apiproducts -n toystore\nkubectl get gateway -n toystore\nkubectl get httproute -n toystore\nkubectl get authpolicies -n toystore\nkubectl get planpolicies -n toystore\n\n# check api keys\nkubectl get secrets -n toystore\n</code></pre>"},{"location":"kuadrant-backstage-plugin/kuadrant-dev-setup/#development-workflow","title":"development workflow","text":"<ol> <li> <p>create cluster (once):    <pre><code>make kind-create\n</code></pre></p> </li> <li> <p>develop plugins (with hot reload):    <pre><code>cd ..\nyarn dev\n</code></pre>    changes to plugin code automatically rebuild</p> </li> <li> <p>test in browser:</p> </li> <li>main page: http://localhost:3000/kuadrant</li> <li>catalog: http://localhost:3000/catalog</li> <li> <p>api entity: http://localhost:3000/catalog/default/api/toystore-api</p> </li> <li> <p>cleanup (when done):    <pre><code>make kind-delete\n</code></pre></p> </li> </ol>"},{"location":"kuadrant-backstage-plugin/kuadrant-dev-setup/#troubleshooting","title":"troubleshooting","text":""},{"location":"kuadrant-backstage-plugin/kuadrant-dev-setup/#cluster-wont-start","title":"cluster won't start","text":"<pre><code># delete and recreate\nmake kind-delete\nmake kind-create\n</code></pre>"},{"location":"kuadrant-backstage-plugin/kuadrant-dev-setup/#kuadrant-not-installing","title":"kuadrant not installing","text":"<pre><code># check helm repos\n./bin/helm-v3.13.0 repo list\n\n# reinstall\nmake kuadrant-install\n</code></pre>"},{"location":"kuadrant-backstage-plugin/kuadrant-dev-setup/#demo-resources-missing","title":"demo resources missing","text":"<pre><code># reinstall demo\nmake demo-uninstall\nmake demo-install\n</code></pre>"},{"location":"kuadrant-backstage-plugin/kuadrant-dev-setup/#rhdh-cant-connect-to-cluster","title":"rhdh can't connect to cluster","text":"<pre><code># verify service account\nkubectl get sa rhdh-service-account -n rhdh\n\n# check rbac\nkubectl get clusterrole rhdh-kuadrant\nkubectl get clusterrolebinding rhdh-kuadrant\n\n# check kubeconfig (rhdh uses local ~/.kube/config in dev mode)\nkubectl config current-context\n</code></pre>"},{"location":"kuadrant-backstage-plugin/kuadrant-dev-setup/#dependencies","title":"dependencies","text":"<p>the makefile automatically downloads:</p> <ul> <li>kind v0.20.0 (to <code>bin/kind-v0.20.0</code>)</li> <li>helm v3.13.0 (to <code>bin/helm-v3.13.0</code>)</li> </ul> <p>no manual installation needed.</p>"},{"location":"kuadrant-backstage-plugin/kuadrant-dev-setup/#differences-from-kuadrant-backstage-plugin-repo","title":"differences from kuadrant-backstage-plugin repo","text":"<p>this setup is simplified for rhdh development:</p> <p>what we kept:</p> <ul> <li>kind cluster creation</li> <li>kuadrant installation</li> <li>toystore demo resources</li> <li>custom crds</li> </ul> <p>what we simplified:</p> <ul> <li>single makefile (no complex includes)</li> <li>no rhdh-local submodule (uses rhdh's yarn dev)</li> <li>no dynamic plugin export (direct imports)</li> <li>no rbac user switching (uses guest auth)</li> <li>no separate backstage mode (only hot reload mode)</li> </ul> <p>result: cleaner development experience with hot reload and full catalog integration.</p>"},{"location":"mcp-gateway/docs/design/backend-mcp-management/","title":"Backend mcp management","text":""},{"location":"mcp-gateway/docs/design/backend-mcp-management/#mcp-server-registration-and-management","title":"MCP Server Registration and Management","text":""},{"location":"mcp-gateway/docs/design/backend-mcp-management/#problem","title":"Problem","text":"<p>The MCP Gateway needs to discover and register backend MCP servers so that their tools can be aggregated and presented to clients as a unified MCP server. When an MCPServerRegistration custom resource is created or updated in Kubernetes, the MCP Controller must:</p> <ol> <li>Discover the MCP server endpoint from the referenced HTTPRoute</li> <li>Update the broker and router configuration</li> <li>Initialize connections to the backend MCP server</li> <li>Discover available tools</li> <li>Register for state change notifications</li> <li>Handle configuration changes</li> <li>Periodically ensure that the backend MCP Server is alive and healthy</li> </ol> <p>The broker needs a robust mechanism to manage the lifecycle of each upstream MCP server connection, including periodic health checks, reconnection logic, and graceful handling of configuration changes.</p>"},{"location":"mcp-gateway/docs/design/backend-mcp-management/#solution","title":"Solution","text":"<p>The MCP Gateway uses a two-phase registration process:</p> <ol> <li>Controller Phase: The MCP Controller watches for MCPServerRegistration resources, discovers server endpoints from HTTPRoutes, and writes aggregated configuration to ConfigMaps</li> <li>Broker Phase: The MCP Broker reads configuration changes and manages each upstream MCP server through an <code>MCPManager</code> struct that handles the full lifecycle of the connection</li> </ol> <p>Each upstream MCP server is managed by a dedicated <code>MCPManager</code> instance that runs as a background routine, handling:</p> <ul> <li>Initial connection and discovery</li> <li>Periodic health checks and reconnection</li> <li>State change notification subscriptions such as <code>notifications/tools/list_changed</code></li> <li>Graceful shutdown</li> </ul>"},{"location":"mcp-gateway/docs/design/backend-mcp-management/#registration-flow","title":"Registration Flow","text":"<pre><code>sequenceDiagram\n  participant Controller as MCP Controller\n  participant ConfigMap as ConfigMap\n  participant Broker as MCP Broker\n  participant Manager as MCPManager\n  participant Server as MCP Server\n\n  Note over Controller: Watch MCPServerRegistration resources\n  Controller-&gt;&gt;ConfigMap: Write aggregated config\n  Note right of ConfigMap: Config includes:&lt;br/&gt;- Server URL&lt;br/&gt;- Hostname&lt;br/&gt;- Tool Prefix&lt;br/&gt;- Credentials\n\n  ConfigMap-&gt;&gt;Broker: Config change notification\n  Broker-&gt;&gt;Broker: OnConfigChange()\n\n  alt Server not registered\n    Broker-&gt;&gt;Broker: mcpManager := NewMCPManager(config)\n    Broker-&gt;&gt;Manager: Start() [background routine]\n    Broker-&gt;&gt;Broker: upstreamMCPS[id] = mcpManager\n  else Server already registered\n    Broker-&gt;&gt;Broker: Check if config changed\n    alt Config changed\n      Broker-&gt;&gt;Broker: upstreamMCPS[id].Stop()\n        Broker-&gt;&gt;Broker: mcpManager := NewMCPManager(config)\n        Broker-&gt;&gt;Manager: Start() [background routine]\n        Broker-&gt;&gt;Broker: upstreamMCPS[id] = mcpManager\n    end\n  end\n\n  Note over Manager,Server: MCPManager lifecycle\n  Manager-&gt;&gt;Server: POST /mcp \"initialize\"\n  Server-&gt;&gt;Manager: initialize response\n  Note right of Manager: Validate protocol version&lt;br/&gt;and capabilities\n  Manager-&gt;&gt;Server: POST /mcp \"notifications/initialized\"\n  Note right of Manager: Subscribe to state change&lt;br/&gt;notifications via SSE\n  Manager-&gt;&gt;Server: GET /mcp [SSE connection]\n  Manager-&gt;&gt;Server: POST /mcp \"tools/list\"\n  Server-&gt;&gt;Manager: tools/list response\n  Manager-&gt;&gt;Broker: Register discovered tools\n  Manager-&gt;&gt;Manager: Periodic health checks\n  Manager-&gt;&gt;Server: [monitor for notifications]\n  Controller-&gt;&gt;Broker: Fetch status updates /status</code></pre>"},{"location":"mcp-gateway/docs/design/backend-mcp-management/#mcpmanager-responsibilities","title":"MCPManager Responsibilities","text":"<p>The <code>MCPManager</code> is responsible for managing a single upstream MCP server connection. It handles:</p> <ol> <li>Initialization: Establishes connection, validates protocol version and capabilities</li> <li>Discovery: Fetches initial tool list and registers tools with the broker</li> <li>Notification Subscription: Sets up SSE connection for state change events</li> <li>Health Monitoring: Periodically checks connection health and reconnects if needed</li> <li>Notification Handling: Processes state change notifications and forwards them to the broker</li> <li>Graceful Shutdown: Cleans up connections and resources when stopped</li> </ol>"},{"location":"mcp-gateway/docs/design/backend-mcp-management/#state-change-notifications","title":"State Change Notifications","text":"<p>The MCPManager subscribes to state change notifications from the upstream MCP server:</p> <ul> <li><code>notifications/tools/list_changed</code></li> <li><code>notifications/resources/list_changed</code></li> <li><code>notifications/prompts/list_changed</code></li> <li><code>notifications/roots/list_changed</code></li> </ul> <p>When a notification is received, the MCPManager:</p> <ol> <li>Updates its internal state (e.g., re-fetches tool list)</li> <li>Forwards the notification to the broker</li> <li>The broker forwards it to all connected clients</li> </ol> <p>For more details, see the notifications design documentation.</p>"},{"location":"mcp-gateway/docs/design/backend-mcp-management/#error-handling-and-retry-logic","title":"Error Handling and Retry Logic","text":"<p>The MCPManager implements exponential backoff retry for:</p> <ul> <li>Initial connection failures</li> <li>Discovery failures</li> <li>Health check failures</li> <li>Notification connection drops</li> </ul> <p>Retries are handled in background routines to avoid blocking the main broker operations.</p>"},{"location":"mcp-gateway/docs/design/backend-mcp-management/#status-and-health","title":"Status and Health","text":"<p>The broker exposes status information about registered servers:</p> <ul> <li>Connection status</li> <li>Last successful discovery time</li> <li>Tool count</li> <li>Error messages (if any)</li> </ul> <p>This information is available via the <code>/status</code> endpoint for debugging and monitoring.</p>"},{"location":"mcp-gateway/docs/design/flows/","title":"MCP Gateway Request Flows","text":"<p>This document captures the main request flows that involve the MCP Gateway.</p> <p>note: Some show \"no auth\" this is to reduce noise and focus on the main flow through the gateway components.</p>"},{"location":"mcp-gateway/docs/design/flows/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Components</li> <li>High Level Flow</li> <li>Initialize</li> <li>Aggregated Tools/List</li> <li>Tools/Call (no auth)</li> <li>MCP Server Registration</li> <li>Auth</li> <li>Tools/Call with auth (valid bearer token)</li> <li>MCP Server Tool Call with Auth (Full auth flow)</li> <li>MCP Notifications</li> </ul>"},{"location":"mcp-gateway/docs/design/flows/#components","title":"Components","text":"Component Description Gateway Envoy proxy handling ingress traffic. Routes requests based on headers set by MCPRouter. MCPRouter Envoy external processor (ext_proc) that parses MCP requests, validates payloads, and sets routing headers (authority, x-mcp-tool, etc.). MCPBroker HTTP service that aggregates tools from multiple upstream MCP servers. Handles initialize and tools/list requests. MCPServer An upstream MCP server that provides tools. Receives tools/call requests routed by the Gateway. SessionCache In-memory or Redis based cache storing backend MCP server session IDs, keyed by gateway-session-id and server-name. WASM WebAssembly filter in Envoy that integrates with Authorino via Kuadrant for auth enforcement. Authorino Authentication and authorization service that validates JWTs and enforces AuthPolicy rules. AuthServer External OAuth/OIDC provider for client authentication."},{"location":"mcp-gateway/docs/design/flows/#high-level-flow","title":"High Level Flow","text":"<p>The flow below shows the common request flow with MCP Gateway. The MCPBackend represents either an actual MCPServer or the MCPBroker component. The type of request dictates which of these will be called in response to the MCP request.</p> <pre><code>sequenceDiagram\n        title MCP Gateway Request Flow\n        actor MCPClient\n        MCPClient-&gt;&gt;Gateway: MCP Request\n        Gateway-&gt;&gt;MCPRouter: MCP Request\n        MCPRouter-&gt;&gt;Gateway: Set headers and routing instructions\n        Gateway-&gt;&gt;Auth: Auth MCP Request &lt;br/&gt; (if configured)\n        Auth-&gt;&gt;Gateway: Auth response &lt;br/&gt; (ok/not ok)\n        Gateway-&gt;&gt;MCPClient: (not ok)\n        note left of MCPRouter: (request auth ok)\n        note right of Gateway: tools/call to the target MCPServer &lt;br/&gt; tools/list, initialize to the MCPBroker component &lt;br/&gt; tool list filtering is applied by the MCPBroker component.\n        Gateway-&gt;&gt;MCPBackend:   MCP Request\n        MCPBackend-&gt;&gt;MCPClient: MCP Response</code></pre>"},{"location":"mcp-gateway/docs/design/flows/#initialize","title":"Initialize","text":"<pre><code>sequenceDiagram\n        title MCP Initialize Request Flow (no auth)\n        actor MCPClient\n        MCPClient-&gt;&gt;Gateway: POST /mcp init\n        Gateway-&gt;&gt;MCPRouter: POST /mcp init\n        MCPRouter-&gt;&gt;Gateway: set headers\n        Gateway-&gt;&gt;MCPBroker: POST /mcp init\n        note right of MCPBroker: MCPBroker is the default backend for /mcp\n        MCPBroker-&gt;&gt;MCPClient: set mcp-session-id</code></pre>"},{"location":"mcp-gateway/docs/design/flows/#aggregated-toolslist","title":"Aggregated Tools/List","text":"<p>Auth is removed in this diagram. Auth is shown in larger diagrams below.</p> <pre><code>sequenceDiagram\n  actor MCPClient\n  participant Gateway as Gateway\n  participant MCPRouter as MCPRouter\n  participant MCPBroker as MCPBroker\n  MCPClient-&gt;&gt;Gateway: tools/list\n  Gateway-&gt;&gt;MCPRouter: tools/list\n  MCPRouter-&gt;&gt;Gateway: set headers\n  Gateway-&gt;&gt;MCPBroker: tools/list\n  MCPBroker-&gt;&gt;MCPClient: aggregated tools/list response\n  note left of MCPBroker: list is built via discovery phase. &lt;br/&gt; The MCPBroker applies filtering to this list. &lt;br/&gt; via signed x-authorised-tools header &lt;br/&gt; and client specified x-mcp-virtualserver headers.</code></pre>"},{"location":"mcp-gateway/docs/design/flows/#toolscall","title":"Tools/Call","text":"<pre><code>sequenceDiagram\n        title MCP Tool Call\n        actor MCPClient\n        MCPClient-&gt;&gt;Gateway: POST /mcp\n        note right of MCPClient: method: tools/call\n        Gateway-&gt;&gt;MCPRouter: POST /mcp\n        note left of MCPRouter: method: tools/call &lt;br/&gt; gateway mcp-session-id present &lt;br/&gt; payload validated\n        MCPRouter-&gt;&gt;SessionCache: get backend mcp server mcp-session-id\n        SessionCache-&gt;&gt;MCPRouter: no backend mcp server session found\n        MCPRouter-&gt;&gt;Gateway: initialize with client headers via gateway to ensure any additional auth applied\n        Gateway-&gt;&gt;MCPServer: initialize\n        MCPServer-&gt;&gt;MCPRouter: initialize response OK\n        MCPRouter-&gt;&gt;SessionCache: store backend mcp server mcp-session-id keyed against gateway-session-id/server-name\n        MCPRouter-&gt;&gt;Gateway: set header mcp-session-id\n        MCPRouter-&gt;&gt;Gateway: set header authority: &lt;configured host&gt;\n        MCPRouter-&gt;&gt;Gateway: update body to remove prefix (if needed)\n        MCPRouter-&gt;&gt;Gateway: set header x-mcp-tool header\n        Gateway-&gt;&gt;MCPServer: Route &lt;configured host&gt; Post /mcp tools/call\n        MCPServer-&gt;&gt;MCPClient: tools/call response</code></pre>"},{"location":"mcp-gateway/docs/design/flows/#mcp-server-registration","title":"MCP Server Registration","text":"<p>For detailed information on how MCP server registration works, including the MCPManager lifecycle and configuration change handling, see the backend MCP Management doc.</p>"},{"location":"mcp-gateway/docs/design/flows/#auth","title":"Auth","text":"<p>Below are some attempts with Auth in the mix.</p>"},{"location":"mcp-gateway/docs/design/flows/#mcp-gateway-request-authentication","title":"MCP Gateway Request Authentication","text":""},{"location":"mcp-gateway/docs/design/flows/#toolscall-with-auth-valid-bearer-token","title":"Tools/Call with auth (valid bearer token)","text":"<pre><code>sequenceDiagram\n        title Simplified MCP Tool Call with Auth\n        MCPClient-&gt;&gt;Gateway: POST /mcp\n        note right of MCPClient: method: tools/call &lt;br/&gt; name: prefix_echo\n        Gateway-&gt;&gt;MCPRouter: POST /mcp\n        note left of MCPRouter: method: tools/call &lt;br/&gt; name: prefix_echo\n        MCPRouter-&gt;&gt;Gateway: set authority: &lt;prefix&gt;.&lt;host&gt;\n        MCPRouter-&gt;&gt;Gateway: update body to remove prefix\n        MCPRouter-&gt;&gt;Gateway: set x-mcp-tool, x-mcp-method header\n        Gateway-&gt;&gt;WASM: apply auth\n        WASM-&gt;&gt;Authorino: apply auth policy rules\n        note right of Authorino: checking JWT, method and tool name access etc &lt;br/&gt; rules defined in AuthPolicy\n        Authorino-&gt;&gt;WASM: OK\n        WASM-&gt;&gt;Gateway: OK\n        Gateway-&gt;&gt;MCPServer: POST /mcp tools/call</code></pre> <p>In the above diagram we are showing the flow when a client has a valid bearer token. Below we have the full flow including the OAuth dance:</p> <pre><code>sequenceDiagram\n        title MCP Initialize Request Flow (auth)\n        actor MCPClient\n        MCPClient-&gt;&gt;Gateway: POST /mcp init\n        Gateway-&gt;&gt;MCPRouter: POST /mcp init\n        MCPRouter-&gt;&gt;Gateway: no routing needed\n        Gateway-&gt;&gt;WASM: POST /mcp init\n        WASM-&gt;&gt;Authorino: Apply Auth\n        Authorino-&gt;&gt;MCPClient: 401 WWW-Authenticate with resource meta-data\n        note left of Authorino: WWW-Authenticate: Bearer &lt;br/&gt; resource_metadata=&lt;host&gt;/.well-known/oauth-protected-resource/mcp\n        MCPClient-&gt;&gt;Gateway: GET /.well-known/oauth-protected-resource/mcp\n        Gateway-&gt;&gt;MCPRouter: GET /.well-known/oauth-protected-resource/mcp\n        MCPRouter-&gt;&gt;Gateway: no routing needed\n        Gateway-&gt;&gt;MCPBroker: GET /.well-known/oauth-protected-resource/mcp\n        MCPBroker-&gt;&gt;MCPClient: responds with resource json with configured auth server etc\n        MCPClient-&gt;&gt;AuthServer: register\n        MCPClient-&gt;&gt;AuthServer: authenticate\n        AuthServer-&gt;&gt;MCPClient: authenticated !\n        MCPClient-&gt;&gt;Gateway: Bearer header set POST/mcp init\n        Gateway-&gt;&gt;MCPRouter: POST /mcp init\n        MCPRouter-&gt;&gt;Gateway: no routing needed\n        Gateway-&gt;&gt;WASM: POST /mcp init\n        WASM-&gt;&gt;Authorino: Apply Auth\n        Authorino-&gt;&gt;WASM: 200\n        Gateway-&gt;&gt;MCPBroker: POST /mcp init\n        MCPBroker-&gt;&gt;MCPClient: init response 200</code></pre>"},{"location":"mcp-gateway/docs/design/flows/#mcp-server-tool-call-with-auth-full-auth-flow","title":"MCP Server Tool Call with Auth (Full auth flow)","text":"<pre><code>sequenceDiagram\n        title MCP Tool Call (auth)\n        MCPClient-&gt;&gt;Gateway: POST /mcp\n        note right of MCPClient: method: tools/call &lt;br/&gt; name: prefix_echo\n        Gateway-&gt;&gt;MCPRouter: POST /mcp\n        note left of MCPRouter: method: tools/call &lt;br/&gt; name: prefix_echo\n        MCPRouter-&gt;&gt;Gateway: set authority: &lt;prefix&gt;.&lt;host&gt;\n        MCPRouter-&gt;&gt;Gateway: update body to remove prefix\n        MCPRouter-&gt;&gt;Gateway: set x-mcp-tool header\n        Gateway-&gt;&gt;WASM: auth on authority\n        WASM-&gt;&gt;Authorino: apply auth\n        note right of Authorino: checking JWT and tool name &lt;br/&gt; defined in AuthPolicy\n        Authorino-&gt;&gt;WASM: 401 WWW-Authenticate\n        note left of Authorino: WWW-Authenticate: Bearer &lt;br/&gt; resource_metadata=&lt;host&gt;/.well-known/oauth-protected-resource/mcp\n        WASM-&gt;&gt;MCPClient: 401 WWW-Authenticate\n        note left of WASM: WWW-Authenticate: Bearer &lt;br/&gt; resource_metadata=&lt;host&gt;/.well-known/oauth-protected-resource/mcp\n        MCPClient-&gt;&gt;Gateway: .well-known/oauth-protected-resource/mcp\n        Gateway-&gt;&gt;MCPRouter: .well-known/oauth-protected-resource/mcp\n        Gateway-&gt;&gt;MCPBroker: .well-known/oauth-protected-resource/mcp\n        MCPBroker-&gt;&gt;MCPClient: auth metadata response\n        MCPClient-&gt;&gt;AuthServer: Authenticate (dynamic client reg etc)\n        AuthServer-&gt;&gt;MCPClient: Authenticated !!\n        MCPClient-&gt;&gt;Gateway: Bearer header set POST/mcp\n        note right of MCPClient: method: tools/call &lt;br/&gt; name: prefix_echo\n        Gateway-&gt;&gt;MCPRouter: POST /mcp tools/call\n        MCPRouter-&gt;&gt;Gateway: set authority: &lt;prefix&gt;.&lt;host&gt;\n        MCPRouter-&gt;&gt;Gateway: update body to remove prefix set headers etc\n        Gateway-&gt;&gt;WASM: POST /mcp tools/call\n        WASM-&gt;&gt;Authorino: Apply Auth\n        Authorino-&gt;&gt;WASM: OK\n        Gateway-&gt;&gt;MCPServer: POST /mcp tools/call\n        MCPServer-&gt;&gt;MCPClient: tools/call response</code></pre>"},{"location":"mcp-gateway/docs/design/flows/#mcp-notifications","title":"MCP Notifications","text":"<p>For detailed information on how notifications work in the MCP Gateway, see the notifications design documentation.</p>"},{"location":"mcp-gateway/docs/design/notifications/","title":"Notifications","text":""},{"location":"mcp-gateway/docs/design/notifications/#notifications","title":"Notifications","text":""},{"location":"mcp-gateway/docs/design/notifications/#implementation-status","title":"Implementation Status","text":"Feature Status Notes <code>notifications/tools/list_changed</code> (upstream detection) Implemented MCPManager detects and re-fetches tools <code>notifications/tools/list_changed</code> (client forwarding) Implemented Handled by mcp-go library; E2E tested Progress updates (streamed in tool call POST) Implemented Handled by mcp-go library; covered by <code>tools-call-with-progress</code> conformance test Elicitation request/response routing Not implemented Requires request ID mapping infrastructure <code>notifications/resources/list_changed</code> Not applicable Gateway does not federate resources <code>notifications/prompts/list_changed</code> Not applicable Gateway does not federate prompts <code>notifications/roots/list_changed</code> Not applicable Gateway does not federate roots"},{"location":"mcp-gateway/docs/design/notifications/#problem","title":"Problem","text":"<p>The MCP protocol supports real-time notifications that enable servers to inform clients about changes without being explicitly requested. These notifications are crucial for maintaining synchronization between clients and servers when:</p> <ul> <li>Tool lists change (e.g., <code>notifications/tools/list_changed</code>)</li> <li>Resource lists change (e.g., <code>notifications/resources/list_changed</code>) </li> <li>Prompt lists change (e.g., <code>notifications/prompts/list_changed</code>)</li> <li>Root lists change (e.g., <code>notifications/roots/list_changed</code>)</li> <li>Long-running tool calls emit progress updates</li> <li>Elicitation requests are made (e.g., <code>elicitation/create</code>) - This is particularly important for prompting users before destructive actions, and for out-of-band authentication URL elicitation (see MCP GitHub issue #1036)</li> </ul> <p>For more details on MCP notifications, see the MCP Architecture documentation.</p> <p>In the MCP Gateway architecture, clients connect to the gateway's <code>/mcp</code> endpoint, which is backed by the MCP Broker. The broker aggregates multiple backend MCP servers and presents them as a unified MCP server to clients. This aggregation creates a challenge: how should notifications from individual backend MCP servers be forwarded to the appropriate clients?</p> <p>The gateway uses a lazy initialization approach where backend sessions to MCP servers are only established when a client makes a tool call. However, some notifications (like <code>list_changed</code> notifications) are logically 'broadcast' notifications and should be sent to all connected clients, not just those who have made tool calls.</p>"},{"location":"mcp-gateway/docs/design/notifications/#non-goals","title":"Non-Goals","text":"<p>At this time, the MCP Gateway does not support elicitation requests that require out-of-band communication over the GET <code>/mcp</code> notification channel. Only state change events that are logically 'broadcast' (safe to send to all connected clients) are supported over the GET notification channel.</p> <p>This is a technical limitation due to the complexity of implementing a fan-out approach where the broker would need to maintain separate GET connections to each backend MCP server for each client, particularly when those connections require the client's authentication credentials. The challenges include:</p> <ul> <li>Managing per-client, per-server GET connections with client-specific authentication</li> <li>Connection lifecycle management and reconnection logic for multiple fan-out connections</li> <li>Resource overhead of maintaining many concurrent connections</li> </ul> <p>Progress updates are streamed as events within tool call POST responses by the mcp-go library, which naturally aligns with the client's authentication context and tool call lifecycle. Elicitation support is planned but not yet implemented.</p>"},{"location":"mcp-gateway/docs/design/notifications/#solution","title":"Solution","text":"<p>The MCP Gateway supports two distinct types of notification mechanisms:</p> <ol> <li> <p>State Change Events: Notifications that are safe to send to all connected clients (e.g., <code>notifications/tools/list_changed</code>, <code>notifications/resources/list_changed</code>, <code>notifications/prompts/list_changed</code>, <code>notifications/roots/list_changed</code>). These are received via persistent Server-Sent Events (SSE) connections the broker maintains to all backend MCP servers using the broker's configured authentication credentials.</p> </li> <li> <p>Client-Specific Events: Events related to specific client sessions that are streamed as part of tool call POST responses:</p> </li> <li>Progress updates for long-running tool calls</li> <li>Elicitation requests that require client interaction</li> </ol> <p>The broker maintains a Server-Sent Events (SSE) connection with each connected client for receiving state change events. When the broker receives a state change event from a backend MCP server, it forwards it to all currently connected clients via their respective GET connections.</p> <p>Note: For detailed information on MCP notification specifications, see the MCP Prompts specification and the MCP Architecture documentation.</p>"},{"location":"mcp-gateway/docs/design/notifications/#notification-architecture","title":"Notification Architecture","text":""},{"location":"mcp-gateway/docs/design/notifications/#state-change-events","title":"State Change Events","text":"<p>Implementation Note: The <code>notifications/tools/list_changed</code> event is fully implemented. The MCPManager detects this notification from upstream servers and re-fetches the tool list. The mcp-go library handles forwarding state change notifications to all connected clients via their GET SSE connections. Other state change events (<code>resources/list_changed</code>, <code>prompts/list_changed</code>, <code>roots/list_changed</code>) are not applicable as the gateway currently only federates tools.</p> <p>State change events are notifications that are safe and appropriate to send to all connected clients. The gateway supports the following state change events:</p> <ul> <li><code>notifications/tools/list_changed</code> - When a backend MCP server's tool list changes</li> <li><code>notifications/resources/list_changed</code> - When a backend MCP server's resource list changes  </li> <li><code>notifications/prompts/list_changed</code> - When a backend MCP server's prompt list changes</li> <li><code>notifications/roots/list_changed</code> - When a backend MCP server's root list changes</li> </ul> <p>How State Change Events Work:</p> <pre><code>sequenceDiagram\n  participant Client1 as MCP Client 1\n  participant Client2 as MCP Client 2\n  participant Gateway as Gateway/MCP Router/MCP Broker\n  participant Server1 as MCP Server 1\n  participant Server2 as MCP Server 2\n\n  Note over Gateway, Server2: State change event channel establishment\n  Gateway -&gt;&gt; Server1: POST /mcp \"initialize\" (broker auth)\n  Server1 --&gt;&gt; Gateway: initialize response (capabilities)\n  Gateway -&gt;&gt; Server1: POST /mcp \"notifications/initialized\"\n  Gateway -&gt;&gt; Server1: GET /mcp\n  Server1 --&gt;&gt; Gateway: SSE connection established\n  Gateway -&gt;&gt; Server2: POST /mcp \"initialize\" (broker auth)\n  Server2 --&gt;&gt; Gateway: initialize response (capabilities)\n  Gateway -&gt;&gt; Server2: POST /mcp \"notifications/initialized\"\n  Gateway -&gt;&gt; Server2: GET /mcp\n  Server2 --&gt;&gt; Gateway: SSE connection established\n  Note over Client1, Gateway: Client notifications connection\n  Client1 -&gt;&gt; Gateway: POST /mcp \"initialize\"\n  Client1 -&gt;&gt; Gateway: POST /mcp \"notifications/initialized\"\n  Client1 -&gt;&gt; Gateway: GET /mcp\n  Gateway --&gt;&gt; Client1: SSE connection established\n  Client2 -&gt;&gt; Gateway: POST /mcp \"initialize\"\n  Client2 -&gt;&gt; Gateway: POST /mcp \"notifications/initialized\"\n  Client2 -&gt;&gt; Gateway: GET /mcp\n  Gateway --&gt;&gt; Client2: SSE connection established\n  Note over Server2, Client1: State change events\n  Server1 --&gt;&gt; Gateway: notifications/tools/list_changed\n  Gateway --&gt;&gt; Client1: forward notification\n  Gateway --&gt;&gt; Client2: forward notification\n  Server2 --&gt;&gt; Gateway: notifications/prompts/list_changed\n  Gateway --&gt;&gt; Client1: forward notification\n  Gateway --&gt;&gt; Client2: forward notification</code></pre> <ol> <li> <p>Capability Checking: When a backend MCP server is discovered, the broker first sends an <code>initialize</code> request using the broker's configured authentication credentials. The broker checks the <code>initialize</code> response to determine which state change event capabilities the server supports (e.g., <code>notifications/tools/list_changed</code>, <code>notifications/resources/list_changed</code>, etc.).</p> </li> <li> <p>Persistent Broker Connections: For each backend MCP server that supports state change events, the broker establishes a persistent GET connection:</p> </li> <li>Sends a <code>notifications/initialized</code> notification</li> <li>Establishes a GET <code>/mcp</code> connection for receiving SSE notifications</li> </ol> <p>These connections remain open for the lifetime of the backend server connection. The broker must implement reconnection logic to handle cases where connections are dropped due to server restarts, session invalidation, or network issues.</p> <ol> <li> <p>Event Reception and Forwarding: When a backend MCP server sends a state change event (e.g., <code>notifications/tools/list_changed</code>), the broker receives it via the persistent connection and forwards it to all currently connected clients via their respective GET connections.</p> </li> <li> <p>Client Response: Clients typically respond to <code>list_changed</code> notifications by making a new <code>tools/list</code>, <code>resources/list</code>, <code>prompts/list</code>, or <code>roots/list</code> request to refresh their understanding of available primitives.</p> </li> </ol> <p>Why Broker Auth for State Change Events:</p> <p>The broker uses its own authentication credentials (configured at startup) rather than client credentials because state change events are not tied to any specific client session, must be received even when no clients have made tool calls yet, and allows the broker to maintain a single persistent connection per backend server rather than per client.</p>"},{"location":"mcp-gateway/docs/design/notifications/#client-specific-events","title":"Client-Specific Events","text":"<p>Implementation Note: Progress updates work without special gateway implementation \u2014 the mcp-go library streams progress events as part of the tool call POST response. Elicitation support is not yet implemented and requires the request ID mapping infrastructure described below.</p> <p>Client-specific events are related to a particular client's tool execution and are delivered as streamed events within the tool call POST response, not via separate GET notification channels. The gateway supports two types of client-specific events:</p> <ol> <li>Progress Updates: Progress notifications for long-running tool calls</li> <li>Elicitations: Requests for user input during tool execution (e.g., confirming destructive actions)</li> </ol> <p>Note: The gateway does not currently support other client-specific notifications/events such as: - Log message notifications (<code>logging/setLevel</code> and <code>notifications/message</code>) - See MCP Logging specification - Subscribe requests (<code>resources/subscribe</code> and <code>notifications/resources/updated</code>) - See MCP SubscribeRequest schema</p> <p>How Progress Updates Work:</p> <p>Implementation Note: This is handled transparently by the mcp-go library. The gateway forwards the tool call POST request to the backend, and the library streams progress events back to the client as part of the same HTTP response. No special gateway logic is required.</p> <p>Progress updates are streamed events sent by the backend MCP server as part of the <code>tools/call</code> POST response. The client indicates they want progress updates by including a <code>progressToken</code> field in the tool call request with an arbitrary value. The backend server uses this token to associate progress events with the specific tool call. See the MCP Progress specification for more details.</p> <pre><code>sequenceDiagram\n  participant Client as MCP Client\n  participant Gateway as Gateway/MCP Router/MCP Broker\n  participant Server as MCP Server\n\n  Note over Client, Server: Long-running tool call with progress\n  Client -&gt;&gt; Gateway: POST /mcp \"tools/call\" (with progressToken)\n  Gateway -&gt;&gt; Server: POST /mcp \"tools/call\" (with progressToken)\n  Note over Server, Client: Streamed progress events\n  Server --&gt;&gt; Gateway: Progress event (0.2/1.0)\n  Gateway --&gt;&gt; Client: forward progress event\n  Server --&gt;&gt; Gateway: Progress event (0.6/1.0)\n  Gateway --&gt;&gt; Client: forward progress event\n  Server --&gt;&gt; Gateway: Progress event (1.0/1.0)\n  Gateway --&gt;&gt; Client: forward progress event\n  Note over Server, Client: Tool call completion\n  Server --&gt;&gt; Gateway: tool/call response\n  Gateway --&gt;&gt; Client: tool/call response</code></pre> <p>How Elicitations Work:</p> <p>Implementation Note: Elicitation support is not yet implemented. The design below describes the planned approach.</p> <p>Elicitations allow backend MCP servers to request user input during tool execution. When an <code>elicitation/create</code> event is sent, the tool call on the server halts, waiting for the client's response. The elicitation message contains a unique request ID that the client must use when responding. See the MCP Elicitation specification for more details.</p> <p>The gateway must intercept and modify the request ID in the elicitation message to enable proper routing of the client's follow-up response to the correct backend MCP server.</p> <pre><code>sequenceDiagram\n  participant Client as MCP Client\n  participant Gateway as Gateway/MCP Router/MCP Broker\n  participant Server as MCP Server\n\n  Note over Client, Server: Tool call with elicitation\n  Client -&gt;&gt; Gateway: POST /mcp \"tools/call\"\n  Gateway -&gt;&gt; Server: POST /mcp \"tools/call\"\n  Note over Server, Gateway: Elicitation event\n  Server --&gt;&gt; Gateway: Streamed event: elicitation/create (id: 42)\n  Gateway -&gt;&gt; Gateway: Map server request ID (42) to gateway request ID (gateway-123)\n  Gateway --&gt;&gt; Client: Streamed event: elicitation/create (id: gateway-123)\n  Note over Client: User provides input\n  Client -&gt;&gt; Gateway: POST /mcp elicitation response (id: gateway-123)\n  Gateway -&gt;&gt; Gateway: Map gateway request ID (gateway-123) to server request ID (42)\n  Gateway -&gt;&gt; Server: POST /mcp elicitation response (id: 42)\n  Note over Server, Gateway: Tool call continues/resumes\n  Server --&gt;&gt; Gateway: tool/call response\n  Gateway --&gt;&gt; Client: tool/call response</code></pre> <p>Example Elicitation Message:</p> <pre><code>{\n  \"method\": \"elicitation/create\",\n  \"params\": {\n    \"message\": \"Please provide inputs for the following fields:\",\n    \"requestedSchema\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"name\": {\n          \"title\": \"Full Name\",\n          \"type\": \"string\",\n          \"description\": \"Your full, legal name\"\n        },\n        \"check\": {\n          \"title\": \"Agree to terms\",\n          \"type\": \"boolean\",\n          \"description\": \"A boolean check\"\n        }\n      },\n      \"required\": [\"name\"]\n    }\n  },\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1\n}\n</code></pre> <p>Example Client Response:</p> <pre><code>{\n  \"result\": {\n    \"action\": \"accept\"\n  },\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1\n}\n</code></pre> <p>Request ID Mapping for Elicitations:</p> <p>Since elicitation responses arrive as new POST requests from the client, the gateway must maintain a mapping that associates:</p> <ul> <li>The gateway-assigned request ID (sent to the client)</li> <li>The original backend server request ID</li> <li>The backend server session (for routing)</li> </ul> <p>When forwarding an elicitation to the client, the gateway replaces the backend server's request ID with a gateway-specific ID. When the client responds, the gateway uses the mapping to restore the original request ID and route the response to the correct backend server session.</p>"},{"location":"mcp-gateway/docs/design/notifications/#implementation-considerations","title":"Implementation Considerations","text":"<ol> <li>Connection Management: The broker must efficiently manage multiple concurrent connections:</li> <li>One persistent GET connection per backend MCP server (for state change events)</li> <li>One GET connection per connected client (for receiving state change events)</li> <li> <p>Long-running POST connections for tool calls that emit progress updates or elicitations</p> </li> <li> <p>Capability Detection: The broker must check the <code>initialize</code> response from each backend MCP server to determine which state change event capabilities are supported before establishing GET notification connections.</p> </li> <li> <p>Request ID Mapping: The broker must maintain a mapping table for elicitation request IDs that includes:</p> </li> <li>Gateway-assigned request ID</li> <li>Original backend server request ID</li> <li>Backend server session information</li> <li>Expiration/TTL to clean up stale mappings</li> </ol> <p>Request ID Type Handling: Backend MCP servers may use request IDs of different types (string, integer, or float). The gateway implementation must:</p> <ul> <li>Preserve the original backend server request ID type when restoring it in the client's response</li> <li>From the gateway's perspective, gateway-assigned request IDs could use strings with a pattern (e.g., prefixing the server name) to ensure uniqueness and enable routing, though specific implementation details are left to implementation time</li> <li> <p>Test scenarios with string, integer, and float request IDs from backend servers to ensure proper type preservation and routing</p> </li> <li> <p>Error Handling and Reconnection: The broker must handle:</p> </li> <li>Backend MCP server connection failures</li> <li>Client connection failures</li> <li>Event delivery failures</li> <li>Connection retry logic with exponential backoff</li> <li>Automatic reconnection when backend servers restart</li> <li>Session invalidation detection and reconnection</li> <li> <p>Network interruption recovery</p> </li> <li> <p>Lifecycle Management: The broker must properly:</p> </li> <li>Establish state change event connections when backend servers are discovered (after capability checking)</li> <li>Clean up connections when backend servers are removed</li> <li>Manage long-running POST connections for tool calls with progress/elicitation</li> <li>Clean up request ID mappings when tool calls complete or timeout</li> </ul>"},{"location":"mcp-gateway/docs/design/notifications/#security-considerations","title":"Security Considerations","text":"<ol> <li> <p>Event Validation: The broker should validate that state change events received from backend MCP servers are well-formed and safe to forward before broadcasting them to clients.</p> </li> <li> <p>Authorization: The broker forwards events as-is but relies on the backend MCP server's authorization rules, if any, tied to the broker auth credentials configured for each MCP Server.</p> </li> <li> <p>Request ID Mapping Security: The gateway-assigned request IDs in elicitation mappings should be cryptographically random and unguessable to prevent unauthorized access to tool call sessions.</p> </li> </ol>"},{"location":"mcp-gateway/docs/design/notifications/#open-questions","title":"Open Questions","text":"<ol> <li>Elicitation Mapping Cleanup: What is the appropriate timeout/TTL for elicitation request ID mappings? Should mappings persist for the entire tool call duration, or should there be a shorter timeout for elicitation responses?</li> </ol>"},{"location":"mcp-gateway/docs/design/overview/","title":"Architecture","text":""},{"location":"mcp-gateway/docs/design/overview/#mcp-gateway-architecture-overview","title":"MCP Gateway Architecture Overview","text":""},{"location":"mcp-gateway/docs/design/overview/#overview","title":"Overview","text":"<p>MCP Gateway looks to build on top of the routing capabilities of Envoy with capabilities to handle the Model Context protocol. </p>"},{"location":"mcp-gateway/docs/design/overview/#vision","title":"Vision","text":"<p>Provide an Envoy based integration that allows teams and platform engineers to be able to operate and collaborate to expose MCP servers via a gateway as secure and protected services just as they do with existing RESTFul based APIs.</p> <p>Design Constraints</p> <ul> <li>Work with Gateway API as a routing configuration</li> <li>Allow Envoy to control routing and traffic</li> <li>Focus MCP Gateway on the MCP Protocol and enabling Envoy to route this traffic</li> <li>Be able to leverage Istio as the Gateway Control Plane in kube environments</li> <li>Allow other integrations to provide key features such as Auth and RateLimiting (e.g Kuadrant)</li> <li>Allow in the future for the move of some functionality (likely the router) towards WASM or a Dynamic module</li> </ul> <p>High Level Overview</p> <p></p>"},{"location":"mcp-gateway/docs/design/overview/#components","title":"Components","text":""},{"location":"mcp-gateway/docs/design/overview/#mcp-router","title":"MCP Router","text":"<p>Overview:</p> <p>The MCP router is an envoy focused ext_proc component that is capable of parsing the MCP protocol and using it to set headers to force correct routing of the request to the correct MCP server. It is mostly involved with specific tools call requests.</p> <p>Responsibilities:</p> <ul> <li>Parsing and validation of the MCP JSON-RPC body</li> <li>Setting the key request headers: <ul> <li>x-destination-mcp, x-mcp-tool, mcp-session-id</li> </ul> </li> <li>Watching for 404 responses from MCP servers and invalidating the  session store.</li> <li>Handling session initialization and storage on behalf of a requesting  MCP client during a tools/call</li> </ul>"},{"location":"mcp-gateway/docs/design/overview/#mcp-broker","title":"MCP Broker","text":"<p>Overview:</p> <p>The MCP Broker is a backend service configured with other MCP servers that acts as a default MCP server backend for the /mcp endpoint.</p> <p>Responsibilities:</p> <ul> <li>General MCP Backend </li> <li>Acts as a client to discovered MCP servers (init, tools/list, notifications)</li> <li>Handles the external client init call and responding with the baseline capabilities, version and service info</li> <li>Brokering SSE notifications between client and MCP server</li> <li>Creating the aggregated tools/list call</li> <li>Validating discovered MCP Servers meet minimum requirements (protocol version and capabilities) before including their tools in the list</li> <li>Handle notification requests from clients and MCP Servers (proxying from the MCP server notification to registered clients)</li> </ul>"},{"location":"mcp-gateway/docs/design/overview/#mcp-discovery-controller","title":"MCP Discovery Controller","text":"<p>Overview</p> <p>The MCP Discovery Controller is a Kubernetes-based controller that will watch for resources and discover new MCP servers to form configuration for the other components.</p> <p>Responsibilities:</p> <ul> <li>Watching MCPServerRegistration resources labelled as MCP routes</li> <li>Maintaining a config from the HTTPRoute and the MCPServerRegistration resources</li> <li>Updating the MCP Broker and MCP Router config (configmap) based on discovered MCPServerRegistration resources and the HTTPRoutes it targets.</li> <li>Reporting status of MCPServerRegistrations</li> </ul>"},{"location":"mcp-gateway/docs/design/overview/#request-flows","title":"Request Flows","text":"<p>Note: these diagrams are also being iterated on rapidly</p> <p>sequence diagrams</p>"},{"location":"mcp-gateway/docs/guides/authentication/","title":"Authentication Configuration","text":"<p>This guide covers configuring authentication for MCP Gateway using the Model Context Protocol (MCP) authorization specification.</p>"},{"location":"mcp-gateway/docs/guides/authentication/#overview","title":"Overview","text":"<p>MCP Gateway implements the MCP Authorization specification which is based on OAuth 2.1. When authentication is enabled, the MCP Gateway broker acts as an OAuth 2.1 resource server, requiring valid access tokens for protected requests.</p> <p>Key concepts:</p> <ul> <li>OAuth 2.1 Resource Server: MCP Gateway validates access tokens issued by your identity provider</li> <li>WWW-Authenticate Response: Returns 401 with authorization server discovery information</li> <li>Protected Resource Metadata: Exposes OAuth configuration at <code>/.well-known/oauth-protected-resource</code></li> <li>Dynamic Client Registration: Supports automatic client registration for MCP clients</li> </ul>"},{"location":"mcp-gateway/docs/guides/authentication/#prerequisites","title":"Prerequisites","text":"<ul> <li>MCP Gateway installed and configured</li> <li>Identity provider supporting OAuth 2.1 (this guide uses Keycloak)</li> <li>Kuadrant operator installed</li> <li>Node.js and npm installed (for MCP Inspector testing)</li> </ul> <p>Note: This guide demonstrates authentication using Kuadrant's AuthPolicy, but MCP Gateway supports any Istio/Gateway API compatible authentication mechanism.</p>"},{"location":"mcp-gateway/docs/guides/authentication/#step-1-deploy-identity-provider","title":"Step 1: Deploy Identity Provider","text":"<p>Deploy Keycloak as your OAuth 2.1 authorization server:</p> <pre><code># Install Keycloak\nkubectl create namespace keycloak\nkubectl apply -f https://raw.githubusercontent.com/Kuadrant/mcp-gateway/main/config/keycloak/realm-import.yaml\nkubectl apply -f https://raw.githubusercontent.com/Kuadrant/mcp-gateway/main/config/keycloak/deployment.yaml\nkubectl apply -f https://raw.githubusercontent.com/Kuadrant/mcp-gateway/main/config/keycloak/httproute.yaml\nkubectl set env deployment/keycloak -n keycloak KC_HOSTNAME-\n\n# Wait for Keycloak to be ready\nkubectl wait --for=condition=ready pod -l app=keycloak -n keycloak --timeout=120s\n\n# Apply CORS preflight fix for Keycloak OIDC client registration\n# This works around a known Keycloak bug: https://github.com/keycloak/keycloak/issues/39629\nkubectl apply -f https://raw.githubusercontent.com/Kuadrant/mcp-gateway/refs/heads/main/config/keycloak/preflight_envoyfilter.yaml\n\n# Add a listener to the gateway for Keycloak\nkubectl patch gateway mcp-gateway -n gateway-system --type json -p '[\n  {\n    \"op\": \"add\",\n    \"path\": \"/spec/listeners/-\",\n    \"value\": {\n      \"name\": \"keycloak\",\n      \"hostname\": \"keycloak.127-0-0-1.sslip.io\",\n      \"port\": 8002,\n      \"protocol\": \"HTTP\",\n      \"allowedRoutes\": {\n        \"namespaces\": {\n          \"from\": \"Selector\",\n          \"selector\": {\n            \"matchLabels\": {\n              \"kubernetes.io/metadata.name\": \"keycloak\"\n            }\n          }\n        }\n      }\n    }\n  }\n]'\n</code></pre> <p>What this setup creates:</p> <ul> <li>MCP Realm: Dedicated realm for MCP Gateway authentication</li> <li>Test MCP Resource Server Clients: OAuth resource server clients to model role-based access control for MCP tools</li> <li>Test User: User 'mcp' with password 'mcp' for testing</li> <li>Accounting Group: Group for authorization testing (test 'mcp' user and selected tools are added to this group)</li> <li>Token Settings: 30-minute session timeout and access token lifetime</li> <li>Anonymous Client Registration: Removes trusted hosts policy to allow dynamic client registration from any host (For development only. Not recommended for production)</li> </ul> <p>Why this setup is needed:</p> <ul> <li>Dedicated Realm: Isolates MCP authentication from other applications</li> <li>Dynamic Client Registration: Allows MCP clients to automatically register without manual setup</li> <li>RBAC: Enables Role-Based Access Control (used in authorization guide)</li> <li>OIDC Configuration: Enables proper JWT token issuance with required claims</li> </ul>"},{"location":"mcp-gateway/docs/guides/authentication/#step-2-configure-mcp-gateway-oauth-environment","title":"Step 2: Configure MCP Gateway OAuth Environment","text":"<p>Configure the MCP Gateway broker to respond with OAuth discovery information:</p> <pre><code>kubectl set env deployment/mcp-gateway \\\n  OAUTH_RESOURCE_NAME=\"MCP Server\" \\\n  OAUTH_RESOURCE=\"http://mcp.127-0-0-1.sslip.io:8001/mcp\" \\\n  OAUTH_AUTHORIZATION_SERVERS=\"http://keycloak.127-0-0-1.sslip.io:8002/realms/mcp\" \\\n  OAUTH_BEARER_METHODS_SUPPORTED=\"header\" \\\n  OAUTH_SCOPES_SUPPORTED=\"basic,groups,roles,profile\" \\\n  -n mcp-system\n</code></pre> <p>Environment Variables Explained:</p> <ul> <li><code>OAUTH_RESOURCE_NAME</code>: Human-readable name for this resource server</li> <li><code>OAUTH_RESOURCE</code>: Canonical URI of the MCP server (used for token audience validation)</li> <li><code>OAUTH_AUTHORIZATION_SERVERS</code>: Authorization server URL for client discovery</li> <li><code>OAUTH_BEARER_METHODS_SUPPORTED</code>: Supported bearer token methods (header, body, query)</li> <li><code>OAUTH_SCOPES_SUPPORTED</code>: OAuth scopes this resource server understands</li> </ul>"},{"location":"mcp-gateway/docs/guides/authentication/#step-3-configure-authpolicy-for-authentication","title":"Step 3: Configure AuthPolicy for Authentication","text":"<p>Install Kuadrant:</p> <pre><code>helm repo add kuadrant https://kuadrant.io/helm-charts 2&gt;/dev/null || true\nhelm repo update\nhelm install kuadrant-operator kuadrant/kuadrant-operator \\\n  --create-namespace \\\n    --wait \\\n    --timeout=600s \\\n    --namespace kuadrant-system;\n\nkubectl apply -f https://raw.githubusercontent.com/Kuadrant/mcp-gateway/main/config/kuadrant/kuadrant.yaml\n\nkubectl wait --for=condition=available --timeout=90s deployment/authorino -n kuadrant-system\n\n# Patch Authorino deployment to resolve Keycloak's host name to MCP gateway IP (Development environment only):\nexport GATEWAY_IP=$(kubectl get gateway/mcp-gateway -n gateway-system -o jsonpath='{.status.addresses[0].value}' 2&gt;/dev/null || true)\nkubectl patch deployment authorino -n kuadrant-system --type='json' -p=\"[\n  {\n    \\\"op\\\": \\\"add\\\",\n    \\\"path\\\": \\\"/spec/template/spec/hostAliases\\\",\n    \\\"value\\\": [\n      {\n        \\\"ip\\\": \\\"${GATEWAY_IP}\\\",\n        \\\"hostnames\\\": [\\\"keycloak.127-0-0-1.sslip.io\\\"]\n      }\n    ]\n  }\n]\"\n</code></pre> <p>Apply the authentication policy that validates JWT tokens:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1\nkind: AuthPolicy\nmetadata:\n  name: mcp-auth-policy\n  namespace: gateway-system\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: mcp-gateway\n    sectionName: mcp\n  defaults:\n    when:\n\n      - predicate: \"!request.path.contains('/.well-known')\"\n    rules:\n      authentication:\n        'keycloak':\n          jwt:\n            issuerUrl: http://keycloak.127-0-0-1.sslip.io:8002/realms/mcp\n      response:\n        unauthenticated:\n          code: 401\n          headers:\n            'WWW-Authenticate':\n              value: Bearer resource_metadata=http://mcp.127-0-0-1.sslip.io:8001/.well-known/oauth-protected-resource/mcp\n          body:\n            value: |\n              {\n                \"error\": \"Unauthorized\",\n                \"message\": \"Authentication required.\"\n              }\nEOF\n</code></pre> <p>Key Configuration Points:</p> <ul> <li>JWT Validation: Validates tokens against Keycloak's OIDC issuer</li> <li>Discovery Exclusion: Allows unauthenticated access to <code>/.well-known</code> endpoints</li> <li>WWW-Authenticate Header: Points clients to OAuth discovery metadata</li> <li>Standard Response: Returns 401 with proper OAuth error format</li> </ul>"},{"location":"mcp-gateway/docs/guides/authentication/#step-4-verify-oauth-discovery","title":"Step 4: Verify OAuth Discovery","text":"<p>Test that the broker now serves OAuth discovery information:</p> <pre><code># Check the protected resource metadata endpoint\ncurl http://mcp.127-0-0-1.sslip.io:8001/.well-known/oauth-protected-resource\n\n# Should return OAuth 2.0 Protected Resource Metadata like:\n# {\n#   \"resource_name\": \"MCP Server\",\n#   \"resource\": \"http://mcp.127-0-0-1.sslip.io:8001/mcp\",\n#   \"authorization_servers\": [\n#     \"http://keycloak.127-0-0-1.sslip.io:8002/realms/mcp\"\n#   ],\n#   \"bearer_methods_supported\": [\n#     \"header\"\n#   ],\n#   \"scopes_supported\": [\n#     \"basic\",\n#     \"groups\"\n#   ]\n# }\n</code></pre> <p>Test that protected endpoints now require authentication:</p> <pre><code># This should return 401 with WWW-Authenticate header\ncurl -v http://mcp.127-0-0-1.sslip.io:8001/mcp \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"jsonrpc\": \"2.0\", \"id\": 1, \"method\": \"tools/list\"}'\n</code></pre> <p>You should get a response like this:</p> <pre><code>{\n  \"error\": \"Unauthorized\",\n  \"message\": \"Authentication required.\"\n}\n</code></pre>"},{"location":"mcp-gateway/docs/guides/authentication/#step-5-test-authentication-flow","title":"Step 5: Test Authentication Flow","text":"<p>Use the MCP Inspector to test the complete OAuth flow.</p> <pre><code># Start MCP Inspector (requires Node.js/npm)\nnpx @modelcontextprotocol/inspector@latest &amp;\nINSPECTOR_PID=$!\n\n# Wait a moment for services to start\nsleep 3\n\n# Open MCP Inspector with the gateway URL\nopen \"http://localhost:6274/?transport=streamable-http&amp;serverUrl=http://mcp.127-0-0-1.sslip.io:8001/mcp\"\n</code></pre> <p>What this does:</p> <ul> <li>MCP Inspector: Launches the official MCP debugging tool</li> <li>Auto-Configuration: Pre-configures the inspector to connect to your gateway</li> </ul> <p>To stop the services later: <pre><code>kill $INSPECTOR_PID\n</code></pre></p> <p>The MCP Inspector will:</p> <ol> <li>Detect the 401 response and WWW-Authenticate header</li> <li>Retrieve authorization server metadata from <code>/.well-known/oauth-protected-resource</code></li> <li>Perform dynamic client registration (if supported)</li> <li>Redirect to Keycloak for user authentication</li> <li>Exchange authorization code for access token</li> <li>Use the access token for subsequent MCP requests</li> </ol> <p>Test Credentials: <code>mcp</code> / <code>mcp</code></p>"},{"location":"mcp-gateway/docs/guides/authentication/#alternative-authentication-methods","title":"Alternative Authentication Methods","text":"<p>While this guide uses Kuadrant AuthPolicy with Keycloak, MCP Gateway supports any Istio/Gateway API compatible authentication mechanism including other identity providers and authentication methods.</p>"},{"location":"mcp-gateway/docs/guides/authentication/#next-steps","title":"Next Steps","text":"<p>With authentication configured, you can proceed to:</p> <ul> <li>Authorization Configuration - Control which users can access specific tools</li> <li>External MCP Servers - Connect authenticated external services</li> </ul>"},{"location":"mcp-gateway/docs/guides/authorization/","title":"Authorization Configuration","text":"<p>This guide covers configuring fine-grained authorization and access control for MCP Gateway, building on the authentication setup.</p>"},{"location":"mcp-gateway/docs/guides/authorization/#overview","title":"Overview","text":"<p>Authorization in MCP Gateway controls which authenticated users can access specific MCP tools. This guide demonstrates using Kuadrant's AuthPolicy with Common Expression Language (CEL) to implement role-based access control.</p> <p>Key concepts:</p> <ul> <li>Tool-Level Authorization: Control access to individual MCP tools</li> <li>Role-Based Access: Use Keycloak client roles and group bindings for permission decisions</li> <li>Self-contained ACL: Access control lists stored in the signed JWT tokens</li> <li>CEL Expressions: Define complex authorization logic using Common Expression Language</li> </ul>"},{"location":"mcp-gateway/docs/guides/authorization/#prerequisites","title":"Prerequisites","text":"<ul> <li>Authentication Configuration completed</li> <li>Identity provider configured to include group/role claims in tokens</li> <li>Node.js and npm installed (for MCP Inspector testing)</li> </ul> <p>Note: This guide demonstrates authorization using Kuadrant's AuthPolicy, but MCP Gateway supports any Istio/Gateway API compatible authorization mechanism.</p>"},{"location":"mcp-gateway/docs/guides/authorization/#understanding-the-authorization-flow","title":"Understanding the Authorization Flow","text":"<ol> <li>Authentication: User authenticates and receives JWT token with permissions</li> <li>Tool Request: Client makes MCP tool call (e.g., <code>tools/call</code>)</li> <li>Request Identity Check: AuthPolicy verifies JWT token and extracts authorization claims</li> <li>Authorization Check: CEL expression evaluates requested tool against user's permissions extracted from the JWT</li> <li>Access Decision: Allow or deny based on evaluation result</li> </ol>"},{"location":"mcp-gateway/docs/guides/authorization/#step-1-customise-token-issuance-to-include-acl-information","title":"Step 1: Customise token issuance to include ACL information","text":"<p>Ensure your identity provider (e.g., Keycloak) includes necessary group/role claims in the issued JWT tokens.</p> <p>The issued OAuth token should include claims similar to:</p> <pre><code>{\n  \"resource_access\": {\n    \"mcp-ns/arithmetic-mcp-server\": { // matches the namespaced name of the MCPServerRegistration CR\n      \"roles\": [\"add\", \"sum\", \"multiply\", \"divide\"] // roles representing the allowed tools\n    },\n    \"mcp-ns/geometry-mcp-server\": {\n      \"roles\": [\"area\", \"distance\", \"volume\"]\n    }\n  }\n}\n</code></pre> <p>Note: The test Keycloak instance deployed in the authentication guide is already configured to include these claims based on user group membership. The <code>mcp</code> user is part of both <code>accounting</code> group, which map to different tool permissions.</p>"},{"location":"mcp-gateway/docs/guides/authorization/#step-2-configure-tool-level-authorization","title":"Step 2: Configure Tool-Level Authorization","text":"<p>Apply an AuthPolicy that enforces tool-level access control:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1\nkind: AuthPolicy\nmetadata:\n  name: mcp-tool-auth-policy\n  namespace: gateway-system\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: mcp-gateway\n    sectionName: mcps  # Targets the MCP server listener\n  rules:\n    authentication:\n      'sso-server':\n        jwt:\n          issuerUrl: http://keycloak.127-0-0-1.sslip.io:8002/realms/mcp\n    authorization:\n      'tool-access-check':\n        patternMatching:\n          patterns:\n\n            - predicate: |\n                request.headers['x-mcp-toolname'] in (has(auth.identity.resource_access) &amp;&amp; auth.identity.resource_access.exists(p, p == request.headers['x-mcp-servername']) ? auth.identity.resource_access[request.headers['x-mcp-servername']].roles : [])\n    response:\n      unauthenticated:\n        headers:\n          'WWW-Authenticate':\n            value: Bearer resource_metadata=http://mcp.127-0-0-1.sslip.io:8001/.well-known/oauth-protected-resource/mcp\n        body:\n          value: |\n            {\n              \"error\": \"Unauthorized\",\n              \"message\": \"MCP Tool Access denied: Authentication required.\"\n            }\n      unauthorized:\n        body:\n          value: |\n            {\n              \"error\": \"Forbidden\",\n              \"message\": \"MCP Tool Access denied: Insufficient permissions for this tool.\"\n            }\nEOF\n</code></pre> <p>Key Configuration Explained:</p> <ul> <li>Authentication: Validates the JWT token using the configured issuer URL</li> <li>Authorization Logic: CEL expression checks if user's roles allow access to the requested tool</li> <li>CEL Breakdown:</li> <li><code>request.headers['x-mcp-toolname']</code>: The name of the requested MCP tool (stripped from prefix)</li> <li><code>request.headers['x-mcp-servername']</code>: The namespaced name of the MCP server matching the MCPServerRegistration resource</li> <li><code>auth.identity.resource_access</code>: The JWT claim containing all roles representing each allowed tool the user can access, grouped by MCP server</li> <li>Response Handling: Custom 401 and 403 responses for unauthenticated and unauthorized access attempts</li> </ul>"},{"location":"mcp-gateway/docs/guides/authorization/#step-3-test-authorization","title":"Step 3: Test Authorization","text":"<p>Note: The authentication guide already created the <code>accounting</code> group, added the <code>mcp</code> user to it, and configured group claims in JWT tokens. No additional Keycloak configuration is needed.</p> <p>Test that authorization now controls tool access by setting up the MCP Inspector:</p> <pre><code># Start MCP Inspector (requires Node.js/npm)\nnpx @modelcontextprotocol/inspector@latest &amp;\nINSPECTOR_PID=$!\n\n# Wait for services to start\nsleep 3\n\n# Open MCP Inspector with the gateway URL\nopen \"http://localhost:6274/?transport=streamable-http&amp;serverUrl=http://mcp.127-0-0-1.sslip.io:8001/mcp\"\n</code></pre> <p>What this accomplishes:</p> <ul> <li>Gateway Access: Makes the MCP Gateway accessible through your local browser</li> <li>Authentication Testing: Allows you to test the complete OAuth + authorization flow</li> <li>Tool Verification: Lets you verify which tools are accessible based on user groups</li> </ul> <p>Test Scenarios:</p> <ol> <li>Login as mcp/mcp (has both <code>accounting</code> and <code>developers</code> groups)</li> <li>Try allowed tools:</li> <li><code>test1_greet</code></li> <li><code>test2_headers</code></li> <li><code>test3_add</code></li> <li>Try restricted tools:</li> <li><code>apikey_hello_world</code> - Should return 403 Forbidden</li> </ol>"},{"location":"mcp-gateway/docs/guides/authorization/#alternative-authorization-mechanisms","title":"Alternative Authorization Mechanisms","text":"<p>While this guide uses Kuadrant AuthPolicy, MCP Gateway supports various authorization approaches including other policy engines, built-in Istio authorization, and Gateway API policy extensions.</p>"},{"location":"mcp-gateway/docs/guides/authorization/#monitoring-and-observability","title":"Monitoring and Observability","text":"<p>Monitor authorization decisions:</p> <pre><code># Check AuthPolicy status\nkubectl get authpolicy -A\n\n# View authorization logs\nkubectl logs -n kuadrant-system -l app=authorino\n</code></pre>"},{"location":"mcp-gateway/docs/guides/authorization/#next-steps","title":"Next Steps","text":"<p>With authorization configured, you can:</p> <ul> <li>External MCP Servers - Apply auth to external services</li> <li>Virtual MCP Servers - Compose auth across multiple servers</li> <li>Troubleshooting - Debug auth and authz issues</li> </ul>"},{"location":"mcp-gateway/docs/guides/configure-mcp-gateway-listener-and-router/","title":"Configure MCP Gateway Listener and Route","text":"<p>This guide covers adding an MCP listener to your existing Gateway and creating an HTTPRoute to route traffic to the MCP Gateway broker.</p>"},{"location":"mcp-gateway/docs/guides/configure-mcp-gateway-listener-and-router/#prerequisites","title":"Prerequisites","text":"<ul> <li>MCP Gateway installed in your cluster</li> <li>Existing Gateway resource</li> <li>Gateway API Provider (Istio) configured</li> </ul>"},{"location":"mcp-gateway/docs/guides/configure-mcp-gateway-listener-and-router/#step-1-add-mcp-listener-to-gateway","title":"Step 1: Add MCP Listener to Gateway","text":"<p>Add a listener for MCP traffic to your existing Gateway:</p> <pre><code>apiVersion: gateway.networking.k8s.io/v1\nkind: Gateway\nmetadata:\n  name: your-gateway-name\n  namespace: your-gateway-namespace\nspec:\n  gatewayClassName: istio\n  listeners:\n  # ... your existing listeners ...\n\n  - name: mcp\n    hostname: 'mcp.127-0-0-1.sslip.io'  # Change to your hostname\n    port: 8080\n    protocol: HTTP\n    allowedRoutes:\n      namespaces:\n        from: All\n</code></pre> <p>Important: If you installed MCP Gateway using Helm, ensure the <code>gateway.publicHost</code> value in your Helm values matches the hostname above. For example: <pre><code>helm upgrade mcp-gateway oci://ghcr.io/kuadrant/charts/mcp-gateway \\\n  --set gateway.publicHost=mcp.127-0-0-1.sslip.io\n</code></pre></p>"},{"location":"mcp-gateway/docs/guides/configure-mcp-gateway-listener-and-router/#step-2-create-httproute","title":"Step 2: Create HTTPRoute","text":"<p>Create an HTTPRoute to route MCP traffic to the broker:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: mcp-route\n  namespace: mcp-system\nspec:\n  parentRefs:\n\n    - name: your-gateway-name        # Change to your Gateway name\n      namespace: your-gateway-namespace  # Change to your Gateway namespace\n  hostnames:\n    - 'mcp.127-0-0-1.sslip.io'              # Match the Gateway listener hostname\n  rules:\n    - matches:\n        - path:\n            type: PathPrefix\n            value: /mcp\n      filters:\n        - type: ResponseHeaderModifier\n          responseHeaderModifier:\n            add:\n              - name: Access-Control-Allow-Origin\n                value: \"*\"\n              - name: Access-Control-Allow-Methods\n                value: \"GET, POST, PUT, DELETE, OPTIONS, HEAD\"\n              - name: Access-Control-Allow-Headers\n                value: \"Content-Type, Authorization, Accept, Origin, X-Requested-With\"\n              - name: Access-Control-Max-Age\n                value: \"3600\"\n              - name: Access-Control-Allow-Credentials\n                value: \"true\"\n      backendRefs:\n        - name: mcp-gateway     # MCP Gateway broker service name\n          port: 8080\n    - matches:\n        - path:\n            type: PathPrefix\n            value: /.well-known/oauth-protected-resource\n      backendRefs:\n        - name: mcp-gateway\n          port: 8080\nEOF\n</code></pre>"},{"location":"mcp-gateway/docs/guides/configure-mcp-gateway-listener-and-router/#step-3-verify-envoyfilter-configuration","title":"Step 3: Verify EnvoyFilter Configuration","text":"<p>The MCP Gateway controller automatically creates the EnvoyFilter when the MCPGatewayExtension is ready. Check that it exists:</p> <pre><code># EnvoyFilter is created in the Gateway's namespace\nkubectl get envoyfilter -n your-gateway-namespace -l app.kubernetes.io/managed-by=mcp-gateway-controller\n</code></pre> <p>If you see the EnvoyFilter, you can proceed to verification. If the EnvoyFilter is missing:</p> <ol> <li> <p>Check that the MCPGatewayExtension is ready:    <pre><code>kubectl get mcpgatewayextension -n mcp-system\n</code></pre></p> </li> <li> <p>Check the controller logs for errors:    <pre><code>kubectl logs -n mcp-system deployment/mcp-gateway-controller\n</code></pre></p> </li> <li> <p>Verify the target Gateway exists and the MCPGatewayExtension has proper permissions (ReferenceGrant if cross-namespace).</p> </li> </ol>"},{"location":"mcp-gateway/docs/guides/configure-mcp-gateway-listener-and-router/#step-4-verify-configuration","title":"Step 4: Verify Configuration","text":"<p>Test that the MCP endpoint is accessible through your Gateway:</p> <pre><code>curl -X POST http://mcp.127-0-0-1.sslip.io:8080/mcp \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"jsonrpc\": \"2.0\", \"id\": 1, \"method\": \"initialize\"}'\n</code></pre> <p>You should get a response like this:</p> <pre><code>{\"jsonrpc\":\"2.0\",\"id\":1,\"result\":{\"protocolVersion\":\"2025-03-26\",\"capabilities\":{\"tools\":{\"listChanged\":true}},\"serverInfo\":{\"name\":\"Kagenti MCP Broker\",\"version\":\"0.0.1\"}}}\n</code></pre>"},{"location":"mcp-gateway/docs/guides/configure-mcp-gateway-listener-and-router/#next-steps","title":"Next Steps","text":"<p>Now that you have MCP Gateway routing configured, you can connect your MCP servers:</p> <ul> <li>Configure MCP Servers - Connect internal MCP servers to the gateway</li> </ul>"},{"location":"mcp-gateway/docs/guides/external-mcp-server/","title":"Connecting to External MCP Servers","text":"<p>This guide demonstrates how to connect MCP Gateway to external MCP servers using Gateway API and Istio. We'll use the public GitHub MCP server as an example.</p> <p>Clients call your Gateway's hostname, and the Gateway rewrites and routes traffic to the external service.</p>"},{"location":"mcp-gateway/docs/guides/external-mcp-server/#prerequisites","title":"Prerequisites","text":"<ul> <li>MCP Gateway installed and configured</li> <li>Gateway API Provider (Istio) with ServiceEntry and DestinationRule support</li> <li>Network egress access to external MCP server</li> <li>Authentication credentials for the external server (if required)</li> <li>MCPGatewayExtension targeting the Gateway (required for MCPServerRegistration to work)</li> </ul> <p>Note: If you're trying this locally, <code>make local-env-setup</code> already meets all prerequisites except the GitHub PAT.</p> <p>If you haven't created an MCPGatewayExtension yet, see Configure MCP Servers for instructions.</p>"},{"location":"mcp-gateway/docs/guides/external-mcp-server/#about-the-github-mcp-server","title":"About the GitHub MCP Server","text":"<p>The GitHub MCP server (https://api.githubcopilot.com/mcp/) provides programmatic access to GitHub functionality through the Model Context Protocol. It exposes tools for repository management, issues, pull requests, and code operations.</p> <p>For this example, you'll need a GitHub Personal Access Token with <code>read:user</code> permissions. Get one at https://github.com/settings/tokens/new</p> <pre><code>export GITHUB_PAT=\"ghp_YOUR_GITHUB_TOKEN_HERE\"\n</code></pre>"},{"location":"mcp-gateway/docs/guides/external-mcp-server/#quick-start","title":"Quick Start","text":"<p>The fastest way to set up the GitHub MCP server is using the provided script:</p> <pre><code># Set your GitHub PAT\nexport GITHUB_PAT=\"ghp_YOUR_GITHUB_TOKEN_HERE\"\n\n# Run the setup script\n./config/samples/remote-github/create_resources.sh\n</code></pre> <p>The script will:</p> <ul> <li>Validate your GITHUB_PAT environment variable and token format</li> <li>Create ServiceEntry, DestinationRule, HTTPRoute, Secret, and MCPServerRegistration</li> <li>Apply the AuthPolicy for OAuth + API key handling</li> </ul> <p>All the sample YAML files are available in <code>config/samples/remote-github/</code> for reference or customization. For a detailed explanation of each component, continue reading the manual setup steps below.</p>"},{"location":"mcp-gateway/docs/guides/external-mcp-server/#overview","title":"Overview","text":"<p>To connect to an external MCP server, you need:</p> <ol> <li>ServiceEntry to register the external service in Istio</li> <li>DestinationRule for TLS and connection policies</li> <li>HTTPRoute with your hostname that rewrites and routes to the external service</li> <li>MCPServerRegistration resource to register with MCP Gateway</li> <li>Secret with authentication credentials</li> <li>AuthPolicy to handle authentication headers (optional, for OAuth scenarios)</li> </ol> <p>The existing Gateway already has a <code>*.mcp.local</code> wildcard listener, so we'll use <code>github.mcp.local</code> as our internal hostname.</p>"},{"location":"mcp-gateway/docs/guides/external-mcp-server/#step-1-create-serviceentry","title":"Step 1: Create ServiceEntry","text":"<p>The <code>ServiceEntry</code> registers the external service in Istio's service registry:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: networking.istio.io/v1beta1\nkind: ServiceEntry\nmetadata:\n  name: github-mcp-external\n  namespace: mcp-test\nspec:\n  hosts:\n\n  - api.githubcopilot.com\n  ports:\n  - number: 443\n    name: https\n    protocol: HTTPS\n  location: MESH_EXTERNAL\n  resolution: DNS\nEOF\n</code></pre>"},{"location":"mcp-gateway/docs/guides/external-mcp-server/#step-2-create-destinationrule","title":"Step 2: Create DestinationRule","text":"<p>Configure TLS settings for the external service:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: networking.istio.io/v1beta1\nkind: DestinationRule\nmetadata:\n  name: github-mcp-external\n  namespace: mcp-test\nspec:\n  host: api.githubcopilot.com\n  trafficPolicy:\n    tls:\n      mode: SIMPLE\n      sni: api.githubcopilot.com\nEOF\n</code></pre>"},{"location":"mcp-gateway/docs/guides/external-mcp-server/#step-3-create-httproute","title":"Step 3: Create HTTPRoute","text":"<p>Create an <code>HTTPRoute</code> that matches your internal hostname and routes to the external service using Istio's Hostname backendRef:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: github-mcp-external\n  namespace: mcp-test\nspec:\n  parentRefs:\n\n  - group: gateway.networking.k8s.io\n    kind: Gateway\n    name: mcp-gateway\n    namespace: gateway-system\n  hostnames:\n  - github.mcp.local  # your internal hostname, matches *.mcp.local listener\n  rules:\n  - matches:\n    - path:\n        type: PathPrefix\n        value: /mcp\n    filters:\n    - type: URLRewrite\n      urlRewrite:\n        hostname: api.githubcopilot.com  # rewrite to external hostname\n    backendRefs:\n    - name: api.githubcopilot.com\n      kind: Hostname\n      group: networking.istio.io\n      port: 443\nEOF\n</code></pre>"},{"location":"mcp-gateway/docs/guides/external-mcp-server/#step-4-create-secret-with-authentication","title":"Step 4: Create Secret with Authentication","text":"<p>Create a secret containing your GitHub PAT token with the Bearer prefix:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: github-token\n  namespace: mcp-test\n  labels:\n    mcp.kuadrant.io/credential: \"true\"  # required label\ntype: Opaque\nstringData:\n  token: \"Bearer $GITHUB_PAT\"\nEOF\n</code></pre> <p>The <code>mcp.kuadrant.io/credential=true</code> label is required. Without it the MCPServerRegistration will fail validation.</p>"},{"location":"mcp-gateway/docs/guides/external-mcp-server/#step-5-create-the-mcpserverregistration-resource","title":"Step 5: Create the MCPServerRegistration Resource","text":"<p>Create the <code>MCPServer</code> resource that registers the GitHub MCP server with the gateway:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: mcp.kagenti.com/v1alpha1\nkind: MCPServerRegistration\nmetadata:\n  name: github\n  namespace: mcp-test\nspec:\n  toolPrefix: github_\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: github-mcp-external\n  credentialRef:\n    name: github-token\n    key: token\nEOF\n</code></pre>"},{"location":"mcp-gateway/docs/guides/external-mcp-server/#step-6-create-authpolicy-optional","title":"Step 6: Create AuthPolicy (Optional)","text":"<p>If you're using Kuadrant/Authorino for OAuth authentication, create an <code>AuthPolicy</code> to handle authorization headers:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1\nkind: AuthPolicy\nmetadata:\n  name: mcps-auth-policy\n  namespace: mcp-test\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: github-mcp-external\n  rules:\n    response:\n      success:\n        headers:\n          authorization:\n            plain:\n              expression: 'request.headers[\"authorization\"]'\n          x-mcp-api-key:\n            plain:\n              expression: 'request.headers[\"authorization\"].split(\" \")[1]'\nEOF\n</code></pre> <p>This AuthPolicy extracts the API key from the OAuth token and sets it as the <code>x-mcp-api-key</code> header, resolving the OAuth + API Key conflict described in Issue #201.</p> <p>Note: This step is only required if you're using AuthPolicy for OAuth authentication. For simple bearer token auth, the router handles the Authorization header automatically.</p>"},{"location":"mcp-gateway/docs/guides/external-mcp-server/#step-7-wait-for-configuration-sync","title":"Step 7: Wait for Configuration Sync","text":"<p>Wait for the configuration to sync to the broker:</p> <pre><code>echo \"Waiting for GitHub tools to be discovered...\"\nuntil kubectl logs -n mcp-system deploy/mcp-gateway | grep \"Discovered.*tools.*github\"; do\n  echo \"Still waiting...\"\n  sleep 5\ndone\necho \"GitHub tools discovered!\"\n</code></pre>"},{"location":"mcp-gateway/docs/guides/external-mcp-server/#verification","title":"Verification","text":"<p>Check that the MCPServerRegistration is registered:</p> <pre><code>kubectl get mcpsrs -n mcp-test\nkubectl logs -n mcp-system deployment/mcp-gateway | grep \"Discovered.*tools.*github\"\n</code></pre>"},{"location":"mcp-gateway/docs/guides/external-mcp-server/#test-integration","title":"Test Integration","text":"<p>Test tools/list through the gateway:</p> <pre><code>curl -X POST http://mcp.127-0-0-1.sslip.io:8001/mcp \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"jsonrpc\": \"2.0\", \"id\": 1, \"method\": \"tools/list\"}'\n</code></pre> <p>To test tool calls, open the MCP Inspector:</p> <pre><code>make inspect-gateway\n</code></pre> <p>In the <code>Authentication</code> section, add a HTTP header called <code>Authorization</code> with value <code>Bearer $GITHUB_PAT</code>. After connecting to the Gateway, under <code>Tools-&gt;List Tools</code>, you should see a list of Github tools with prefix <code>github_</code>. If everything works, when you run the tool <code>github_get_me</code>, you should see the information associated with your access token.</p>"},{"location":"mcp-gateway/docs/guides/external-mcp-server/#cleanup","title":"Cleanup","text":"<pre><code>kubectl delete mcpserver github -n mcp-test\nkubectl delete httproute github-mcp-external -n mcp-test\nkubectl delete serviceentry github-mcp-external -n mcp-test\nkubectl delete destinationrule github-mcp-external -n mcp-test\nkubectl delete secret github-token -n mcp-test\nkubectl delete authpolicy mcps-auth-policy -n mcp-test --ignore-not-found\n</code></pre>"},{"location":"mcp-gateway/docs/guides/getting-started/","title":"Getting Started","text":"<p>Want to try MCP Gateway on Kubernetes and connect your first MCP servers? Start here: Installation Guide</p>"},{"location":"mcp-gateway/docs/guides/getting-started/#essential-setup","title":"Essential Setup","text":"<ul> <li>Installation and Configuration - Get MCP Gateway running</li> <li>Configure Gateway Routing - Set up traffic routing</li> <li>Configure MCP Servers - Connect internal servers</li> <li>External MCP Servers - Connect to external APIs</li> </ul>"},{"location":"mcp-gateway/docs/guides/getting-started/#advanced-features","title":"Advanced Features","text":"<ul> <li>Authentication - OAuth-based security</li> <li>Authorization - Fine-grained access control</li> <li>Virtual MCP Servers - Focused tool collections</li> </ul> <ul> <li>Vault Integration</li> <li>Troubleshooting - Common issues and solutions</li> </ul>"},{"location":"mcp-gateway/docs/guides/how-to-install-and-configure/","title":"Installing and Configuring MCP Gateway","text":"<p>This guide demonstrates how to install and configure the MCP Gateway to aggregate multiple Model Context Protocol (MCP) servers behind a single endpoint.</p>"},{"location":"mcp-gateway/docs/guides/how-to-install-and-configure/#prerequisites","title":"Prerequisites","text":"<p>MCP Gateway runs on Kubernetes and integrates with Gateway API and Istio. You should be familiar with:</p> <ul> <li>Kubernetes - Basic kubectl and YAML knowledge</li> <li>Gateway API - Kubernetes standard for traffic routing</li> <li>Istio - Gateway API provider</li> </ul> <p>Choose your setup approach:</p> <p>Option A: Local Setup Start (5 minutes)</p> <ul> <li>Want to try MCP Gateway immediately with minimal setup</li> <li>Automated script handles everything for you</li> <li>Perfect for evaluation and testing</li> <li>Quick Start Guide</li> </ul> <p>Option B: Existing Cluster</p> <ul> <li>You have a Kubernetes cluster with Gateway API CRDs and Istio already installed</li> <li>Are ready to deploy MCP Gateway immediately</li> <li>If you want to deploy isolated MCP Gateway instances for different teams there is a specific guide for that Isolated Gateway Deployment Guide which goes into more detail.</li> </ul>"},{"location":"mcp-gateway/docs/guides/how-to-install-and-configure/#installation","title":"Installation","text":""},{"location":"mcp-gateway/docs/guides/how-to-install-and-configure/#step-1-install-crds","title":"Step 1: Install CRDs","text":"<pre><code>export MCP_GATEWAY_VERSION=main  # or a specific version tag\nkubectl apply -k \"https://github.com/kuadrant/mcp-gateway/config/crd?ref=${MCP_GATEWAY_VERSION}\"\n</code></pre> <p>Verify CRDs are installed:</p> <pre><code>kubectl get crd | grep mcp.kagenti.com\n</code></pre> <p>Note: CRDs are also installed automatically when deploying via Helm.</p>"},{"location":"mcp-gateway/docs/guides/how-to-install-and-configure/#step-2-install-mcp-gateway","title":"Step 2: Install MCP Gateway","text":"<p>Install from GitHub Container Registry:</p> <pre><code>helm upgrade -i mcp-gateway oci://ghcr.io/kuadrant/charts/mcp-gateway \\\n  --version ${MCP_GATEWAY_VERSION} \\\n  --namespace mcp-system \\\n  --create-namespace \\\n  --set controller.enabled=true \\\n  --set gateway.publicHost=your-hostname.example.com \\\n  --set mcpGatewayExtension.create=true \\\n  --set mcpGatewayExtension.gatewayRef.name=your-gateway \\\n  --set mcpGatewayExtension.gatewayRef.namespace=gateway-system\n</code></pre> <p>This automatically installs:</p> <ul> <li>MCP Controller - Watches MCPGatewayExtension and MCPServerRegistration resources</li> <li>MCPGatewayExtension - Custom resource targeting your Gateway</li> </ul> <p>When the MCPGatewayExtension becomes ready, the controller automatically creates:</p> <ul> <li>MCP Broker/Router Deployment - Aggregates tools from upstream MCP servers</li> <li>MCP Broker/Router Service - Named <code>mcp-gateway</code> in the MCPGatewayExtension namespace</li> <li>EnvoyFilter - Configures Istio to route requests through the external processor (created in the Gateway's namespace)</li> </ul> <p>Note: The <code>gateway.publicHost</code> value must match the hostname configured in your Gateway listener (see Configure Gateway Listener and Route).</p>"},{"location":"mcp-gateway/docs/guides/how-to-install-and-configure/#post-installation-configuration","title":"Post-Installation Configuration","text":"<p>After installation, you'll need to configure the gateway and connect your MCP servers:</p> <ol> <li>Configure Gateway Listener and Route - Set up traffic routing</li> <li>Register MCP Servers - Connect internal MCP servers</li> <li>Connect to External MCP Servers - Connect to external APIs</li> </ol>"},{"location":"mcp-gateway/docs/guides/how-to-install-and-configure/#optional-configuration","title":"Optional Configuration","text":"<ul> <li>Authentication - Configure OAuth-based authentication</li> <li>Authorization - Set up fine-grained access control</li> <li>User Based Tool Filtering - Define what tools a client is allowed to see.</li> <li>Virtual MCP Servers - Create focused tool collections</li> <li>Isolated Gateway Deployment - Multi-instance deployments for team isolation</li> </ul>"},{"location":"mcp-gateway/docs/guides/isolated-gateway-deployment/","title":"Isolated MCP Gateway Deployment","text":"<p>This guide demonstrates how to deploy MCP Gateway instances for your environment. Each deployment is given its own configuration for MCP Servers to manage based on the MCPGatewayExtension resource. This allows for multiple MCP Gateway instances to be deployed within a single cluster and to isolate traffic.</p> <p>This guide assumes some knowledge about exposing MCP servers via an HTTPRoute. You can find more info in the following guide configure-mcp-gateway-listener.</p> <p>This guide assumes some knowledge about configuring an MCPServerRegistration. You can find more information in the following guide register-mcp-servers.</p>"},{"location":"mcp-gateway/docs/guides/isolated-gateway-deployment/#overview","title":"Overview","text":"<p>The MCP Gateway requires an <code>MCPGatewayExtension</code> resource to operate. This resource:</p> <ul> <li>Defines which Gateway the MCP Gateway instance is responsible for</li> <li>Determines where configuration secrets are created (same namespace as the MCPGatewayExtension)</li> <li>Enables isolation by allowing multiple MCP Gateway instances (in different namespaces) to target different Gateways</li> </ul>"},{"location":"mcp-gateway/docs/guides/isolated-gateway-deployment/#prerequisites","title":"Prerequisites","text":"<ul> <li>Cluster with Gateway API support</li> <li>Istio installed as the Gateway API provider</li> <li>Helm 3.x</li> </ul> <p>Note: The guide expects you have cloned the repo locally. This allows using the latest code. If you want to make use of a specific release, use the following in the helm commands and then there is no need for the repo locally:</p> <pre><code>helm upgrade -i mcp-controller oci://ghcr.io/kuadrant/charts/mcp-gateway \\\n    --version ${MCP_GATEWAY_VERSION} \\\n</code></pre>"},{"location":"mcp-gateway/docs/guides/isolated-gateway-deployment/#step-1-install-mcp-gateway-crds","title":"Step 1: Install MCP Gateway CRDs","text":"<pre><code>export MCP_GATEWAY_VERSION=main #change this to the version you want\nkubectl apply -k \"https://github.com/kuadrant/mcp-gateway/config/crd?ref=${MCP_GATEWAY_VERSION}\"\n</code></pre> <p>Verify the CRDs are installed:</p> <pre><code>kubectl get crd | grep mcp.kagenti.com\n</code></pre> <p>Note: CRDs are also installed automatically when deploying the controller via Helm in Step 3.</p>"},{"location":"mcp-gateway/docs/guides/isolated-gateway-deployment/#architecture","title":"Architecture","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                        MCP System Namespace                          \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                    MCP Controller (cluster-wide)                     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                    \u2502\n              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n              \u25bc                                           \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502          Team A NS            \u2502     \u2502          Team B NS            \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524     \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 MCPGatewayExtension           \u2502     \u2502 MCPGatewayExtension           \u2502\n\u2502   \u2192 Gateway A                 \u2502     \u2502   \u2192 Gateway B                 \u2502\n\u2502 MCP Broker/Router             \u2502     \u2502 MCP Broker/Router             \u2502\n\u2502 Config Secret                 \u2502     \u2502 Config Secret                 \u2502\n\u2502 MCPServerRegistrations        \u2502     \u2502 MCPServerRegistrations        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Each MCPGatewayExtension must target a different Gateway. The controller creates configuration secrets in the same namespace(s) as valid MCPGatewayExtension(s), which are mounted into the broker/router deployments.</p> <p>For cross-namespace Gateway references with a MCPGatewayExtension, a ReferenceGrant must exist in the target Gateway's namespace.</p>"},{"location":"mcp-gateway/docs/guides/isolated-gateway-deployment/#step-2-set-environment-variables","title":"Step 2: Set Environment Variables","text":""},{"location":"mcp-gateway/docs/guides/isolated-gateway-deployment/#openshift","title":"OpenShift","text":"<pre><code>export TEAM_A_HOST=\"team-a.apps.$(oc get dns cluster -o jsonpath='{.spec.baseDomain}')\"\nexport TEAM_B_HOST=\"team-b.apps.$(oc get dns cluster -o jsonpath='{.spec.baseDomain}')\"\n</code></pre>"},{"location":"mcp-gateway/docs/guides/isolated-gateway-deployment/#kindkubernetes","title":"Kind/Kubernetes","text":"<p>What is shown below is just an example and what is used locally via Kind.</p> <pre><code>export TEAM_A_HOST=\"team-a.127-0-0-1.sslip.io\"\nexport TEAM_B_HOST=\"team-b.127-0-0-1.sslip.io\"\n</code></pre>"},{"location":"mcp-gateway/docs/guides/isolated-gateway-deployment/#step-3-deploy-the-mcp-controller","title":"Step 3: Deploy the MCP Controller","text":"<p>The MCP Controller runs cluster-wide and reconciles MCPGatewayExtension and MCPServerRegistration resources. Deploy it once in a central namespace:</p> <pre><code>helm upgrade -i mcp-controller ./charts/mcp-gateway \\\n  --namespace mcp-system \\\n  --create-namespace \\\n  --set controller.enabled=true \\\n  --set gateway.create=false \\\n  --set httpRoute.create=false \\\n  --set mcpGatewayExtension.create=false \\\n  --set envoyFilter.create=false\n</code></pre> <p>Verify the controller is running:</p> <pre><code>kubectl get pods -n mcp-system\n</code></pre>"},{"location":"mcp-gateway/docs/guides/isolated-gateway-deployment/#step-4-deploy-team-a-gateway-instance","title":"Step 4: Deploy Team A Gateway Instance","text":"<p>Deploy an MCP Gateway instance for Team A with its own Gateway resource:</p> <pre><code>helm upgrade -i team-a-mcp-gateway ./charts/mcp-gateway \\\n  --namespace team-a \\\n  --create-namespace \\\n  --set controller.enabled=false \\\n  --set broker.create=true \\\n  --set gateway.create=true \\\n  --set gateway.name=team-a-gateway \\\n  --set gateway.namespace=gateway-system \\\n  --set gateway.publicHost=\"$TEAM_A_HOST\" \\\n  --set gateway.internalHostPattern=\"*.team-a.mcp.local\" \\\n  --set httpRoute.create=true \\\n  --set mcpGatewayExtension.create=true \\\n  --set mcpGatewayExtension.gatewayRef.name=team-a-gateway \\\n  --set mcpGatewayExtension.gatewayRef.namespace=gateway-system \\\n  --set envoyFilter.create=true \\\n  --set envoyFilter.name=team-a-gateway\n</code></pre> <p>The Helm chart creates:</p> <ul> <li>Gateway resource in gateway-system namespace</li> <li>HTTPRoute for the MCP endpoint</li> <li>MCPGatewayExtension targeting the Gateway</li> <li>ReferenceGrant in the Gateway namespace (for cross-namespace references)</li> <li>Broker/Router deployment</li> <li>Service for the broker</li> <li>EnvoyFilter to route traffic through the external processor</li> <li>ServiceAccount and RBAC</li> <li>Config Secret for MCP server configuration</li> </ul>"},{"location":"mcp-gateway/docs/guides/isolated-gateway-deployment/#step-5-verify-team-a-deployment","title":"Step 5: Verify Team A Deployment","text":"<pre><code># Check Gateway is created\nkubectl get gateway team-a-gateway -n gateway-system\n\n# Check MCPGatewayExtension is ready\nkubectl wait --for=condition=Ready mcpgatewayextension/team-a-mcp-gateway -n team-a --timeout=60s\n\n# Check pods are running\nkubectl get pods -n team-a\n</code></pre>"},{"location":"mcp-gateway/docs/guides/isolated-gateway-deployment/#step-6-deploy-team-b-gateway-instance","title":"Step 6: Deploy Team B Gateway Instance","text":"<p>Deploy a second isolated gateway for Team B:</p> <pre><code>helm upgrade -i team-b-mcp-gateway ./charts/mcp-gateway \\\n  --namespace team-b \\\n  --create-namespace \\\n  --set controller.enabled=false \\\n  --set broker.create=true \\\n  --set gateway.create=true \\\n  --set gateway.name=team-b-gateway \\\n  --set gateway.namespace=gateway-system \\\n  --set gateway.publicHost=\"$TEAM_B_HOST\" \\\n  --set gateway.internalHostPattern=\"*.team-b.mcp.local\" \\\n  --set httpRoute.create=true \\\n  --set mcpGatewayExtension.create=true \\\n  --set mcpGatewayExtension.gatewayRef.name=team-b-gateway \\\n  --set mcpGatewayExtension.gatewayRef.namespace=gateway-system \\\n  --set envoyFilter.create=true \\\n  --set envoyFilter.name=team-b-gateway\n</code></pre>"},{"location":"mcp-gateway/docs/guides/isolated-gateway-deployment/#step-7-verify-team-b-deployment","title":"Step 7: Verify Team B Deployment","text":"<pre><code># Check Gateway is created\nkubectl get gateway team-b-gateway -n gateway-system\n\n# Check MCPGatewayExtension is ready\nkubectl wait --for=condition=Ready mcpgatewayextension/team-b-mcp-gateway -n team-b --timeout=60s\n\n# Check broker pod is running\nkubectl get pods -n team-b\n</code></pre>"},{"location":"mcp-gateway/docs/guides/isolated-gateway-deployment/#step-8-expose-gateways-externally","title":"Step 8: Expose Gateways Externally","text":""},{"location":"mcp-gateway/docs/guides/isolated-gateway-deployment/#openshift-routes","title":"OpenShift (Routes)","text":"<p>OpenShift Routes expose the Gateways externally with TLS termination.</p> <p>Team A gateway route: <pre><code>oc apply -f - &lt;&lt;EOF\napiVersion: route.openshift.io/v1\nkind: Route\nmetadata:\n  name: team-a-gateway\n  namespace: gateway-system\nspec:\n  host: $TEAM_A_HOST\n  tls:\n    insecureEdgeTerminationPolicy: Redirect\n    termination: edge\n  port:\n    targetPort: mcp\n  to:\n    kind: Service\n    name: team-a-gateway-istio\n    weight: 100\n  wildcardPolicy: None\nEOF\n</code></pre></p> <p>Team B gateway route: <pre><code>oc apply -f - &lt;&lt;EOF\napiVersion: route.openshift.io/v1\nkind: Route\nmetadata:\n  name: team-b-gateway\n  namespace: gateway-system\nspec:\n  host: $TEAM_B_HOST\n  tls:\n    insecureEdgeTerminationPolicy: Redirect\n    termination: edge\n  port:\n    targetPort: mcp\n  to:\n    kind: Service\n    name: team-b-gateway-istio\n    weight: 100\n  wildcardPolicy: None\nEOF\n</code></pre></p> <p>Verify routes are created: <pre><code>oc get routes -n gateway-system\n</code></pre></p>"},{"location":"mcp-gateway/docs/guides/isolated-gateway-deployment/#exposing-via-nodeport","title":"Exposing via NodePort","text":"<p>For a local kind or kubernetes setup you can configure helm to setup the NodePort service. Re-run the commands with the following flags set</p> <pre><code># Team A gateway\n--set gateway.nodePort.create=true \\\n--set gateway.nodePort.mcpPort=30080 \\\n</code></pre> <pre><code># Team B gateway\n--set gateway.nodePort.create=true \\\n--set gateway.nodePort.mcpPort=30471 \\\n</code></pre>"},{"location":"mcp-gateway/docs/guides/isolated-gateway-deployment/#next-steps-register-mcp-servers","title":"Next Steps: Register MCP Servers","text":"<p>Once your gateway instances are deployed, register MCP servers with each instance. See the Register MCP Servers guide for detailed instructions.</p> <p>When registering servers, ensure the HTTPRoute's <code>parentRef</code> targets the correct Gateway:</p> <ul> <li>Team A instance: <code>team-a-gateway</code> in <code>gateway-system</code></li> <li>Team B instance: <code>team-b-gateway</code> in <code>gateway-system</code></li> </ul>"},{"location":"mcp-gateway/docs/guides/isolated-gateway-deployment/#limitations","title":"Limitations","text":"<p>Broker/Router must be co-located with MCPGatewayExtension: The MCP Gateway instance (broker and router) must be deployed in the same namespace as the MCPGatewayExtension. The controller writes the configuration secret to the MCPGatewayExtension's namespace, and the broker/router mount this secret.</p> <p>One MCPGatewayExtension per namespace: Each namespace can only have one MCPGatewayExtension. The controller writes configuration to a well-known secret name, so multiple extensions would overwrite each other.</p> <p>One MCPGatewayExtension per Gateway: Only one MCPGatewayExtension can target a given Gateway. If multiple extensions target the same Gateway, the controller marks newer ones as conflicted. The oldest extension (by creation timestamp) wins.</p>"},{"location":"mcp-gateway/docs/guides/isolated-gateway-deployment/#troubleshooting","title":"Troubleshooting","text":""},{"location":"mcp-gateway/docs/guides/isolated-gateway-deployment/#mcpgatewayextension-shows-refgrantrequired","title":"MCPGatewayExtension shows RefGrantRequired","text":"<p>The MCPGatewayExtension is targeting a Gateway in a different namespace, but no ReferenceGrant exists:</p> <pre><code>kubectl get mcpgatewayextension -n team-a -o yaml\n</code></pre> <p>Look for the condition: <pre><code>conditions:\n\n  - type: Ready\n    status: \"False\"\n    reason: ReferenceGrantRequired\n    message: \"ReferenceGrant required in namespace gateway-system to allow cross-namespace reference\"\n</code></pre></p> <p>The Helm chart should create the ReferenceGrant automatically. If not, create it manually as shown in the Manual Resource Creation section.</p>"},{"location":"mcp-gateway/docs/guides/isolated-gateway-deployment/#mcpgatewayextension-shows-invalidmcpgatewayextension","title":"MCPGatewayExtension shows InvalidMCPGatewayExtension","text":"<p>The target Gateway doesn't exist or there's a conflict.</p> <p>Check if there is another MCPGatewayExtension that is older that is also targeting the Gateway.</p>"},{"location":"mcp-gateway/docs/guides/isolated-gateway-deployment/#mcpserverregistration-shows-notready","title":"MCPServerRegistration shows NotReady","text":"<p>The registration can't find a valid MCPGatewayExtension for the Gateway its HTTPRoute is attached to:</p> <p>MCPServerRegistration resources are only processed when a valid MCPGatewayExtension exists for the Gateway their HTTPRoute is attached to. Without a matching MCPGatewayExtension, registrations will show a NotReady status.</p> <pre><code>kubectl get mcpserverregistration -n team-a -o yaml\n</code></pre> <p>Check that:</p> <ol> <li>The HTTPRoute exists and references the correct Gateway and its status is accepted</li> <li>An MCPGatewayExtension exists targeting that Gateway</li> <li>The MCPGatewayExtension is in Ready state</li> </ol>"},{"location":"mcp-gateway/docs/guides/isolated-gateway-deployment/#no-configuration-in-secret","title":"No configuration in secret","text":"<p>The config secret exists but has no servers:</p> <pre><code>kubectl get secret mcp-gateway-config -n team-a -o jsonpath='{.data.config\\.yaml}' | base64 -d\n</code></pre> <p>Check that MCPServerRegistration resources exist and are Ready:</p> <pre><code>kubectl get mcpserverregistration -n team-a\n</code></pre>"},{"location":"mcp-gateway/docs/guides/isolated-gateway-deployment/#cleanup","title":"Cleanup","text":"<p>To remove the deployments:</p>"},{"location":"mcp-gateway/docs/guides/isolated-gateway-deployment/#openshift_1","title":"OpenShift","text":"<pre><code># Delete routes\noc delete route team-a-gateway team-b-gateway -n gateway-system\n\n# Uninstall gateway Helm releases\nhelm uninstall team-b-mcp-gateway -n team-b\nhelm uninstall team-a-mcp-gateway -n team-a\n\n# Uninstall controller\nhelm uninstall mcp-controller -n mcp-system\n\n# Delete namespaces\noc delete namespace team-b\noc delete namespace team-a\noc delete namespace mcp-system\n</code></pre>"},{"location":"mcp-gateway/docs/guides/isolated-gateway-deployment/#kindkubernetes_1","title":"Kind/Kubernetes","text":"<pre><code># Uninstall gateway Helm releases\nhelm uninstall team-b-mcp-gateway -n team-b\nhelm uninstall team-a-mcp-gateway -n team-a\n\n# Uninstall controller\nhelm uninstall mcp-controller -n mcp-system\n\n# Delete namespaces\nkubectl delete namespace team-b\nkubectl delete namespace team-a\nkubectl delete namespace mcp-system\n</code></pre>"},{"location":"mcp-gateway/docs/guides/isolated-gateway-deployment/#manual-resource-creation","title":"Manual Resource Creation","text":"<p>If you prefer to create the MCPGatewayExtension and ReferenceGrant manually instead of having Helm manage them, disable automatic creation and apply the resources yourself:</p>"},{"location":"mcp-gateway/docs/guides/isolated-gateway-deployment/#referencegrant-cross-namespace-only","title":"ReferenceGrant (Cross-Namespace Only)","text":"<p>If the MCPGatewayExtension is in a different namespace than the Gateway, create a ReferenceGrant in the Gateway's namespace:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1beta1\nkind: ReferenceGrant\nmetadata:\n  name: allow-team-a\n  namespace: gateway-system\nspec:\n  from:\n\n    - group: mcp.kagenti.com\n      kind: MCPGatewayExtension\n      namespace: team-a\n  to:\n    - group: gateway.networking.k8s.io\n      kind: Gateway\nEOF\n</code></pre>"},{"location":"mcp-gateway/docs/guides/isolated-gateway-deployment/#mcpgatewayextension","title":"MCPGatewayExtension","text":"<p>Create the MCPGatewayExtension to associate the team's namespace with the target Gateway:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: mcp.kagenti.com/v1alpha1\nkind: MCPGatewayExtension\nmetadata:\n  name: team-a-gateway\n  namespace: team-a\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: team-a-gateway\n    namespace: gateway-system\nEOF\n</code></pre>"},{"location":"mcp-gateway/docs/guides/isolated-gateway-deployment/#deploy-without-automatic-resource-creation","title":"Deploy without automatic resource creation","text":"<pre><code>helm install team-a-mcp-gateway ./charts/mcp-gateway \\\n  --namespace team-a \\\n  --set controller.enabled=false \\\n  --set gateway.create=true \\\n  --set gateway.name=team-a-gateway \\\n  --set gateway.namespace=gateway-system \\\n  --set gateway.publicHost=\"$TEAM_A_HOST\" \\\n  --set httpRoute.create=true \\\n  --set envoyFilter.create=true \\\n  --set envoyFilter.name=team-a-gateway \\\n  --set mcpGatewayExtension.create=false\n</code></pre>"},{"location":"mcp-gateway/docs/guides/overview/","title":"MCP Gateway Overview","text":"<p>Centralize and manage the connectivity for agentic AI applications that access your Model Context Protocol (MCP) servers by using the Model Context Protocol (MCP) gateway.</p>"},{"location":"mcp-gateway/docs/guides/overview/#why-use-the-mcp-gateway","title":"Why use the MCP Gateway","text":"<p>By using the MCP Gateway, you can focus on your agentic AI systems without building networking into your application code.</p> <ul> <li>Aggregate MCP servers behind a single endpoint.</li> <li>Grow your agentic AI applications at scale.</li> <li>Manage access to and the security of AI tools and MCP servers.</li> </ul>"},{"location":"mcp-gateway/docs/guides/overview/#how-it-works","title":"How it works","text":"<p>This MCP gateway extends the benefits of the Envoy proxy server to your customized AI agent systems that require data or need to perform actions based on the data or functions contained in your backend MCP servers. Envoy intercepts all network traffic and is a conformance-tested implementation of the Kubernetes Gateway API.</p>"},{"location":"mcp-gateway/docs/guides/overview/#early-preview-feature","title":"Early preview feature","text":"<p>The MCP Gateway is an early preview feature. This early preview feature is not complete or production-ready. This early preview feature gives you access so that you can experiment with functionality and give feedback during the development process. This feature is subject to change or removal at any time. Testing is limited.</p>"},{"location":"mcp-gateway/docs/guides/overview/#get-started","title":"Get started","text":"<p>Information and links to get you started:</p> <pre><code>- [Documentation links](./README.md)\n</code></pre>"},{"location":"mcp-gateway/docs/guides/quick-start/","title":"Quick Start Guide","text":"<p>Get MCP Gateway running in 5 minutes with our automated setup script.</p>"},{"location":"mcp-gateway/docs/guides/quick-start/#overview","title":"Overview","text":"<p>This guide uses an automated script that sets up everything you need:</p> <ul> <li>Local Kind Kubernetes cluster</li> <li>Gateway API CRDs</li> <li>Istio service mesh</li> <li>MCP Gateway with Helm</li> <li>Example MCP servers</li> <li>Gateway routing configuration</li> <li>MCP Inspector for testing</li> </ul> <p>Perfect for evaluation, demos, and getting started quickly.</p>"},{"location":"mcp-gateway/docs/guides/quick-start/#prerequisites","title":"Prerequisites","text":"<ul> <li>Docker or Podman installed and running</li> <li>Kind installed</li> <li>Helm installed</li> <li>kubectl installed</li> <li>Node.js and npm installed (for MCP Inspector)</li> </ul>"},{"location":"mcp-gateway/docs/guides/quick-start/#quick-setup","title":"Quick Setup","text":"<p>Set the release version to install:</p> <pre><code>export MCP_GATEWAY_BRANCH=release-0.5.0\n</code></pre> <p>Run the automated setup script:</p> <pre><code># Download and run the setup script\ncurl -sSL https://raw.githubusercontent.com/Kuadrant/mcp-gateway/${MCP_GATEWAY_BRANCH}/charts/sample_local_helm_setup.sh | bash\n</code></pre> <p>Or clone the repository and run locally:</p> <pre><code>git clone https://github.com/Kuadrant/mcp-gateway.git\ncd mcp-gateway\ngit checkout $MCP_GATEWAY_BRANCH\nUSE_LOCAL_CHART=true ./charts/sample_local_helm_setup.sh\n</code></pre>"},{"location":"mcp-gateway/docs/guides/quick-start/#what-the-script-does","title":"What the Script Does","text":"<p>The setup script automatically:</p> <ol> <li>Creates Kind cluster with proper port mappings</li> <li>Installs Gateway API CRDs for traffic routing</li> <li>Deploys Istio service mesh with Helm</li> <li>Sets up Istio Gateway for external traffic</li> <li>Installs MCP Gateway using the Helm chart</li> <li>Deploys test MCP servers for demonstration</li> <li>Configures routing with HTTPRoute resources</li> <li>Launches MCP Inspector for testing and exploration</li> </ol>"},{"location":"mcp-gateway/docs/guides/quick-start/#testing-your-setup","title":"Testing Your Setup","text":"<p>Once the script completes, you'll have:</p>"},{"location":"mcp-gateway/docs/guides/quick-start/#mcp-inspector-access","title":"MCP Inspector Access","text":"<ul> <li>URL: http://localhost:6274</li> <li>Gateway URL: http://mcp.127-0-0-1.sslip.io:7001/mcp</li> <li>Pre-configured: The inspector opens with the correct gateway URL</li> </ul>"},{"location":"mcp-gateway/docs/guides/quick-start/#available-test-tools","title":"Available Test Tools","text":"<p>The setup includes example MCP servers with tools like:</p> <ul> <li><code>test1_hello_world</code> - Simple greeting tool</li> <li><code>test1_headers</code> - HTTP header inspection</li> <li><code>test2_headers</code> - Additional header tool</li> </ul>"},{"location":"mcp-gateway/docs/guides/quick-start/#try-it-out","title":"Try It Out","text":"<ol> <li>Connect: MCP Inspector should open automatically</li> <li>Initialize: Click \"Connect\" to initialize the MCP session</li> <li>Explore Tools: Browse available tools in the left panel</li> <li>Test Tools: Try calling <code>test1_hello_world</code> or <code>test1_headers</code></li> <li>View Logs: Check the request/response flow</li> </ol>"},{"location":"mcp-gateway/docs/guides/quick-start/#cleanup","title":"Cleanup","text":"<p>To stop the services and clean up:</p> <pre><code># Then delete the Kind cluster\nkind delete cluster\n</code></pre>"},{"location":"mcp-gateway/docs/guides/quick-start/#next-steps","title":"Next Steps","text":"<p>Now that you have MCP Gateway running, explore other features:</p> <ul> <li>Authentication - Configure OAuth-based security with Keycloak</li> <li>Authorization - Set up fine-grained access</li> <li>Virtual MCP Servers - Create focused tool collections for specific use cases</li> <li>External MCP Servers - Connect to external APIs and services</li> </ul>"},{"location":"mcp-gateway/docs/guides/register-mcp-servers/","title":"MCP Server Registration","text":"<p>You must register your MCP servers to be discovered and routed by the MCP Gateway. To connect an MCP server to MCP Gateway, you must create an <code>HTTPRoute</code> that routes to your MCP server and an <code>MCPServerRegistration</code> resource that references the <code>HTTPRoute</code>.</p>"},{"location":"mcp-gateway/docs/guides/register-mcp-servers/#prerequisites","title":"Prerequisites","text":"<ul> <li>You installed and configured the MCP Gateway</li> <li>You configured a gateway and <code>HTTPRoute</code> for the MCP Gateway</li> <li>An MCP server is running in your cluster</li> </ul>"},{"location":"mcp-gateway/docs/guides/register-mcp-servers/#procedure","title":"Procedure","text":"<p>To connect an MCP server to MCP Gateway, you need:</p> <ol> <li>An MCPGatewayExtension resource that targets your Gateway</li> <li>A ReferenceGrant if the MCPGatewayExtension is in a different namespace than the Gateway</li> <li>An HTTPRoute that routes to your MCP server</li> <li>An MCPServerRegistration resource that references the HTTPRoute</li> </ol> <p>The MCPGatewayExtension tells the controller which Gateway this MCP Gateway instance serves. Without it, MCPServerRegistration resources will remain in NotReady status.</p>"},{"location":"mcp-gateway/docs/guides/register-mcp-servers/#step-1-create-mcpgatewayextension","title":"Step 1: Create MCPGatewayExtension","text":"<p>First, create an MCPGatewayExtension in the same namespace as your MCP Gateway broker/router deployment. It should target a unique Gateway resource. </p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: mcp.kagenti.com/v1alpha1\nkind: MCPGatewayExtension\nmetadata:\n  name: mcp-extension\n  namespace: mcp-test\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: mcp-gateway\n    namespace: gateway-system\nEOF\n</code></pre> <p>Wait for it to become ready:</p> <pre><code>kubectl wait --for=condition=Ready mcpgatewayextension/mcp-extension -n mcp-test --timeout=60s\n</code></pre> <p>If your target Gateway is in a different namespace than your MCPGatewayExtension, you will also need to create a ReferenceGrant:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1beta1\nkind: ReferenceGrant\nmetadata:\n  name: allow-mcp-extension\n  namespace: gateway-system  # Gateway's namespace\nspec:\n  from:\n\n    - group: mcp.kagenti.com\n      kind: MCPGatewayExtension\n      namespace: mcp-test  # MCPGatewayExtension's namespace\n  to:\n    - group: gateway.networking.k8s.io\n      kind: Gateway\nEOF\n</code></pre> <p>Skip the ReferenceGrant if the MCPGatewayExtension is in the same namespace as the Gateway.</p> <p>Create an <code>HTTPRoute</code> that routes to your MCP server:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: mcp-api-key-server-route\n  namespace: mcp-test\n  labels:\n    mcp-server: 'true'\nspec:\n  parentRefs:\n\n    - name: mcp-gateway\n      namespace: gateway-system\n  hostnames:\n    - 'api-key-server.mcp.local'  # Internal routing hostname\n  rules:\n    - matches:\n        - path:\n            type: PathPrefix\n            value: /\n      backendRefs:\n        - name: mcp-api-key-server  # Your MCP server service name\n          port: 9090                # Your MCP server port\nEOF\n</code></pre>"},{"location":"mcp-gateway/docs/guides/register-mcp-servers/#step-2-create-mcpserverregistration-resource","title":"Step 2: Create MCPServerRegistration Resource","text":"<p>Create an <code>MCPServerRegistration</code> resource that references the HTTPRoute:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: mcp.kagenti.com/v1alpha1\nkind: MCPServerRegistration\nmetadata:\n  name: my-mcp-server\n  namespace: mcp-test\nspec:\n  toolPrefix: \"myserver_\"\n  targetRef:\n    group: \"gateway.networking.k8s.io\"\n    kind: \"HTTPRoute\"\n    name: \"mcp-api-key-server-route\"  # The name and namespace of your MCP Server HTTPRoute\n    namespace: \"mcp-test\"\nEOF\n</code></pre>"},{"location":"mcp-gateway/docs/guides/register-mcp-servers/#step-3-verify-registration","title":"Step 3: Verify Registration","text":"<p>Check that the <code>MCPServerRegistration</code> was created and discovered:</p> <pre><code># Check MCPServerRegistration status\nkubectl get mcpsr -A\n\n# Check controller logs\nkubectl logs -n mcp-system deployment/mcp-gateway-controller\n\n# Check broker logs for tool discovery\nkubectl logs -n mcp-system deployment/mcp-gateway | grep \"Discovered tools\"\n</code></pre>"},{"location":"mcp-gateway/docs/guides/register-mcp-servers/#step-4-test-tool-discovery","title":"Step 4: Test Tool Discovery","text":"<p>Verify that your MCP server tools are available through the gateway by using the following commands:</p> <pre><code># Step 1: Initialize MCP session and capture session ID\n# Use -D to dump headers to a file, then read the session ID\ncurl -s -D /tmp/mcp_headers -X POST http://mcp.127-0-0-1.sslip.io:8001/mcp \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"jsonrpc\": \"2.0\", \"id\": 1, \"method\": \"initialize\", \"params\": {\"protocolVersion\": \"2025-06-18\", \"capabilities\": {}, \"clientInfo\": {\"name\": \"test-client\", \"version\": \"1.0.0\"}}}'\n\n# Extract the MCP session ID from response headers\nSESSION_ID=$(grep -i \"mcp-session-id:\" /tmp/mcp_headers | cut -d' ' -f2 | tr -d '\\r')\n\necho \"MCP Session ID: $SESSION_ID\"\n\n# Step 2: List tools using the session ID\ncurl -X POST http://mcp.127-0-0-1.sslip.io:8001/mcp \\\n  -H \"Content-Type: application/json\" \\\n  -H \"mcp-session-id: $SESSION_ID\" \\\n  -d '{\"jsonrpc\": \"2.0\", \"id\": 2, \"method\": \"tools/list\"}'\n\n# Clean up\nrm -f /tmp/mcp_headers\n</code></pre> <p>You should now see your MCP server tools in the response, prefixed with your configured <code>toolPrefix</code> (e.g., <code>myserver_</code>).</p>"},{"location":"mcp-gateway/docs/guides/register-mcp-servers/#next-steps","title":"Next Steps","text":"<p>After you have MCP servers registered, you can explore advanced features:</p> <ul> <li>Create focused tool collections with Virtual MCP Servers</li> <li>Configure OAuth-based security with Authentication</li> <li>Set up fine-grained access control with Authorization</li> </ul>"},{"location":"mcp-gateway/docs/guides/troubleshooting/","title":"Troubleshooting MCP Gateway","text":"<p>This guide covers common issues and solutions when working with MCP Gateway across installation, configuration, and operation.</p>"},{"location":"mcp-gateway/docs/guides/troubleshooting/#installation-issues","title":"Installation Issues","text":""},{"location":"mcp-gateway/docs/guides/troubleshooting/#helm-installation-fails","title":"Helm Installation Fails","text":"<p>Symptom: <code>helm install</code> command fails or times out</p> <pre><code># Check Helm repository access\nhelm repo list\n\n# Verify connectivity to GitHub Container Registry\ncurl -I https://ghcr.io\n\n# Check cluster connectivity\nkubectl cluster-info\n</code></pre> <p>Solutions:</p> <ul> <li>Ensure you have network access to <code>ghcr.io</code></li> <li>Verify your cluster is running and accessible</li> <li>Check that Gateway API CRDs are installed: <code>kubectl get crd gateways.gateway.networking.k8s.io</code></li> <li>Ensure Istio is installed: <code>kubectl get pods -n istio-system</code></li> </ul>"},{"location":"mcp-gateway/docs/guides/troubleshooting/#kustomize-installation-fails","title":"Kustomize Installation Fails","text":"<p>Symptom: <code>kubectl apply -k</code> fails with validation errors</p> <pre><code># Verify Gateway API CRDs exist\nkubectl get crd gateways.gateway.networking.k8s.io httproutes.gateway.networking.k8s.io\n\n# Check for resource conflicts\nkubectl get mcpsr -A\nkubectl get deployment -n mcp-system\n</code></pre> <p>Solutions:</p> <ul> <li>Install Gateway API CRDs first: <code>kubectl apply -f https://github.com/kubernetes-sigs/gateway-api/releases/download/v1.2.1/standard-install.yaml</code></li> <li>Delete existing resources if upgrading: <code>kubectl delete -k 'https://github.com/Kuadrant/mcp-gateway/config/install?ref=main'</code></li> </ul>"},{"location":"mcp-gateway/docs/guides/troubleshooting/#pods-not-starting","title":"Pods Not Starting","text":"<p>Symptom: MCP Gateway pods stuck in <code>Pending</code>, <code>CrashLoopBackOff</code>, or <code>ImagePullBackOff</code></p> <pre><code># Check pod status\nkubectl get pods -n mcp-system\n\n# Describe problem pods\nkubectl describe pod -n mcp-system &lt;pod-name&gt;\n\n# Check logs\nkubectl logs -n mcp-system &lt;pod-name&gt;\n</code></pre> <p>Common Causes:</p> <ul> <li>ImagePullBackOff: Check image repository access and credentials</li> <li>CrashLoopBackOff: Check logs for application errors</li> <li>Pending: Check resource availability and node capacity</li> <li>Init Container Failures: Check RBAC permissions</li> </ul>"},{"location":"mcp-gateway/docs/guides/troubleshooting/#gateway-routing-issues","title":"Gateway Routing Issues","text":""},{"location":"mcp-gateway/docs/guides/troubleshooting/#gateway-listener-not-working","title":"Gateway Listener Not Working","text":"<p>Symptom: Cannot reach MCP endpoint at configured hostname</p> <pre><code># Check Gateway status\nkubectl get gateway -A\nkubectl describe gateway &lt;gateway-name&gt; -n &lt;namespace&gt;\n\n# Verify listener configuration\nkubectl get gateway &lt;gateway-name&gt; -n &lt;namespace&gt; -o yaml | grep -A 10 listeners\n</code></pre> <p>Solutions:</p> <ul> <li>Ensure Gateway has <code>Accepted</code> and <code>Programmed</code> conditions set to <code>True</code></li> <li>Verify hostname in listener matches your DNS/hosts configuration</li> <li>Check that Istio gateway pod is running: <code>kubectl get pods -n gateway-system -l istio=ingressgateway</code></li> <li>Verify port is not already in use: <code>kubectl get gateway -A -o yaml | grep \"port:\"</code></li> </ul>"},{"location":"mcp-gateway/docs/guides/troubleshooting/#httproute-not-attached","title":"HTTPRoute Not Attached","text":"<p>Symptom: HTTPRoute exists but traffic doesn't reach the backend</p> <pre><code># Check HTTPRoute status\nkubectl get httproute -A\nkubectl describe httproute &lt;route-name&gt; -n &lt;namespace&gt;\n\n# Verify parent reference\nkubectl get httproute &lt;route-name&gt; -n &lt;namespace&gt; -o yaml | grep -A 5 parentRefs\n</code></pre> <p>Solutions:</p> <ul> <li>Ensure <code>parentRefs</code> matches your Gateway name and namespace exactly</li> <li>Verify <code>hostnames</code> in HTTPRoute matches Gateway listener hostname</li> <li>Check that <code>allowedRoutes.namespaces</code> in Gateway allows HTTPRoute namespace</li> <li>Look for <code>Accepted</code> condition in HTTPRoute status</li> </ul>"},{"location":"mcp-gateway/docs/guides/troubleshooting/#envoyfilter-not-applied","title":"EnvoyFilter Not Applied","text":"<p>Symptom: MCP requests fail or bypass the router</p> <p>The EnvoyFilter is automatically created by the MCP Gateway controller when the MCPGatewayExtension is ready. It is created in the Gateway's namespace (not istio-system).</p> <pre><code># Check EnvoyFilter exists (in Gateway namespace)\nkubectl get envoyfilter -n &lt;gateway-namespace&gt; -l app.kubernetes.io/managed-by=mcp-gateway-controller\n\n# Verify EnvoyFilter configuration\nkubectl describe envoyfilter -n &lt;gateway-namespace&gt; -l app.kubernetes.io/managed-by=mcp-gateway-controller\n\n# Check Istio gateway pod configuration\nkubectl exec -n &lt;gateway-namespace&gt; deploy/&lt;gateway-name&gt;-istio -- curl localhost:15000/config_dump | grep ext_proc\n</code></pre> <p>Solutions:</p> <ul> <li>Verify MCPGatewayExtension is Ready: <code>kubectl get mcpgatewayextension -A</code></li> <li>Check controller logs for EnvoyFilter creation errors: <code>kubectl logs -n mcp-system deployment/mcp-gateway-controller</code></li> <li>Ensure the Gateway exists and is in the expected namespace</li> <li>Verify ReferenceGrant exists if MCPGatewayExtension is in a different namespace than the Gateway</li> <li>Check port number matches Gateway listener port (default: 8080)</li> <li>Restart Istio gateway to force config reload: <code>kubectl rollout restart deployment/&lt;gateway-name&gt;-istio -n &lt;gateway-namespace&gt;</code></li> </ul>"},{"location":"mcp-gateway/docs/guides/troubleshooting/#mcpgatewayextension-issues","title":"MCPGatewayExtension Issues","text":""},{"location":"mcp-gateway/docs/guides/troubleshooting/#mcpgatewayextension-not-ready","title":"MCPGatewayExtension Not Ready","text":"<p>Symptom: MCPGatewayExtension shows <code>Ready: False</code> status</p> <pre><code># Check MCPGatewayExtension status\nkubectl get mcpgatewayextension -A\nkubectl describe mcpgatewayextension &lt;name&gt; -n &lt;namespace&gt;\n</code></pre> <p>Common Reasons:</p> <ul> <li>ReferenceGrantRequired: The MCPGatewayExtension targets a Gateway in a different namespace but no ReferenceGrant exists</li> <li>InvalidMCPGatewayExtension: The target Gateway doesn't exist, or another MCPGatewayExtension already targets this Gateway</li> </ul> <p>Solutions:</p> <ul> <li>For cross-namespace references, create a ReferenceGrant in the Gateway's namespace:   <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1beta1\nkind: ReferenceGrant\nmetadata:\n  name: allow-mcp-extension\n  namespace: &lt;gateway-namespace&gt;\nspec:\n  from:\n    - group: mcp.kagenti.com\n      kind: MCPGatewayExtension\n      namespace: &lt;mcpgatewayextension-namespace&gt;\n  to:\n    - group: gateway.networking.k8s.io\n      kind: Gateway\nEOF\n</code></pre></li> <li>Verify the target Gateway exists: <code>kubectl get gateway -n &lt;gateway-namespace&gt;</code></li> <li>Check for conflicting MCPGatewayExtensions: <code>kubectl get mcpgatewayextension -A</code></li> </ul>"},{"location":"mcp-gateway/docs/guides/troubleshooting/#mcpserverregistration-shows-notready-no-valid-mcpgatewayextension","title":"MCPServerRegistration Shows NotReady - No Valid MCPGatewayExtension","text":"<p>Symptom: MCPServerRegistration has condition <code>Ready: False</code> with message about no valid MCPGatewayExtension</p> <pre><code>kubectl describe mcpsr &lt;name&gt; -n &lt;namespace&gt;\n</code></pre> <p>Solutions:</p> <ul> <li>Verify an MCPGatewayExtension exists in the same namespace as the MCPServerRegistration</li> <li>Ensure the MCPGatewayExtension targets the Gateway that the HTTPRoute is attached to</li> <li>Check the MCPGatewayExtension is in Ready state: <code>kubectl get mcpgatewayextension -n &lt;namespace&gt;</code></li> </ul>"},{"location":"mcp-gateway/docs/guides/troubleshooting/#mcp-server-configuration-issues","title":"MCP Server Configuration Issues","text":""},{"location":"mcp-gateway/docs/guides/troubleshooting/#mcp-server-not-discovered","title":"MCP Server Not Discovered","text":"<p>Symptom: Tools from MCP server don't appear in <code>tools/list</code></p> <pre><code># Check MCPServerRegistration resource status\nkubectl get mcpsr -A\nkubectl describe mcpserver &lt;server-name&gt; -n &lt;namespace&gt;\n\n# Check controller logs\nkubectl logs -n mcp-system -l app=mcp-controller | grep &lt;server-name&gt;\n\n# Check broker logs\nkubectl logs -n mcp-system -l app=mcp-gateway | grep \"Discovered tools\"\n</code></pre> <p>Solutions:</p> <ul> <li>Verify MCPServerRegistration <code>targetRef</code> points to correct HTTPRoute name and namespace</li> <li>Ensure HTTPRoute has <code>mcp-server: 'true'</code> label</li> <li>Check that backend MCP server is running: <code>kubectl get pods -n &lt;mcp-server-namespace&gt;</code></li> <li>Verify backend service exists: <code>kubectl get svc -n &lt;namespace&gt; &lt;service-name&gt;</code></li> <li>Check HTTPRoute has valid backend reference: <code>kubectl describe httproute &lt;route-name&gt;</code></li> </ul>"},{"location":"mcp-gateway/docs/guides/troubleshooting/#tools-not-appearing","title":"Tools Not Appearing","text":"<p>Symptom: MCPServerRegistration discovered but tools missing</p> <pre><code># Test backend server directly\n#\u00a0NOTE: You may need a valid mcp-session-id header set\nkubectl run -it --rm debug --image=nicolaka/netshoot --restart=Never -- \\\n  curl -X POST http://&lt;service-name&gt;.&lt;namespace&gt;.svc.cluster.local:&lt;port&gt;/mcp \\\n  -H \"mcp-session-id: SESSION_ID\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"jsonrpc\": \"2.0\", \"id\": 1, \"method\": \"tools/list\"}'\n\n# Check broker router logs for errors\nkubectl logs -n mcp-system -l app=mcp-gateway\n</code></pre> <p>Solutions:</p> <ul> <li>Verify backend MCP server implements <code>tools/list</code> method correctly</li> <li>Check backend server logs for errors</li> <li>Ensure backend server returns valid MCP protocol responses</li> <li>Verify <code>toolPrefix</code> in MCPServerRegistration spec is valid (no spaces or special chars)</li> </ul>"},{"location":"mcp-gateway/docs/guides/troubleshooting/#tool-prefix-not-applied","title":"Tool Prefix Not Applied","text":"<p>Symptom: Tools appear without the configured prefix</p> <pre><code># Check MCPServerRegistration configuration\nkubectl get mcpsr &lt;server-name&gt; -n &lt;namespace&gt; -o yaml | grep toolPrefix\n\n# Check controller logs\nkubectl logs -n mcp-system deployment/mcp-gateway-controller | grep prefix\n</code></pre> <p>Solutions:</p> <ul> <li>Ensure <code>toolPrefix</code> is set in MCPServerRegistration spec</li> <li>Verify no typos in <code>toolPrefix</code> field name</li> <li>Restart broker after MCPServerRegistration changes: <code>kubectl rollout restart deployment/mcp-gateway -n mcp-system</code></li> </ul>"},{"location":"mcp-gateway/docs/guides/troubleshooting/#external-mcp-server-issues","title":"External MCP Server Issues","text":""},{"location":"mcp-gateway/docs/guides/troubleshooting/#cannot-connect-to-external-server","title":"Cannot Connect to External Server","text":"<p>Symptom: External MCP server tools not appearing or connection errors</p> <pre><code># Check ServiceEntry\nkubectl get serviceentry -n &lt;namespace&gt;\nkubectl describe serviceentry &lt;name&gt; -n &lt;namespace&gt;\n\n# Check DestinationRule\nkubectl get destinationrule -n &lt;namespace&gt;\nkubectl describe destinationrule &lt;name&gt; -n &lt;namespace&gt;\n\n# Test DNS resolution\nkubectl run -it --rm debug --image=nicolaka/netshoot --restart=Never -- \\\n  nslookup &lt;external-hostname&gt;\n\n# Test external connectivity\nkubectl run -it --rm debug --image=nicolaka/netshoot --restart=Never -- \\\n  curl -v https://&lt;external-hostname&gt;\n</code></pre> <p>Solutions:</p> <ul> <li>Verify ServiceEntry <code>hosts</code> matches external hostname exactly</li> <li>Ensure DestinationRule <code>host</code> matches ServiceEntry host</li> <li>Check network egress policies allow external traffic</li> <li>Verify HTTPRoute uses Hostname backendRef with correct external hostname</li> <li>Check TLS configuration in DestinationRule (mode, SNI)</li> <li>Ensure HTTPRoute has URLRewrite filter to rewrite to external hostname</li> </ul>"},{"location":"mcp-gateway/docs/guides/troubleshooting/#external-server-authentication-failing","title":"External Server Authentication Failing","text":"<p>Symptom: External server returns 401/403 errors</p> <pre><code># Check secret exists and has correct label\nkubectl get secret &lt;secret-name&gt; -n &lt;namespace&gt; --show-labels\n\n# Verify secret contents\nkubectl get secret &lt;secret-name&gt; -n &lt;namespace&gt; -o yaml\n\n# Check MCPServerRegistration credentialRef\nkubectl get mcpsr &lt;name&gt; -n &lt;namespace&gt; -o yaml | grep -A 3 credentialRef\n</code></pre> <p>Solutions:</p> <ul> <li>Ensure secret has label <code>mcp.kuadrant.io/credential: \"true\"</code></li> <li>Verify secret data key matches <code>credentialRef.key</code> in MCPServerRegistration</li> <li>Check credential format (e.g., \"Bearer TOKEN\" for GitHub)</li> <li>Verify credential has necessary permissions for the external service</li> <li>Check broker logs for credential errors: <code>kubectl logs -n mcp-system deployment/mcp-gateway | grep -i auth</code></li> </ul>"},{"location":"mcp-gateway/docs/guides/troubleshooting/#authentication-issues","title":"Authentication Issues","text":""},{"location":"mcp-gateway/docs/guides/troubleshooting/#oauth-discovery-not-working","title":"OAuth Discovery Not Working","text":"<p>Symptom: Clients cannot discover OAuth configuration</p> <pre><code># Test protected resource metadata endpoint\ncurl http://&lt;mcp-hostname&gt;/.well-known/oauth-protected-resource\n\n# Check broker environment variables\nkubectl get deployment mcp-gateway -n mcp-system -o yaml | grep -A 10 env\n</code></pre> <p>Solutions:</p> <ul> <li>Verify <code>OAUTH_*</code> environment variables are set on broker deployment</li> <li>Ensure HTTPRoute includes path for <code>/.well-known/oauth-protected-resource</code></li> <li>Check that <code>/.well-known</code> paths are excluded from authentication policy</li> <li>Verify broker pod restarted after environment variable changes</li> </ul>"},{"location":"mcp-gateway/docs/guides/troubleshooting/#jwt-token-validation-failing","title":"JWT Token Validation Failing","text":"<p>Symptom: Valid tokens rejected with 401 errors</p> <pre><code># Check AuthPolicy configuration\nkubectl get authpolicy -A\nkubectl describe authpolicy &lt;policy-name&gt; -n &lt;namespace&gt;\n\n# Check Authorino logs\nkubectl logs -n kuadrant-system -l authorino-resource=authorino\n\n# Decode JWT to verify claims\necho \"&lt;your-token&gt;\" | cut -d. -f2 | base64 -d | jq\n</code></pre> <p>Solutions:</p> <ul> <li>Verify <code>issuerUrl</code> in AuthPolicy matches Keycloak realm</li> <li>Ensure issuer URL is reachable from cluster (use cluster-local service name)</li> <li>Check token expiration time (<code>exp</code> claim)</li> <li>Verify audience (<code>aud</code> claim) if required</li> <li>Ensure token includes required claims (groups, email, etc.)</li> </ul>"},{"location":"mcp-gateway/docs/guides/troubleshooting/#www-authenticate-header-missing","title":"WWW-Authenticate Header Missing","text":"<p>Symptom: 401 responses don't include OAuth discovery information</p> <pre><code># Test with verbose output\ncurl -v http://&lt;mcp-hostname&gt;/mcp \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"jsonrpc\": \"2.0\", \"id\": 1, \"method\": \"tools/list\"}'\n</code></pre> <p>Solutions:</p> <ul> <li>Verify AuthPolicy includes <code>response.unauthenticated.headers.WWW-Authenticate</code></li> <li>Check that response value includes correct metadata URL</li> <li>Ensure AuthPolicy is applied to correct Gateway/listener</li> </ul>"},{"location":"mcp-gateway/docs/guides/troubleshooting/#authorization-issues","title":"Authorization Issues","text":""},{"location":"mcp-gateway/docs/guides/troubleshooting/#all-tools-denied-403","title":"All Tools Denied (403)","text":"<p>Symptom: Authenticated user gets 403 for all tool calls</p> <pre><code># Check AuthPolicy authorization rules\nkubectl get authpolicy &lt;policy-name&gt; -n &lt;namespace&gt; -o yaml | grep -A 20 authorization\n\n# Check Authorino logs for CEL evaluation\nkubectl logs -n kuadrant-system -l authorino-resource=authorino | grep -i authz\n</code></pre> <p>Solutions:</p> <ul> <li>Ensure Authorino can communicate with the Keycloak server</li> <li>Verify JWT token includes <code>resource_access[server-name].roles</code> claims</li> </ul>"},{"location":"mcp-gateway/docs/guides/troubleshooting/#authorization-policy-not-applied","title":"Authorization Policy Not Applied","text":"<p>Symptom: Authorization checks not enforced</p> <pre><code># Check AuthPolicy status\nkubectl describe authpolicy &lt;policy-name&gt; -n &lt;namespace&gt;\n\n# Verify policy targets correct resource\nkubectl get authpolicy &lt;policy-name&gt; -n &lt;namespace&gt; -o yaml | grep -A 5 targetRef\n</code></pre> <p>Solutions:</p> <ul> <li>Ensure AuthPolicy <code>targetRef</code> matches Gateway name and namespace</li> <li>Verify <code>sectionName</code> matches Gateway listener name</li> <li>Check that Kuadrant operator is running: <code>kubectl get pods -n kuadrant-system</code></li> <li>Look for <code>Accepted</code> condition in AuthPolicy status</li> </ul>"},{"location":"mcp-gateway/docs/guides/troubleshooting/#cel-expression-errors","title":"CEL Expression Errors","text":"<p>Symptom: Authorization fails with CEL evaluation errors</p> <pre><code># Check Authorino logs for CEL errors\nkubectl logs -n kuadrant-system -l authorino-resource=authorino | grep -i cel\n</code></pre> <p>Solutions:</p> <ul> <li>Verify CEL syntax in authorization rules</li> <li>Check that referenced fields exist (e.g., <code>auth.identity.groups</code>)</li> <li>Ensure metadata source is accessible and returns expected structure</li> <li>Test CEL expression syntax using online validators</li> <li>Add logging to understand CEL evaluation context</li> </ul>"},{"location":"mcp-gateway/docs/guides/troubleshooting/#virtual-mcp-server-issues","title":"Virtual MCP Server Issues","text":""},{"location":"mcp-gateway/docs/guides/troubleshooting/#virtual-server-not-filtering-tools","title":"Virtual Server Not Filtering Tools","text":"<p>Symptom: All tools returned even with virtual server header</p> <pre><code># Check MCPVirtualServer resource\nkubectl get mcpvirtualserver -A\nkubectl describe mcpvirtualserver &lt;name&gt; -n &lt;namespace&gt;\n\n# Test with virtual server header\ncurl -X POST http://&lt;mcp-hostname&gt;/mcp \\\n  -H \"Content-Type: application/json\" \\\n  -H \"mcp-session-id: &lt;session-id&gt;\" \\\n  -H \"X-Mcp-Virtualserver: &lt;namespace&gt;/&lt;name&gt;\" \\\n  -d '{\"jsonrpc\": \"2.0\", \"id\": 1, \"method\": \"tools/list\"}' | jq '.result.tools[].name'\n</code></pre> <p>Solutions:</p> <ul> <li>Verify <code>X-Mcp-Virtualserver</code> header format is <code>namespace/name</code></li> <li>Ensure virtual server name and namespace match exactly (case-sensitive)</li> <li>Check that tool names in virtual server spec match actual tool names</li> <li>Verify session was initialized with same virtual server header</li> <li>Check broker logs for virtual server processing</li> </ul>"},{"location":"mcp-gateway/docs/guides/troubleshooting/#virtual-server-tools-not-found","title":"Virtual Server Tools Not Found","text":"<p>Symptom: Virtual server returns empty tool list</p> <pre><code># List all available tools\ncurl -X POST http://&lt;mcp-hostname&gt;/mcp \\\n  -H \"Content-Type: application/json\" \\\n  -H \"mcp-session-id: &lt;session-id&gt;\" \\\n  -d '{\"jsonrpc\": \"2.0\", \"id\": 1, \"method\": \"tools/list\"}' | jq '.result.tools[].name'\n\n# Compare with virtual server tool list\nkubectl get mcpvirtualserver &lt;name&gt; -n &lt;namespace&gt; -o yaml | grep -A 20 tools\n</code></pre> <p>Solutions:</p> <ul> <li>Ensure tool names in virtual server spec match exactly (including prefix)</li> <li>Check for typos in tool names</li> <li>Verify tools exist in underlying MCP servers</li> <li>Update virtual server spec with correct tool names</li> </ul>"},{"location":"mcp-gateway/docs/guides/troubleshooting/#session-management-issues","title":"Session Management Issues","text":""},{"location":"mcp-gateway/docs/guides/troubleshooting/#session-id-not-returned","title":"Session ID Not Returned","text":"<p>Symptom: <code>initialize</code> response doesn't include <code>mcp-session-id</code> header</p> <pre><code># Test initialization with header dump\ncurl -D - -X POST http://&lt;mcp-hostname&gt;/mcp \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"jsonrpc\": \"2.0\", \"id\": 1, \"method\": \"initialize\", \"params\": {\"protocolVersion\": \"2025-06-18\", \"capabilities\": {}, \"clientInfo\": {\"name\": \"test\", \"version\": \"1.0\"}}}'\n</code></pre> <p>Solutions:</p> <ul> <li>Verify broker is handling MCP protocol correctly</li> <li>Check broker logs for initialization errors</li> <li>Ensure EnvoyFilter is properly routing to external processor</li> <li>Test with <code>-D -</code> flag to dump response headers</li> </ul>"},{"location":"mcp-gateway/docs/guides/troubleshooting/#session-state-lost","title":"Session State Lost","text":"<p>Symptom: Subsequent requests fail with \"session not found\"</p> <pre><code># Check broker session storage\nkubectl logs -n mcp-system -l app=mcp-gateway | grep -i session\n</code></pre> <p>Solutions:</p> <ul> <li>Ensure <code>mcp-session-id</code> header is included in subsequent requests</li> <li>Verify session hasn't expired (default timeout varies)</li> <li>Check if broker pod restarted (loses in-memory sessions)</li> <li>Consider implementing persistent session storage for production</li> </ul>"},{"location":"mcp-gateway/docs/guides/troubleshooting/#general-debugging","title":"General Debugging","text":""},{"location":"mcp-gateway/docs/guides/troubleshooting/#enable-debug-logging","title":"Enable Debug Logging","text":"<pre><code># Increase log verbosity for controller (adjust deployment name as needed)\nkubectl set env deployment/mcp-gateway-controller LOG_LEVEL=debug -n mcp-system\n\n# Increase log verbosity for broker (adjust deployment name as needed)\nkubectl set env deployment/mcp-gateway LOG_LEVEL=debug -n mcp-system\n\n# Check Istio proxy logs (adjust deployment name as needed)\nkubectl logs -n gateway-system deploy/mcp-gateway-istio -c istio-proxy\n</code></pre>"},{"location":"mcp-gateway/docs/guides/troubleshooting/#check-component-health","title":"Check Component Health","text":"<pre><code># Check all MCP Gateway components\nkubectl get pods -n mcp-system\nkubectl get deploy -n mcp-system\n\n# Check resource status\nkubectl get mcpsr -A\nkubectl get mcpvirtualserver -A\nkubectl get authpolicy -A\n\n# Check Gateway API resources\nkubectl get gateway -A\nkubectl get httproute -A\n</code></pre>"},{"location":"mcp-gateway/docs/guides/troubleshooting/#network-connectivity-testing","title":"Network Connectivity Testing","text":"<pre><code># Test broker from within cluster\nkubectl run -it --rm test --image=curlimages/curl --restart=Never -- \\\n  curl -v http://mcp-gateway.mcp-system.svc.cluster.local:8080/health\n</code></pre>"},{"location":"mcp-gateway/docs/guides/troubleshooting/#getting-help","title":"Getting Help","text":"<p>If you continue to experience issues:</p> <ol> <li> <p>Collect logs from all components:    <pre><code>kubectl logs -n mcp-system -l app=mcp-controller &gt; controller.log\nkubectl logs -n mcp-system -l app=mcp-gateway &gt; broker.log\nkubectl get mcpsr -A -o yaml &gt; mcpservers.yaml\nkubectl get httproute -A -o yaml &gt; httproutes.yaml\nkubectl get gateway -A -o yaml &gt; gateways.yaml\n</code></pre></p> </li> <li> <p>Check resource status:    <pre><code>kubectl describe mcpserver -A &gt; mcpserver-status.txt\nkubectl describe gateway -A &gt; gateway-status.txt\nkubectl describe httproute -A &gt; httproute-status.txt\n</code></pre></p> </li> <li> <p>Open an issue at https://github.com/Kuadrant/mcp-gateway/issues with:</p> </li> <li>Description of the problem</li> <li>Steps to reproduce</li> <li>Relevant logs and resource configurations</li> <li>Kubernetes and Istio versions</li> </ol>"},{"location":"mcp-gateway/docs/guides/user-based-tool-filter/","title":"User based tool filter","text":""},{"location":"mcp-gateway/docs/guides/user-based-tool-filter/#trusted-header-public-key-configuration","title":"Trusted Header Public Key Configuration","text":"<p>The MCP Broker can filter tools based on a signed JWT in the <code>x-authorized-tools</code> header. This enables identity-based tool filtering when integrated with an external authorization system.</p>"},{"location":"mcp-gateway/docs/guides/user-based-tool-filter/#how-it-works","title":"How It Works","text":"<ol> <li>An upstream authorization system validates the user's identity</li> <li>It creates a signed JWT containing the user's allowed tools in an <code>allowed-tools</code> claim</li> <li>This JWT is passed to the broker via the <code>x-authorized-tools</code> header</li> <li>The broker validates the JWT signature and filters <code>tools/list</code> responses accordingly</li> </ol>"},{"location":"mcp-gateway/docs/guides/user-based-tool-filter/#jwt-payload-format","title":"JWT Payload Format","text":"<p>The <code>allowed-tools</code> claim should contain a JSON object mapping server routes to tool arrays:</p> <pre><code>{\n  \"allowed-tools\": \"{\\\"mcp-test/server1-route\\\":[\\\"tool_a\\\",\\\"tool_b\\\"],\\\"mcp-test/server2-route\\\":[\\\"tool_c\\\"]}\",\n  \"exp\": 1760004918,\n  \"iat\": 1760004618\n}\n</code></pre>"},{"location":"mcp-gateway/docs/guides/user-based-tool-filter/#example-key-pair-generation","title":"Example Key Pair Generation","text":"<p>Generate an ECDSA P-256 key pair:</p> <pre><code># Generate private key\nopenssl ecparam -name prime256v1 -genkey -noout -out private-key.pem\n\n# Extract public key\nopenssl ec -in private-key.pem -pubout -out public-key.pem\n</code></pre>"},{"location":"mcp-gateway/docs/guides/user-based-tool-filter/#create-kubernetes-secret","title":"Create Kubernetes Secret","text":"<pre><code>kubectl create secret generic trusted-headers-public-key \\\n  --from-file=key=public-key.pem \\\n  -n mcp-system\n</code></pre>"},{"location":"mcp-gateway/docs/guides/user-based-tool-filter/#configure-the-broker","title":"Configure the Broker","text":"<p>Reference the secret in the broker deployment:</p> <pre><code>env:\n\n  - name: TRUSTED_HEADER_PUBLIC_KEY\n    valueFrom:\n      secretKeyRef:\n        name: trusted-headers-public-key\n        key: key\n</code></pre> <p>When this environment variable is set, the broker will validate any <code>x-authorized-tools</code> header using ES256 and filter the tools list accordingly. If validation fails, an empty tools list is returned.</p>"},{"location":"mcp-gateway/docs/guides/user-based-tool-filter/#example-authpolicy-that-uses-this-method","title":"Example AuthPolicy that uses this method","text":"<p>An example AuthPolicy that implements the <code>x-authorized-tools</code> can be found at Sample Tool Filtering</p>"},{"location":"mcp-gateway/docs/guides/vault-integration/","title":"Integrating Vault with MCP Gateway","text":""},{"location":"mcp-gateway/docs/guides/vault-integration/#overview","title":"Overview","text":"<p>The Kuadrant MCP Gateway provides a centralized way to connect AI agents to tools with the Model Context Protocol (MCP). Many backend MCP servers require sensitive credentials such as API keys or Personal Access Tokens (PATs) to access external APIs (for example, GitHub and Slack).</p>"},{"location":"mcp-gateway/docs/guides/vault-integration/#using-vault","title":"Using Vault","text":"<p>You can use HashiCorp Vault to securely store these credentials and a Kuadrant AuthPolicy to retrieve and inject those credentials into the request flow. Authorino is used by Kuadrant to add authorization and authentication to APIs that do not have credential checks built-in. The essentials of the workflow include the following elements:</p> <ul> <li>MCP Gateway: Acts as the entry point for AI clients (e.g., Claude Code, VS Code).</li> <li>Authorino: The external authorization service used by Kuadrant to validate identities and fetch external metadata.</li> <li>HashiCorp Vault: The source of truth for secrets.</li> <li>AuthPolicy: The Kuadrant resource that defines how to authenticate the user and fetch their specific secret from Vault.</li> </ul>"},{"location":"mcp-gateway/docs/guides/vault-integration/#using-an-existing-setup","title":"Using an existing setup","text":"<p>If you already have a Kubernetes cluster, a central authorization tool that uses standard protocols like OpenID Connect or OAuth 2.0, and an MCP server ready to connect, use the AuthPolicy examples that follow to create your own object and apply it.</p> <p>Adjust the commands and configuration in the following examples according to your use case. The goal of this documentation is to guide you on testing an AuthPolicy that speaks with an OIDC server on one side and with a Vault instance on the other.</p> <p>The sample procedure presented below enforces an AuthPolicy that integrates MCP Gateway with Vault for requests targeting a specific MCP server. For enforcing the Vault integration policy on multiple servers, you can consider targeting a Gateway or individual gateway Listener instead. However, those details are beyond the scope of this documentation.</p>"},{"location":"mcp-gateway/docs/guides/vault-integration/#enable-jwt-authentication-in-your-vault-server","title":"Enable JWT authentication in your Vault server","text":"<p>For instructions on how to configure JWT authentication in Vault, see Vault's documentation. This method is for use cases where you do not want root access, which is more secure.</p> <p>Make sure to create a Vault policy and Vault role that grants access for Authorino to read secrets at the <code>secret/data/mcp-gateway/*</code> path, or whatever path you decided to namespace the MCP server secrets.</p> Example Vault policy and role for Authorino  In general, you can create a Vault policy and Vault role for Authorino by running the following commands: <pre><code>curl -H \"X-Vault-Token: $VAULT_TOKEN\" -H 'Content-Type: application/json' -X POST \\\n  --data '{\n    \"policy\": \"path \\\"secret/data/mcp-gateway/*\\\" {\\n  capabilities = [\\\"read\\\", \\\"list\\\"]\\n}\"\n  }' \\\n  http://localhost:8200/v1/sys/policies/acl/authorino\n</code></pre> <pre><code>curl -H \"X-Vault-Token: $VAULT_TOKEN\" -H 'Content-Type: application/json' -X POST \\\n  --data '{\n    \"role_type\": \"jwt\",\n    \"bound_audiences\": [\"authorino\"],\n    \"user_claim\": \"sub\",\n    \"policies\": [\"authorino\"],\n    \"ttl\": \"1h\"\n  }'\n</code></pre>"},{"location":"mcp-gateway/docs/guides/vault-integration/#create-the-authpolicy","title":"Create the AuthPolicy","text":"<p>Create an AuthPolicy to connect an external OIDC Identity Provider (IdP) with Vault to get a Vault token on behalf of the user or service that needs access to the MCP server data.</p> <p><pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: kuadrant.io/v1\nkind: AuthPolicy\nmetadata:\n  name: vault-integration-policy\n  namespace: mcp-test\nspec:\n  # Change it to target your MCP server route that requires fetching credentials from Vault or\n  # the entire MCP Gateway listener used to route internal MCP traffic if all routes require Vault integration\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: mcp-server2-route\n  rules:\n    authentication:\n      \"mcp-clients\":\n        jwt:\n          # Change it to the issuer URL of your OpenId Connect SSO provider\n          # You can also use jwksUrl instead of issuerUrl for authentication servers that do not implement OIDC Discovery\n          issuerUrl: &lt;insert_issuer_URL_here&gt;\n    metadata:\n      \"oauth-token\":\n        priority: 0\n        http:\n         # Change it to the issuer URL of your OAuth provider\n          url: &lt;insert_oauth-token-issuer_URL_here&gt;\n          method: POST\n          credentials:\n            authorizationHeader:\n              prefix: Basic\n          sharedSecretRef:\n            name: authorino-oauth-client\n            key: client_secret\n          bodyParameters:\n            grant_type:\n              value: client_credentials\n            scope:\n              value: openid\n        cache:\n          key:\n            value: 'singleton'\n          ttl: 1800 # 30 minutes\n      \"vault-login\":\n        priority: 1\n        when:\n\n        - predicate: auth.metadata.exists(p, p == \"oauth-token\") &amp;&amp; has(auth.metadata[\"oauth-token\"].access_token)\n        http:\n          # Change it to your Vault server URL.\n          url: http://vault.vault.svc.cluster.local:8200/v1/auth/jwt/login\n          method: POST\n          body:\n            expression: |\n              \"{\\\"role\\\": \\\"authorino\\\", \\\"jwt\\\": \\\"\" + auth.metadata[\"oauth-token\"].access_token + \"\\\"}\"\n        cache:\n          key:\n            value: 'singleton'\n          ttl: 3600 # 1 hour\n      \"vault\":\n        priority: 2\n        when:\n        - predicate: auth.metadata.exists(p, p == \"vault-login\") &amp;&amp; has(auth.metadata[\"vault-login\"].auth ) &amp;&amp; has(auth.metadata[\"vault-login\"].auth.client_token)\n        http:\n          # Change it to your Vault server URL and secret path. Adapt the auth-identity according to\n          # how your claims uniquely identify an MCP Gateway user\n          urlExpression: |\n            \"http://vault.vault.svc.cluster.local:8200/v1/secret/data/mcp-gateway/\" + auth.identity.sub\n          method: GET\n          headers:\n            \"X-Vault-Token\":\n              expression: auth.metadata[\"vault-login\"].auth.client_token\n    authorization:\n      \"found-vault-secret\":\n        patternMatching:\n          patterns:\n          - predicate: |\n              has(auth.metadata.vault.data) &amp;&amp; has(auth.metadata.vault.data) &amp;&amp; has(auth.metadata.vault.data.data.test_server2_pat) &amp;&amp; type(auth.metadata.vault.data.data.test_server2_pat) == string\n            # \u2018test_server2_pat\u2019 is hard-coded here as the entry inside of the Vault secret that contains\n            # the user's PAT to authenticate with the targeted MCP server\n            # For more than one MCP server in the scope of the AuthPolicy, you can make this entry\n            # fetch the name of the server dynamically, depending on what you are targeting\n    response:\n      success:\n        headers:\n          \"Authorization\":\n            plain:\n              expression: |\n                \"Bearer \" + auth.metadata.vault.data.data.test_server2_pat\n      ---\napiVersion: v1\nkind: Secret\nmetadata:\n  name: authorino-oauth-client\n  namespace: kuadrant-system\nstringData:\n  client_secret: &lt;secret-value&gt;\ntype: Opaque\nEOF\n</code></pre> - <code>oauth-token</code>: the policy makes a call to the OAuth provider. - <code>vault-login</code>: the step that performs the JWT authentication against Vault. - <code>vault</code>: fetches the secret from Vault.</p> <p> </p>"},{"location":"mcp-gateway/docs/guides/vault-integration/#using-a-vault-root-token","title":"Using a Vault root token","text":"<p>This option is easier to use, but much less secure than using tokens configured with policies. Using the Vault root token for Authorino to authenticate to Vault gives Authorino full access to read and write any secret stored in Vault. Use a root token only for initial setup or in development environments.</p> <p>The following <code>AuthPolicy</code> is an example. Update it with the specifications that apply to your use case.</p>"},{"location":"mcp-gateway/docs/guides/vault-integration/#create-the-authpolicy_1","title":"Create the AuthPolicy","text":"<pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: kuadrant.io/v1\nkind: AuthPolicy\nmetadata:\n  name: vault-integration-policy\n  namespace: mcp-test\nspec:\n  # Change it to target your MCP server route that requires fetching credentials from Vault or\n  # the entire MCP Gateway listener used to route internal MCP traffic if all routes require Vault integration\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: &lt;mcp-server2-route&gt;\n  rules:\n    authentication:\n      \"mcp-clients\":\n        jwt:\n          issuerUrl: &lt;your-issuer-url&gt;\n          # Use the issuer URL of your OpenId Connect SSO provider\n          # Or an jwksUrl instead for authentication servers that do not implement OIDC Discovery\n    metadata:\n      \"vault\":\n        http:\n          # Use your Vault server URL and secret path\n          urlExpression: |\n            \"https://vault.vault.svc.cluster.local:8200/v1/secret/data/mcp-gateway/\" + auth.identity.sub\n          method: GET\n          credentials:\n            customHeader:\n              name: X-Vault-Token\n          sharedSecretRef:\n            name: vault-secret\n            key: root-token\n    authorization:\n      \"found-vault-secret\":\n        patternMatching:\n          patterns:\n\n          - predicate: |\n              has(auth.metadata.vault.data) &amp;&amp; has(auth.metadata.vault.data.data) &amp;&amp; has(auth.metadata.vault.data.data.test_server2_pat) &amp;&amp; type(auth.metadata.vault.data.data.test_server2_pat) == string\n    response:\n      success:\n        headers:\n          \"Authorization\":\n            plain:\n              expression: |\n                \"Bearer \" + auth.metadata.vault.data.data.test_server2_pat\n---\napiVersion: v1\nkind: Secret\nmetadata:\n  name: vault-secret\n  namespace: kuadrant-system\nstringData:\n  root-token: root\ntype: Opaque\nEOF\n</code></pre>"},{"location":"mcp-gateway/docs/guides/vault-integration/#testing-mcp-gateway-integration-with-vault","title":"Testing MCP Gateway integration with Vault","text":"<p>You can test your MCP Gateway integration by using the general steps that follow. Example commands are available in the details lists for reference.</p>"},{"location":"mcp-gateway/docs/guides/vault-integration/#1-store-a-secret-in-vault","title":"1. Store a secret in Vault","text":"Example curl command to store a vault token <pre><code>curl -s -H \"X-Vault-Token: $VAULT_TOKEN\" -H 'Content-Type: application/json' -X POST \\\n  --data '{\"data\":{\"test_server2_pat\":\"s3cr3t\"}}' \\\n  http://localhost:8200/v1/secret/data/mcp-gateway/&lt;sub&gt;\n</code></pre>"},{"location":"mcp-gateway/docs/guides/vault-integration/#2-get-an-access-token","title":"2. Get an access token","text":"Example access token request <pre><code>ACCESS_TOKEN=$(curl &lt;replace-with-your-issuer-url&gt; -s -d 'grant_type=client_credentials' -d 'client_id=&lt;mcp-client-id&gt;' -d 'client_secret=&lt;mcp-client-secret&gt;' -d 'scope=openid profile groups roles' | jq -r .access_token)\n</code></pre>"},{"location":"mcp-gateway/docs/guides/vault-integration/#3-start-a-session-with-the-mcp-gateway","title":"3. Start a session with the MCP Gateway","text":"<p>You can initialize a session according to your own development environment's set up.</p>"},{"location":"mcp-gateway/docs/guides/vault-integration/#4-send-a-request-to-the-mcp-server-route-that-requires-fetching-credentials-from-vault","title":"4. Send a request to the MCP server route that requires fetching credentials from Vault","text":"<p>You can send a request to the MCP server according to your own development environment's set up.</p>"},{"location":"mcp-gateway/docs/guides/vault-integration/#example-output","title":"Example output","text":"<p>The expected output shows that the request was successful and the <code>Authorization:</code> header was set using the secret fetched from Vault:</p> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"result\": {\n    \"content\": [\n      {\n        \"type\": \"text\",\n        \"text\": \"Authorization: [Bearer s3cr3t]\"\n      },\n      \u2026\n    ],\n    \u2026\n  }\n}\n</code></pre>"},{"location":"mcp-gateway/docs/guides/virtual-mcp-servers/","title":"Virtual MCP Servers Configuration","text":"<p>This guide covers configuring virtual MCP servers to create focused, curated tool collections from your aggregated MCP servers.</p>"},{"location":"mcp-gateway/docs/guides/virtual-mcp-servers/#overview","title":"Overview","text":"<p>Virtual MCP servers solve a common problem when using MCP Gateway: while aggregating all your MCP tools centrally provides excellent benefits for authentication, authorization, and configuration management, it can overwhelm LLMs and AI agents with too many tools to choose from.</p> <p>Why use virtual MCP servers:</p> <ul> <li>Focused Tool Sets: Create specialized collections of tools for specific use cases</li> <li>Improved AI Performance: Reduce cognitive load on LLMs by presenting fewer, more relevant tools</li> <li>Domain-Specific Interfaces: Group tools by function (e.g., \"development tools\", \"data analysis tools\")</li> <li>Simplified Discovery: Make it easier for users and agents to find the right tools</li> <li>Layered Access Control: Combine with authorization policies for fine-grained access management</li> </ul> <p>Virtual servers work by filtering the complete tool list based on a curated selection, accessed via HTTP headers.</p>"},{"location":"mcp-gateway/docs/guides/virtual-mcp-servers/#prerequisites","title":"Prerequisites","text":"<ul> <li>MCP Gateway installed and configured</li> <li>MCP servers configured with tools available</li> <li>kubectl installed</li> </ul>"},{"location":"mcp-gateway/docs/guides/virtual-mcp-servers/#understanding-virtual-servers","title":"Understanding Virtual Servers","text":"<p>A virtual MCP server is defined by an <code>MCPVirtualServer</code> custom resource that specifies:</p> <ul> <li>Tool Selection: Which tools from the aggregated pool to expose</li> <li>Description: Human-readable description of the virtual server's purpose</li> <li>Access Method: Accessed via <code>X-Mcp-Virtualserver</code> header with <code>namespace/name</code> format</li> </ul> <p>When a client includes the virtual server header, MCP Gateway filters responses to only include the specified tools.</p>"},{"location":"mcp-gateway/docs/guides/virtual-mcp-servers/#step-1-create-virtual-server-definitions","title":"Step 1: Create Virtual Server Definitions","text":"<p>Create virtual servers for different use cases using tools from your configured MCP servers:</p>"},{"location":"mcp-gateway/docs/guides/virtual-mcp-servers/#development-tools-virtual-server","title":"Development Tools Virtual Server","text":"<pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: mcp.kagenti.com/v1alpha1\nkind: MCPVirtualServer\nmetadata:\n  name: dev-tools\n  namespace: mcp-system\nspec:\n  description: \"Development and debugging tools\"\n  tools:\n\n  - test1_hello_world      # Example: replace with your actual tool names\n  - test1_headers\n  - github_get_me\n  - github_list_repos\nEOF\n</code></pre>"},{"location":"mcp-gateway/docs/guides/virtual-mcp-servers/#data-analysis-virtual-server","title":"Data Analysis Virtual Server","text":"<pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: mcp.kagenti.com/v1alpha1\nkind: MCPVirtualServer\nmetadata:\n  name: data-tools\n  namespace: mcp-system\nspec:\n  description: \"Data analysis and reporting tools\"\n  tools:\n\n  - test2_time            # Example: replace with your actual tool names\n  - test3_dozen\n  - github_get_repo_stats\nEOF\n</code></pre> <p>Important: Replace the example tool names above with actual tools from your configured MCP servers.</p>"},{"location":"mcp-gateway/docs/guides/virtual-mcp-servers/#step-2-verify-virtual-server-creation","title":"Step 2: Verify Virtual Server Creation","text":"<p>Check that your virtual servers were created successfully:</p> <pre><code># List all virtual servers\nkubectl get mcpvirtualserver -A\n</code></pre>"},{"location":"mcp-gateway/docs/guides/virtual-mcp-servers/#step-3-test-virtual-server-access","title":"Step 3: Test Virtual Server Access","text":"<p>Test your virtual servers using curl with the appropriate header:</p>"},{"location":"mcp-gateway/docs/guides/virtual-mcp-servers/#test-development-tools-virtual-server","title":"Test Development Tools Virtual Server","text":"<pre><code>curl -s -D /tmp/mcp_headers -X POST http://mcp.127-0-0-1.sslip.io:8001/mcp \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"jsonrpc\": \"2.0\", \"id\": 1, \"method\": \"initialize\", \"params\": {\"protocolVersion\": \"2025-06-18\", \"capabilities\": {}, \"clientInfo\": {\"name\": \"test-client\", \"version\": \"1.0.0\"}}}'\n\n# Extract the MCP session ID from response headers\nSESSION_ID=$(grep -i \"mcp-session-id:\" /tmp/mcp_headers | cut -d' ' -f2 | tr -d '\\r')\n\necho \"MCP Session ID: $SESSION_ID\"\n\n# Request tools from the dev-tools virtual server\ncurl -X POST http://mcp.127-0-0-1.sslip.io:8001/mcp \\\n  -H \"Content-Type: application/json\" \\\n  -H \"mcp-session-id: $SESSION_ID\" \\\n  -H \"X-Mcp-Virtualserver: mcp-system/dev-tools\" \\\n  -d '{\"jsonrpc\": \"2.0\", \"id\": 1, \"method\": \"tools/list\"}' | jq '.result.tools[].name'\n</code></pre> <p>Expected Response: Only tools specified in the <code>dev-tools</code> virtual server (the example tools you configured)</p>"},{"location":"mcp-gateway/docs/guides/virtual-mcp-servers/#test-data-analysis-virtual-server","title":"Test Data Analysis Virtual Server","text":"<pre><code># Request tools from the data-tools virtual server\ncurl -X POST http://mcp.127-0-0-1.sslip.io:8001/mcp \\\n  -H \"Content-Type: application/json\" \\\n  -H \"mcp-session-id: $SESSION_ID\" \\\n  -H \"X-Mcp-Virtualserver: mcp-system/data-tools\" \\\n  -d '{\"jsonrpc\": \"2.0\", \"id\": 1, \"method\": \"tools/list\"}' | jq '.result.tools[].name'\n</code></pre> <p>Expected Response: Only tools specified in the <code>data-tools</code> virtual server (the example tools you configured)</p>"},{"location":"mcp-gateway/docs/guides/virtual-mcp-servers/#test-without-virtual-server-header","title":"Test Without Virtual Server Header","text":"<pre><code># Request all available tools (no filtering)\ncurl -X POST http://mcp.127-0-0-1.sslip.io:8001/mcp \\\n  -H \"mcp-session-id: $SESSION_ID\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"jsonrpc\": \"2.0\", \"id\": 1, \"method\": \"tools/list\"}' | jq '.result.tools[].name'\n</code></pre> <p>Expected Response: All tools from all configured MCP servers</p>"},{"location":"mcp-gateway/docs/guides/virtual-mcp-servers/#step-4-use-with-mcp-inspector","title":"Step 4: Use with MCP Inspector","text":"<p>You can also test virtual servers using the MCP Inspector by setting the virtual server header. The MCP Inspector allows you to configure custom headers for testing different virtual server configurations.</p>"},{"location":"mcp-gateway/docs/guides/virtual-mcp-servers/#remove-virtual-servers","title":"Remove Virtual Servers","text":"<pre><code># Delete a virtual server\nkubectl delete mcpvirtualserver dev-tools -n mcp-system\n</code></pre>"},{"location":"mcp-gateway/docs/guides/virtual-mcp-servers/#next-steps","title":"Next Steps","text":"<p>With virtual MCP servers configured, you can:</p> <ul> <li>Configure Authentication - Add user identity validation to virtual servers</li> <li>Configure Authorization - Add access control to virtual servers</li> <li>External MCP Servers - Include external tools in virtual servers</li> </ul>"}]}